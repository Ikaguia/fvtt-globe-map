function Va(f) {
    return f && f.__esModule && Object.prototype.hasOwnProperty.call(f, "default") ? f.default : f
}
var Ru = {
    exports: {}
};
/**
 * MapLibre GL JS
 * @license 3-Clause BSD. Full text of license: https://github.com/maplibre/maplibre-gl-js/blob/v5.2.0/LICENSE.txt
 */
var T_ = Ru.exports, Pf;
function M_() {
    return Pf || (Pf = 1,
    function(f, _) {
        (function(w, I) {
            f.exports = I()
        }
        )(T_, function() {
            var w = {}
              , I = {};
            function z(M, l, ce) {
                if (I[M] = ce,
                M === "index") {
                    var de = "var sharedModule = {}; (" + I.shared + ")(sharedModule); (" + I.worker + ")(sharedModule);"
                      , ge = {};
                    return I.shared(ge),
                    I.index(w, ge),
                    typeof window < "u" && w.setWorkerUrl(window.URL.createObjectURL(new Blob([de],{
                        type: "text/javascript"
                    }))),
                    w
                }
            }
            z("shared", ["exports"], function(M) {
                function l(r, t, n, s) {
                    return new (n || (n = Promise))(function(c, d) {
                        function p(b) {
                            try {
                                x(s.next(b))
                            } catch (C) {
                                d(C)
                            }
                        }
                        function g(b) {
                            try {
                                x(s.throw(b))
                            } catch (C) {
                                d(C)
                            }
                        }
                        function x(b) {
                            var C;
                            b.done ? c(b.value) : (C = b.value,
                            C instanceof n ? C : new n(function(P) {
                                P(C)
                            }
                            )).then(p, g)
                        }
                        x((s = s.apply(r, t || [])).next())
                    }
                    )
                }
                function ce(r) {
                    return r && r.__esModule && Object.prototype.hasOwnProperty.call(r, "default") ? r.default : r
                }
                var de, ge;
                function ze() {
                    if (ge)
                        return de;
                    function r(t, n) {
                        this.x = t,
                        this.y = n
                    }
                    return ge = 1,
                    de = r,
                    r.prototype = {
                        clone: function() {
                            return new r(this.x,this.y)
                        },
                        add: function(t) {
                            return this.clone()._add(t)
                        },
                        sub: function(t) {
                            return this.clone()._sub(t)
                        },
                        multByPoint: function(t) {
                            return this.clone()._multByPoint(t)
                        },
                        divByPoint: function(t) {
                            return this.clone()._divByPoint(t)
                        },
                        mult: function(t) {
                            return this.clone()._mult(t)
                        },
                        div: function(t) {
                            return this.clone()._div(t)
                        },
                        rotate: function(t) {
                            return this.clone()._rotate(t)
                        },
                        rotateAround: function(t, n) {
                            return this.clone()._rotateAround(t, n)
                        },
                        matMult: function(t) {
                            return this.clone()._matMult(t)
                        },
                        unit: function() {
                            return this.clone()._unit()
                        },
                        perp: function() {
                            return this.clone()._perp()
                        },
                        round: function() {
                            return this.clone()._round()
                        },
                        mag: function() {
                            return Math.sqrt(this.x * this.x + this.y * this.y)
                        },
                        equals: function(t) {
                            return this.x === t.x && this.y === t.y
                        },
                        dist: function(t) {
                            return Math.sqrt(this.distSqr(t))
                        },
                        distSqr: function(t) {
                            var n = t.x - this.x
                              , s = t.y - this.y;
                            return n * n + s * s
                        },
                        angle: function() {
                            return Math.atan2(this.y, this.x)
                        },
                        angleTo: function(t) {
                            return Math.atan2(this.y - t.y, this.x - t.x)
                        },
                        angleWith: function(t) {
                            return this.angleWithSep(t.x, t.y)
                        },
                        angleWithSep: function(t, n) {
                            return Math.atan2(this.x * n - this.y * t, this.x * t + this.y * n)
                        },
                        _matMult: function(t) {
                            var n = t[2] * this.x + t[3] * this.y;
                            return this.x = t[0] * this.x + t[1] * this.y,
                            this.y = n,
                            this
                        },
                        _add: function(t) {
                            return this.x += t.x,
                            this.y += t.y,
                            this
                        },
                        _sub: function(t) {
                            return this.x -= t.x,
                            this.y -= t.y,
                            this
                        },
                        _mult: function(t) {
                            return this.x *= t,
                            this.y *= t,
                            this
                        },
                        _div: function(t) {
                            return this.x /= t,
                            this.y /= t,
                            this
                        },
                        _multByPoint: function(t) {
                            return this.x *= t.x,
                            this.y *= t.y,
                            this
                        },
                        _divByPoint: function(t) {
                            return this.x /= t.x,
                            this.y /= t.y,
                            this
                        },
                        _unit: function() {
                            return this._div(this.mag()),
                            this
                        },
                        _perp: function() {
                            var t = this.y;
                            return this.y = this.x,
                            this.x = -t,
                            this
                        },
                        _rotate: function(t) {
                            var n = Math.cos(t)
                              , s = Math.sin(t)
                              , c = s * this.x + n * this.y;
                            return this.x = n * this.x - s * this.y,
                            this.y = c,
                            this
                        },
                        _rotateAround: function(t, n) {
                            var s = Math.cos(t)
                              , c = Math.sin(t)
                              , d = n.y + c * (this.x - n.x) + s * (this.y - n.y);
                            return this.x = n.x + s * (this.x - n.x) - c * (this.y - n.y),
                            this.y = d,
                            this
                        },
                        _round: function() {
                            return this.x = Math.round(this.x),
                            this.y = Math.round(this.y),
                            this
                        }
                    },
                    r.convert = function(t) {
                        return t instanceof r ? t : Array.isArray(t) ? new r(t[0],t[1]) : t
                    }
                    ,
                    de
                }
                typeof SuppressedError == "function" && SuppressedError;
                var oe, Y, Te = ce(ze()), He = function() {
                    if (Y)
                        return oe;
                    function r(t, n, s, c) {
                        this.cx = 3 * t,
                        this.bx = 3 * (s - t) - this.cx,
                        this.ax = 1 - this.cx - this.bx,
                        this.cy = 3 * n,
                        this.by = 3 * (c - n) - this.cy,
                        this.ay = 1 - this.cy - this.by,
                        this.p1x = t,
                        this.p1y = n,
                        this.p2x = s,
                        this.p2y = c
                    }
                    return Y = 1,
                    oe = r,
                    r.prototype = {
                        sampleCurveX: function(t) {
                            return ((this.ax * t + this.bx) * t + this.cx) * t
                        },
                        sampleCurveY: function(t) {
                            return ((this.ay * t + this.by) * t + this.cy) * t
                        },
                        sampleCurveDerivativeX: function(t) {
                            return (3 * this.ax * t + 2 * this.bx) * t + this.cx
                        },
                        solveCurveX: function(t, n) {
                            if (n === void 0 && (n = 1e-6),
                            t < 0)
                                return 0;
                            if (t > 1)
                                return 1;
                            for (var s = t, c = 0; c < 8; c++) {
                                var d = this.sampleCurveX(s) - t;
                                if (Math.abs(d) < n)
                                    return s;
                                var p = this.sampleCurveDerivativeX(s);
                                if (Math.abs(p) < 1e-6)
                                    break;
                                s -= d / p
                            }
                            var g = 0
                              , x = 1;
                            for (s = t,
                            c = 0; c < 20 && (d = this.sampleCurveX(s),
                            !(Math.abs(d - t) < n)); c++)
                                t > d ? g = s : x = s,
                                s = .5 * (x - g) + g;
                            return s
                        },
                        solve: function(t, n) {
                            return this.sampleCurveY(this.solveCurveX(t, n))
                        }
                    },
                    oe
                }(), ft = ce(He);
                let Pt, vt;
                function St() {
                    return Pt == null && (Pt = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1,1).getContext("2d") && typeof createImageBitmap == "function"),
                    Pt
                }
                function Wt() {
                    if (vt == null && (vt = !1,
                    St())) {
                        const t = new OffscreenCanvas(5,5).getContext("2d", {
                            willReadFrequently: !0
                        });
                        if (t) {
                            for (let s = 0; s < 5 * 5; s++) {
                                const c = 4 * s;
                                t.fillStyle = `rgb(${c},${c + 1},${c + 2})`,
                                t.fillRect(s % 5, Math.floor(s / 5), 1, 1)
                            }
                            const n = t.getImageData(0, 0, 5, 5).data;
                            for (let s = 0; s < 5 * 5 * 4; s++)
                                if (s % 4 != 3 && n[s] !== s) {
                                    vt = !0;
                                    break
                                }
                        }
                    }
                    return vt || !1
                }
                var pi, Mt = 1e-6, gt = typeof Float32Array < "u" ? Float32Array : Array;
                function It() {
                    var r = new gt(9);
                    return gt != Float32Array && (r[1] = 0,
                    r[2] = 0,
                    r[3] = 0,
                    r[5] = 0,
                    r[6] = 0,
                    r[7] = 0),
                    r[0] = 1,
                    r[4] = 1,
                    r[8] = 1,
                    r
                }
                function Pi(r) {
                    return r[0] = 1,
                    r[1] = 0,
                    r[2] = 0,
                    r[3] = 0,
                    r[4] = 0,
                    r[5] = 1,
                    r[6] = 0,
                    r[7] = 0,
                    r[8] = 0,
                    r[9] = 0,
                    r[10] = 1,
                    r[11] = 0,
                    r[12] = 0,
                    r[13] = 0,
                    r[14] = 0,
                    r[15] = 1,
                    r
                }
                function ei() {
                    var r = new gt(3);
                    return gt != Float32Array && (r[0] = 0,
                    r[1] = 0,
                    r[2] = 0),
                    r
                }
                function nt(r, t, n) {
                    var s = new gt(3);
                    return s[0] = r,
                    s[1] = t,
                    s[2] = n,
                    s
                }
                function Wi(r, t, n) {
                    var s = t[0]
                      , c = t[1]
                      , d = t[2]
                      , p = t[3];
                    return r[0] = n[0] * s + n[4] * c + n[8] * d + n[12] * p,
                    r[1] = n[1] * s + n[5] * c + n[9] * d + n[13] * p,
                    r[2] = n[2] * s + n[6] * c + n[10] * d + n[14] * p,
                    r[3] = n[3] * s + n[7] * c + n[11] * d + n[15] * p,
                    r
                }
                function Lt() {
                    var r = new gt(4);
                    return gt != Float32Array && (r[0] = 0,
                    r[1] = 0,
                    r[2] = 0),
                    r[3] = 1,
                    r
                }
                function ti() {
                    var r = new gt(2);
                    return gt != Float32Array && (r[0] = 0,
                    r[1] = 0),
                    r
                }
                function fi(r, t) {
                    var n = new gt(2);
                    return n[0] = r,
                    n[1] = t,
                    n
                }
                Math.hypot || (Math.hypot = function() {
                    for (var r = 0, t = arguments.length; t--; )
                        r += arguments[t] * arguments[t];
                    return Math.sqrt(r)
                }
                ),
                ei(),
                pi = new gt(4),
                gt != Float32Array && (pi[0] = 0,
                pi[1] = 0,
                pi[2] = 0,
                pi[3] = 0),
                ei(),
                nt(1, 0, 0),
                nt(0, 1, 0),
                Lt(),
                Lt(),
                It(),
                ti();
                const ut = 8192;
                function or(r, t, n) {
                    return t * (ut / (r.tileSize * Math.pow(2, n - r.tileID.overscaledZ)))
                }
                function ar(r, t) {
                    return (r % t + t) % t
                }
                function mi(r, t, n) {
                    return r * (1 - n) + t * n
                }
                function wr(r) {
                    if (r <= 0)
                        return 0;
                    if (r >= 1)
                        return 1;
                    const t = r * r
                      , n = t * r;
                    return 4 * (r < .5 ? n : 3 * (r - t) + n - .75)
                }
                function Br(r, t, n, s) {
                    const c = new ft(r,t,n,s);
                    return d => c.solve(d)
                }
                const gi = Br(.25, .1, .25, 1);
                function si(r, t, n) {
                    return Math.min(n, Math.max(t, r))
                }
                function _i(r, t, n) {
                    const s = n - t
                      , c = ((r - t) % s + s) % s + t;
                    return c === t ? n : c
                }
                function Ft(r, ...t) {
                    for (const n of t)
                        for (const s in n)
                            r[s] = n[s];
                    return r
                }
                let Yi = 1;
                function Xi(r, t, n) {
                    const s = {};
                    for (const c in r)
                        s[c] = t.call(this, r[c], c, r);
                    return s
                }
                function en(r, t, n) {
                    const s = {};
                    for (const c in r)
                        t.call(this, r[c], c, r) && (s[c] = r[c]);
                    return s
                }
                function Vi(r) {
                    return Array.isArray(r) ? r.map(Vi) : typeof r == "object" && r ? Xi(r, Vi) : r
                }
                const Hn = {};
                function yi(r) {
                    Hn[r] || (typeof console < "u" && console.warn(r),
                    Hn[r] = !0)
                }
                function ii(r, t, n) {
                    return (n.y - r.y) * (t.x - r.x) > (t.y - r.y) * (n.x - r.x)
                }
                function Tr(r) {
                    return typeof WorkerGlobalScope < "u" && r !== void 0 && r instanceof WorkerGlobalScope
                }
                let oi = null;
                function Wn(r) {
                    return typeof ImageBitmap < "u" && r instanceof ImageBitmap
                }
                const Xn = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAAC0lEQVQYV2NgAAIAAAUAAarVyFEAAAAASUVORK5CYII=";
                function Or(r, t, n, s, c) {
                    return l(this, void 0, void 0, function*() {
                        if (typeof VideoFrame > "u")
                            throw new Error("VideoFrame not supported");
                        const d = new VideoFrame(r,{
                            timestamp: 0
                        });
                        try {
                            const p = d?.format;
                            if (!p || !p.startsWith("BGR") && !p.startsWith("RGB"))
                                throw new Error(`Unrecognized format ${p}`);
                            const g = p.startsWith("BGR")
                              , x = new Uint8ClampedArray(s * c * 4);
                            if (yield d.copyTo(x, function(b, C, P, D, F) {
                                const B = 4 * Math.max(1, 0)
                                  , j = (Math.max(0, P) - P) * D * 4 + B
                                  , G = 4 * D
                                  , X = Math.max(0, C)
                                  , ae = Math.max(0, P);
                                return {
                                    rect: {
                                        x: X,
                                        y: ae,
                                        width: Math.min(b.width, C + D) - X,
                                        height: Math.min(b.height, P + F) - ae
                                    },
                                    layout: [{
                                        offset: j,
                                        stride: G
                                    }]
                                }
                            }(r, t, n, s, c)),
                            g)
                                for (let b = 0; b < x.length; b += 4) {
                                    const C = x[b];
                                    x[b] = x[b + 2],
                                    x[b + 2] = C
                                }
                            return x
                        } finally {
                            d.close()
                        }
                    })
                }
                let zn, kn;
                function tn(r, t, n, s) {
                    return r.addEventListener(t, n, s),
                    {
                        unsubscribe: () => {
                            r.removeEventListener(t, n, s)
                        }
                    }
                }
                function Nr(r) {
                    return r / Math.PI * 180
                }
                const ws = "AbortError";
                function Kn() {
                    return new Error(ws)
                }
                const Jn = {
                    MAX_PARALLEL_IMAGE_REQUESTS: 16,
                    MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME: 8,
                    MAX_TILE_CACHE_ZOOM_LEVELS: 5,
                    REGISTERED_PROTOCOLS: {},
                    WORKER_URL: ""
                };
                function Ts(r) {
                    return Jn.REGISTERED_PROTOCOLS[r.substring(0, r.indexOf("://"))]
                }
                const Yn = "global-dispatcher";
                class mn extends Error {
                    constructor(t, n, s, c) {
                        super(`AJAXError: ${n} (${t}): ${s}`),
                        this.status = t,
                        this.statusText = n,
                        this.url = s,
                        this.body = c
                    }
                }
                const gn = () => Tr(self) ? self.worker && self.worker.referrer : (window.location.protocol === "blob:" ? window.parent : window).location.href
                  , Ln = function(r, t) {
                    if (/:\/\//.test(r.url) && !/^https?:|^file:/.test(r.url)) {
                        const s = Ts(r.url);
                        if (s)
                            return s(r, t);
                        if (Tr(self) && self.worker && self.worker.actor)
                            return self.worker.actor.sendAsync({
                                type: "GR",
                                data: r,
                                targetMapId: Yn
                            }, t)
                    }
                    if (!(/^file:/.test(n = r.url) || /^file:/.test(gn()) && !/^\w+:/.test(n))) {
                        if (fetch && Request && AbortController && Object.prototype.hasOwnProperty.call(Request.prototype, "signal"))
                            return function(s, c) {
                                return l(this, void 0, void 0, function*() {
                                    const d = new Request(s.url,{
                                        method: s.method || "GET",
                                        body: s.body,
                                        credentials: s.credentials,
                                        headers: s.headers,
                                        cache: s.cache,
                                        referrer: gn(),
                                        signal: c.signal
                                    });
                                    let p, g;
                                    s.type !== "json" || d.headers.has("Accept") || d.headers.set("Accept", "application/json");
                                    try {
                                        p = yield fetch(d)
                                    } catch (b) {
                                        throw new mn(0,b.message,s.url,new Blob)
                                    }
                                    if (!p.ok) {
                                        const b = yield p.blob();
                                        throw new mn(p.status,p.statusText,s.url,b)
                                    }
                                    g = s.type === "arrayBuffer" || s.type === "image" ? p.arrayBuffer() : s.type === "json" ? p.json() : p.text();
                                    const x = yield g;
                                    if (c.signal.aborted)
                                        throw Kn();
                                    return {
                                        data: x,
                                        cacheControl: p.headers.get("Cache-Control"),
                                        expires: p.headers.get("Expires")
                                    }
                                })
                            }(r, t);
                        if (Tr(self) && self.worker && self.worker.actor)
                            return self.worker.actor.sendAsync({
                                type: "GR",
                                data: r,
                                mustQueue: !0,
                                targetMapId: Yn
                            }, t)
                    }
                    var n;
                    return function(s, c) {
                        return new Promise( (d, p) => {
                            var g;
                            const x = new XMLHttpRequest;
                            x.open(s.method || "GET", s.url, !0),
                            s.type !== "arrayBuffer" && s.type !== "image" || (x.responseType = "arraybuffer");
                            for (const b in s.headers)
                                x.setRequestHeader(b, s.headers[b]);
                            s.type === "json" && (x.responseType = "text",
                            !((g = s.headers) === null || g === void 0) && g.Accept || x.setRequestHeader("Accept", "application/json")),
                            x.withCredentials = s.credentials === "include",
                            x.onerror = () => {
                                p(new Error(x.statusText))
                            }
                            ,
                            x.onload = () => {
                                if (!c.signal.aborted)
                                    if ((x.status >= 200 && x.status < 300 || x.status === 0) && x.response !== null) {
                                        let b = x.response;
                                        if (s.type === "json")
                                            try {
                                                b = JSON.parse(x.response)
                                            } catch (C) {
                                                return void p(C)
                                            }
                                        d({
                                            data: b,
                                            cacheControl: x.getResponseHeader("Cache-Control"),
                                            expires: x.getResponseHeader("Expires")
                                        })
                                    } else {
                                        const b = new Blob([x.response],{
                                            type: x.getResponseHeader("Content-Type")
                                        });
                                        p(new mn(x.status,x.statusText,s.url,b))
                                    }
                            }
                            ,
                            c.signal.addEventListener("abort", () => {
                                x.abort(),
                                p(Kn())
                            }
                            ),
                            x.send(s.body)
                        }
                        )
                    }(r, t)
                };
                function Dn(r) {
                    if (!r || r.indexOf("://") <= 0 || r.indexOf("data:image/") === 0 || r.indexOf("blob:") === 0)
                        return !0;
                    const t = new URL(r)
                      , n = window.location;
                    return t.protocol === n.protocol && t.host === n.host
                }
                function eo(r, t, n) {
                    n[r] && n[r].indexOf(t) !== -1 || (n[r] = n[r] || [],
                    n[r].push(t))
                }
                function Ms(r, t, n) {
                    if (n && n[r]) {
                        const s = n[r].indexOf(t);
                        s !== -1 && n[r].splice(s, 1)
                    }
                }
                class to {
                    constructor(t, n={}) {
                        Ft(this, n),
                        this.type = t
                    }
                }
                class _n extends to {
                    constructor(t, n={}) {
                        super("error", Ft({
                            error: t
                        }, n))
                    }
                }
                class pe {
                    on(t, n) {
                        return this._listeners = this._listeners || {},
                        eo(t, n, this._listeners),
                        {
                            unsubscribe: () => {
                                this.off(t, n)
                            }
                        }
                    }
                    off(t, n) {
                        return Ms(t, n, this._listeners),
                        Ms(t, n, this._oneTimeListeners),
                        this
                    }
                    once(t, n) {
                        return n ? (this._oneTimeListeners = this._oneTimeListeners || {},
                        eo(t, n, this._oneTimeListeners),
                        this) : new Promise(s => this.once(t, s))
                    }
                    fire(t, n) {
                        typeof t == "string" && (t = new to(t,n || {}));
                        const s = t.type;
                        if (this.listens(s)) {
                            t.target = this;
                            const c = this._listeners && this._listeners[s] ? this._listeners[s].slice() : [];
                            for (const g of c)
                                g.call(this, t);
                            const d = this._oneTimeListeners && this._oneTimeListeners[s] ? this._oneTimeListeners[s].slice() : [];
                            for (const g of d)
                                Ms(s, g, this._oneTimeListeners),
                                g.call(this, t);
                            const p = this._eventedParent;
                            p && (Ft(t, typeof this._eventedParentData == "function" ? this._eventedParentData() : this._eventedParentData),
                            p.fire(t))
                        } else
                            t instanceof _n && console.error(t.error);
                        return this
                    }
                    listens(t) {
                        return this._listeners && this._listeners[t] && this._listeners[t].length > 0 || this._oneTimeListeners && this._oneTimeListeners[t] && this._oneTimeListeners[t].length > 0 || this._eventedParent && this._eventedParent.listens(t)
                    }
                    setEventedParent(t, n) {
                        return this._eventedParent = t,
                        this._eventedParentData = n,
                        this
                    }
                }
                var E = {
                    $version: 8,
                    $root: {
                        version: {
                            required: !0,
                            type: "enum",
                            values: [8]
                        },
                        name: {
                            type: "string"
                        },
                        metadata: {
                            type: "*"
                        },
                        center: {
                            type: "array",
                            value: "number"
                        },
                        centerAltitude: {
                            type: "number"
                        },
                        zoom: {
                            type: "number"
                        },
                        bearing: {
                            type: "number",
                            default: 0,
                            period: 360,
                            units: "degrees"
                        },
                        pitch: {
                            type: "number",
                            default: 0,
                            units: "degrees"
                        },
                        roll: {
                            type: "number",
                            default: 0,
                            units: "degrees"
                        },
                        light: {
                            type: "light"
                        },
                        sky: {
                            type: "sky"
                        },
                        projection: {
                            type: "projection"
                        },
                        terrain: {
                            type: "terrain"
                        },
                        sources: {
                            required: !0,
                            type: "sources"
                        },
                        sprite: {
                            type: "sprite"
                        },
                        glyphs: {
                            type: "string"
                        },
                        transition: {
                            type: "transition"
                        },
                        layers: {
                            required: !0,
                            type: "array",
                            value: "layer"
                        }
                    },
                    sources: {
                        "*": {
                            type: "source"
                        }
                    },
                    source: ["source_vector", "source_raster", "source_raster_dem", "source_geojson", "source_video", "source_image"],
                    source_vector: {
                        type: {
                            required: !0,
                            type: "enum",
                            values: {
                                vector: {}
                            }
                        },
                        url: {
                            type: "string"
                        },
                        tiles: {
                            type: "array",
                            value: "string"
                        },
                        bounds: {
                            type: "array",
                            value: "number",
                            length: 4,
                            default: [-180, -85.051129, 180, 85.051129]
                        },
                        scheme: {
                            type: "enum",
                            values: {
                                xyz: {},
                                tms: {}
                            },
                            default: "xyz"
                        },
                        minzoom: {
                            type: "number",
                            default: 0
                        },
                        maxzoom: {
                            type: "number",
                            default: 22
                        },
                        attribution: {
                            type: "string"
                        },
                        promoteId: {
                            type: "promoteId"
                        },
                        volatile: {
                            type: "boolean",
                            default: !1
                        },
                        "*": {
                            type: "*"
                        }
                    },
                    source_raster: {
                        type: {
                            required: !0,
                            type: "enum",
                            values: {
                                raster: {}
                            }
                        },
                        url: {
                            type: "string"
                        },
                        tiles: {
                            type: "array",
                            value: "string"
                        },
                        bounds: {
                            type: "array",
                            value: "number",
                            length: 4,
                            default: [-180, -85.051129, 180, 85.051129]
                        },
                        minzoom: {
                            type: "number",
                            default: 0
                        },
                        maxzoom: {
                            type: "number",
                            default: 22
                        },
                        tileSize: {
                            type: "number",
                            default: 512,
                            units: "pixels"
                        },
                        scheme: {
                            type: "enum",
                            values: {
                                xyz: {},
                                tms: {}
                            },
                            default: "xyz"
                        },
                        attribution: {
                            type: "string"
                        },
                        volatile: {
                            type: "boolean",
                            default: !1
                        },
                        "*": {
                            type: "*"
                        }
                    },
                    source_raster_dem: {
                        type: {
                            required: !0,
                            type: "enum",
                            values: {
                                "raster-dem": {}
                            }
                        },
                        url: {
                            type: "string"
                        },
                        tiles: {
                            type: "array",
                            value: "string"
                        },
                        bounds: {
                            type: "array",
                            value: "number",
                            length: 4,
                            default: [-180, -85.051129, 180, 85.051129]
                        },
                        minzoom: {
                            type: "number",
                            default: 0
                        },
                        maxzoom: {
                            type: "number",
                            default: 22
                        },
                        tileSize: {
                            type: "number",
                            default: 512,
                            units: "pixels"
                        },
                        attribution: {
                            type: "string"
                        },
                        encoding: {
                            type: "enum",
                            values: {
                                terrarium: {},
                                mapbox: {},
                                custom: {}
                            },
                            default: "mapbox"
                        },
                        redFactor: {
                            type: "number",
                            default: 1
                        },
                        blueFactor: {
                            type: "number",
                            default: 1
                        },
                        greenFactor: {
                            type: "number",
                            default: 1
                        },
                        baseShift: {
                            type: "number",
                            default: 0
                        },
                        volatile: {
                            type: "boolean",
                            default: !1
                        },
                        "*": {
                            type: "*"
                        }
                    },
                    source_geojson: {
                        type: {
                            required: !0,
                            type: "enum",
                            values: {
                                geojson: {}
                            }
                        },
                        data: {
                            required: !0,
                            type: "*"
                        },
                        maxzoom: {
                            type: "number",
                            default: 18
                        },
                        attribution: {
                            type: "string"
                        },
                        buffer: {
                            type: "number",
                            default: 128,
                            maximum: 512,
                            minimum: 0
                        },
                        filter: {
                            type: "*"
                        },
                        tolerance: {
                            type: "number",
                            default: .375
                        },
                        cluster: {
                            type: "boolean",
                            default: !1
                        },
                        clusterRadius: {
                            type: "number",
                            default: 50,
                            minimum: 0
                        },
                        clusterMaxZoom: {
                            type: "number"
                        },
                        clusterMinPoints: {
                            type: "number"
                        },
                        clusterProperties: {
                            type: "*"
                        },
                        lineMetrics: {
                            type: "boolean",
                            default: !1
                        },
                        generateId: {
                            type: "boolean",
                            default: !1
                        },
                        promoteId: {
                            type: "promoteId"
                        }
                    },
                    source_video: {
                        type: {
                            required: !0,
                            type: "enum",
                            values: {
                                video: {}
                            }
                        },
                        urls: {
                            required: !0,
                            type: "array",
                            value: "string"
                        },
                        coordinates: {
                            required: !0,
                            type: "array",
                            length: 4,
                            value: {
                                type: "array",
                                length: 2,
                                value: "number"
                            }
                        }
                    },
                    source_image: {
                        type: {
                            required: !0,
                            type: "enum",
                            values: {
                                image: {}
                            }
                        },
                        url: {
                            required: !0,
                            type: "string"
                        },
                        coordinates: {
                            required: !0,
                            type: "array",
                            length: 4,
                            value: {
                                type: "array",
                                length: 2,
                                value: "number"
                            }
                        }
                    },
                    layer: {
                        id: {
                            type: "string",
                            required: !0
                        },
                        type: {
                            type: "enum",
                            values: {
                                fill: {},
                                line: {},
                                symbol: {},
                                circle: {},
                                heatmap: {},
                                "fill-extrusion": {},
                                raster: {},
                                hillshade: {},
                                background: {}
                            },
                            required: !0
                        },
                        metadata: {
                            type: "*"
                        },
                        source: {
                            type: "string"
                        },
                        "source-layer": {
                            type: "string"
                        },
                        minzoom: {
                            type: "number",
                            minimum: 0,
                            maximum: 24
                        },
                        maxzoom: {
                            type: "number",
                            minimum: 0,
                            maximum: 24
                        },
                        filter: {
                            type: "filter"
                        },
                        layout: {
                            type: "layout"
                        },
                        paint: {
                            type: "paint"
                        }
                    },
                    layout: ["layout_fill", "layout_line", "layout_circle", "layout_heatmap", "layout_fill-extrusion", "layout_symbol", "layout_raster", "layout_hillshade", "layout_background"],
                    layout_background: {
                        visibility: {
                            type: "enum",
                            values: {
                                visible: {},
                                none: {}
                            },
                            default: "visible",
                            "property-type": "constant"
                        }
                    },
                    layout_fill: {
                        "fill-sort-key": {
                            type: "number",
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom", "feature"]
                            },
                            "property-type": "data-driven"
                        },
                        visibility: {
                            type: "enum",
                            values: {
                                visible: {},
                                none: {}
                            },
                            default: "visible",
                            "property-type": "constant"
                        }
                    },
                    layout_circle: {
                        "circle-sort-key": {
                            type: "number",
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom", "feature"]
                            },
                            "property-type": "data-driven"
                        },
                        visibility: {
                            type: "enum",
                            values: {
                                visible: {},
                                none: {}
                            },
                            default: "visible",
                            "property-type": "constant"
                        }
                    },
                    layout_heatmap: {
                        visibility: {
                            type: "enum",
                            values: {
                                visible: {},
                                none: {}
                            },
                            default: "visible",
                            "property-type": "constant"
                        }
                    },
                    "layout_fill-extrusion": {
                        visibility: {
                            type: "enum",
                            values: {
                                visible: {},
                                none: {}
                            },
                            default: "visible",
                            "property-type": "constant"
                        }
                    },
                    layout_line: {
                        "line-cap": {
                            type: "enum",
                            values: {
                                butt: {},
                                round: {},
                                square: {}
                            },
                            default: "butt",
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "line-join": {
                            type: "enum",
                            values: {
                                bevel: {},
                                round: {},
                                miter: {}
                            },
                            default: "miter",
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom", "feature"]
                            },
                            "property-type": "data-driven"
                        },
                        "line-miter-limit": {
                            type: "number",
                            default: 2,
                            requires: [{
                                "line-join": "miter"
                            }],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "line-round-limit": {
                            type: "number",
                            default: 1.05,
                            requires: [{
                                "line-join": "round"
                            }],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "line-sort-key": {
                            type: "number",
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom", "feature"]
                            },
                            "property-type": "data-driven"
                        },
                        visibility: {
                            type: "enum",
                            values: {
                                visible: {},
                                none: {}
                            },
                            default: "visible",
                            "property-type": "constant"
                        }
                    },
                    layout_symbol: {
                        "symbol-placement": {
                            type: "enum",
                            values: {
                                point: {},
                                line: {},
                                "line-center": {}
                            },
                            default: "point",
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "symbol-spacing": {
                            type: "number",
                            default: 250,
                            minimum: 1,
                            units: "pixels",
                            requires: [{
                                "symbol-placement": "line"
                            }],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "symbol-avoid-edges": {
                            type: "boolean",
                            default: !1,
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "symbol-sort-key": {
                            type: "number",
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom", "feature"]
                            },
                            "property-type": "data-driven"
                        },
                        "symbol-z-order": {
                            type: "enum",
                            values: {
                                auto: {},
                                "viewport-y": {},
                                source: {}
                            },
                            default: "auto",
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "icon-allow-overlap": {
                            type: "boolean",
                            default: !1,
                            requires: ["icon-image", {
                                "!": "icon-overlap"
                            }],
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "icon-overlap": {
                            type: "enum",
                            values: {
                                never: {},
                                always: {},
                                cooperative: {}
                            },
                            requires: ["icon-image"],
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "icon-ignore-placement": {
                            type: "boolean",
                            default: !1,
                            requires: ["icon-image"],
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "icon-optional": {
                            type: "boolean",
                            default: !1,
                            requires: ["icon-image", "text-field"],
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "icon-rotation-alignment": {
                            type: "enum",
                            values: {
                                map: {},
                                viewport: {},
                                auto: {}
                            },
                            default: "auto",
                            requires: ["icon-image"],
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "icon-size": {
                            type: "number",
                            default: 1,
                            minimum: 0,
                            units: "factor of the original icon size",
                            requires: ["icon-image"],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature"]
                            },
                            "property-type": "data-driven"
                        },
                        "icon-text-fit": {
                            type: "enum",
                            values: {
                                none: {},
                                width: {},
                                height: {},
                                both: {}
                            },
                            default: "none",
                            requires: ["icon-image", "text-field"],
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "icon-text-fit-padding": {
                            type: "array",
                            value: "number",
                            length: 4,
                            default: [0, 0, 0, 0],
                            units: "pixels",
                            requires: ["icon-image", "text-field", {
                                "icon-text-fit": ["both", "width", "height"]
                            }],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "icon-image": {
                            type: "resolvedImage",
                            tokens: !0,
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom", "feature"]
                            },
                            "property-type": "data-driven"
                        },
                        "icon-rotate": {
                            type: "number",
                            default: 0,
                            period: 360,
                            units: "degrees",
                            requires: ["icon-image"],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature"]
                            },
                            "property-type": "data-driven"
                        },
                        "icon-padding": {
                            type: "padding",
                            default: [2],
                            units: "pixels",
                            requires: ["icon-image"],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature"]
                            },
                            "property-type": "data-driven"
                        },
                        "icon-keep-upright": {
                            type: "boolean",
                            default: !1,
                            requires: ["icon-image", {
                                "icon-rotation-alignment": "map"
                            }, {
                                "symbol-placement": ["line", "line-center"]
                            }],
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "icon-offset": {
                            type: "array",
                            value: "number",
                            length: 2,
                            default: [0, 0],
                            requires: ["icon-image"],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature"]
                            },
                            "property-type": "data-driven"
                        },
                        "icon-anchor": {
                            type: "enum",
                            values: {
                                center: {},
                                left: {},
                                right: {},
                                top: {},
                                bottom: {},
                                "top-left": {},
                                "top-right": {},
                                "bottom-left": {},
                                "bottom-right": {}
                            },
                            default: "center",
                            requires: ["icon-image"],
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom", "feature"]
                            },
                            "property-type": "data-driven"
                        },
                        "icon-pitch-alignment": {
                            type: "enum",
                            values: {
                                map: {},
                                viewport: {},
                                auto: {}
                            },
                            default: "auto",
                            requires: ["icon-image"],
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "text-pitch-alignment": {
                            type: "enum",
                            values: {
                                map: {},
                                viewport: {},
                                auto: {}
                            },
                            default: "auto",
                            requires: ["text-field"],
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "text-rotation-alignment": {
                            type: "enum",
                            values: {
                                map: {},
                                viewport: {},
                                "viewport-glyph": {},
                                auto: {}
                            },
                            default: "auto",
                            requires: ["text-field"],
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "text-field": {
                            type: "formatted",
                            default: "",
                            tokens: !0,
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom", "feature"]
                            },
                            "property-type": "data-driven"
                        },
                        "text-font": {
                            type: "array",
                            value: "string",
                            default: ["Open Sans Regular", "Arial Unicode MS Regular"],
                            requires: ["text-field"],
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom", "feature"]
                            },
                            "property-type": "data-driven"
                        },
                        "text-size": {
                            type: "number",
                            default: 16,
                            minimum: 0,
                            units: "pixels",
                            requires: ["text-field"],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature"]
                            },
                            "property-type": "data-driven"
                        },
                        "text-max-width": {
                            type: "number",
                            default: 10,
                            minimum: 0,
                            units: "ems",
                            requires: ["text-field"],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature"]
                            },
                            "property-type": "data-driven"
                        },
                        "text-line-height": {
                            type: "number",
                            default: 1.2,
                            units: "ems",
                            requires: ["text-field"],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "text-letter-spacing": {
                            type: "number",
                            default: 0,
                            units: "ems",
                            requires: ["text-field"],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature"]
                            },
                            "property-type": "data-driven"
                        },
                        "text-justify": {
                            type: "enum",
                            values: {
                                auto: {},
                                left: {},
                                center: {},
                                right: {}
                            },
                            default: "center",
                            requires: ["text-field"],
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom", "feature"]
                            },
                            "property-type": "data-driven"
                        },
                        "text-radial-offset": {
                            type: "number",
                            units: "ems",
                            default: 0,
                            requires: ["text-field"],
                            "property-type": "data-driven",
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature"]
                            }
                        },
                        "text-variable-anchor": {
                            type: "array",
                            value: "enum",
                            values: {
                                center: {},
                                left: {},
                                right: {},
                                top: {},
                                bottom: {},
                                "top-left": {},
                                "top-right": {},
                                "bottom-left": {},
                                "bottom-right": {}
                            },
                            requires: ["text-field", {
                                "symbol-placement": ["point"]
                            }],
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "text-variable-anchor-offset": {
                            type: "variableAnchorOffsetCollection",
                            requires: ["text-field", {
                                "symbol-placement": ["point"]
                            }],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature"]
                            },
                            "property-type": "data-driven"
                        },
                        "text-anchor": {
                            type: "enum",
                            values: {
                                center: {},
                                left: {},
                                right: {},
                                top: {},
                                bottom: {},
                                "top-left": {},
                                "top-right": {},
                                "bottom-left": {},
                                "bottom-right": {}
                            },
                            default: "center",
                            requires: ["text-field", {
                                "!": "text-variable-anchor"
                            }],
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom", "feature"]
                            },
                            "property-type": "data-driven"
                        },
                        "text-max-angle": {
                            type: "number",
                            default: 45,
                            units: "degrees",
                            requires: ["text-field", {
                                "symbol-placement": ["line", "line-center"]
                            }],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "text-writing-mode": {
                            type: "array",
                            value: "enum",
                            values: {
                                horizontal: {},
                                vertical: {}
                            },
                            requires: ["text-field", {
                                "symbol-placement": ["point"]
                            }],
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "text-rotate": {
                            type: "number",
                            default: 0,
                            period: 360,
                            units: "degrees",
                            requires: ["text-field"],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature"]
                            },
                            "property-type": "data-driven"
                        },
                        "text-padding": {
                            type: "number",
                            default: 2,
                            minimum: 0,
                            units: "pixels",
                            requires: ["text-field"],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "text-keep-upright": {
                            type: "boolean",
                            default: !0,
                            requires: ["text-field", {
                                "text-rotation-alignment": "map"
                            }, {
                                "symbol-placement": ["line", "line-center"]
                            }],
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "text-transform": {
                            type: "enum",
                            values: {
                                none: {},
                                uppercase: {},
                                lowercase: {}
                            },
                            default: "none",
                            requires: ["text-field"],
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom", "feature"]
                            },
                            "property-type": "data-driven"
                        },
                        "text-offset": {
                            type: "array",
                            value: "number",
                            units: "ems",
                            length: 2,
                            default: [0, 0],
                            requires: ["text-field", {
                                "!": "text-radial-offset"
                            }],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature"]
                            },
                            "property-type": "data-driven"
                        },
                        "text-allow-overlap": {
                            type: "boolean",
                            default: !1,
                            requires: ["text-field", {
                                "!": "text-overlap"
                            }],
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "text-overlap": {
                            type: "enum",
                            values: {
                                never: {},
                                always: {},
                                cooperative: {}
                            },
                            requires: ["text-field"],
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "text-ignore-placement": {
                            type: "boolean",
                            default: !1,
                            requires: ["text-field"],
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "text-optional": {
                            type: "boolean",
                            default: !1,
                            requires: ["text-field", "icon-image"],
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        visibility: {
                            type: "enum",
                            values: {
                                visible: {},
                                none: {}
                            },
                            default: "visible",
                            "property-type": "constant"
                        }
                    },
                    layout_raster: {
                        visibility: {
                            type: "enum",
                            values: {
                                visible: {},
                                none: {}
                            },
                            default: "visible",
                            "property-type": "constant"
                        }
                    },
                    layout_hillshade: {
                        visibility: {
                            type: "enum",
                            values: {
                                visible: {},
                                none: {}
                            },
                            default: "visible",
                            "property-type": "constant"
                        }
                    },
                    filter: {
                        type: "array",
                        value: "*"
                    },
                    filter_operator: {
                        type: "enum",
                        values: {
                            "==": {},
                            "!=": {},
                            ">": {},
                            ">=": {},
                            "<": {},
                            "<=": {},
                            in: {},
                            "!in": {},
                            all: {},
                            any: {},
                            none: {},
                            has: {},
                            "!has": {}
                        }
                    },
                    geometry_type: {
                        type: "enum",
                        values: {
                            Point: {},
                            LineString: {},
                            Polygon: {}
                        }
                    },
                    function: {
                        expression: {
                            type: "expression"
                        },
                        stops: {
                            type: "array",
                            value: "function_stop"
                        },
                        base: {
                            type: "number",
                            default: 1,
                            minimum: 0
                        },
                        property: {
                            type: "string",
                            default: "$zoom"
                        },
                        type: {
                            type: "enum",
                            values: {
                                identity: {},
                                exponential: {},
                                interval: {},
                                categorical: {}
                            },
                            default: "exponential"
                        },
                        colorSpace: {
                            type: "enum",
                            values: {
                                rgb: {},
                                lab: {},
                                hcl: {}
                            },
                            default: "rgb"
                        },
                        default: {
                            type: "*",
                            required: !1
                        }
                    },
                    function_stop: {
                        type: "array",
                        minimum: 0,
                        maximum: 24,
                        value: ["number", "color"],
                        length: 2
                    },
                    expression: {
                        type: "array",
                        value: "*",
                        minimum: 1
                    },
                    light: {
                        anchor: {
                            type: "enum",
                            default: "viewport",
                            values: {
                                map: {},
                                viewport: {}
                            },
                            "property-type": "data-constant",
                            transition: !1,
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            }
                        },
                        position: {
                            type: "array",
                            default: [1.15, 210, 30],
                            length: 3,
                            value: "number",
                            "property-type": "data-constant",
                            transition: !0,
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            }
                        },
                        color: {
                            type: "color",
                            "property-type": "data-constant",
                            default: "#ffffff",
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            transition: !0
                        },
                        intensity: {
                            type: "number",
                            "property-type": "data-constant",
                            default: .5,
                            minimum: 0,
                            maximum: 1,
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            transition: !0
                        }
                    },
                    sky: {
                        "sky-color": {
                            type: "color",
                            "property-type": "data-constant",
                            default: "#88C6FC",
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            transition: !0
                        },
                        "horizon-color": {
                            type: "color",
                            "property-type": "data-constant",
                            default: "#ffffff",
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            transition: !0
                        },
                        "fog-color": {
                            type: "color",
                            "property-type": "data-constant",
                            default: "#ffffff",
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            transition: !0
                        },
                        "fog-ground-blend": {
                            type: "number",
                            "property-type": "data-constant",
                            default: .5,
                            minimum: 0,
                            maximum: 1,
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            transition: !0
                        },
                        "horizon-fog-blend": {
                            type: "number",
                            "property-type": "data-constant",
                            default: .8,
                            minimum: 0,
                            maximum: 1,
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            transition: !0
                        },
                        "sky-horizon-blend": {
                            type: "number",
                            "property-type": "data-constant",
                            default: .8,
                            minimum: 0,
                            maximum: 1,
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            transition: !0
                        },
                        "atmosphere-blend": {
                            type: "number",
                            "property-type": "data-constant",
                            default: .8,
                            minimum: 0,
                            maximum: 1,
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            transition: !0
                        }
                    },
                    terrain: {
                        source: {
                            type: "string",
                            required: !0
                        },
                        exaggeration: {
                            type: "number",
                            minimum: 0,
                            default: 1
                        }
                    },
                    projection: {
                        type: {
                            type: "projectionDefinition",
                            default: "mercator",
                            "property-type": "data-constant",
                            transition: !1,
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            }
                        }
                    },
                    paint: ["paint_fill", "paint_line", "paint_circle", "paint_heatmap", "paint_fill-extrusion", "paint_symbol", "paint_raster", "paint_hillshade", "paint_background"],
                    paint_fill: {
                        "fill-antialias": {
                            type: "boolean",
                            default: !0,
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "fill-opacity": {
                            type: "number",
                            default: 1,
                            minimum: 0,
                            maximum: 1,
                            transition: !0,
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature", "feature-state"]
                            },
                            "property-type": "data-driven"
                        },
                        "fill-color": {
                            type: "color",
                            default: "#000000",
                            transition: !0,
                            requires: [{
                                "!": "fill-pattern"
                            }],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature", "feature-state"]
                            },
                            "property-type": "data-driven"
                        },
                        "fill-outline-color": {
                            type: "color",
                            transition: !0,
                            requires: [{
                                "!": "fill-pattern"
                            }, {
                                "fill-antialias": !0
                            }],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature", "feature-state"]
                            },
                            "property-type": "data-driven"
                        },
                        "fill-translate": {
                            type: "array",
                            value: "number",
                            length: 2,
                            default: [0, 0],
                            transition: !0,
                            units: "pixels",
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "fill-translate-anchor": {
                            type: "enum",
                            values: {
                                map: {},
                                viewport: {}
                            },
                            default: "map",
                            requires: ["fill-translate"],
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "fill-pattern": {
                            type: "resolvedImage",
                            transition: !0,
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom", "feature"]
                            },
                            "property-type": "cross-faded-data-driven"
                        }
                    },
                    "paint_fill-extrusion": {
                        "fill-extrusion-opacity": {
                            type: "number",
                            default: 1,
                            minimum: 0,
                            maximum: 1,
                            transition: !0,
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "fill-extrusion-color": {
                            type: "color",
                            default: "#000000",
                            transition: !0,
                            requires: [{
                                "!": "fill-extrusion-pattern"
                            }],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature", "feature-state"]
                            },
                            "property-type": "data-driven"
                        },
                        "fill-extrusion-translate": {
                            type: "array",
                            value: "number",
                            length: 2,
                            default: [0, 0],
                            transition: !0,
                            units: "pixels",
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "fill-extrusion-translate-anchor": {
                            type: "enum",
                            values: {
                                map: {},
                                viewport: {}
                            },
                            default: "map",
                            requires: ["fill-extrusion-translate"],
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "fill-extrusion-pattern": {
                            type: "resolvedImage",
                            transition: !0,
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom", "feature"]
                            },
                            "property-type": "cross-faded-data-driven"
                        },
                        "fill-extrusion-height": {
                            type: "number",
                            default: 0,
                            minimum: 0,
                            units: "meters",
                            transition: !0,
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature", "feature-state"]
                            },
                            "property-type": "data-driven"
                        },
                        "fill-extrusion-base": {
                            type: "number",
                            default: 0,
                            minimum: 0,
                            units: "meters",
                            transition: !0,
                            requires: ["fill-extrusion-height"],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature", "feature-state"]
                            },
                            "property-type": "data-driven"
                        },
                        "fill-extrusion-vertical-gradient": {
                            type: "boolean",
                            default: !0,
                            transition: !1,
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        }
                    },
                    paint_line: {
                        "line-opacity": {
                            type: "number",
                            default: 1,
                            minimum: 0,
                            maximum: 1,
                            transition: !0,
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature", "feature-state"]
                            },
                            "property-type": "data-driven"
                        },
                        "line-color": {
                            type: "color",
                            default: "#000000",
                            transition: !0,
                            requires: [{
                                "!": "line-pattern"
                            }],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature", "feature-state"]
                            },
                            "property-type": "data-driven"
                        },
                        "line-translate": {
                            type: "array",
                            value: "number",
                            length: 2,
                            default: [0, 0],
                            transition: !0,
                            units: "pixels",
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "line-translate-anchor": {
                            type: "enum",
                            values: {
                                map: {},
                                viewport: {}
                            },
                            default: "map",
                            requires: ["line-translate"],
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "line-width": {
                            type: "number",
                            default: 1,
                            minimum: 0,
                            transition: !0,
                            units: "pixels",
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature", "feature-state"]
                            },
                            "property-type": "data-driven"
                        },
                        "line-gap-width": {
                            type: "number",
                            default: 0,
                            minimum: 0,
                            transition: !0,
                            units: "pixels",
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature", "feature-state"]
                            },
                            "property-type": "data-driven"
                        },
                        "line-offset": {
                            type: "number",
                            default: 0,
                            transition: !0,
                            units: "pixels",
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature", "feature-state"]
                            },
                            "property-type": "data-driven"
                        },
                        "line-blur": {
                            type: "number",
                            default: 0,
                            minimum: 0,
                            transition: !0,
                            units: "pixels",
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature", "feature-state"]
                            },
                            "property-type": "data-driven"
                        },
                        "line-dasharray": {
                            type: "array",
                            value: "number",
                            minimum: 0,
                            transition: !0,
                            units: "line widths",
                            requires: [{
                                "!": "line-pattern"
                            }],
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "cross-faded"
                        },
                        "line-pattern": {
                            type: "resolvedImage",
                            transition: !0,
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom", "feature"]
                            },
                            "property-type": "cross-faded-data-driven"
                        },
                        "line-gradient": {
                            type: "color",
                            transition: !1,
                            requires: [{
                                "!": "line-dasharray"
                            }, {
                                "!": "line-pattern"
                            }, {
                                source: "geojson",
                                has: {
                                    lineMetrics: !0
                                }
                            }],
                            expression: {
                                interpolated: !0,
                                parameters: ["line-progress"]
                            },
                            "property-type": "color-ramp"
                        }
                    },
                    paint_circle: {
                        "circle-radius": {
                            type: "number",
                            default: 5,
                            minimum: 0,
                            transition: !0,
                            units: "pixels",
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature", "feature-state"]
                            },
                            "property-type": "data-driven"
                        },
                        "circle-color": {
                            type: "color",
                            default: "#000000",
                            transition: !0,
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature", "feature-state"]
                            },
                            "property-type": "data-driven"
                        },
                        "circle-blur": {
                            type: "number",
                            default: 0,
                            transition: !0,
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature", "feature-state"]
                            },
                            "property-type": "data-driven"
                        },
                        "circle-opacity": {
                            type: "number",
                            default: 1,
                            minimum: 0,
                            maximum: 1,
                            transition: !0,
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature", "feature-state"]
                            },
                            "property-type": "data-driven"
                        },
                        "circle-translate": {
                            type: "array",
                            value: "number",
                            length: 2,
                            default: [0, 0],
                            transition: !0,
                            units: "pixels",
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "circle-translate-anchor": {
                            type: "enum",
                            values: {
                                map: {},
                                viewport: {}
                            },
                            default: "map",
                            requires: ["circle-translate"],
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "circle-pitch-scale": {
                            type: "enum",
                            values: {
                                map: {},
                                viewport: {}
                            },
                            default: "map",
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "circle-pitch-alignment": {
                            type: "enum",
                            values: {
                                map: {},
                                viewport: {}
                            },
                            default: "viewport",
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "circle-stroke-width": {
                            type: "number",
                            default: 0,
                            minimum: 0,
                            transition: !0,
                            units: "pixels",
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature", "feature-state"]
                            },
                            "property-type": "data-driven"
                        },
                        "circle-stroke-color": {
                            type: "color",
                            default: "#000000",
                            transition: !0,
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature", "feature-state"]
                            },
                            "property-type": "data-driven"
                        },
                        "circle-stroke-opacity": {
                            type: "number",
                            default: 1,
                            minimum: 0,
                            maximum: 1,
                            transition: !0,
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature", "feature-state"]
                            },
                            "property-type": "data-driven"
                        }
                    },
                    paint_heatmap: {
                        "heatmap-radius": {
                            type: "number",
                            default: 30,
                            minimum: 1,
                            transition: !0,
                            units: "pixels",
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature", "feature-state"]
                            },
                            "property-type": "data-driven"
                        },
                        "heatmap-weight": {
                            type: "number",
                            default: 1,
                            minimum: 0,
                            transition: !1,
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature", "feature-state"]
                            },
                            "property-type": "data-driven"
                        },
                        "heatmap-intensity": {
                            type: "number",
                            default: 1,
                            minimum: 0,
                            transition: !0,
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "heatmap-color": {
                            type: "color",
                            default: ["interpolate", ["linear"], ["heatmap-density"], 0, "rgba(0, 0, 255, 0)", .1, "royalblue", .3, "cyan", .5, "lime", .7, "yellow", 1, "red"],
                            transition: !1,
                            expression: {
                                interpolated: !0,
                                parameters: ["heatmap-density"]
                            },
                            "property-type": "color-ramp"
                        },
                        "heatmap-opacity": {
                            type: "number",
                            default: 1,
                            minimum: 0,
                            maximum: 1,
                            transition: !0,
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        }
                    },
                    paint_symbol: {
                        "icon-opacity": {
                            type: "number",
                            default: 1,
                            minimum: 0,
                            maximum: 1,
                            transition: !0,
                            requires: ["icon-image"],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature", "feature-state"]
                            },
                            "property-type": "data-driven"
                        },
                        "icon-color": {
                            type: "color",
                            default: "#000000",
                            transition: !0,
                            requires: ["icon-image"],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature", "feature-state"]
                            },
                            "property-type": "data-driven"
                        },
                        "icon-halo-color": {
                            type: "color",
                            default: "rgba(0, 0, 0, 0)",
                            transition: !0,
                            requires: ["icon-image"],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature", "feature-state"]
                            },
                            "property-type": "data-driven"
                        },
                        "icon-halo-width": {
                            type: "number",
                            default: 0,
                            minimum: 0,
                            transition: !0,
                            units: "pixels",
                            requires: ["icon-image"],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature", "feature-state"]
                            },
                            "property-type": "data-driven"
                        },
                        "icon-halo-blur": {
                            type: "number",
                            default: 0,
                            minimum: 0,
                            transition: !0,
                            units: "pixels",
                            requires: ["icon-image"],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature", "feature-state"]
                            },
                            "property-type": "data-driven"
                        },
                        "icon-translate": {
                            type: "array",
                            value: "number",
                            length: 2,
                            default: [0, 0],
                            transition: !0,
                            units: "pixels",
                            requires: ["icon-image"],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "icon-translate-anchor": {
                            type: "enum",
                            values: {
                                map: {},
                                viewport: {}
                            },
                            default: "map",
                            requires: ["icon-image", "icon-translate"],
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "text-opacity": {
                            type: "number",
                            default: 1,
                            minimum: 0,
                            maximum: 1,
                            transition: !0,
                            requires: ["text-field"],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature", "feature-state"]
                            },
                            "property-type": "data-driven"
                        },
                        "text-color": {
                            type: "color",
                            default: "#000000",
                            transition: !0,
                            overridable: !0,
                            requires: ["text-field"],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature", "feature-state"]
                            },
                            "property-type": "data-driven"
                        },
                        "text-halo-color": {
                            type: "color",
                            default: "rgba(0, 0, 0, 0)",
                            transition: !0,
                            requires: ["text-field"],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature", "feature-state"]
                            },
                            "property-type": "data-driven"
                        },
                        "text-halo-width": {
                            type: "number",
                            default: 0,
                            minimum: 0,
                            transition: !0,
                            units: "pixels",
                            requires: ["text-field"],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature", "feature-state"]
                            },
                            "property-type": "data-driven"
                        },
                        "text-halo-blur": {
                            type: "number",
                            default: 0,
                            minimum: 0,
                            transition: !0,
                            units: "pixels",
                            requires: ["text-field"],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom", "feature", "feature-state"]
                            },
                            "property-type": "data-driven"
                        },
                        "text-translate": {
                            type: "array",
                            value: "number",
                            length: 2,
                            default: [0, 0],
                            transition: !0,
                            units: "pixels",
                            requires: ["text-field"],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "text-translate-anchor": {
                            type: "enum",
                            values: {
                                map: {},
                                viewport: {}
                            },
                            default: "map",
                            requires: ["text-field", "text-translate"],
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        }
                    },
                    paint_raster: {
                        "raster-opacity": {
                            type: "number",
                            default: 1,
                            minimum: 0,
                            maximum: 1,
                            transition: !0,
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "raster-hue-rotate": {
                            type: "number",
                            default: 0,
                            period: 360,
                            transition: !0,
                            units: "degrees",
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "raster-brightness-min": {
                            type: "number",
                            default: 0,
                            minimum: 0,
                            maximum: 1,
                            transition: !0,
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "raster-brightness-max": {
                            type: "number",
                            default: 1,
                            minimum: 0,
                            maximum: 1,
                            transition: !0,
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "raster-saturation": {
                            type: "number",
                            default: 0,
                            minimum: -1,
                            maximum: 1,
                            transition: !0,
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "raster-contrast": {
                            type: "number",
                            default: 0,
                            minimum: -1,
                            maximum: 1,
                            transition: !0,
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "raster-resampling": {
                            type: "enum",
                            values: {
                                linear: {},
                                nearest: {}
                            },
                            default: "linear",
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "raster-fade-duration": {
                            type: "number",
                            default: 300,
                            minimum: 0,
                            transition: !1,
                            units: "milliseconds",
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        }
                    },
                    paint_hillshade: {
                        "hillshade-illumination-direction": {
                            type: "number",
                            default: 335,
                            minimum: 0,
                            maximum: 359,
                            transition: !1,
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "hillshade-illumination-anchor": {
                            type: "enum",
                            values: {
                                map: {},
                                viewport: {}
                            },
                            default: "viewport",
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "hillshade-exaggeration": {
                            type: "number",
                            default: .5,
                            minimum: 0,
                            maximum: 1,
                            transition: !0,
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "hillshade-shadow-color": {
                            type: "color",
                            default: "#000000",
                            transition: !0,
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "hillshade-highlight-color": {
                            type: "color",
                            default: "#FFFFFF",
                            transition: !0,
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "hillshade-accent-color": {
                            type: "color",
                            default: "#000000",
                            transition: !0,
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        }
                    },
                    paint_background: {
                        "background-color": {
                            type: "color",
                            default: "#000000",
                            transition: !0,
                            requires: [{
                                "!": "background-pattern"
                            }],
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        },
                        "background-pattern": {
                            type: "resolvedImage",
                            transition: !0,
                            expression: {
                                interpolated: !1,
                                parameters: ["zoom"]
                            },
                            "property-type": "cross-faded"
                        },
                        "background-opacity": {
                            type: "number",
                            default: 1,
                            minimum: 0,
                            maximum: 1,
                            transition: !0,
                            expression: {
                                interpolated: !0,
                                parameters: ["zoom"]
                            },
                            "property-type": "data-constant"
                        }
                    },
                    transition: {
                        duration: {
                            type: "number",
                            default: 300,
                            minimum: 0,
                            units: "milliseconds"
                        },
                        delay: {
                            type: "number",
                            default: 0,
                            minimum: 0,
                            units: "milliseconds"
                        }
                    },
                    "property-type": {
                        "data-driven": {
                            type: "property-type"
                        },
                        "cross-faded": {
                            type: "property-type"
                        },
                        "cross-faded-data-driven": {
                            type: "property-type"
                        },
                        "color-ramp": {
                            type: "property-type"
                        },
                        "data-constant": {
                            type: "property-type"
                        },
                        constant: {
                            type: "property-type"
                        }
                    },
                    promoteId: {
                        "*": {
                            type: "string"
                        }
                    }
                };
                const U = ["type", "source", "source-layer", "minzoom", "maxzoom", "filter", "layout"];
                function $(r, t) {
                    const n = {};
                    for (const s in r)
                        s !== "ref" && (n[s] = r[s]);
                    return U.forEach(s => {
                        s in t && (n[s] = t[s])
                    }
                    ),
                    n
                }
                function K(r, t) {
                    if (Array.isArray(r)) {
                        if (!Array.isArray(t) || r.length !== t.length)
                            return !1;
                        for (let n = 0; n < r.length; n++)
                            if (!K(r[n], t[n]))
                                return !1;
                        return !0
                    }
                    if (typeof r == "object" && r !== null && t !== null) {
                        if (typeof t != "object" || Object.keys(r).length !== Object.keys(t).length)
                            return !1;
                        for (const n in r)
                            if (!K(r[n], t[n]))
                                return !1;
                        return !0
                    }
                    return r === t
                }
                function re(r, t) {
                    r.push(t)
                }
                function he(r, t, n) {
                    re(n, {
                        command: "addSource",
                        args: [r, t[r]]
                    })
                }
                function ve(r, t, n) {
                    re(t, {
                        command: "removeSource",
                        args: [r]
                    }),
                    n[r] = !0
                }
                function ue(r, t, n, s) {
                    ve(r, n, s),
                    he(r, t, n)
                }
                function Se(r, t, n) {
                    let s;
                    for (s in r[n])
                        if (Object.prototype.hasOwnProperty.call(r[n], s) && s !== "data" && !K(r[n][s], t[n][s]))
                            return !1;
                    for (s in t[n])
                        if (Object.prototype.hasOwnProperty.call(t[n], s) && s !== "data" && !K(r[n][s], t[n][s]))
                            return !1;
                    return !0
                }
                function we(r, t, n, s, c, d) {
                    r = r || {},
                    t = t || {};
                    for (const p in r)
                        Object.prototype.hasOwnProperty.call(r, p) && (K(r[p], t[p]) || n.push({
                            command: d,
                            args: [s, p, t[p], c]
                        }));
                    for (const p in t)
                        Object.prototype.hasOwnProperty.call(t, p) && !Object.prototype.hasOwnProperty.call(r, p) && (K(r[p], t[p]) || n.push({
                            command: d,
                            args: [s, p, t[p], c]
                        }))
                }
                function fe(r) {
                    return r.id
                }
                function ke(r, t) {
                    return r[t.id] = t,
                    r
                }
                class me {
                    constructor(t, n, s, c) {
                        this.message = (t ? `${t}: ` : "") + s,
                        c && (this.identifier = c),
                        n != null && n.__line__ && (this.line = n.__line__)
                    }
                }
                function je(r, ...t) {
                    for (const n of t)
                        for (const s in n)
                            r[s] = n[s];
                    return r
                }
                class We extends Error {
                    constructor(t, n) {
                        super(n),
                        this.message = n,
                        this.key = t
                    }
                }
                class st {
                    constructor(t, n=[]) {
                        this.parent = t,
                        this.bindings = {};
                        for (const [s,c] of n)
                            this.bindings[s] = c
                    }
                    concat(t) {
                        return new st(this,t)
                    }
                    get(t) {
                        if (this.bindings[t])
                            return this.bindings[t];
                        if (this.parent)
                            return this.parent.get(t);
                        throw new Error(`${t} not found in scope.`)
                    }
                    has(t) {
                        return !!this.bindings[t] || !!this.parent && this.parent.has(t)
                    }
                }
                const tt = {
                    kind: "null"
                }
                  , Ae = {
                    kind: "number"
                }
                  , Ge = {
                    kind: "string"
                }
                  , Ze = {
                    kind: "boolean"
                }
                  , at = {
                    kind: "color"
                }
                  , it = {
                    kind: "projectionDefinition"
                }
                  , lt = {
                    kind: "object"
                }
                  , Je = {
                    kind: "value"
                }
                  , Qn = {
                    kind: "collator"
                }
                  , ui = {
                    kind: "formatted"
                }
                  , xi = {
                    kind: "padding"
                }
                  , Bt = {
                    kind: "resolvedImage"
                }
                  , zo = {
                    kind: "variableAnchorOffsetCollection"
                };
                function Qi(r, t) {
                    return {
                        kind: "array",
                        itemType: r,
                        N: t
                    }
                }
                function zt(r) {
                    if (r.kind === "array") {
                        const t = zt(r.itemType);
                        return typeof r.N == "number" ? `array<${t}, ${r.N}>` : r.itemType.kind === "value" ? "array" : `array<${t}>`
                    }
                    return r.kind
                }
                const xc = [tt, Ae, Ge, Ze, at, it, ui, lt, Qi(Je), xi, Bt, zo];
                function io(r, t) {
                    if (t.kind === "error")
                        return null;
                    if (r.kind === "array") {
                        if (t.kind === "array" && (t.N === 0 && t.itemType.kind === "value" || !io(r.itemType, t.itemType)) && (typeof r.N != "number" || r.N === t.N))
                            return null
                    } else {
                        if (r.kind === t.kind)
                            return null;
                        if (r.kind === "value") {
                            for (const n of xc)
                                if (!io(n, t))
                                    return null
                        }
                    }
                    return `Expected ${zt(r)} but found ${zt(t)} instead.`
                }
                function Ua(r, t) {
                    return t.some(n => n.kind === r.kind)
                }
                function Rn(r, t) {
                    return t.some(n => n === "null" ? r === null : n === "array" ? Array.isArray(r) : n === "object" ? r && !Array.isArray(r) && typeof r == "object" : n === typeof r)
                }
                function Cs(r, t) {
                    return r.kind === "array" && t.kind === "array" ? r.itemType.kind === t.itemType.kind && typeof r.N == "number" : r.kind === t.kind
                }
                const Za = .96422
                  , vc = .82521
                  , bc = 4 / 29
                  , Ps = 6 / 29
                  , wc = 3 * Ps * Ps
                  , Ku = Ps * Ps * Ps
                  , Ju = Math.PI / 180
                  , Yu = 180 / Math.PI;
                function Ga(r) {
                    return (r %= 360) < 0 && (r += 360),
                    r
                }
                function Ss([r,t,n,s]) {
                    let c, d;
                    const p = qa((.2225045 * (r = $a(r)) + .7168786 * (t = $a(t)) + .0606169 * (n = $a(n))) / 1);
                    r === t && t === n ? c = d = p : (c = qa((.4360747 * r + .3850649 * t + .1430804 * n) / Za),
                    d = qa((.0139322 * r + .0971045 * t + .7141733 * n) / vc));
                    const g = 116 * p - 16;
                    return [g < 0 ? 0 : g, 500 * (c - p), 200 * (p - d), s]
                }
                function $a(r) {
                    return r <= .04045 ? r / 12.92 : Math.pow((r + .055) / 1.055, 2.4)
                }
                function qa(r) {
                    return r > Ku ? Math.pow(r, 1 / 3) : r / wc + bc
                }
                function Is([r,t,n,s]) {
                    let c = (r + 16) / 116
                      , d = isNaN(t) ? c : c + t / 500
                      , p = isNaN(n) ? c : c - n / 200;
                    return c = 1 * Wa(c),
                    d = Za * Wa(d),
                    p = vc * Wa(p),
                    [Ha(3.1338561 * d - 1.6168667 * c - .4906146 * p), Ha(-.9787684 * d + 1.9161415 * c + .033454 * p), Ha(.0719453 * d - .2289914 * c + 1.4052427 * p), s]
                }
                function Ha(r) {
                    return (r = r <= .00304 ? 12.92 * r : 1.055 * Math.pow(r, 1 / 2.4) - .055) < 0 ? 0 : r > 1 ? 1 : r
                }
                function Wa(r) {
                    return r > Ps ? r * r * r : wc * (r - bc)
                }
                function ko(r) {
                    return parseInt(r.padEnd(2, r), 16) / 255
                }
                function Xa(r, t) {
                    return es(t ? r / 100 : r, 0, 1)
                }
                function es(r, t, n) {
                    return Math.min(Math.max(t, r), n)
                }
                function jr(r) {
                    return !r.some(Number.isNaN)
                }
                const _t = {
                    aliceblue: [240, 248, 255],
                    antiquewhite: [250, 235, 215],
                    aqua: [0, 255, 255],
                    aquamarine: [127, 255, 212],
                    azure: [240, 255, 255],
                    beige: [245, 245, 220],
                    bisque: [255, 228, 196],
                    black: [0, 0, 0],
                    blanchedalmond: [255, 235, 205],
                    blue: [0, 0, 255],
                    blueviolet: [138, 43, 226],
                    brown: [165, 42, 42],
                    burlywood: [222, 184, 135],
                    cadetblue: [95, 158, 160],
                    chartreuse: [127, 255, 0],
                    chocolate: [210, 105, 30],
                    coral: [255, 127, 80],
                    cornflowerblue: [100, 149, 237],
                    cornsilk: [255, 248, 220],
                    crimson: [220, 20, 60],
                    cyan: [0, 255, 255],
                    darkblue: [0, 0, 139],
                    darkcyan: [0, 139, 139],
                    darkgoldenrod: [184, 134, 11],
                    darkgray: [169, 169, 169],
                    darkgreen: [0, 100, 0],
                    darkgrey: [169, 169, 169],
                    darkkhaki: [189, 183, 107],
                    darkmagenta: [139, 0, 139],
                    darkolivegreen: [85, 107, 47],
                    darkorange: [255, 140, 0],
                    darkorchid: [153, 50, 204],
                    darkred: [139, 0, 0],
                    darksalmon: [233, 150, 122],
                    darkseagreen: [143, 188, 143],
                    darkslateblue: [72, 61, 139],
                    darkslategray: [47, 79, 79],
                    darkslategrey: [47, 79, 79],
                    darkturquoise: [0, 206, 209],
                    darkviolet: [148, 0, 211],
                    deeppink: [255, 20, 147],
                    deepskyblue: [0, 191, 255],
                    dimgray: [105, 105, 105],
                    dimgrey: [105, 105, 105],
                    dodgerblue: [30, 144, 255],
                    firebrick: [178, 34, 34],
                    floralwhite: [255, 250, 240],
                    forestgreen: [34, 139, 34],
                    fuchsia: [255, 0, 255],
                    gainsboro: [220, 220, 220],
                    ghostwhite: [248, 248, 255],
                    gold: [255, 215, 0],
                    goldenrod: [218, 165, 32],
                    gray: [128, 128, 128],
                    green: [0, 128, 0],
                    greenyellow: [173, 255, 47],
                    grey: [128, 128, 128],
                    honeydew: [240, 255, 240],
                    hotpink: [255, 105, 180],
                    indianred: [205, 92, 92],
                    indigo: [75, 0, 130],
                    ivory: [255, 255, 240],
                    khaki: [240, 230, 140],
                    lavender: [230, 230, 250],
                    lavenderblush: [255, 240, 245],
                    lawngreen: [124, 252, 0],
                    lemonchiffon: [255, 250, 205],
                    lightblue: [173, 216, 230],
                    lightcoral: [240, 128, 128],
                    lightcyan: [224, 255, 255],
                    lightgoldenrodyellow: [250, 250, 210],
                    lightgray: [211, 211, 211],
                    lightgreen: [144, 238, 144],
                    lightgrey: [211, 211, 211],
                    lightpink: [255, 182, 193],
                    lightsalmon: [255, 160, 122],
                    lightseagreen: [32, 178, 170],
                    lightskyblue: [135, 206, 250],
                    lightslategray: [119, 136, 153],
                    lightslategrey: [119, 136, 153],
                    lightsteelblue: [176, 196, 222],
                    lightyellow: [255, 255, 224],
                    lime: [0, 255, 0],
                    limegreen: [50, 205, 50],
                    linen: [250, 240, 230],
                    magenta: [255, 0, 255],
                    maroon: [128, 0, 0],
                    mediumaquamarine: [102, 205, 170],
                    mediumblue: [0, 0, 205],
                    mediumorchid: [186, 85, 211],
                    mediumpurple: [147, 112, 219],
                    mediumseagreen: [60, 179, 113],
                    mediumslateblue: [123, 104, 238],
                    mediumspringgreen: [0, 250, 154],
                    mediumturquoise: [72, 209, 204],
                    mediumvioletred: [199, 21, 133],
                    midnightblue: [25, 25, 112],
                    mintcream: [245, 255, 250],
                    mistyrose: [255, 228, 225],
                    moccasin: [255, 228, 181],
                    navajowhite: [255, 222, 173],
                    navy: [0, 0, 128],
                    oldlace: [253, 245, 230],
                    olive: [128, 128, 0],
                    olivedrab: [107, 142, 35],
                    orange: [255, 165, 0],
                    orangered: [255, 69, 0],
                    orchid: [218, 112, 214],
                    palegoldenrod: [238, 232, 170],
                    palegreen: [152, 251, 152],
                    paleturquoise: [175, 238, 238],
                    palevioletred: [219, 112, 147],
                    papayawhip: [255, 239, 213],
                    peachpuff: [255, 218, 185],
                    peru: [205, 133, 63],
                    pink: [255, 192, 203],
                    plum: [221, 160, 221],
                    powderblue: [176, 224, 230],
                    purple: [128, 0, 128],
                    rebeccapurple: [102, 51, 153],
                    red: [255, 0, 0],
                    rosybrown: [188, 143, 143],
                    royalblue: [65, 105, 225],
                    saddlebrown: [139, 69, 19],
                    salmon: [250, 128, 114],
                    sandybrown: [244, 164, 96],
                    seagreen: [46, 139, 87],
                    seashell: [255, 245, 238],
                    sienna: [160, 82, 45],
                    silver: [192, 192, 192],
                    skyblue: [135, 206, 235],
                    slateblue: [106, 90, 205],
                    slategray: [112, 128, 144],
                    slategrey: [112, 128, 144],
                    snow: [255, 250, 250],
                    springgreen: [0, 255, 127],
                    steelblue: [70, 130, 180],
                    tan: [210, 180, 140],
                    teal: [0, 128, 128],
                    thistle: [216, 191, 216],
                    tomato: [255, 99, 71],
                    turquoise: [64, 224, 208],
                    violet: [238, 130, 238],
                    wheat: [245, 222, 179],
                    white: [255, 255, 255],
                    whitesmoke: [245, 245, 245],
                    yellow: [255, 255, 0],
                    yellowgreen: [154, 205, 50]
                };
                function lr(r, t, n) {
                    return r + n * (t - r)
                }
                function Mr(r, t, n) {
                    return r.map( (s, c) => lr(s, t[c], n))
                }
                class yt {
                    constructor(t, n, s, c=1, d=!0) {
                        this.r = t,
                        this.g = n,
                        this.b = s,
                        this.a = c,
                        d || (this.r *= c,
                        this.g *= c,
                        this.b *= c,
                        c || this.overwriteGetter("rgb", [t, n, s, c]))
                    }
                    static parse(t) {
                        if (t instanceof yt)
                            return t;
                        if (typeof t != "string")
                            return;
                        const n = function(s) {
                            if ((s = s.toLowerCase().trim()) === "transparent")
                                return [0, 0, 0, 0];
                            const c = _t[s];
                            if (c) {
                                const [p,g,x] = c;
                                return [p / 255, g / 255, x / 255, 1]
                            }
                            if (s.startsWith("#") && /^#(?:[0-9a-f]{3,4}|[0-9a-f]{6}|[0-9a-f]{8})$/.test(s)) {
                                const p = s.length < 6 ? 1 : 2;
                                let g = 1;
                                return [ko(s.slice(g, g += p)), ko(s.slice(g, g += p)), ko(s.slice(g, g += p)), ko(s.slice(g, g + p) || "ff")]
                            }
                            if (s.startsWith("rgb")) {
                                const p = s.match(/^rgba?\(\s*([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s+|\s*(,)\s*)([\de.+-]+)(%)?(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
                                if (p) {
                                    const [g,x,b,C,P,D,F,B,j,G,X,ae] = p
                                      , Q = [C || " ", F || " ", G].join("");
                                    if (Q === "  " || Q === "  /" || Q === ",," || Q === ",,,") {
                                        const R = [b, D, j].join("")
                                          , Z = R === "%%%" ? 100 : R === "" ? 255 : 0;
                                        if (Z) {
                                            const ee = [es(+x / Z, 0, 1), es(+P / Z, 0, 1), es(+B / Z, 0, 1), X ? Xa(+X, ae) : 1];
                                            if (jr(ee))
                                                return ee
                                        }
                                    }
                                    return
                                }
                            }
                            const d = s.match(/^hsla?\(\s*([\de.+-]+)(?:deg)?(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s+|\s*(,)\s*)([\de.+-]+)%(?:\s*([,\/])\s*([\de.+-]+)(%)?)?\s*\)$/);
                            if (d) {
                                const [p,g,x,b,C,P,D,F,B] = d
                                  , j = [x || " ", C || " ", D].join("");
                                if (j === "  " || j === "  /" || j === ",," || j === ",,,") {
                                    const G = [+g, es(+b, 0, 100), es(+P, 0, 100), F ? Xa(+F, B) : 1];
                                    if (jr(G))
                                        return function([X,ae,Q,R]) {
                                            function Z(ee) {
                                                const ye = (ee + X / 30) % 12
                                                  , Le = ae * Math.min(Q, 1 - Q);
                                                return Q - Le * Math.max(-1, Math.min(ye - 3, 9 - ye, 1))
                                            }
                                            return X = Ga(X),
                                            ae /= 100,
                                            Q /= 100,
                                            [Z(0), Z(8), Z(4), R]
                                        }(G)
                                }
                            }
                        }(t);
                        return n ? new yt(...n,!1) : void 0
                    }
                    get rgb() {
                        const {r: t, g: n, b: s, a: c} = this
                          , d = c || 1 / 0;
                        return this.overwriteGetter("rgb", [t / d, n / d, s / d, c])
                    }
                    get hcl() {
                        return this.overwriteGetter("hcl", function(t) {
                            const [n,s,c,d] = Ss(t)
                              , p = Math.sqrt(s * s + c * c);
                            return [Math.round(1e4 * p) ? Ga(Math.atan2(c, s) * Yu) : NaN, p, n, d]
                        }(this.rgb))
                    }
                    get lab() {
                        return this.overwriteGetter("lab", Ss(this.rgb))
                    }
                    overwriteGetter(t, n) {
                        return Object.defineProperty(this, t, {
                            value: n
                        }),
                        n
                    }
                    toString() {
                        const [t,n,s,c] = this.rgb;
                        return `rgba(${[t, n, s].map(d => Math.round(255 * d)).join(",")},${c})`
                    }
                    static interpolate(t, n, s, c="rgb") {
                        switch (c) {
                        case "rgb":
                            {
                                const [d,p,g,x] = Mr(t.rgb, n.rgb, s);
                                return new yt(d,p,g,x,!1)
                            }
                        case "hcl":
                            {
                                const [d,p,g,x] = t.hcl
                                  , [b,C,P,D] = n.hcl;
                                let F, B;
                                if (isNaN(d) || isNaN(b))
                                    isNaN(d) ? isNaN(b) ? F = NaN : (F = b,
                                    g !== 1 && g !== 0 || (B = C)) : (F = d,
                                    P !== 1 && P !== 0 || (B = p));
                                else {
                                    let Q = b - d;
                                    b > d && Q > 180 ? Q -= 360 : b < d && d - b > 180 && (Q += 360),
                                    F = d + s * Q
                                }
                                const [j,G,X,ae] = function([Q,R,Z,ee]) {
                                    return Q = isNaN(Q) ? 0 : Q * Ju,
                                    Is([Z, Math.cos(Q) * R, Math.sin(Q) * R, ee])
                                }([F, B ?? lr(p, C, s), lr(g, P, s), lr(x, D, s)]);
                                return new yt(j,G,X,ae,!1)
                            }
                        case "lab":
                            {
                                const [d,p,g,x] = Is(Mr(t.lab, n.lab, s));
                                return new yt(d,p,g,x,!1)
                            }
                        }
                    }
                }
                yt.black = new yt(0,0,0,1),
                yt.white = new yt(1,1,1,1),
                yt.transparent = new yt(0,0,0,0),
                yt.red = new yt(1,0,0,1);
                class Lo {
                    constructor(t, n, s) {
                        this.sensitivity = t ? n ? "variant" : "case" : n ? "accent" : "base",
                        this.locale = s,
                        this.collator = new Intl.Collator(this.locale ? this.locale : [],{
                            sensitivity: this.sensitivity,
                            usage: "search"
                        })
                    }
                    compare(t, n) {
                        return this.collator.compare(t, n)
                    }
                    resolvedLocale() {
                        return new Intl.Collator(this.locale ? this.locale : []).resolvedOptions().locale
                    }
                }
                const Ka = ["bottom", "center", "top"];
                class Cr {
                    constructor(t, n, s, c, d, p) {
                        this.text = t,
                        this.image = n,
                        this.scale = s,
                        this.fontStack = c,
                        this.textColor = d,
                        this.verticalAlign = p
                    }
                }
                class Fi {
                    constructor(t) {
                        this.sections = t
                    }
                    static fromString(t) {
                        return new Fi([new Cr(t,null,null,null,null,null)])
                    }
                    isEmpty() {
                        return this.sections.length === 0 || !this.sections.some(t => t.text.length !== 0 || t.image && t.image.name.length !== 0)
                    }
                    static factory(t) {
                        return t instanceof Fi ? t : Fi.fromString(t)
                    }
                    toString() {
                        return this.sections.length === 0 ? "" : this.sections.map(t => t.text).join("")
                    }
                }
                class Si {
                    constructor(t) {
                        this.values = t.slice()
                    }
                    static parse(t) {
                        if (t instanceof Si)
                            return t;
                        if (typeof t == "number")
                            return new Si([t, t, t, t]);
                        if (Array.isArray(t) && !(t.length < 1 || t.length > 4)) {
                            for (const n of t)
                                if (typeof n != "number")
                                    return;
                            switch (t.length) {
                            case 1:
                                t = [t[0], t[0], t[0], t[0]];
                                break;
                            case 2:
                                t = [t[0], t[1], t[0], t[1]];
                                break;
                            case 3:
                                t = [t[0], t[1], t[2], t[1]]
                            }
                            return new Si(t)
                        }
                    }
                    toString() {
                        return JSON.stringify(this.values)
                    }
                    static interpolate(t, n, s) {
                        return new Si(Mr(t.values, n.values, s))
                    }
                }
                class Xt {
                    constructor(t) {
                        this.name = "ExpressionEvaluationError",
                        this.message = t
                    }
                    toJSON() {
                        return this.message
                    }
                }
                const Ja = new Set(["center", "left", "right", "top", "bottom", "top-left", "top-right", "bottom-left", "bottom-right"]);
                class Ii {
                    constructor(t) {
                        this.values = t.slice()
                    }
                    static parse(t) {
                        if (t instanceof Ii)
                            return t;
                        if (Array.isArray(t) && !(t.length < 1) && t.length % 2 == 0) {
                            for (let n = 0; n < t.length; n += 2) {
                                const s = t[n]
                                  , c = t[n + 1];
                                if (typeof s != "string" || !Ja.has(s) || !Array.isArray(c) || c.length !== 2 || typeof c[0] != "number" || typeof c[1] != "number")
                                    return
                            }
                            return new Ii(t)
                        }
                    }
                    toString() {
                        return JSON.stringify(this.values)
                    }
                    static interpolate(t, n, s) {
                        const c = t.values
                          , d = n.values;
                        if (c.length !== d.length)
                            throw new Xt(`Cannot interpolate values of different length. from: ${t.toString()}, to: ${n.toString()}`);
                        const p = [];
                        for (let g = 0; g < c.length; g += 2) {
                            if (c[g] !== d[g])
                                throw new Xt(`Cannot interpolate values containing mismatched anchors. from[${g}]: ${c[g]}, to[${g}]: ${d[g]}`);
                            p.push(c[g]);
                            const [x,b] = c[g + 1]
                              , [C,P] = d[g + 1];
                            p.push([lr(x, C, s), lr(b, P, s)])
                        }
                        return new Ii(p)
                    }
                }
                class Ki {
                    constructor(t) {
                        this.name = t.name,
                        this.available = t.available
                    }
                    toString() {
                        return this.name
                    }
                    static fromString(t) {
                        return t ? new Ki({
                            name: t,
                            available: !1
                        }) : null
                    }
                }
                class er {
                    constructor(t, n, s) {
                        this.from = t,
                        this.to = n,
                        this.transition = s
                    }
                    static interpolate(t, n, s) {
                        return new er(t,n,s)
                    }
                    static parse(t) {
                        return t instanceof er ? t : Array.isArray(t) && t.length === 3 && typeof t[0] == "string" && typeof t[1] == "string" && typeof t[2] == "number" ? new er(t[0],t[1],t[2]) : typeof t == "object" && typeof t.from == "string" && typeof t.to == "string" && typeof t.transition == "number" ? new er(t.from,t.to,t.transition) : typeof t == "string" ? new er(t,t,1) : void 0
                    }
                }
                function Do(r, t, n, s) {
                    return typeof r == "number" && r >= 0 && r <= 255 && typeof t == "number" && t >= 0 && t <= 255 && typeof n == "number" && n >= 0 && n <= 255 ? s === void 0 || typeof s == "number" && s >= 0 && s <= 1 ? null : `Invalid rgba value [${[r, t, n, s].join(", ")}]: 'a' must be between 0 and 1.` : `Invalid rgba value [${(typeof s == "number" ? [r, t, n, s] : [r, t, n]).join(", ")}]: 'r', 'g', and 'b' must be between 0 and 255.`
                }
                function Vr(r) {
                    if (r === null || typeof r == "string" || typeof r == "boolean" || typeof r == "number" || r instanceof er || r instanceof yt || r instanceof Lo || r instanceof Fi || r instanceof Si || r instanceof Ii || r instanceof Ki)
                        return !0;
                    if (Array.isArray(r)) {
                        for (const t of r)
                            if (!Vr(t))
                                return !1;
                        return !0
                    }
                    if (typeof r == "object") {
                        for (const t in r)
                            if (!Vr(r[t]))
                                return !1;
                        return !0
                    }
                    return !1
                }
                function hi(r) {
                    if (r === null)
                        return tt;
                    if (typeof r == "string")
                        return Ge;
                    if (typeof r == "boolean")
                        return Ze;
                    if (typeof r == "number")
                        return Ae;
                    if (r instanceof yt)
                        return at;
                    if (r instanceof er)
                        return it;
                    if (r instanceof Lo)
                        return Qn;
                    if (r instanceof Fi)
                        return ui;
                    if (r instanceof Si)
                        return xi;
                    if (r instanceof Ii)
                        return zo;
                    if (r instanceof Ki)
                        return Bt;
                    if (Array.isArray(r)) {
                        const t = r.length;
                        let n;
                        for (const s of r) {
                            const c = hi(s);
                            if (n) {
                                if (n === c)
                                    continue;
                                n = Je;
                                break
                            }
                            n = c
                        }
                        return Qi(n || Je, t)
                    }
                    return lt
                }
                function Fn(r) {
                    const t = typeof r;
                    return r === null ? "" : t === "string" || t === "number" || t === "boolean" ? String(r) : r instanceof yt || r instanceof er || r instanceof Fi || r instanceof Si || r instanceof Ii || r instanceof Ki ? r.toString() : JSON.stringify(r)
                }
                class Pr {
                    constructor(t, n) {
                        this.type = t,
                        this.value = n
                    }
                    static parse(t, n) {
                        if (t.length !== 2)
                            return n.error(`'literal' expression requires exactly one argument, but found ${t.length - 1} instead.`);
                        if (!Vr(t[1]))
                            return n.error("invalid value");
                        const s = t[1];
                        let c = hi(s);
                        const d = n.expectedType;
                        return c.kind !== "array" || c.N !== 0 || !d || d.kind !== "array" || typeof d.N == "number" && d.N !== 0 || (c = d),
                        new Pr(c,s)
                    }
                    evaluate() {
                        return this.value
                    }
                    eachChild() {}
                    outputDefined() {
                        return !0
                    }
                }
                const ro = {
                    string: Ge,
                    number: Ae,
                    boolean: Ze,
                    object: lt
                };
                class Sr {
                    constructor(t, n) {
                        this.type = t,
                        this.args = n
                    }
                    static parse(t, n) {
                        if (t.length < 2)
                            return n.error("Expected at least one argument.");
                        let s, c = 1;
                        const d = t[0];
                        if (d === "array") {
                            let g, x;
                            if (t.length > 2) {
                                const b = t[1];
                                if (typeof b != "string" || !(b in ro) || b === "object")
                                    return n.error('The item type argument of "array" must be one of string, number, boolean', 1);
                                g = ro[b],
                                c++
                            } else
                                g = Je;
                            if (t.length > 3) {
                                if (t[2] !== null && (typeof t[2] != "number" || t[2] < 0 || t[2] !== Math.floor(t[2])))
                                    return n.error('The length argument to "array" must be a positive integer literal', 2);
                                x = t[2],
                                c++
                            }
                            s = Qi(g, x)
                        } else {
                            if (!ro[d])
                                throw new Error(`Types doesn't contain name = ${d}`);
                            s = ro[d]
                        }
                        const p = [];
                        for (; c < t.length; c++) {
                            const g = n.parse(t[c], c, Je);
                            if (!g)
                                return null;
                            p.push(g)
                        }
                        return new Sr(s,p)
                    }
                    evaluate(t) {
                        for (let n = 0; n < this.args.length; n++) {
                            const s = this.args[n].evaluate(t);
                            if (!io(this.type, hi(s)))
                                return s;
                            if (n === this.args.length - 1)
                                throw new Xt(`Expected value to be of type ${zt(this.type)}, but found ${zt(hi(s))} instead.`)
                        }
                        throw new Error
                    }
                    eachChild(t) {
                        this.args.forEach(t)
                    }
                    outputDefined() {
                        return this.args.every(t => t.outputDefined())
                    }
                }
                const Ya = {
                    "to-boolean": Ze,
                    "to-color": at,
                    "to-number": Ae,
                    "to-string": Ge
                };
                class Ur {
                    constructor(t, n) {
                        this.type = t,
                        this.args = n
                    }
                    static parse(t, n) {
                        if (t.length < 2)
                            return n.error("Expected at least one argument.");
                        const s = t[0];
                        if (!Ya[s])
                            throw new Error(`Can't parse ${s} as it is not part of the known types`);
                        if ((s === "to-boolean" || s === "to-string") && t.length !== 2)
                            return n.error("Expected one argument.");
                        const c = Ya[s]
                          , d = [];
                        for (let p = 1; p < t.length; p++) {
                            const g = n.parse(t[p], p, Je);
                            if (!g)
                                return null;
                            d.push(g)
                        }
                        return new Ur(c,d)
                    }
                    evaluate(t) {
                        switch (this.type.kind) {
                        case "boolean":
                            return !!this.args[0].evaluate(t);
                        case "color":
                            {
                                let n, s;
                                for (const c of this.args) {
                                    if (n = c.evaluate(t),
                                    s = null,
                                    n instanceof yt)
                                        return n;
                                    if (typeof n == "string") {
                                        const d = t.parseColor(n);
                                        if (d)
                                            return d
                                    } else if (Array.isArray(n) && (s = n.length < 3 || n.length > 4 ? `Invalid rgba value ${JSON.stringify(n)}: expected an array containing either three or four numeric values.` : Do(n[0], n[1], n[2], n[3]),
                                    !s))
                                        return new yt(n[0] / 255,n[1] / 255,n[2] / 255,n[3])
                                }
                                throw new Xt(s || `Could not parse color from value '${typeof n == "string" ? n : JSON.stringify(n)}'`)
                            }
                        case "padding":
                            {
                                let n;
                                for (const s of this.args) {
                                    n = s.evaluate(t);
                                    const c = Si.parse(n);
                                    if (c)
                                        return c
                                }
                                throw new Xt(`Could not parse padding from value '${typeof n == "string" ? n : JSON.stringify(n)}'`)
                            }
                        case "variableAnchorOffsetCollection":
                            {
                                let n;
                                for (const s of this.args) {
                                    n = s.evaluate(t);
                                    const c = Ii.parse(n);
                                    if (c)
                                        return c
                                }
                                throw new Xt(`Could not parse variableAnchorOffsetCollection from value '${typeof n == "string" ? n : JSON.stringify(n)}'`)
                            }
                        case "number":
                            {
                                let n = null;
                                for (const s of this.args) {
                                    if (n = s.evaluate(t),
                                    n === null)
                                        return 0;
                                    const c = Number(n);
                                    if (!isNaN(c))
                                        return c
                                }
                                throw new Xt(`Could not convert ${JSON.stringify(n)} to number.`)
                            }
                        case "formatted":
                            return Fi.fromString(Fn(this.args[0].evaluate(t)));
                        case "resolvedImage":
                            return Ki.fromString(Fn(this.args[0].evaluate(t)));
                        case "projectionDefinition":
                            return this.args[0].evaluate(t);
                        default:
                            return Fn(this.args[0].evaluate(t))
                        }
                    }
                    eachChild(t) {
                        this.args.forEach(t)
                    }
                    outputDefined() {
                        return this.args.every(t => t.outputDefined())
                    }
                }
                const Vt = ["Unknown", "Point", "LineString", "Polygon"];
                class Ro {
                    constructor() {
                        this.globals = null,
                        this.feature = null,
                        this.featureState = null,
                        this.formattedSection = null,
                        this._parseColorCache = {},
                        this.availableImages = null,
                        this.canonical = null
                    }
                    id() {
                        return this.feature && "id"in this.feature ? this.feature.id : null
                    }
                    geometryType() {
                        return this.feature ? typeof this.feature.type == "number" ? Vt[this.feature.type] : this.feature.type : null
                    }
                    geometry() {
                        return this.feature && "geometry"in this.feature ? this.feature.geometry : null
                    }
                    canonicalID() {
                        return this.canonical
                    }
                    properties() {
                        return this.feature && this.feature.properties || {}
                    }
                    parseColor(t) {
                        let n = this._parseColorCache[t];
                        return n || (n = this._parseColorCache[t] = yt.parse(t)),
                        n
                    }
                }
                class pt {
                    constructor(t, n, s=[], c, d=new st, p=[]) {
                        this.registry = t,
                        this.path = s,
                        this.key = s.map(g => `[${g}]`).join(""),
                        this.scope = d,
                        this.errors = p,
                        this.expectedType = c,
                        this._isConstant = n
                    }
                    parse(t, n, s, c, d={}) {
                        return n ? this.concat(n, s, c)._parse(t, d) : this._parse(t, d)
                    }
                    _parse(t, n) {
                        function s(c, d, p) {
                            return p === "assert" ? new Sr(d,[c]) : p === "coerce" ? new Ur(d,[c]) : c
                        }
                        if (t !== null && typeof t != "string" && typeof t != "boolean" && typeof t != "number" || (t = ["literal", t]),
                        Array.isArray(t)) {
                            if (t.length === 0)
                                return this.error('Expected an array with at least one element. If you wanted a literal array, use ["literal", []].');
                            const c = t[0];
                            if (typeof c != "string")
                                return this.error(`Expression name must be a string, but found ${typeof c} instead. If you wanted a literal array, use ["literal", [...]].`, 0),
                                null;
                            const d = this.registry[c];
                            if (d) {
                                let p = d.parse(t, this);
                                if (!p)
                                    return null;
                                if (this.expectedType) {
                                    const g = this.expectedType
                                      , x = p.type;
                                    if (g.kind !== "string" && g.kind !== "number" && g.kind !== "boolean" && g.kind !== "object" && g.kind !== "array" || x.kind !== "value")
                                        if (g.kind !== "projectionDefinition" || x.kind !== "string" && x.kind !== "array")
                                            if (g.kind !== "color" && g.kind !== "formatted" && g.kind !== "resolvedImage" || x.kind !== "value" && x.kind !== "string")
                                                if (g.kind !== "padding" || x.kind !== "value" && x.kind !== "number" && x.kind !== "array")
                                                    if (g.kind !== "variableAnchorOffsetCollection" || x.kind !== "value" && x.kind !== "array") {
                                                        if (this.checkSubtype(g, x))
                                                            return null
                                                    } else
                                                        p = s(p, g, n.typeAnnotation || "coerce");
                                                else
                                                    p = s(p, g, n.typeAnnotation || "coerce");
                                            else
                                                p = s(p, g, n.typeAnnotation || "coerce");
                                        else
                                            p = s(p, g, n.typeAnnotation || "coerce");
                                    else
                                        p = s(p, g, n.typeAnnotation || "assert")
                                }
                                if (!(p instanceof Pr) && p.type.kind !== "resolvedImage" && this._isConstant(p)) {
                                    const g = new Ro;
                                    try {
                                        p = new Pr(p.type,p.evaluate(g))
                                    } catch (x) {
                                        return this.error(x.message),
                                        null
                                    }
                                }
                                return p
                            }
                            return this.error(`Unknown expression "${c}". If you wanted a literal array, use ["literal", [...]].`, 0)
                        }
                        return this.error(t === void 0 ? "'undefined' value invalid. Use null instead." : typeof t == "object" ? 'Bare objects invalid. Use ["literal", {...}] instead.' : `Expected an array, but found ${typeof t} instead.`)
                    }
                    concat(t, n, s) {
                        const c = typeof t == "number" ? this.path.concat(t) : this.path
                          , d = s ? this.scope.concat(s) : this.scope;
                        return new pt(this.registry,this._isConstant,c,n || null,d,this.errors)
                    }
                    error(t, ...n) {
                        const s = `${this.key}${n.map(c => `[${c}]`).join("")}`;
                        this.errors.push(new We(s,t))
                    }
                    checkSubtype(t, n) {
                        const s = io(t, n);
                        return s && this.error(s),
                        s
                    }
                }
                class ot {
                    constructor(t, n) {
                        this.type = n.type,
                        this.bindings = [].concat(t),
                        this.result = n
                    }
                    evaluate(t) {
                        return this.result.evaluate(t)
                    }
                    eachChild(t) {
                        for (const n of this.bindings)
                            t(n[1]);
                        t(this.result)
                    }
                    static parse(t, n) {
                        if (t.length < 4)
                            return n.error(`Expected at least 3 arguments, but found ${t.length - 1} instead.`);
                        const s = [];
                        for (let d = 1; d < t.length - 1; d += 2) {
                            const p = t[d];
                            if (typeof p != "string")
                                return n.error(`Expected string, but found ${typeof p} instead.`, d);
                            if (/[^a-zA-Z0-9_]/.test(p))
                                return n.error("Variable names must contain only alphanumeric characters or '_'.", d);
                            const g = n.parse(t[d + 1], d + 1);
                            if (!g)
                                return null;
                            s.push([p, g])
                        }
                        const c = n.parse(t[t.length - 1], t.length - 1, n.expectedType, s);
                        return c ? new ot(s,c) : null
                    }
                    outputDefined() {
                        return this.result.outputDefined()
                    }
                }
                class Es {
                    constructor(t, n) {
                        this.type = n.type,
                        this.name = t,
                        this.boundExpression = n
                    }
                    static parse(t, n) {
                        if (t.length !== 2 || typeof t[1] != "string")
                            return n.error("'var' expression requires exactly one string literal argument.");
                        const s = t[1];
                        return n.scope.has(s) ? new Es(s,n.scope.get(s)) : n.error(`Unknown variable "${s}". Make sure "${s}" has been bound in an enclosing "let" expression before using it.`, 1)
                    }
                    evaluate(t) {
                        return this.boundExpression.evaluate(t)
                    }
                    eachChild() {}
                    outputDefined() {
                        return !1
                    }
                }
                class mt {
                    constructor(t, n, s) {
                        this.type = t,
                        this.index = n,
                        this.input = s
                    }
                    static parse(t, n) {
                        if (t.length !== 3)
                            return n.error(`Expected 2 arguments, but found ${t.length - 1} instead.`);
                        const s = n.parse(t[1], 1, Ae)
                          , c = n.parse(t[2], 2, Qi(n.expectedType || Je));
                        return s && c ? new mt(c.type.itemType,s,c) : null
                    }
                    evaluate(t) {
                        const n = this.index.evaluate(t)
                          , s = this.input.evaluate(t);
                        if (n < 0)
                            throw new Xt(`Array index out of bounds: ${n} < 0.`);
                        if (n >= s.length)
                            throw new Xt(`Array index out of bounds: ${n} > ${s.length - 1}.`);
                        if (n !== Math.floor(n))
                            throw new Xt(`Array index must be an integer, but found ${n} instead.`);
                        return s[n]
                    }
                    eachChild(t) {
                        t(this.index),
                        t(this.input)
                    }
                    outputDefined() {
                        return !1
                    }
                }
                class no {
                    constructor(t, n) {
                        this.type = Ze,
                        this.needle = t,
                        this.haystack = n
                    }
                    static parse(t, n) {
                        if (t.length !== 3)
                            return n.error(`Expected 2 arguments, but found ${t.length - 1} instead.`);
                        const s = n.parse(t[1], 1, Je)
                          , c = n.parse(t[2], 2, Je);
                        return s && c ? Ua(s.type, [Ze, Ge, Ae, tt, Je]) ? new no(s,c) : n.error(`Expected first argument to be of type boolean, string, number or null, but found ${zt(s.type)} instead`) : null
                    }
                    evaluate(t) {
                        const n = this.needle.evaluate(t)
                          , s = this.haystack.evaluate(t);
                        if (!s)
                            return !1;
                        if (!Rn(n, ["boolean", "string", "number", "null"]))
                            throw new Xt(`Expected first argument to be of type boolean, string, number or null, but found ${zt(hi(n))} instead.`);
                        if (!Rn(s, ["string", "array"]))
                            throw new Xt(`Expected second argument to be of type array or string, but found ${zt(hi(s))} instead.`);
                        return s.indexOf(n) >= 0
                    }
                    eachChild(t) {
                        t(this.needle),
                        t(this.haystack)
                    }
                    outputDefined() {
                        return !0
                    }
                }
                class Ir {
                    constructor(t, n, s) {
                        this.type = Ae,
                        this.needle = t,
                        this.haystack = n,
                        this.fromIndex = s
                    }
                    static parse(t, n) {
                        if (t.length <= 2 || t.length >= 5)
                            return n.error(`Expected 3 or 4 arguments, but found ${t.length - 1} instead.`);
                        const s = n.parse(t[1], 1, Je)
                          , c = n.parse(t[2], 2, Je);
                        if (!s || !c)
                            return null;
                        if (!Ua(s.type, [Ze, Ge, Ae, tt, Je]))
                            return n.error(`Expected first argument to be of type boolean, string, number or null, but found ${zt(s.type)} instead`);
                        if (t.length === 4) {
                            const d = n.parse(t[3], 3, Ae);
                            return d ? new Ir(s,c,d) : null
                        }
                        return new Ir(s,c)
                    }
                    evaluate(t) {
                        const n = this.needle.evaluate(t)
                          , s = this.haystack.evaluate(t);
                        if (!Rn(n, ["boolean", "string", "number", "null"]))
                            throw new Xt(`Expected first argument to be of type boolean, string, number or null, but found ${zt(hi(n))} instead.`);
                        let c;
                        if (this.fromIndex && (c = this.fromIndex.evaluate(t)),
                        Rn(s, ["string"])) {
                            const d = s.indexOf(n, c);
                            return d === -1 ? -1 : [...s.slice(0, d)].length
                        }
                        if (Rn(s, ["array"]))
                            return s.indexOf(n, c);
                        throw new Xt(`Expected second argument to be of type array or string, but found ${zt(hi(s))} instead.`)
                    }
                    eachChild(t) {
                        t(this.needle),
                        t(this.haystack),
                        this.fromIndex && t(this.fromIndex)
                    }
                    outputDefined() {
                        return !1
                    }
                }
                class so {
                    constructor(t, n, s, c, d, p) {
                        this.inputType = t,
                        this.type = n,
                        this.input = s,
                        this.cases = c,
                        this.outputs = d,
                        this.otherwise = p
                    }
                    static parse(t, n) {
                        if (t.length < 5)
                            return n.error(`Expected at least 4 arguments, but found only ${t.length - 1}.`);
                        if (t.length % 2 != 1)
                            return n.error("Expected an even number of arguments.");
                        let s, c;
                        n.expectedType && n.expectedType.kind !== "value" && (c = n.expectedType);
                        const d = {}
                          , p = [];
                        for (let b = 2; b < t.length - 1; b += 2) {
                            let C = t[b];
                            const P = t[b + 1];
                            Array.isArray(C) || (C = [C]);
                            const D = n.concat(b);
                            if (C.length === 0)
                                return D.error("Expected at least one branch label.");
                            for (const B of C) {
                                if (typeof B != "number" && typeof B != "string")
                                    return D.error("Branch labels must be numbers or strings.");
                                if (typeof B == "number" && Math.abs(B) > Number.MAX_SAFE_INTEGER)
                                    return D.error(`Branch labels must be integers no larger than ${Number.MAX_SAFE_INTEGER}.`);
                                if (typeof B == "number" && Math.floor(B) !== B)
                                    return D.error("Numeric branch labels must be integer values.");
                                if (s) {
                                    if (D.checkSubtype(s, hi(B)))
                                        return null
                                } else
                                    s = hi(B);
                                if (d[String(B)] !== void 0)
                                    return D.error("Branch labels must be unique.");
                                d[String(B)] = p.length
                            }
                            const F = n.parse(P, b, c);
                            if (!F)
                                return null;
                            c = c || F.type,
                            p.push(F)
                        }
                        const g = n.parse(t[1], 1, Je);
                        if (!g)
                            return null;
                        const x = n.parse(t[t.length - 1], t.length - 1, c);
                        return x ? g.type.kind !== "value" && n.concat(1).checkSubtype(s, g.type) ? null : new so(s,c,g,d,p,x) : null
                    }
                    evaluate(t) {
                        const n = this.input.evaluate(t);
                        return (hi(n) === this.inputType && this.outputs[this.cases[n]] || this.otherwise).evaluate(t)
                    }
                    eachChild(t) {
                        t(this.input),
                        this.outputs.forEach(t),
                        t(this.otherwise)
                    }
                    outputDefined() {
                        return this.outputs.every(t => t.outputDefined()) && this.otherwise.outputDefined()
                    }
                }
                class Fo {
                    constructor(t, n, s) {
                        this.type = t,
                        this.branches = n,
                        this.otherwise = s
                    }
                    static parse(t, n) {
                        if (t.length < 4)
                            return n.error(`Expected at least 3 arguments, but found only ${t.length - 1}.`);
                        if (t.length % 2 != 0)
                            return n.error("Expected an odd number of arguments.");
                        let s;
                        n.expectedType && n.expectedType.kind !== "value" && (s = n.expectedType);
                        const c = [];
                        for (let p = 1; p < t.length - 1; p += 2) {
                            const g = n.parse(t[p], p, Ze);
                            if (!g)
                                return null;
                            const x = n.parse(t[p + 1], p + 1, s);
                            if (!x)
                                return null;
                            c.push([g, x]),
                            s = s || x.type
                        }
                        const d = n.parse(t[t.length - 1], t.length - 1, s);
                        if (!d)
                            return null;
                        if (!s)
                            throw new Error("Can't infer output type");
                        return new Fo(s,c,d)
                    }
                    evaluate(t) {
                        for (const [n,s] of this.branches)
                            if (n.evaluate(t))
                                return s.evaluate(t);
                        return this.otherwise.evaluate(t)
                    }
                    eachChild(t) {
                        for (const [n,s] of this.branches)
                            t(n),
                            t(s);
                        t(this.otherwise)
                    }
                    outputDefined() {
                        return this.branches.every( ([t,n]) => n.outputDefined()) && this.otherwise.outputDefined()
                    }
                }
                class oo {
                    constructor(t, n, s, c) {
                        this.type = t,
                        this.input = n,
                        this.beginIndex = s,
                        this.endIndex = c
                    }
                    static parse(t, n) {
                        if (t.length <= 2 || t.length >= 5)
                            return n.error(`Expected 3 or 4 arguments, but found ${t.length - 1} instead.`);
                        const s = n.parse(t[1], 1, Je)
                          , c = n.parse(t[2], 2, Ae);
                        if (!s || !c)
                            return null;
                        if (!Ua(s.type, [Qi(Je), Ge, Je]))
                            return n.error(`Expected first argument to be of type array or string, but found ${zt(s.type)} instead`);
                        if (t.length === 4) {
                            const d = n.parse(t[3], 3, Ae);
                            return d ? new oo(s.type,s,c,d) : null
                        }
                        return new oo(s.type,s,c)
                    }
                    evaluate(t) {
                        const n = this.input.evaluate(t)
                          , s = this.beginIndex.evaluate(t);
                        let c;
                        if (this.endIndex && (c = this.endIndex.evaluate(t)),
                        Rn(n, ["string"]))
                            return [...n].slice(s, c).join("");
                        if (Rn(n, ["array"]))
                            return n.slice(s, c);
                        throw new Xt(`Expected first argument to be of type array or string, but found ${zt(hi(n))} instead.`)
                    }
                    eachChild(t) {
                        t(this.input),
                        t(this.beginIndex),
                        this.endIndex && t(this.endIndex)
                    }
                    outputDefined() {
                        return !1
                    }
                }
                function As(r, t) {
                    const n = r.length - 1;
                    let s, c, d = 0, p = n, g = 0;
                    for (; d <= p; )
                        if (g = Math.floor((d + p) / 2),
                        s = r[g],
                        c = r[g + 1],
                        s <= t) {
                            if (g === n || t < c)
                                return g;
                            d = g + 1
                        } else {
                            if (!(s > t))
                                throw new Xt("Input is not a number.");
                            p = g - 1
                        }
                    return 0
                }
                class zs {
                    constructor(t, n, s) {
                        this.type = t,
                        this.input = n,
                        this.labels = [],
                        this.outputs = [];
                        for (const [c,d] of s)
                            this.labels.push(c),
                            this.outputs.push(d)
                    }
                    static parse(t, n) {
                        if (t.length - 1 < 4)
                            return n.error(`Expected at least 4 arguments, but found only ${t.length - 1}.`);
                        if ((t.length - 1) % 2 != 0)
                            return n.error("Expected an even number of arguments.");
                        const s = n.parse(t[1], 1, Ae);
                        if (!s)
                            return null;
                        const c = [];
                        let d = null;
                        n.expectedType && n.expectedType.kind !== "value" && (d = n.expectedType);
                        for (let p = 1; p < t.length; p += 2) {
                            const g = p === 1 ? -1 / 0 : t[p]
                              , x = t[p + 1]
                              , b = p
                              , C = p + 1;
                            if (typeof g != "number")
                                return n.error('Input/output pairs for "step" expressions must be defined using literal numeric values (not computed expressions) for the input values.', b);
                            if (c.length && c[c.length - 1][0] >= g)
                                return n.error('Input/output pairs for "step" expressions must be arranged with input values in strictly ascending order.', b);
                            const P = n.parse(x, C, d);
                            if (!P)
                                return null;
                            d = d || P.type,
                            c.push([g, P])
                        }
                        return new zs(d,s,c)
                    }
                    evaluate(t) {
                        const n = this.labels
                          , s = this.outputs;
                        if (n.length === 1)
                            return s[0].evaluate(t);
                        const c = this.input.evaluate(t);
                        if (c <= n[0])
                            return s[0].evaluate(t);
                        const d = n.length;
                        return c >= n[d - 1] ? s[d - 1].evaluate(t) : s[As(n, c)].evaluate(t)
                    }
                    eachChild(t) {
                        t(this.input);
                        for (const n of this.outputs)
                            t(n)
                    }
                    outputDefined() {
                        return this.outputs.every(t => t.outputDefined())
                    }
                }
                function Qu(r) {
                    return r && r.__esModule && Object.prototype.hasOwnProperty.call(r, "default") ? r.default : r
                }
                var Bo, Qa, ao = function() {
                    if (Qa)
                        return Bo;
                    function r(t, n, s, c) {
                        this.cx = 3 * t,
                        this.bx = 3 * (s - t) - this.cx,
                        this.ax = 1 - this.cx - this.bx,
                        this.cy = 3 * n,
                        this.by = 3 * (c - n) - this.cy,
                        this.ay = 1 - this.cy - this.by,
                        this.p1x = t,
                        this.p1y = n,
                        this.p2x = s,
                        this.p2y = c
                    }
                    return Qa = 1,
                    Bo = r,
                    r.prototype = {
                        sampleCurveX: function(t) {
                            return ((this.ax * t + this.bx) * t + this.cx) * t
                        },
                        sampleCurveY: function(t) {
                            return ((this.ay * t + this.by) * t + this.cy) * t
                        },
                        sampleCurveDerivativeX: function(t) {
                            return (3 * this.ax * t + 2 * this.bx) * t + this.cx
                        },
                        solveCurveX: function(t, n) {
                            if (n === void 0 && (n = 1e-6),
                            t < 0)
                                return 0;
                            if (t > 1)
                                return 1;
                            for (var s = t, c = 0; c < 8; c++) {
                                var d = this.sampleCurveX(s) - t;
                                if (Math.abs(d) < n)
                                    return s;
                                var p = this.sampleCurveDerivativeX(s);
                                if (Math.abs(p) < 1e-6)
                                    break;
                                s -= d / p
                            }
                            var g = 0
                              , x = 1;
                            for (s = t,
                            c = 0; c < 20 && (d = this.sampleCurveX(s),
                            !(Math.abs(d - t) < n)); c++)
                                t > d ? g = s : x = s,
                                s = .5 * (x - g) + g;
                            return s
                        },
                        solve: function(t, n) {
                            return this.sampleCurveY(this.solveCurveX(t, n))
                        }
                    },
                    Bo
                }(), Ui = Qu(ao);
                class Zi {
                    constructor(t, n, s, c, d) {
                        this.type = t,
                        this.operator = n,
                        this.interpolation = s,
                        this.input = c,
                        this.labels = [],
                        this.outputs = [];
                        for (const [p,g] of d)
                            this.labels.push(p),
                            this.outputs.push(g)
                    }
                    static interpolationFactor(t, n, s, c) {
                        let d = 0;
                        if (t.name === "exponential")
                            d = Oo(n, t.base, s, c);
                        else if (t.name === "linear")
                            d = Oo(n, 1, s, c);
                        else if (t.name === "cubic-bezier") {
                            const p = t.controlPoints;
                            d = new Ui(p[0],p[1],p[2],p[3]).solve(Oo(n, 1, s, c))
                        }
                        return d
                    }
                    static parse(t, n) {
                        let[s,c,d,...p] = t;
                        if (!Array.isArray(c) || c.length === 0)
                            return n.error("Expected an interpolation type expression.", 1);
                        if (c[0] === "linear")
                            c = {
                                name: "linear"
                            };
                        else if (c[0] === "exponential") {
                            const b = c[1];
                            if (typeof b != "number")
                                return n.error("Exponential interpolation requires a numeric base.", 1, 1);
                            c = {
                                name: "exponential",
                                base: b
                            }
                        } else {
                            if (c[0] !== "cubic-bezier")
                                return n.error(`Unknown interpolation type ${String(c[0])}`, 1, 0);
                            {
                                const b = c.slice(1);
                                if (b.length !== 4 || b.some(C => typeof C != "number" || C < 0 || C > 1))
                                    return n.error("Cubic bezier interpolation requires four numeric arguments with values between 0 and 1.", 1);
                                c = {
                                    name: "cubic-bezier",
                                    controlPoints: b
                                }
                            }
                        }
                        if (t.length - 1 < 4)
                            return n.error(`Expected at least 4 arguments, but found only ${t.length - 1}.`);
                        if ((t.length - 1) % 2 != 0)
                            return n.error("Expected an even number of arguments.");
                        if (d = n.parse(d, 2, Ae),
                        !d)
                            return null;
                        const g = [];
                        let x = null;
                        s === "interpolate-hcl" || s === "interpolate-lab" ? x = at : n.expectedType && n.expectedType.kind !== "value" && (x = n.expectedType);
                        for (let b = 0; b < p.length; b += 2) {
                            const C = p[b]
                              , P = p[b + 1]
                              , D = b + 3
                              , F = b + 4;
                            if (typeof C != "number")
                                return n.error('Input/output pairs for "interpolate" expressions must be defined using literal numeric values (not computed expressions) for the input values.', D);
                            if (g.length && g[g.length - 1][0] >= C)
                                return n.error('Input/output pairs for "interpolate" expressions must be arranged with input values in strictly ascending order.', D);
                            const B = n.parse(P, F, x);
                            if (!B)
                                return null;
                            x = x || B.type,
                            g.push([C, B])
                        }
                        return Cs(x, Ae) || Cs(x, it) || Cs(x, at) || Cs(x, xi) || Cs(x, zo) || Cs(x, Qi(Ae)) ? new Zi(x,s,c,d,g) : n.error(`Type ${zt(x)} is not interpolatable.`)
                    }
                    evaluate(t) {
                        const n = this.labels
                          , s = this.outputs;
                        if (n.length === 1)
                            return s[0].evaluate(t);
                        const c = this.input.evaluate(t);
                        if (c <= n[0])
                            return s[0].evaluate(t);
                        const d = n.length;
                        if (c >= n[d - 1])
                            return s[d - 1].evaluate(t);
                        const p = As(n, c)
                          , g = Zi.interpolationFactor(this.interpolation, c, n[p], n[p + 1])
                          , x = s[p].evaluate(t)
                          , b = s[p + 1].evaluate(t);
                        switch (this.operator) {
                        case "interpolate":
                            switch (this.type.kind) {
                            case "number":
                                return lr(x, b, g);
                            case "color":
                                return yt.interpolate(x, b, g);
                            case "padding":
                                return Si.interpolate(x, b, g);
                            case "variableAnchorOffsetCollection":
                                return Ii.interpolate(x, b, g);
                            case "array":
                                return Mr(x, b, g);
                            case "projectionDefinition":
                                return er.interpolate(x, b, g)
                            }
                        case "interpolate-hcl":
                            return yt.interpolate(x, b, g, "hcl");
                        case "interpolate-lab":
                            return yt.interpolate(x, b, g, "lab")
                        }
                    }
                    eachChild(t) {
                        t(this.input);
                        for (const n of this.outputs)
                            t(n)
                    }
                    outputDefined() {
                        return this.outputs.every(t => t.outputDefined())
                    }
                }
                function Oo(r, t, n, s) {
                    const c = s - n
                      , d = r - n;
                    return c === 0 ? 0 : t === 1 ? d / c : (Math.pow(t, d) - 1) / (Math.pow(t, c) - 1)
                }
                const cr = {
                    color: yt.interpolate,
                    number: lr,
                    padding: Si.interpolate,
                    variableAnchorOffsetCollection: Ii.interpolate,
                    array: Mr
                };
                class ai {
                    constructor(t, n) {
                        this.type = t,
                        this.args = n
                    }
                    static parse(t, n) {
                        if (t.length < 2)
                            return n.error("Expected at least one argument.");
                        let s = null;
                        const c = n.expectedType;
                        c && c.kind !== "value" && (s = c);
                        const d = [];
                        for (const g of t.slice(1)) {
                            const x = n.parse(g, 1 + d.length, s, void 0, {
                                typeAnnotation: "omit"
                            });
                            if (!x)
                                return null;
                            s = s || x.type,
                            d.push(x)
                        }
                        if (!s)
                            throw new Error("No output type");
                        const p = c && d.some(g => io(c, g.type));
                        return new ai(p ? Je : s,d)
                    }
                    evaluate(t) {
                        let n, s = null, c = 0;
                        for (const d of this.args)
                            if (c++,
                            s = d.evaluate(t),
                            s && s instanceof Ki && !s.available && (n || (n = s.name),
                            s = null,
                            c === this.args.length && (s = n)),
                            s !== null)
                                break;
                        return s
                    }
                    eachChild(t) {
                        this.args.forEach(t)
                    }
                    outputDefined() {
                        return this.args.every(t => t.outputDefined())
                    }
                }
                function el(r, t) {
                    return r === "==" || r === "!=" ? t.kind === "boolean" || t.kind === "string" || t.kind === "number" || t.kind === "null" || t.kind === "value" : t.kind === "string" || t.kind === "number" || t.kind === "value"
                }
                function No(r, t, n, s) {
                    return s.compare(t, n) === 0
                }
                function ts(r, t, n) {
                    const s = r !== "==" && r !== "!=";
                    return class Hf {
                        constructor(d, p, g) {
                            this.type = Ze,
                            this.lhs = d,
                            this.rhs = p,
                            this.collator = g,
                            this.hasUntypedArgument = d.type.kind === "value" || p.type.kind === "value"
                        }
                        static parse(d, p) {
                            if (d.length !== 3 && d.length !== 4)
                                return p.error("Expected two or three arguments.");
                            const g = d[0];
                            let x = p.parse(d[1], 1, Je);
                            if (!x)
                                return null;
                            if (!el(g, x.type))
                                return p.concat(1).error(`"${g}" comparisons are not supported for type '${zt(x.type)}'.`);
                            let b = p.parse(d[2], 2, Je);
                            if (!b)
                                return null;
                            if (!el(g, b.type))
                                return p.concat(2).error(`"${g}" comparisons are not supported for type '${zt(b.type)}'.`);
                            if (x.type.kind !== b.type.kind && x.type.kind !== "value" && b.type.kind !== "value")
                                return p.error(`Cannot compare types '${zt(x.type)}' and '${zt(b.type)}'.`);
                            s && (x.type.kind === "value" && b.type.kind !== "value" ? x = new Sr(b.type,[x]) : x.type.kind !== "value" && b.type.kind === "value" && (b = new Sr(x.type,[b])));
                            let C = null;
                            if (d.length === 4) {
                                if (x.type.kind !== "string" && b.type.kind !== "string" && x.type.kind !== "value" && b.type.kind !== "value")
                                    return p.error("Cannot use collator to compare non-string types.");
                                if (C = p.parse(d[3], 3, Qn),
                                !C)
                                    return null
                            }
                            return new Hf(x,b,C)
                        }
                        evaluate(d) {
                            const p = this.lhs.evaluate(d)
                              , g = this.rhs.evaluate(d);
                            if (s && this.hasUntypedArgument) {
                                const x = hi(p)
                                  , b = hi(g);
                                if (x.kind !== b.kind || x.kind !== "string" && x.kind !== "number")
                                    throw new Xt(`Expected arguments for "${r}" to be (string, string) or (number, number), but found (${x.kind}, ${b.kind}) instead.`)
                            }
                            if (this.collator && !s && this.hasUntypedArgument) {
                                const x = hi(p)
                                  , b = hi(g);
                                if (x.kind !== "string" || b.kind !== "string")
                                    return t(d, p, g)
                            }
                            return this.collator ? n(d, p, g, this.collator.evaluate(d)) : t(d, p, g)
                        }
                        eachChild(d) {
                            d(this.lhs),
                            d(this.rhs),
                            this.collator && d(this.collator)
                        }
                        outputDefined() {
                            return !0
                        }
                    }
                }
                const eh = ts("==", function(r, t, n) {
                    return t === n
                }, No)
                  , jo = ts("!=", function(r, t, n) {
                    return t !== n
                }, function(r, t, n, s) {
                    return !No(0, t, n, s)
                })
                  , tl = ts("<", function(r, t, n) {
                    return t < n
                }, function(r, t, n, s) {
                    return s.compare(t, n) < 0
                })
                  , th = ts(">", function(r, t, n) {
                    return t > n
                }, function(r, t, n, s) {
                    return s.compare(t, n) > 0
                })
                  , Vo = ts("<=", function(r, t, n) {
                    return t <= n
                }, function(r, t, n, s) {
                    return s.compare(t, n) <= 0
                })
                  , Uo = ts(">=", function(r, t, n) {
                    return t >= n
                }, function(r, t, n, s) {
                    return s.compare(t, n) >= 0
                });
                class tr {
                    constructor(t, n, s) {
                        this.type = Qn,
                        this.locale = s,
                        this.caseSensitive = t,
                        this.diacriticSensitive = n
                    }
                    static parse(t, n) {
                        if (t.length !== 2)
                            return n.error("Expected one argument.");
                        const s = t[1];
                        if (typeof s != "object" || Array.isArray(s))
                            return n.error("Collator options argument must be an object.");
                        const c = n.parse(s["case-sensitive"] !== void 0 && s["case-sensitive"], 1, Ze);
                        if (!c)
                            return null;
                        const d = n.parse(s["diacritic-sensitive"] !== void 0 && s["diacritic-sensitive"], 1, Ze);
                        if (!d)
                            return null;
                        let p = null;
                        return s.locale && (p = n.parse(s.locale, 1, Ge),
                        !p) ? null : new tr(c,d,p)
                    }
                    evaluate(t) {
                        return new Lo(this.caseSensitive.evaluate(t),this.diacriticSensitive.evaluate(t),this.locale ? this.locale.evaluate(t) : null)
                    }
                    eachChild(t) {
                        t(this.caseSensitive),
                        t(this.diacriticSensitive),
                        this.locale && t(this.locale)
                    }
                    outputDefined() {
                        return !1
                    }
                }
                class Zo {
                    constructor(t, n, s, c, d) {
                        this.type = Ge,
                        this.number = t,
                        this.locale = n,
                        this.currency = s,
                        this.minFractionDigits = c,
                        this.maxFractionDigits = d
                    }
                    static parse(t, n) {
                        if (t.length !== 3)
                            return n.error("Expected two arguments.");
                        const s = n.parse(t[1], 1, Ae);
                        if (!s)
                            return null;
                        const c = t[2];
                        if (typeof c != "object" || Array.isArray(c))
                            return n.error("NumberFormat options argument must be an object.");
                        let d = null;
                        if (c.locale && (d = n.parse(c.locale, 1, Ge),
                        !d))
                            return null;
                        let p = null;
                        if (c.currency && (p = n.parse(c.currency, 1, Ge),
                        !p))
                            return null;
                        let g = null;
                        if (c["min-fraction-digits"] && (g = n.parse(c["min-fraction-digits"], 1, Ae),
                        !g))
                            return null;
                        let x = null;
                        return c["max-fraction-digits"] && (x = n.parse(c["max-fraction-digits"], 1, Ae),
                        !x) ? null : new Zo(s,d,p,g,x)
                    }
                    evaluate(t) {
                        return new Intl.NumberFormat(this.locale ? this.locale.evaluate(t) : [],{
                            style: this.currency ? "currency" : "decimal",
                            currency: this.currency ? this.currency.evaluate(t) : void 0,
                            minimumFractionDigits: this.minFractionDigits ? this.minFractionDigits.evaluate(t) : void 0,
                            maximumFractionDigits: this.maxFractionDigits ? this.maxFractionDigits.evaluate(t) : void 0
                        }).format(this.number.evaluate(t))
                    }
                    eachChild(t) {
                        t(this.number),
                        this.locale && t(this.locale),
                        this.currency && t(this.currency),
                        this.minFractionDigits && t(this.minFractionDigits),
                        this.maxFractionDigits && t(this.maxFractionDigits)
                    }
                    outputDefined() {
                        return !1
                    }
                }
                class is {
                    constructor(t) {
                        this.type = ui,
                        this.sections = t
                    }
                    static parse(t, n) {
                        if (t.length < 2)
                            return n.error("Expected at least one argument.");
                        const s = t[1];
                        if (!Array.isArray(s) && typeof s == "object")
                            return n.error("First argument must be an image or text section.");
                        const c = [];
                        let d = !1;
                        for (let p = 1; p <= t.length - 1; ++p) {
                            const g = t[p];
                            if (d && typeof g == "object" && !Array.isArray(g)) {
                                d = !1;
                                let x = null;
                                if (g["font-scale"] && (x = n.parse(g["font-scale"], 1, Ae),
                                !x))
                                    return null;
                                let b = null;
                                if (g["text-font"] && (b = n.parse(g["text-font"], 1, Qi(Ge)),
                                !b))
                                    return null;
                                let C = null;
                                if (g["text-color"] && (C = n.parse(g["text-color"], 1, at),
                                !C))
                                    return null;
                                let P = null;
                                if (g["vertical-align"]) {
                                    if (typeof g["vertical-align"] == "string" && !Ka.includes(g["vertical-align"]))
                                        return n.error(`'vertical-align' must be one of: 'bottom', 'center', 'top' but found '${g["vertical-align"]}' instead.`);
                                    if (P = n.parse(g["vertical-align"], 1, Ge),
                                    !P)
                                        return null
                                }
                                const D = c[c.length - 1];
                                D.scale = x,
                                D.font = b,
                                D.textColor = C,
                                D.verticalAlign = P
                            } else {
                                const x = n.parse(t[p], 1, Je);
                                if (!x)
                                    return null;
                                const b = x.type.kind;
                                if (b !== "string" && b !== "value" && b !== "null" && b !== "resolvedImage")
                                    return n.error("Formatted text type must be 'string', 'value', 'image' or 'null'.");
                                d = !0,
                                c.push({
                                    content: x,
                                    scale: null,
                                    font: null,
                                    textColor: null,
                                    verticalAlign: null
                                })
                            }
                        }
                        return new is(c)
                    }
                    evaluate(t) {
                        return new Fi(this.sections.map(n => {
                            const s = n.content.evaluate(t);
                            return hi(s) === Bt ? new Cr("",s,null,null,null,n.verticalAlign ? n.verticalAlign.evaluate(t) : null) : new Cr(Fn(s),null,n.scale ? n.scale.evaluate(t) : null,n.font ? n.font.evaluate(t).join(",") : null,n.textColor ? n.textColor.evaluate(t) : null,n.verticalAlign ? n.verticalAlign.evaluate(t) : null)
                        }
                        ))
                    }
                    eachChild(t) {
                        for (const n of this.sections)
                            t(n.content),
                            n.scale && t(n.scale),
                            n.font && t(n.font),
                            n.textColor && t(n.textColor),
                            n.verticalAlign && t(n.verticalAlign)
                    }
                    outputDefined() {
                        return !1
                    }
                }
                class il {
                    constructor(t) {
                        this.type = Bt,
                        this.input = t
                    }
                    static parse(t, n) {
                        if (t.length !== 2)
                            return n.error("Expected two arguments.");
                        const s = n.parse(t[1], 1, Ge);
                        return s ? new il(s) : n.error("No image name provided.")
                    }
                    evaluate(t) {
                        const n = this.input.evaluate(t)
                          , s = Ki.fromString(n);
                        return s && t.availableImages && (s.available = t.availableImages.indexOf(n) > -1),
                        s
                    }
                    eachChild(t) {
                        t(this.input)
                    }
                    outputDefined() {
                        return !1
                    }
                }
                class lo {
                    constructor(t) {
                        this.type = Ae,
                        this.input = t
                    }
                    static parse(t, n) {
                        if (t.length !== 2)
                            return n.error(`Expected 1 argument, but found ${t.length - 1} instead.`);
                        const s = n.parse(t[1], 1);
                        return s ? s.type.kind !== "array" && s.type.kind !== "string" && s.type.kind !== "value" ? n.error(`Expected argument of type string or array, but found ${zt(s.type)} instead.`) : new lo(s) : null
                    }
                    evaluate(t) {
                        const n = this.input.evaluate(t);
                        if (typeof n == "string")
                            return [...n].length;
                        if (Array.isArray(n))
                            return n.length;
                        throw new Xt(`Expected value to be of type string or array, but found ${zt(hi(n))} instead.`)
                    }
                    eachChild(t) {
                        t(this.input)
                    }
                    outputDefined() {
                        return !1
                    }
                }
                const rn = 8192;
                function ih(r, t) {
                    const n = (180 + r[0]) / 360
                      , s = (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + r[1] * Math.PI / 360))) / 360
                      , c = Math.pow(2, t.z);
                    return [Math.round(n * c * rn), Math.round(s * c * rn)]
                }
                function rl(r, t) {
                    const n = Math.pow(2, t.z);
                    return [(c = (r[0] / rn + t.x) / n,
                    360 * c - 180), (s = (r[1] / rn + t.y) / n,
                    360 / Math.PI * Math.atan(Math.exp((180 - 360 * s) * Math.PI / 180)) - 90)];
                    var s, c
                }
                function co(r, t) {
                    r[0] = Math.min(r[0], t[0]),
                    r[1] = Math.min(r[1], t[1]),
                    r[2] = Math.max(r[2], t[0]),
                    r[3] = Math.max(r[3], t[1])
                }
                function Bn(r, t) {
                    return !(r[0] <= t[0] || r[2] >= t[2] || r[1] <= t[1] || r[3] >= t[3])
                }
                function rh(r, t, n) {
                    const s = r[0] - t[0]
                      , c = r[1] - t[1]
                      , d = r[0] - n[0]
                      , p = r[1] - n[1];
                    return s * p - d * c == 0 && s * d <= 0 && c * p <= 0
                }
                function uo(r, t, n, s) {
                    return (c = [s[0] - n[0], s[1] - n[1]])[0] * (d = [t[0] - r[0], t[1] - r[1]])[1] - c[1] * d[0] != 0 && !(!Pc(r, t, n, s) || !Pc(n, s, r, t));
                    var c, d
                }
                function Tc(r, t, n) {
                    for (const s of n)
                        for (let c = 0; c < s.length - 1; ++c)
                            if (uo(r, t, s[c], s[c + 1]))
                                return !0;
                    return !1
                }
                function ks(r, t, n=!1) {
                    let s = !1;
                    for (const g of t)
                        for (let x = 0; x < g.length - 1; x++) {
                            if (rh(r, g[x], g[x + 1]))
                                return n;
                            (d = g[x])[1] > (c = r)[1] != (p = g[x + 1])[1] > c[1] && c[0] < (p[0] - d[0]) * (c[1] - d[1]) / (p[1] - d[1]) + d[0] && (s = !s)
                        }
                    var c, d, p;
                    return s
                }
                function Mc(r, t) {
                    for (const n of t)
                        if (ks(r, n))
                            return !0;
                    return !1
                }
                function Cc(r, t) {
                    for (const n of r)
                        if (!ks(n, t))
                            return !1;
                    for (let n = 0; n < r.length - 1; ++n)
                        if (Tc(r[n], r[n + 1], t))
                            return !1;
                    return !0
                }
                function nh(r, t) {
                    for (const n of t)
                        if (Cc(r, n))
                            return !0;
                    return !1
                }
                function Pc(r, t, n, s) {
                    const c = s[0] - n[0]
                      , d = s[1] - n[1]
                      , p = (r[0] - n[0]) * d - c * (r[1] - n[1])
                      , g = (t[0] - n[0]) * d - c * (t[1] - n[1]);
                    return p > 0 && g < 0 || p < 0 && g > 0
                }
                function nl(r, t, n) {
                    const s = [];
                    for (let c = 0; c < r.length; c++) {
                        const d = [];
                        for (let p = 0; p < r[c].length; p++) {
                            const g = ih(r[c][p], n);
                            co(t, g),
                            d.push(g)
                        }
                        s.push(d)
                    }
                    return s
                }
                function Sc(r, t, n) {
                    const s = [];
                    for (let c = 0; c < r.length; c++) {
                        const d = nl(r[c], t, n);
                        s.push(d)
                    }
                    return s
                }
                function sl(r, t, n, s) {
                    if (r[0] < n[0] || r[0] > n[2]) {
                        const c = .5 * s;
                        let d = r[0] - n[0] > c ? -s : n[0] - r[0] > c ? s : 0;
                        d === 0 && (d = r[0] - n[2] > c ? -s : n[2] - r[0] > c ? s : 0),
                        r[0] += d
                    }
                    co(t, r)
                }
                function ol(r, t, n, s) {
                    const c = Math.pow(2, s.z) * rn
                      , d = [s.x * rn, s.y * rn]
                      , p = [];
                    for (const g of r)
                        for (const x of g) {
                            const b = [x.x + d[0], x.y + d[1]];
                            sl(b, t, n, c),
                            p.push(b)
                        }
                    return p
                }
                function al(r, t, n, s) {
                    const c = Math.pow(2, s.z) * rn
                      , d = [s.x * rn, s.y * rn]
                      , p = [];
                    for (const x of r) {
                        const b = [];
                        for (const C of x) {
                            const P = [C.x + d[0], C.y + d[1]];
                            co(t, P),
                            b.push(P)
                        }
                        p.push(b)
                    }
                    if (t[2] - t[0] <= c / 2) {
                        (g = t)[0] = g[1] = 1 / 0,
                        g[2] = g[3] = -1 / 0;
                        for (const x of p)
                            for (const b of x)
                                sl(b, t, n, c)
                    }
                    var g;
                    return p
                }
                class rs {
                    constructor(t, n) {
                        this.type = Ze,
                        this.geojson = t,
                        this.geometries = n
                    }
                    static parse(t, n) {
                        if (t.length !== 2)
                            return n.error(`'within' expression requires exactly one argument, but found ${t.length - 1} instead.`);
                        if (Vr(t[1])) {
                            const s = t[1];
                            if (s.type === "FeatureCollection") {
                                const c = [];
                                for (const d of s.features) {
                                    const {type: p, coordinates: g} = d.geometry;
                                    p === "Polygon" && c.push(g),
                                    p === "MultiPolygon" && c.push(...g)
                                }
                                if (c.length)
                                    return new rs(s,{
                                        type: "MultiPolygon",
                                        coordinates: c
                                    })
                            } else if (s.type === "Feature") {
                                const c = s.geometry.type;
                                if (c === "Polygon" || c === "MultiPolygon")
                                    return new rs(s,s.geometry)
                            } else if (s.type === "Polygon" || s.type === "MultiPolygon")
                                return new rs(s,s)
                        }
                        return n.error("'within' expression requires valid geojson object that contains polygon geometry type.")
                    }
                    evaluate(t) {
                        if (t.geometry() != null && t.canonicalID() != null) {
                            if (t.geometryType() === "Point")
                                return function(n, s) {
                                    const c = [1 / 0, 1 / 0, -1 / 0, -1 / 0]
                                      , d = [1 / 0, 1 / 0, -1 / 0, -1 / 0]
                                      , p = n.canonicalID();
                                    if (s.type === "Polygon") {
                                        const g = nl(s.coordinates, d, p)
                                          , x = ol(n.geometry(), c, d, p);
                                        if (!Bn(c, d))
                                            return !1;
                                        for (const b of x)
                                            if (!ks(b, g))
                                                return !1
                                    }
                                    if (s.type === "MultiPolygon") {
                                        const g = Sc(s.coordinates, d, p)
                                          , x = ol(n.geometry(), c, d, p);
                                        if (!Bn(c, d))
                                            return !1;
                                        for (const b of x)
                                            if (!Mc(b, g))
                                                return !1
                                    }
                                    return !0
                                }(t, this.geometries);
                            if (t.geometryType() === "LineString")
                                return function(n, s) {
                                    const c = [1 / 0, 1 / 0, -1 / 0, -1 / 0]
                                      , d = [1 / 0, 1 / 0, -1 / 0, -1 / 0]
                                      , p = n.canonicalID();
                                    if (s.type === "Polygon") {
                                        const g = nl(s.coordinates, d, p)
                                          , x = al(n.geometry(), c, d, p);
                                        if (!Bn(c, d))
                                            return !1;
                                        for (const b of x)
                                            if (!Cc(b, g))
                                                return !1
                                    }
                                    if (s.type === "MultiPolygon") {
                                        const g = Sc(s.coordinates, d, p)
                                          , x = al(n.geometry(), c, d, p);
                                        if (!Bn(c, d))
                                            return !1;
                                        for (const b of x)
                                            if (!nh(b, g))
                                                return !1
                                    }
                                    return !0
                                }(t, this.geometries)
                        }
                        return !1
                    }
                    eachChild() {}
                    outputDefined() {
                        return !0
                    }
                }
                let Ic = class {
                    constructor(r=[], t= (n, s) => n < s ? -1 : n > s ? 1 : 0) {
                        if (this.data = r,
                        this.length = this.data.length,
                        this.compare = t,
                        this.length > 0)
                            for (let n = (this.length >> 1) - 1; n >= 0; n--)
                                this._down(n)
                    }
                    push(r) {
                        this.data.push(r),
                        this._up(this.length++)
                    }
                    pop() {
                        if (this.length === 0)
                            return;
                        const r = this.data[0]
                          , t = this.data.pop();
                        return --this.length > 0 && (this.data[0] = t,
                        this._down(0)),
                        r
                    }
                    peek() {
                        return this.data[0]
                    }
                    _up(r) {
                        const {data: t, compare: n} = this
                          , s = t[r];
                        for (; r > 0; ) {
                            const c = r - 1 >> 1
                              , d = t[c];
                            if (n(s, d) >= 0)
                                break;
                            t[r] = d,
                            r = c
                        }
                        t[r] = s
                    }
                    _down(r) {
                        const {data: t, compare: n} = this
                          , s = this.length >> 1
                          , c = t[r];
                        for (; r < s; ) {
                            let d = 1 + (r << 1);
                            const p = d + 1;
                            if (p < this.length && n(t[p], t[d]) < 0 && (d = p),
                            n(t[d], c) >= 0)
                                break;
                            t[r] = t[d],
                            r = d
                        }
                        t[r] = c
                    }
                }
                ;
                function Ec(r, t, n=0, s=r.length - 1, c=sh) {
                    for (; s > n; ) {
                        if (s - n > 600) {
                            const x = s - n + 1
                              , b = t - n + 1
                              , C = Math.log(x)
                              , P = .5 * Math.exp(2 * C / 3)
                              , D = .5 * Math.sqrt(C * P * (x - P) / x) * (b - x / 2 < 0 ? -1 : 1);
                            Ec(r, t, Math.max(n, Math.floor(t - b * P / x + D)), Math.min(s, Math.floor(t + (x - b) * P / x + D)), c)
                        }
                        const d = r[t];
                        let p = n
                          , g = s;
                        for (ns(r, n, t),
                        c(r[s], d) > 0 && ns(r, n, s); p < g; ) {
                            for (ns(r, p, g),
                            p++,
                            g--; c(r[p], d) < 0; )
                                p++;
                            for (; c(r[g], d) > 0; )
                                g--
                        }
                        c(r[n], d) === 0 ? ns(r, n, g) : (g++,
                        ns(r, g, s)),
                        g <= t && (n = g + 1),
                        t <= g && (s = g - 1)
                    }
                }
                function ns(r, t, n) {
                    const s = r[t];
                    r[t] = r[n],
                    r[n] = s
                }
                function sh(r, t) {
                    return r < t ? -1 : r > t ? 1 : 0
                }
                function Go(r, t) {
                    if (r.length <= 1)
                        return [r];
                    const n = [];
                    let s, c;
                    for (const d of r) {
                        const p = Ac(d);
                        p !== 0 && (d.area = Math.abs(p),
                        c === void 0 && (c = p < 0),
                        c === p < 0 ? (s && n.push(s),
                        s = [d]) : s.push(d))
                    }
                    if (s && n.push(s),
                    t > 1)
                        for (let d = 0; d < n.length; d++)
                            n[d].length <= t || (Ec(n[d], t, 1, n[d].length - 1, oh),
                            n[d] = n[d].slice(0, t));
                    return n
                }
                function oh(r, t) {
                    return t.area - r.area
                }
                function Ac(r) {
                    let t = 0;
                    for (let n, s, c = 0, d = r.length, p = d - 1; c < d; p = c++)
                        n = r[c],
                        s = r[p],
                        t += (s.x - n.x) * (n.y + s.y);
                    return t
                }
                const ll = 1 / 298.257223563
                  , zc = ll * (2 - ll)
                  , kc = Math.PI / 180;
                class $o {
                    constructor(t) {
                        const n = 6378.137 * kc * 1e3
                          , s = Math.cos(t * kc)
                          , c = 1 / (1 - zc * (1 - s * s))
                          , d = Math.sqrt(c);
                        this.kx = n * d * s,
                        this.ky = n * d * c * (1 - zc)
                    }
                    distance(t, n) {
                        const s = this.wrap(t[0] - n[0]) * this.kx
                          , c = (t[1] - n[1]) * this.ky;
                        return Math.sqrt(s * s + c * c)
                    }
                    pointOnLine(t, n) {
                        let s, c, d, p, g = 1 / 0;
                        for (let x = 0; x < t.length - 1; x++) {
                            let b = t[x][0]
                              , C = t[x][1]
                              , P = this.wrap(t[x + 1][0] - b) * this.kx
                              , D = (t[x + 1][1] - C) * this.ky
                              , F = 0;
                            P === 0 && D === 0 || (F = (this.wrap(n[0] - b) * this.kx * P + (n[1] - C) * this.ky * D) / (P * P + D * D),
                            F > 1 ? (b = t[x + 1][0],
                            C = t[x + 1][1]) : F > 0 && (b += P / this.kx * F,
                            C += D / this.ky * F)),
                            P = this.wrap(n[0] - b) * this.kx,
                            D = (n[1] - C) * this.ky;
                            const B = P * P + D * D;
                            B < g && (g = B,
                            s = b,
                            c = C,
                            d = x,
                            p = F)
                        }
                        return {
                            point: [s, c],
                            index: d,
                            t: Math.max(0, Math.min(1, p))
                        }
                    }
                    wrap(t) {
                        for (; t < -180; )
                            t += 360;
                        for (; t > 180; )
                            t -= 360;
                        return t
                    }
                }
                function cl(r, t) {
                    return t[0] - r[0]
                }
                function qo(r) {
                    return r[1] - r[0] + 1
                }
                function yn(r, t) {
                    return r[1] >= r[0] && r[1] < t
                }
                function ul(r, t) {
                    if (r[0] > r[1])
                        return [null, null];
                    const n = qo(r);
                    if (t) {
                        if (n === 2)
                            return [r, null];
                        const c = Math.floor(n / 2);
                        return [[r[0], r[0] + c], [r[0] + c, r[1]]]
                    }
                    if (n === 1)
                        return [r, null];
                    const s = Math.floor(n / 2) - 1;
                    return [[r[0], r[0] + s], [r[0] + s + 1, r[1]]]
                }
                function Ho(r, t) {
                    if (!yn(t, r.length))
                        return [1 / 0, 1 / 0, -1 / 0, -1 / 0];
                    const n = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
                    for (let s = t[0]; s <= t[1]; ++s)
                        co(n, r[s]);
                    return n
                }
                function hl(r) {
                    const t = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
                    for (const n of r)
                        for (const s of n)
                            co(t, s);
                    return t
                }
                function Lc(r) {
                    return r[0] !== -1 / 0 && r[1] !== -1 / 0 && r[2] !== 1 / 0 && r[3] !== 1 / 0
                }
                function dl(r, t, n) {
                    if (!Lc(r) || !Lc(t))
                        return NaN;
                    let s = 0
                      , c = 0;
                    return r[2] < t[0] && (s = t[0] - r[2]),
                    r[0] > t[2] && (s = r[0] - t[2]),
                    r[1] > t[3] && (c = r[1] - t[3]),
                    r[3] < t[1] && (c = t[1] - r[3]),
                    n.distance([0, 0], [s, c])
                }
                function ss(r, t, n) {
                    const s = n.pointOnLine(t, r);
                    return n.distance(r, s.point)
                }
                function bt(r, t, n, s, c) {
                    const d = Math.min(ss(r, [n, s], c), ss(t, [n, s], c))
                      , p = Math.min(ss(n, [r, t], c), ss(s, [r, t], c));
                    return Math.min(d, p)
                }
                function ah(r, t, n, s, c) {
                    if (!yn(t, r.length) || !yn(s, n.length))
                        return 1 / 0;
                    let d = 1 / 0;
                    for (let p = t[0]; p < t[1]; ++p) {
                        const g = r[p]
                          , x = r[p + 1];
                        for (let b = s[0]; b < s[1]; ++b) {
                            const C = n[b]
                              , P = n[b + 1];
                            if (uo(g, x, C, P))
                                return 0;
                            d = Math.min(d, bt(g, x, C, P, c))
                        }
                    }
                    return d
                }
                function lh(r, t, n, s, c) {
                    if (!yn(t, r.length) || !yn(s, n.length))
                        return NaN;
                    let d = 1 / 0;
                    for (let p = t[0]; p <= t[1]; ++p)
                        for (let g = s[0]; g <= s[1]; ++g)
                            if (d = Math.min(d, c.distance(r[p], n[g])),
                            d === 0)
                                return d;
                    return d
                }
                function ch(r, t, n) {
                    if (ks(r, t, !0))
                        return 0;
                    let s = 1 / 0;
                    for (const c of t) {
                        const d = c[0]
                          , p = c[c.length - 1];
                        if (d !== p && (s = Math.min(s, ss(r, [p, d], n)),
                        s === 0))
                            return s;
                        const g = n.pointOnLine(c, r);
                        if (s = Math.min(s, n.distance(r, g.point)),
                        s === 0)
                            return s
                    }
                    return s
                }
                function uh(r, t, n, s) {
                    if (!yn(t, r.length))
                        return NaN;
                    for (let d = t[0]; d <= t[1]; ++d)
                        if (ks(r[d], n, !0))
                            return 0;
                    let c = 1 / 0;
                    for (let d = t[0]; d < t[1]; ++d) {
                        const p = r[d]
                          , g = r[d + 1];
                        for (const x of n)
                            for (let b = 0, C = x.length, P = C - 1; b < C; P = b++) {
                                const D = x[P]
                                  , F = x[b];
                                if (uo(p, g, D, F))
                                    return 0;
                                c = Math.min(c, bt(p, g, D, F, s))
                            }
                    }
                    return c
                }
                function Dc(r, t) {
                    for (const n of r)
                        for (const s of n)
                            if (ks(s, t, !0))
                                return !0;
                    return !1
                }
                function hh(r, t, n, s=1 / 0) {
                    const c = hl(r)
                      , d = hl(t);
                    if (s !== 1 / 0 && dl(c, d, n) >= s)
                        return s;
                    if (Bn(c, d)) {
                        if (Dc(r, t))
                            return 0
                    } else if (Dc(t, r))
                        return 0;
                    let p = 1 / 0;
                    for (const g of r)
                        for (let x = 0, b = g.length, C = b - 1; x < b; C = x++) {
                            const P = g[C]
                              , D = g[x];
                            for (const F of t)
                                for (let B = 0, j = F.length, G = j - 1; B < j; G = B++) {
                                    const X = F[G]
                                      , ae = F[B];
                                    if (uo(P, D, X, ae))
                                        return 0;
                                    p = Math.min(p, bt(P, D, X, ae, n))
                                }
                        }
                    return p
                }
                function Rc(r, t, n, s, c, d) {
                    if (!d)
                        return;
                    const p = dl(Ho(s, d), c, n);
                    p < t && r.push([p, d, [0, 0]])
                }
                function Wo(r, t, n, s, c, d, p) {
                    if (!d || !p)
                        return;
                    const g = dl(Ho(s, d), Ho(c, p), n);
                    g < t && r.push([g, d, p])
                }
                function Xo(r, t, n, s, c=1 / 0) {
                    let d = Math.min(s.distance(r[0], n[0][0]), c);
                    if (d === 0)
                        return d;
                    const p = new Ic([[0, [0, r.length - 1], [0, 0]]],cl)
                      , g = hl(n);
                    for (; p.length > 0; ) {
                        const x = p.pop();
                        if (x[0] >= d)
                            continue;
                        const b = x[1]
                          , C = t ? 50 : 100;
                        if (qo(b) <= C) {
                            if (!yn(b, r.length))
                                return NaN;
                            if (t) {
                                const P = uh(r, b, n, s);
                                if (isNaN(P) || P === 0)
                                    return P;
                                d = Math.min(d, P)
                            } else
                                for (let P = b[0]; P <= b[1]; ++P) {
                                    const D = ch(r[P], n, s);
                                    if (d = Math.min(d, D),
                                    d === 0)
                                        return 0
                                }
                        } else {
                            const P = ul(b, t);
                            Rc(p, d, s, r, g, P[0]),
                            Rc(p, d, s, r, g, P[1])
                        }
                    }
                    return d
                }
                function Ko(r, t, n, s, c, d=1 / 0) {
                    let p = Math.min(d, c.distance(r[0], n[0]));
                    if (p === 0)
                        return p;
                    const g = new Ic([[0, [0, r.length - 1], [0, n.length - 1]]],cl);
                    for (; g.length > 0; ) {
                        const x = g.pop();
                        if (x[0] >= p)
                            continue;
                        const b = x[1]
                          , C = x[2]
                          , P = t ? 50 : 100
                          , D = s ? 50 : 100;
                        if (qo(b) <= P && qo(C) <= D) {
                            if (!yn(b, r.length) && yn(C, n.length))
                                return NaN;
                            let F;
                            if (t && s)
                                F = ah(r, b, n, C, c),
                                p = Math.min(p, F);
                            else if (t && !s) {
                                const B = r.slice(b[0], b[1] + 1);
                                for (let j = C[0]; j <= C[1]; ++j)
                                    if (F = ss(n[j], B, c),
                                    p = Math.min(p, F),
                                    p === 0)
                                        return p
                            } else if (!t && s) {
                                const B = n.slice(C[0], C[1] + 1);
                                for (let j = b[0]; j <= b[1]; ++j)
                                    if (F = ss(r[j], B, c),
                                    p = Math.min(p, F),
                                    p === 0)
                                        return p
                            } else
                                F = lh(r, b, n, C, c),
                                p = Math.min(p, F)
                        } else {
                            const F = ul(b, t)
                              , B = ul(C, s);
                            Wo(g, p, c, r, n, F[0], B[0]),
                            Wo(g, p, c, r, n, F[0], B[1]),
                            Wo(g, p, c, r, n, F[1], B[0]),
                            Wo(g, p, c, r, n, F[1], B[1])
                        }
                    }
                    return p
                }
                function pl(r) {
                    return r.type === "MultiPolygon" ? r.coordinates.map(t => ({
                        type: "Polygon",
                        coordinates: t
                    })) : r.type === "MultiLineString" ? r.coordinates.map(t => ({
                        type: "LineString",
                        coordinates: t
                    })) : r.type === "MultiPoint" ? r.coordinates.map(t => ({
                        type: "Point",
                        coordinates: t
                    })) : [r]
                }
                class os {
                    constructor(t, n) {
                        this.type = Ae,
                        this.geojson = t,
                        this.geometries = n
                    }
                    static parse(t, n) {
                        if (t.length !== 2)
                            return n.error(`'distance' expression requires exactly one argument, but found ${t.length - 1} instead.`);
                        if (Vr(t[1])) {
                            const s = t[1];
                            if (s.type === "FeatureCollection")
                                return new os(s,s.features.map(c => pl(c.geometry)).flat());
                            if (s.type === "Feature")
                                return new os(s,pl(s.geometry));
                            if ("type"in s && "coordinates"in s)
                                return new os(s,pl(s))
                        }
                        return n.error("'distance' expression requires valid geojson object that contains polygon geometry type.")
                    }
                    evaluate(t) {
                        if (t.geometry() != null && t.canonicalID() != null) {
                            if (t.geometryType() === "Point")
                                return function(n, s) {
                                    const c = n.geometry()
                                      , d = c.flat().map(x => rl([x.x, x.y], n.canonical));
                                    if (c.length === 0)
                                        return NaN;
                                    const p = new $o(d[0][1]);
                                    let g = 1 / 0;
                                    for (const x of s) {
                                        switch (x.type) {
                                        case "Point":
                                            g = Math.min(g, Ko(d, !1, [x.coordinates], !1, p, g));
                                            break;
                                        case "LineString":
                                            g = Math.min(g, Ko(d, !1, x.coordinates, !0, p, g));
                                            break;
                                        case "Polygon":
                                            g = Math.min(g, Xo(d, !1, x.coordinates, p, g))
                                        }
                                        if (g === 0)
                                            return g
                                    }
                                    return g
                                }(t, this.geometries);
                            if (t.geometryType() === "LineString")
                                return function(n, s) {
                                    const c = n.geometry()
                                      , d = c.flat().map(x => rl([x.x, x.y], n.canonical));
                                    if (c.length === 0)
                                        return NaN;
                                    const p = new $o(d[0][1]);
                                    let g = 1 / 0;
                                    for (const x of s) {
                                        switch (x.type) {
                                        case "Point":
                                            g = Math.min(g, Ko(d, !0, [x.coordinates], !1, p, g));
                                            break;
                                        case "LineString":
                                            g = Math.min(g, Ko(d, !0, x.coordinates, !0, p, g));
                                            break;
                                        case "Polygon":
                                            g = Math.min(g, Xo(d, !0, x.coordinates, p, g))
                                        }
                                        if (g === 0)
                                            return g
                                    }
                                    return g
                                }(t, this.geometries);
                            if (t.geometryType() === "Polygon")
                                return function(n, s) {
                                    const c = n.geometry();
                                    if (c.length === 0 || c[0].length === 0)
                                        return NaN;
                                    const d = Go(c, 0).map(x => x.map(b => b.map(C => rl([C.x, C.y], n.canonical))))
                                      , p = new $o(d[0][0][0][1]);
                                    let g = 1 / 0;
                                    for (const x of s)
                                        for (const b of d) {
                                            switch (x.type) {
                                            case "Point":
                                                g = Math.min(g, Xo([x.coordinates], !1, b, p, g));
                                                break;
                                            case "LineString":
                                                g = Math.min(g, Xo(x.coordinates, !0, b, p, g));
                                                break;
                                            case "Polygon":
                                                g = Math.min(g, hh(b, x.coordinates, p, g))
                                            }
                                            if (g === 0)
                                                return g
                                        }
                                    return g
                                }(t, this.geometries)
                        }
                        return NaN
                    }
                    eachChild() {}
                    outputDefined() {
                        return !0
                    }
                }
                const Ls = {
                    "==": eh,
                    "!=": jo,
                    ">": th,
                    "<": tl,
                    ">=": Uo,
                    "<=": Vo,
                    array: Sr,
                    at: mt,
                    boolean: Sr,
                    case: Fo,
                    coalesce: ai,
                    collator: tr,
                    format: is,
                    image: il,
                    in: no,
                    "index-of": Ir,
                    interpolate: Zi,
                    "interpolate-hcl": Zi,
                    "interpolate-lab": Zi,
                    length: lo,
                    let: ot,
                    literal: Pr,
                    match: so,
                    number: Sr,
                    "number-format": Zo,
                    object: Sr,
                    slice: oo,
                    step: zs,
                    string: Sr,
                    "to-boolean": Ur,
                    "to-color": Ur,
                    "to-number": Ur,
                    "to-string": Ur,
                    var: Es,
                    within: rs,
                    distance: os
                };
                class Er {
                    constructor(t, n, s, c) {
                        this.name = t,
                        this.type = n,
                        this._evaluate = s,
                        this.args = c
                    }
                    evaluate(t) {
                        return this._evaluate(t, this.args)
                    }
                    eachChild(t) {
                        this.args.forEach(t)
                    }
                    outputDefined() {
                        return !1
                    }
                    static parse(t, n) {
                        const s = t[0]
                          , c = Er.definitions[s];
                        if (!c)
                            return n.error(`Unknown expression "${s}". If you wanted a literal array, use ["literal", [...]].`, 0);
                        const d = Array.isArray(c) ? c[0] : c.type
                          , p = Array.isArray(c) ? [[c[1], c[2]]] : c.overloads
                          , g = p.filter( ([b]) => !Array.isArray(b) || b.length === t.length - 1);
                        let x = null;
                        for (const [b,C] of g) {
                            x = new pt(n.registry,Jo,n.path,null,n.scope);
                            const P = [];
                            let D = !1;
                            for (let F = 1; F < t.length; F++) {
                                const B = t[F]
                                  , j = Array.isArray(b) ? b[F - 1] : b.type
                                  , G = x.parse(B, 1 + P.length, j);
                                if (!G) {
                                    D = !0;
                                    break
                                }
                                P.push(G)
                            }
                            if (!D)
                                if (Array.isArray(b) && b.length !== P.length)
                                    x.error(`Expected ${b.length} arguments, but found ${P.length} instead.`);
                                else {
                                    for (let F = 0; F < P.length; F++) {
                                        const B = Array.isArray(b) ? b[F] : b.type
                                          , j = P[F];
                                        x.concat(F + 1).checkSubtype(B, j.type)
                                    }
                                    if (x.errors.length === 0)
                                        return new Er(s,d,C,P)
                                }
                        }
                        if (g.length === 1)
                            n.errors.push(...x.errors);
                        else {
                            const b = (g.length ? g : p).map( ([P]) => {
                                return D = P,
                                Array.isArray(D) ? `(${D.map(zt).join(", ")})` : `(${zt(D.type)}...)`;
                                var D
                            }
                            ).join(" | ")
                              , C = [];
                            for (let P = 1; P < t.length; P++) {
                                const D = n.parse(t[P], 1 + C.length);
                                if (!D)
                                    return null;
                                C.push(zt(D.type))
                            }
                            n.error(`Expected arguments of type ${b}, but found (${C.join(", ")}) instead.`)
                        }
                        return null
                    }
                    static register(t, n) {
                        Er.definitions = n;
                        for (const s in n)
                            t[s] = Er
                    }
                }
                function Fc(r, [t,n,s,c]) {
                    t = t.evaluate(r),
                    n = n.evaluate(r),
                    s = s.evaluate(r);
                    const d = c ? c.evaluate(r) : 1
                      , p = Do(t, n, s, d);
                    if (p)
                        throw new Xt(p);
                    return new yt(t / 255,n / 255,s / 255,d,!1)
                }
                function Bc(r, t) {
                    return r in t
                }
                function fl(r, t) {
                    const n = t[r];
                    return n === void 0 ? null : n
                }
                function as(r) {
                    return {
                        type: r
                    }
                }
                function Jo(r) {
                    if (r instanceof Es)
                        return Jo(r.boundExpression);
                    if (r instanceof Er && r.name === "error" || r instanceof tr || r instanceof rs || r instanceof os)
                        return !1;
                    const t = r instanceof Ur || r instanceof Sr;
                    let n = !0;
                    return r.eachChild(s => {
                        n = t ? n && Jo(s) : n && s instanceof Pr
                    }
                    ),
                    !!n && Yo(r) && Qo(r, ["zoom", "heatmap-density", "line-progress", "accumulated", "is-supported-script"])
                }
                function Yo(r) {
                    if (r instanceof Er && (r.name === "get" && r.args.length === 1 || r.name === "feature-state" || r.name === "has" && r.args.length === 1 || r.name === "properties" || r.name === "geometry-type" || r.name === "id" || /^filter-/.test(r.name)) || r instanceof rs || r instanceof os)
                        return !1;
                    let t = !0;
                    return r.eachChild(n => {
                        t && !Yo(n) && (t = !1)
                    }
                    ),
                    t
                }
                function ho(r) {
                    if (r instanceof Er && r.name === "feature-state")
                        return !1;
                    let t = !0;
                    return r.eachChild(n => {
                        t && !ho(n) && (t = !1)
                    }
                    ),
                    t
                }
                function Qo(r, t) {
                    if (r instanceof Er && t.indexOf(r.name) >= 0)
                        return !1;
                    let n = !0;
                    return r.eachChild(s => {
                        n && !Qo(s, t) && (n = !1)
                    }
                    ),
                    n
                }
                function Oc(r) {
                    return {
                        result: "success",
                        value: r
                    }
                }
                function Ds(r) {
                    return {
                        result: "error",
                        value: r
                    }
                }
                function Rs(r) {
                    return r["property-type"] === "data-driven" || r["property-type"] === "cross-faded-data-driven"
                }
                function Nc(r) {
                    return !!r.expression && r.expression.parameters.indexOf("zoom") > -1
                }
                function ml(r) {
                    return !!r.expression && r.expression.interpolated
                }
                function xt(r) {
                    return r instanceof Number ? "number" : r instanceof String ? "string" : r instanceof Boolean ? "boolean" : Array.isArray(r) ? "array" : r === null ? "null" : typeof r
                }
                function ea(r) {
                    return typeof r == "object" && r !== null && !Array.isArray(r)
                }
                function dh(r) {
                    return r
                }
                function jc(r, t) {
                    const n = t.type === "color"
                      , s = r.stops && typeof r.stops[0][0] == "object"
                      , c = s || !(s || r.property !== void 0)
                      , d = r.type || (ml(t) ? "exponential" : "interval");
                    if (n || t.type === "padding") {
                        const C = n ? yt.parse : Si.parse;
                        (r = je({}, r)).stops && (r.stops = r.stops.map(P => [P[0], C(P[1])])),
                        r.default = C(r.default ? r.default : t.default)
                    }
                    if (r.colorSpace && (p = r.colorSpace) !== "rgb" && p !== "hcl" && p !== "lab")
                        throw new Error(`Unknown color space: "${r.colorSpace}"`);
                    var p;
                    let g, x, b;
                    if (d === "exponential")
                        g = Vc;
                    else if (d === "interval")
                        g = fh;
                    else if (d === "categorical") {
                        g = ph,
                        x = Object.create(null);
                        for (const C of r.stops)
                            x[C[0]] = C[1];
                        b = typeof r.stops[0][0]
                    } else {
                        if (d !== "identity")
                            throw new Error(`Unknown function type "${d}"`);
                        g = Uc
                    }
                    if (s) {
                        const C = {}
                          , P = [];
                        for (let B = 0; B < r.stops.length; B++) {
                            const j = r.stops[B]
                              , G = j[0].zoom;
                            C[G] === void 0 && (C[G] = {
                                zoom: G,
                                type: r.type,
                                property: r.property,
                                default: r.default,
                                stops: []
                            },
                            P.push(G)),
                            C[G].stops.push([j[0].value, j[1]])
                        }
                        const D = [];
                        for (const B of P)
                            D.push([C[B].zoom, jc(C[B], t)]);
                        const F = {
                            name: "linear"
                        };
                        return {
                            kind: "composite",
                            interpolationType: F,
                            interpolationFactor: Zi.interpolationFactor.bind(void 0, F),
                            zoomStops: D.map(B => B[0]),
                            evaluate: ({zoom: B}, j) => Vc({
                                stops: D,
                                base: r.base
                            }, t, B).evaluate(B, j)
                        }
                    }
                    if (c) {
                        const C = d === "exponential" ? {
                            name: "exponential",
                            base: r.base !== void 0 ? r.base : 1
                        } : null;
                        return {
                            kind: "camera",
                            interpolationType: C,
                            interpolationFactor: Zi.interpolationFactor.bind(void 0, C),
                            zoomStops: r.stops.map(P => P[0]),
                            evaluate: ({zoom: P}) => g(r, t, P, x, b)
                        }
                    }
                    return {
                        kind: "source",
                        evaluate(C, P) {
                            const D = P && P.properties ? P.properties[r.property] : void 0;
                            return D === void 0 ? ls(r.default, t.default) : g(r, t, D, x, b)
                        }
                    }
                }
                function ls(r, t, n) {
                    return r !== void 0 ? r : t !== void 0 ? t : n !== void 0 ? n : void 0
                }
                function ph(r, t, n, s, c) {
                    return ls(typeof n === c ? s[n] : void 0, r.default, t.default)
                }
                function fh(r, t, n) {
                    if (xt(n) !== "number")
                        return ls(r.default, t.default);
                    const s = r.stops.length;
                    if (s === 1 || n <= r.stops[0][0])
                        return r.stops[0][1];
                    if (n >= r.stops[s - 1][0])
                        return r.stops[s - 1][1];
                    const c = As(r.stops.map(d => d[0]), n);
                    return r.stops[c][1]
                }
                function Vc(r, t, n) {
                    const s = r.base !== void 0 ? r.base : 1;
                    if (xt(n) !== "number")
                        return ls(r.default, t.default);
                    const c = r.stops.length;
                    if (c === 1 || n <= r.stops[0][0])
                        return r.stops[0][1];
                    if (n >= r.stops[c - 1][0])
                        return r.stops[c - 1][1];
                    const d = As(r.stops.map(C => C[0]), n)
                      , p = function(C, P, D, F) {
                        const B = F - D
                          , j = C - D;
                        return B === 0 ? 0 : P === 1 ? j / B : (Math.pow(P, j) - 1) / (Math.pow(P, B) - 1)
                    }(n, s, r.stops[d][0], r.stops[d + 1][0])
                      , g = r.stops[d][1]
                      , x = r.stops[d + 1][1]
                      , b = cr[t.type] || dh;
                    return typeof g.evaluate == "function" ? {
                        evaluate(...C) {
                            const P = g.evaluate.apply(void 0, C)
                              , D = x.evaluate.apply(void 0, C);
                            if (P !== void 0 && D !== void 0)
                                return b(P, D, p, r.colorSpace)
                        }
                    } : b(g, x, p, r.colorSpace)
                }
                function Uc(r, t, n) {
                    switch (t.type) {
                    case "color":
                        n = yt.parse(n);
                        break;
                    case "formatted":
                        n = Fi.fromString(n.toString());
                        break;
                    case "resolvedImage":
                        n = Ki.fromString(n.toString());
                        break;
                    case "padding":
                        n = Si.parse(n);
                        break;
                    default:
                        xt(n) === t.type || t.type === "enum" && t.values[n] || (n = void 0)
                    }
                    return ls(n, r.default, t.default)
                }
                Er.register(Ls, {
                    error: [{
                        kind: "error"
                    }, [Ge], (r, [t]) => {
                        throw new Xt(t.evaluate(r))
                    }
                    ],
                    typeof: [Ge, [Je], (r, [t]) => zt(hi(t.evaluate(r)))],
                    "to-rgba": [Qi(Ae, 4), [at], (r, [t]) => {
                        const [n,s,c,d] = t.evaluate(r).rgb;
                        return [255 * n, 255 * s, 255 * c, d]
                    }
                    ],
                    rgb: [at, [Ae, Ae, Ae], Fc],
                    rgba: [at, [Ae, Ae, Ae, Ae], Fc],
                    has: {
                        type: Ze,
                        overloads: [[[Ge], (r, [t]) => Bc(t.evaluate(r), r.properties())], [[Ge, lt], (r, [t,n]) => Bc(t.evaluate(r), n.evaluate(r))]]
                    },
                    get: {
                        type: Je,
                        overloads: [[[Ge], (r, [t]) => fl(t.evaluate(r), r.properties())], [[Ge, lt], (r, [t,n]) => fl(t.evaluate(r), n.evaluate(r))]]
                    },
                    "feature-state": [Je, [Ge], (r, [t]) => fl(t.evaluate(r), r.featureState || {})],
                    properties: [lt, [], r => r.properties()],
                    "geometry-type": [Ge, [], r => r.geometryType()],
                    id: [Je, [], r => r.id()],
                    zoom: [Ae, [], r => r.globals.zoom],
                    "heatmap-density": [Ae, [], r => r.globals.heatmapDensity || 0],
                    "line-progress": [Ae, [], r => r.globals.lineProgress || 0],
                    accumulated: [Je, [], r => r.globals.accumulated === void 0 ? null : r.globals.accumulated],
                    "+": [Ae, as(Ae), (r, t) => {
                        let n = 0;
                        for (const s of t)
                            n += s.evaluate(r);
                        return n
                    }
                    ],
                    "*": [Ae, as(Ae), (r, t) => {
                        let n = 1;
                        for (const s of t)
                            n *= s.evaluate(r);
                        return n
                    }
                    ],
                    "-": {
                        type: Ae,
                        overloads: [[[Ae, Ae], (r, [t,n]) => t.evaluate(r) - n.evaluate(r)], [[Ae], (r, [t]) => -t.evaluate(r)]]
                    },
                    "/": [Ae, [Ae, Ae], (r, [t,n]) => t.evaluate(r) / n.evaluate(r)],
                    "%": [Ae, [Ae, Ae], (r, [t,n]) => t.evaluate(r) % n.evaluate(r)],
                    ln2: [Ae, [], () => Math.LN2],
                    pi: [Ae, [], () => Math.PI],
                    e: [Ae, [], () => Math.E],
                    "^": [Ae, [Ae, Ae], (r, [t,n]) => Math.pow(t.evaluate(r), n.evaluate(r))],
                    sqrt: [Ae, [Ae], (r, [t]) => Math.sqrt(t.evaluate(r))],
                    log10: [Ae, [Ae], (r, [t]) => Math.log(t.evaluate(r)) / Math.LN10],
                    ln: [Ae, [Ae], (r, [t]) => Math.log(t.evaluate(r))],
                    log2: [Ae, [Ae], (r, [t]) => Math.log(t.evaluate(r)) / Math.LN2],
                    sin: [Ae, [Ae], (r, [t]) => Math.sin(t.evaluate(r))],
                    cos: [Ae, [Ae], (r, [t]) => Math.cos(t.evaluate(r))],
                    tan: [Ae, [Ae], (r, [t]) => Math.tan(t.evaluate(r))],
                    asin: [Ae, [Ae], (r, [t]) => Math.asin(t.evaluate(r))],
                    acos: [Ae, [Ae], (r, [t]) => Math.acos(t.evaluate(r))],
                    atan: [Ae, [Ae], (r, [t]) => Math.atan(t.evaluate(r))],
                    min: [Ae, as(Ae), (r, t) => Math.min(...t.map(n => n.evaluate(r)))],
                    max: [Ae, as(Ae), (r, t) => Math.max(...t.map(n => n.evaluate(r)))],
                    abs: [Ae, [Ae], (r, [t]) => Math.abs(t.evaluate(r))],
                    round: [Ae, [Ae], (r, [t]) => {
                        const n = t.evaluate(r);
                        return n < 0 ? -Math.round(-n) : Math.round(n)
                    }
                    ],
                    floor: [Ae, [Ae], (r, [t]) => Math.floor(t.evaluate(r))],
                    ceil: [Ae, [Ae], (r, [t]) => Math.ceil(t.evaluate(r))],
                    "filter-==": [Ze, [Ge, Je], (r, [t,n]) => r.properties()[t.value] === n.value],
                    "filter-id-==": [Ze, [Je], (r, [t]) => r.id() === t.value],
                    "filter-type-==": [Ze, [Ge], (r, [t]) => r.geometryType() === t.value],
                    "filter-<": [Ze, [Ge, Je], (r, [t,n]) => {
                        const s = r.properties()[t.value]
                          , c = n.value;
                        return typeof s == typeof c && s < c
                    }
                    ],
                    "filter-id-<": [Ze, [Je], (r, [t]) => {
                        const n = r.id()
                          , s = t.value;
                        return typeof n == typeof s && n < s
                    }
                    ],
                    "filter->": [Ze, [Ge, Je], (r, [t,n]) => {
                        const s = r.properties()[t.value]
                          , c = n.value;
                        return typeof s == typeof c && s > c
                    }
                    ],
                    "filter-id->": [Ze, [Je], (r, [t]) => {
                        const n = r.id()
                          , s = t.value;
                        return typeof n == typeof s && n > s
                    }
                    ],
                    "filter-<=": [Ze, [Ge, Je], (r, [t,n]) => {
                        const s = r.properties()[t.value]
                          , c = n.value;
                        return typeof s == typeof c && s <= c
                    }
                    ],
                    "filter-id-<=": [Ze, [Je], (r, [t]) => {
                        const n = r.id()
                          , s = t.value;
                        return typeof n == typeof s && n <= s
                    }
                    ],
                    "filter->=": [Ze, [Ge, Je], (r, [t,n]) => {
                        const s = r.properties()[t.value]
                          , c = n.value;
                        return typeof s == typeof c && s >= c
                    }
                    ],
                    "filter-id->=": [Ze, [Je], (r, [t]) => {
                        const n = r.id()
                          , s = t.value;
                        return typeof n == typeof s && n >= s
                    }
                    ],
                    "filter-has": [Ze, [Je], (r, [t]) => t.value in r.properties()],
                    "filter-has-id": [Ze, [], r => r.id() !== null && r.id() !== void 0],
                    "filter-type-in": [Ze, [Qi(Ge)], (r, [t]) => t.value.indexOf(r.geometryType()) >= 0],
                    "filter-id-in": [Ze, [Qi(Je)], (r, [t]) => t.value.indexOf(r.id()) >= 0],
                    "filter-in-small": [Ze, [Ge, Qi(Je)], (r, [t,n]) => n.value.indexOf(r.properties()[t.value]) >= 0],
                    "filter-in-large": [Ze, [Ge, Qi(Je)], (r, [t,n]) => function(s, c, d, p) {
                        for (; d <= p; ) {
                            const g = d + p >> 1;
                            if (c[g] === s)
                                return !0;
                            c[g] > s ? p = g - 1 : d = g + 1
                        }
                        return !1
                    }(r.properties()[t.value], n.value, 0, n.value.length - 1)],
                    all: {
                        type: Ze,
                        overloads: [[[Ze, Ze], (r, [t,n]) => t.evaluate(r) && n.evaluate(r)], [as(Ze), (r, t) => {
                            for (const n of t)
                                if (!n.evaluate(r))
                                    return !1;
                            return !0
                        }
                        ]]
                    },
                    any: {
                        type: Ze,
                        overloads: [[[Ze, Ze], (r, [t,n]) => t.evaluate(r) || n.evaluate(r)], [as(Ze), (r, t) => {
                            for (const n of t)
                                if (n.evaluate(r))
                                    return !0;
                            return !1
                        }
                        ]]
                    },
                    "!": [Ze, [Ze], (r, [t]) => !t.evaluate(r)],
                    "is-supported-script": [Ze, [Ge], (r, [t]) => {
                        const n = r.globals && r.globals.isSupportedScript;
                        return !n || n(t.evaluate(r))
                    }
                    ],
                    upcase: [Ge, [Ge], (r, [t]) => t.evaluate(r).toUpperCase()],
                    downcase: [Ge, [Ge], (r, [t]) => t.evaluate(r).toLowerCase()],
                    concat: [Ge, as(Je), (r, t) => t.map(n => Fn(n.evaluate(r))).join("")],
                    "resolved-locale": [Ge, [Qn], (r, [t]) => t.evaluate(r).resolvedLocale()]
                });
                class gl {
                    constructor(t, n) {
                        var s;
                        this.expression = t,
                        this._warningHistory = {},
                        this._evaluator = new Ro,
                        this._defaultValue = n ? (s = n).type === "color" && ea(s.default) ? new yt(0,0,0,0) : s.type === "color" ? yt.parse(s.default) || null : s.type === "padding" ? Si.parse(s.default) || null : s.type === "variableAnchorOffsetCollection" ? Ii.parse(s.default) || null : s.type === "projectionDefinition" ? er.parse(s.default) || null : s.default === void 0 ? null : s.default : null,
                        this._enumValues = n && n.type === "enum" ? n.values : null
                    }
                    evaluateWithoutErrorHandling(t, n, s, c, d, p) {
                        return this._evaluator.globals = t,
                        this._evaluator.feature = n,
                        this._evaluator.featureState = s,
                        this._evaluator.canonical = c,
                        this._evaluator.availableImages = d || null,
                        this._evaluator.formattedSection = p,
                        this.expression.evaluate(this._evaluator)
                    }
                    evaluate(t, n, s, c, d, p) {
                        this._evaluator.globals = t,
                        this._evaluator.feature = n || null,
                        this._evaluator.featureState = s || null,
                        this._evaluator.canonical = c,
                        this._evaluator.availableImages = d || null,
                        this._evaluator.formattedSection = p || null;
                        try {
                            const g = this.expression.evaluate(this._evaluator);
                            if (g == null || typeof g == "number" && g != g)
                                return this._defaultValue;
                            if (this._enumValues && !(g in this._enumValues))
                                throw new Xt(`Expected value to be one of ${Object.keys(this._enumValues).map(x => JSON.stringify(x)).join(", ")}, but found ${JSON.stringify(g)} instead.`);
                            return g
                        } catch (g) {
                            return this._warningHistory[g.message] || (this._warningHistory[g.message] = !0,
                            typeof console < "u" && console.warn(g.message)),
                            this._defaultValue
                        }
                    }
                }
                function ta(r) {
                    return Array.isArray(r) && r.length > 0 && typeof r[0] == "string" && r[0]in Ls
                }
                function cs(r, t) {
                    const n = new pt(Ls,Jo,[],t ? function(c) {
                        const d = {
                            color: at,
                            string: Ge,
                            number: Ae,
                            enum: Ge,
                            boolean: Ze,
                            formatted: ui,
                            padding: xi,
                            projectionDefinition: it,
                            resolvedImage: Bt,
                            variableAnchorOffsetCollection: zo
                        };
                        return c.type === "array" ? Qi(d[c.value] || Je, c.length) : d[c.type]
                    }(t) : void 0)
                      , s = n.parse(r, void 0, void 0, void 0, t && t.type === "string" ? {
                        typeAnnotation: "coerce"
                    } : void 0);
                    return s ? Oc(new gl(s,t)) : Ds(n.errors)
                }
                class ia {
                    constructor(t, n) {
                        this.kind = t,
                        this._styleExpression = n,
                        this.isStateDependent = t !== "constant" && !ho(n.expression)
                    }
                    evaluateWithoutErrorHandling(t, n, s, c, d, p) {
                        return this._styleExpression.evaluateWithoutErrorHandling(t, n, s, c, d, p)
                    }
                    evaluate(t, n, s, c, d, p) {
                        return this._styleExpression.evaluate(t, n, s, c, d, p)
                    }
                }
                class _l {
                    constructor(t, n, s, c) {
                        this.kind = t,
                        this.zoomStops = s,
                        this._styleExpression = n,
                        this.isStateDependent = t !== "camera" && !ho(n.expression),
                        this.interpolationType = c
                    }
                    evaluateWithoutErrorHandling(t, n, s, c, d, p) {
                        return this._styleExpression.evaluateWithoutErrorHandling(t, n, s, c, d, p)
                    }
                    evaluate(t, n, s, c, d, p) {
                        return this._styleExpression.evaluate(t, n, s, c, d, p)
                    }
                    interpolationFactor(t, n, s) {
                        return this.interpolationType ? Zi.interpolationFactor(this.interpolationType, t, n, s) : 0
                    }
                }
                function Zc(r, t) {
                    const n = cs(r, t);
                    if (n.result === "error")
                        return n;
                    const s = n.value.expression
                      , c = Yo(s);
                    if (!c && !Rs(t))
                        return Ds([new We("","data expressions not supported")]);
                    const d = Qo(s, ["zoom"]);
                    if (!d && !Nc(t))
                        return Ds([new We("","zoom expressions not supported")]);
                    const p = na(s);
                    return p || d ? p instanceof We ? Ds([p]) : p instanceof Zi && !ml(t) ? Ds([new We("",'"interpolate" expressions cannot be used with this property')]) : Oc(p ? new _l(c ? "camera" : "composite",n.value,p.labels,p instanceof Zi ? p.interpolation : void 0) : new ia(c ? "constant" : "source",n.value)) : Ds([new We("",'"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.')])
                }
                class ra {
                    constructor(t, n) {
                        this._parameters = t,
                        this._specification = n,
                        je(this, jc(this._parameters, this._specification))
                    }
                    static deserialize(t) {
                        return new ra(t._parameters,t._specification)
                    }
                    static serialize(t) {
                        return {
                            _parameters: t._parameters,
                            _specification: t._specification
                        }
                    }
                }
                function na(r) {
                    let t = null;
                    if (r instanceof ot)
                        t = na(r.result);
                    else if (r instanceof ai) {
                        for (const n of r.args)
                            if (t = na(n),
                            t)
                                break
                    } else
                        (r instanceof zs || r instanceof Zi) && r.input instanceof Er && r.input.name === "zoom" && (t = r);
                    return t instanceof We || r.eachChild(n => {
                        const s = na(n);
                        s instanceof We ? t = s : !t && s ? t = new We("",'"zoom" expression may only be used as input to a top-level "step" or "interpolate" expression.') : t && s && t !== s && (t = new We("",'Only one zoom-based "step" or "interpolate" subexpression may be used in an expression.'))
                    }
                    ),
                    t
                }
                function yl(r) {
                    if (r === !0 || r === !1)
                        return !0;
                    if (!Array.isArray(r) || r.length === 0)
                        return !1;
                    switch (r[0]) {
                    case "has":
                        return r.length >= 2 && r[1] !== "$id" && r[1] !== "$type";
                    case "in":
                        return r.length >= 3 && (typeof r[1] != "string" || Array.isArray(r[2]));
                    case "!in":
                    case "!has":
                    case "none":
                        return !1;
                    case "==":
                    case "!=":
                    case ">":
                    case ">=":
                    case "<":
                    case "<=":
                        return r.length !== 3 || Array.isArray(r[1]) || Array.isArray(r[2]);
                    case "any":
                    case "all":
                        for (const t of r.slice(1))
                            if (!yl(t) && typeof t != "boolean")
                                return !1;
                        return !0;
                    default:
                        return !0
                    }
                }
                const Gc = {
                    type: "boolean",
                    default: !1,
                    transition: !1,
                    "property-type": "data-driven",
                    expression: {
                        interpolated: !1,
                        parameters: ["zoom", "feature"]
                    }
                };
                function sa(r) {
                    if (r == null)
                        return {
                            filter: () => !0,
                            needGeometry: !1
                        };
                    yl(r) || (r = po(r));
                    const t = cs(r, Gc);
                    if (t.result === "error")
                        throw new Error(t.value.map(n => `${n.key}: ${n.message}`).join(", "));
                    return {
                        filter: (n, s, c) => t.value.evaluate(n, s, {}, c),
                        needGeometry: $c(r)
                    }
                }
                function mh(r, t) {
                    return r < t ? -1 : r > t ? 1 : 0
                }
                function $c(r) {
                    if (!Array.isArray(r))
                        return !1;
                    if (r[0] === "within" || r[0] === "distance")
                        return !0;
                    for (let t = 1; t < r.length; t++)
                        if ($c(r[t]))
                            return !0;
                    return !1
                }
                function po(r) {
                    if (!r)
                        return !0;
                    const t = r[0];
                    return r.length <= 1 ? t !== "any" : t === "==" ? oa(r[1], r[2], "==") : t === "!=" ? Fs(oa(r[1], r[2], "==")) : t === "<" || t === ">" || t === "<=" || t === ">=" ? oa(r[1], r[2], t) : t === "any" ? (n = r.slice(1),
                    ["any"].concat(n.map(po))) : t === "all" ? ["all"].concat(r.slice(1).map(po)) : t === "none" ? ["all"].concat(r.slice(1).map(po).map(Fs)) : t === "in" ? xl(r[1], r.slice(2)) : t === "!in" ? Fs(xl(r[1], r.slice(2))) : t === "has" ? vl(r[1]) : t !== "!has" || Fs(vl(r[1]));
                    var n
                }
                function oa(r, t, n) {
                    switch (r) {
                    case "$type":
                        return [`filter-type-${n}`, t];
                    case "$id":
                        return [`filter-id-${n}`, t];
                    default:
                        return [`filter-${n}`, r, t]
                    }
                }
                function xl(r, t) {
                    if (t.length === 0)
                        return !1;
                    switch (r) {
                    case "$type":
                        return ["filter-type-in", ["literal", t]];
                    case "$id":
                        return ["filter-id-in", ["literal", t]];
                    default:
                        return t.length > 200 && !t.some(n => typeof n != typeof t[0]) ? ["filter-in-large", r, ["literal", t.sort(mh)]] : ["filter-in-small", r, ["literal", t]]
                    }
                }
                function vl(r) {
                    switch (r) {
                    case "$type":
                        return !0;
                    case "$id":
                        return ["filter-has-id"];
                    default:
                        return ["filter-has", r]
                    }
                }
                function Fs(r) {
                    return ["!", r]
                }
                function fo(r) {
                    const t = typeof r;
                    if (t === "number" || t === "boolean" || t === "string" || r == null)
                        return JSON.stringify(r);
                    if (Array.isArray(r)) {
                        let c = "[";
                        for (const d of r)
                            c += `${fo(d)},`;
                        return `${c}]`
                    }
                    const n = Object.keys(r).sort();
                    let s = "{";
                    for (let c = 0; c < n.length; c++)
                        s += `${JSON.stringify(n[c])}:${fo(r[n[c]])},`;
                    return `${s}}`
                }
                function bl(r) {
                    let t = "";
                    for (const n of U)
                        t += `/${fo(r[n])}`;
                    return t
                }
                function mo(r) {
                    const t = r.value;
                    return t ? [new me(r.key,t,"constants have been deprecated as of v8")] : []
                }
                function ri(r) {
                    return r instanceof Number || r instanceof String || r instanceof Boolean ? r.valueOf() : r
                }
                function us(r) {
                    if (Array.isArray(r))
                        return r.map(us);
                    if (r instanceof Object && !(r instanceof Number || r instanceof String || r instanceof Boolean)) {
                        const t = {};
                        for (const n in r)
                            t[n] = us(r[n]);
                        return t
                    }
                    return ri(r)
                }
                function Ar(r) {
                    const t = r.key
                      , n = r.value
                      , s = r.valueSpec || {}
                      , c = r.objectElementValidators || {}
                      , d = r.style
                      , p = r.styleSpec
                      , g = r.validateSpec;
                    let x = [];
                    const b = xt(n);
                    if (b !== "object")
                        return [new me(t,n,`object expected, ${b} found`)];
                    for (const C in n) {
                        const P = C.split(".")[0]
                          , D = s[P] || s["*"];
                        let F;
                        if (c[P])
                            F = c[P];
                        else if (s[P])
                            F = g;
                        else if (c["*"])
                            F = c["*"];
                        else {
                            if (!s["*"]) {
                                x.push(new me(t,n[C],`unknown property "${C}"`));
                                continue
                            }
                            F = g
                        }
                        x = x.concat(F({
                            key: (t && `${t}.`) + C,
                            value: n[C],
                            valueSpec: D,
                            style: d,
                            styleSpec: p,
                            object: n,
                            objectKey: C,
                            validateSpec: g
                        }, n))
                    }
                    for (const C in s)
                        c[C] || s[C].required && s[C].default === void 0 && n[C] === void 0 && x.push(new me(t,n,`missing required property "${C}"`));
                    return x
                }
                function wl(r) {
                    const t = r.value
                      , n = r.valueSpec
                      , s = r.style
                      , c = r.styleSpec
                      , d = r.key
                      , p = r.arrayElementValidator || r.validateSpec;
                    if (xt(t) !== "array")
                        return [new me(d,t,`array expected, ${xt(t)} found`)];
                    if (n.length && t.length !== n.length)
                        return [new me(d,t,`array length ${n.length} expected, length ${t.length} found`)];
                    if (n["min-length"] && t.length < n["min-length"])
                        return [new me(d,t,`array length at least ${n["min-length"]} expected, length ${t.length} found`)];
                    let g = {
                        type: n.value,
                        values: n.values
                    };
                    c.$version < 7 && (g.function = n.function),
                    xt(n.value) === "object" && (g = n.value);
                    let x = [];
                    for (let b = 0; b < t.length; b++)
                        x = x.concat(p({
                            array: t,
                            arrayIndex: b,
                            value: t[b],
                            valueSpec: g,
                            validateSpec: r.validateSpec,
                            style: s,
                            styleSpec: c,
                            key: `${d}[${b}]`
                        }));
                    return x
                }
                function Tl(r) {
                    const t = r.key
                      , n = r.value
                      , s = r.valueSpec;
                    let c = xt(n);
                    return c === "number" && n != n && (c = "NaN"),
                    c !== "number" ? [new me(t,n,`number expected, ${c} found`)] : "minimum"in s && n < s.minimum ? [new me(t,n,`${n} is less than the minimum value ${s.minimum}`)] : "maximum"in s && n > s.maximum ? [new me(t,n,`${n} is greater than the maximum value ${s.maximum}`)] : []
                }
                function qc(r) {
                    const t = r.valueSpec
                      , n = ri(r.value.type);
                    let s, c, d, p = {};
                    const g = n !== "categorical" && r.value.property === void 0
                      , x = !g
                      , b = xt(r.value.stops) === "array" && xt(r.value.stops[0]) === "array" && xt(r.value.stops[0][0]) === "object"
                      , C = Ar({
                        key: r.key,
                        value: r.value,
                        valueSpec: r.styleSpec.function,
                        validateSpec: r.validateSpec,
                        style: r.style,
                        styleSpec: r.styleSpec,
                        objectElementValidators: {
                            stops: function(F) {
                                if (n === "identity")
                                    return [new me(F.key,F.value,'identity function may not have a "stops" property')];
                                let B = [];
                                const j = F.value;
                                return B = B.concat(wl({
                                    key: F.key,
                                    value: j,
                                    valueSpec: F.valueSpec,
                                    validateSpec: F.validateSpec,
                                    style: F.style,
                                    styleSpec: F.styleSpec,
                                    arrayElementValidator: P
                                })),
                                xt(j) === "array" && j.length === 0 && B.push(new me(F.key,j,"array must have at least one stop")),
                                B
                            },
                            default: function(F) {
                                return F.validateSpec({
                                    key: F.key,
                                    value: F.value,
                                    valueSpec: t,
                                    validateSpec: F.validateSpec,
                                    style: F.style,
                                    styleSpec: F.styleSpec
                                })
                            }
                        }
                    });
                    return n === "identity" && g && C.push(new me(r.key,r.value,'missing required property "property"')),
                    n === "identity" || r.value.stops || C.push(new me(r.key,r.value,'missing required property "stops"')),
                    n === "exponential" && r.valueSpec.expression && !ml(r.valueSpec) && C.push(new me(r.key,r.value,"exponential functions not supported")),
                    r.styleSpec.$version >= 8 && (x && !Rs(r.valueSpec) ? C.push(new me(r.key,r.value,"property functions not supported")) : g && !Nc(r.valueSpec) && C.push(new me(r.key,r.value,"zoom functions not supported"))),
                    n !== "categorical" && !b || r.value.property !== void 0 || C.push(new me(r.key,r.value,'"property" property is required')),
                    C;
                    function P(F) {
                        let B = [];
                        const j = F.value
                          , G = F.key;
                        if (xt(j) !== "array")
                            return [new me(G,j,`array expected, ${xt(j)} found`)];
                        if (j.length !== 2)
                            return [new me(G,j,`array length 2 expected, length ${j.length} found`)];
                        if (b) {
                            if (xt(j[0]) !== "object")
                                return [new me(G,j,`object expected, ${xt(j[0])} found`)];
                            if (j[0].zoom === void 0)
                                return [new me(G,j,"object stop key must have zoom")];
                            if (j[0].value === void 0)
                                return [new me(G,j,"object stop key must have value")];
                            if (d && d > ri(j[0].zoom))
                                return [new me(G,j[0].zoom,"stop zoom values must appear in ascending order")];
                            ri(j[0].zoom) !== d && (d = ri(j[0].zoom),
                            c = void 0,
                            p = {}),
                            B = B.concat(Ar({
                                key: `${G}[0]`,
                                value: j[0],
                                valueSpec: {
                                    zoom: {}
                                },
                                validateSpec: F.validateSpec,
                                style: F.style,
                                styleSpec: F.styleSpec,
                                objectElementValidators: {
                                    zoom: Tl,
                                    value: D
                                }
                            }))
                        } else
                            B = B.concat(D({
                                key: `${G}[0]`,
                                value: j[0],
                                validateSpec: F.validateSpec,
                                style: F.style,
                                styleSpec: F.styleSpec
                            }, j));
                        return ta(us(j[1])) ? B.concat([new me(`${G}[1]`,j[1],"expressions are not allowed in function stops.")]) : B.concat(F.validateSpec({
                            key: `${G}[1]`,
                            value: j[1],
                            valueSpec: t,
                            validateSpec: F.validateSpec,
                            style: F.style,
                            styleSpec: F.styleSpec
                        }))
                    }
                    function D(F, B) {
                        const j = xt(F.value)
                          , G = ri(F.value)
                          , X = F.value !== null ? F.value : B;
                        if (s) {
                            if (j !== s)
                                return [new me(F.key,X,`${j} stop domain type must match previous stop domain type ${s}`)]
                        } else
                            s = j;
                        if (j !== "number" && j !== "string" && j !== "boolean")
                            return [new me(F.key,X,"stop domain value must be a number, string, or boolean")];
                        if (j !== "number" && n !== "categorical") {
                            let ae = `number expected, ${j} found`;
                            return Rs(t) && n === void 0 && (ae += '\nIf you intended to use a categorical function, specify `"type": "categorical"`.'),
                            [new me(F.key,X,ae)]
                        }
                        return n !== "categorical" || j !== "number" || isFinite(G) && Math.floor(G) === G ? n !== "categorical" && j === "number" && c !== void 0 && G < c ? [new me(F.key,X,"stop domain values must appear in ascending order")] : (c = G,
                        n === "categorical" && G in p ? [new me(F.key,X,"stop domain values must be unique")] : (p[G] = !0,
                        [])) : [new me(F.key,X,`integer expected, found ${G}`)]
                    }
                }
                function hs(r) {
                    const t = (r.expressionContext === "property" ? Zc : cs)(us(r.value), r.valueSpec);
                    if (t.result === "error")
                        return t.value.map(s => new me(`${r.key}${s.key}`,r.value,s.message));
                    const n = t.value.expression || t.value._styleExpression.expression;
                    if (r.expressionContext === "property" && r.propertyKey === "text-font" && !n.outputDefined())
                        return [new me(r.key,r.value,`Invalid data expression for "${r.propertyKey}". Output values must be contained as literals within the expression.`)];
                    if (r.expressionContext === "property" && r.propertyType === "layout" && !ho(n))
                        return [new me(r.key,r.value,'"feature-state" data expressions are not supported with layout properties.')];
                    if (r.expressionContext === "filter" && !ho(n))
                        return [new me(r.key,r.value,'"feature-state" data expressions are not supported with filters.')];
                    if (r.expressionContext && r.expressionContext.indexOf("cluster") === 0) {
                        if (!Qo(n, ["zoom", "feature-state"]))
                            return [new me(r.key,r.value,'"zoom" and "feature-state" expressions are not supported with cluster properties.')];
                        if (r.expressionContext === "cluster-initial" && !Yo(n))
                            return [new me(r.key,r.value,"Feature data expressions are not supported with initial expression part of cluster properties.")]
                    }
                    return []
                }
                function Bs(r) {
                    const t = r.key
                      , n = r.value
                      , s = r.valueSpec
                      , c = [];
                    return Array.isArray(s.values) ? s.values.indexOf(ri(n)) === -1 && c.push(new me(t,n,`expected one of [${s.values.join(", ")}], ${JSON.stringify(n)} found`)) : Object.keys(s.values).indexOf(ri(n)) === -1 && c.push(new me(t,n,`expected one of [${Object.keys(s.values).join(", ")}], ${JSON.stringify(n)} found`)),
                    c
                }
                function Os(r) {
                    return yl(us(r.value)) ? hs(je({}, r, {
                        expressionContext: "filter",
                        valueSpec: {
                            value: "boolean"
                        }
                    })) : Hc(r)
                }
                function Hc(r) {
                    const t = r.value
                      , n = r.key;
                    if (xt(t) !== "array")
                        return [new me(n,t,`array expected, ${xt(t)} found`)];
                    const s = r.styleSpec;
                    let c, d = [];
                    if (t.length < 1)
                        return [new me(n,t,"filter array must have at least 1 element")];
                    switch (d = d.concat(Bs({
                        key: `${n}[0]`,
                        value: t[0],
                        valueSpec: s.filter_operator,
                        style: r.style,
                        styleSpec: r.styleSpec
                    })),
                    ri(t[0])) {
                    case "<":
                    case "<=":
                    case ">":
                    case ">=":
                        t.length >= 2 && ri(t[1]) === "$type" && d.push(new me(n,t,`"$type" cannot be use with operator "${t[0]}"`));
                    case "==":
                    case "!=":
                        t.length !== 3 && d.push(new me(n,t,`filter array for operator "${t[0]}" must have 3 elements`));
                    case "in":
                    case "!in":
                        t.length >= 2 && (c = xt(t[1]),
                        c !== "string" && d.push(new me(`${n}[1]`,t[1],`string expected, ${c} found`)));
                        for (let p = 2; p < t.length; p++)
                            c = xt(t[p]),
                            ri(t[1]) === "$type" ? d = d.concat(Bs({
                                key: `${n}[${p}]`,
                                value: t[p],
                                valueSpec: s.geometry_type,
                                style: r.style,
                                styleSpec: r.styleSpec
                            })) : c !== "string" && c !== "number" && c !== "boolean" && d.push(new me(`${n}[${p}]`,t[p],`string, number, or boolean expected, ${c} found`));
                        break;
                    case "any":
                    case "all":
                    case "none":
                        for (let p = 1; p < t.length; p++)
                            d = d.concat(Hc({
                                key: `${n}[${p}]`,
                                value: t[p],
                                style: r.style,
                                styleSpec: r.styleSpec
                            }));
                        break;
                    case "has":
                    case "!has":
                        c = xt(t[1]),
                        t.length !== 2 ? d.push(new me(n,t,`filter array for "${t[0]}" operator must have 2 elements`)) : c !== "string" && d.push(new me(`${n}[1]`,t[1],`string expected, ${c} found`))
                    }
                    return d
                }
                function Ml(r, t) {
                    const n = r.key
                      , s = r.validateSpec
                      , c = r.style
                      , d = r.styleSpec
                      , p = r.value
                      , g = r.objectKey
                      , x = d[`${t}_${r.layerType}`];
                    if (!x)
                        return [];
                    const b = g.match(/^(.*)-transition$/);
                    if (t === "paint" && b && x[b[1]] && x[b[1]].transition)
                        return s({
                            key: n,
                            value: p,
                            valueSpec: d.transition,
                            style: c,
                            styleSpec: d
                        });
                    const C = r.valueSpec || x[g];
                    if (!C)
                        return [new me(n,p,`unknown property "${g}"`)];
                    let P;
                    if (xt(p) === "string" && Rs(C) && !C.tokens && (P = /^{([^}]+)}$/.exec(p)))
                        return [new me(n,p,`"${g}" does not support interpolation syntax
Use an identity property function instead: \`{ "type": "identity", "property": ${JSON.stringify(P[1])} }\`.`)];
                    const D = [];
                    return r.layerType === "symbol" && (g === "text-field" && c && !c.glyphs && D.push(new me(n,p,'use of "text-field" requires a style "glyphs" property')),
                    g === "text-font" && ea(us(p)) && ri(p.type) === "identity" && D.push(new me(n,p,'"text-font" does not support identity functions'))),
                    D.concat(s({
                        key: r.key,
                        value: p,
                        valueSpec: C,
                        style: c,
                        styleSpec: d,
                        expressionContext: "property",
                        propertyType: t,
                        propertyKey: g
                    }))
                }
                function Cl(r) {
                    return Ml(r, "paint")
                }
                function Wc(r) {
                    return Ml(r, "layout")
                }
                function Pl(r) {
                    let t = [];
                    const n = r.value
                      , s = r.key
                      , c = r.style
                      , d = r.styleSpec;
                    n.type || n.ref || t.push(new me(s,n,'either "type" or "ref" is required'));
                    let p = ri(n.type);
                    const g = ri(n.ref);
                    if (n.id) {
                        const x = ri(n.id);
                        for (let b = 0; b < r.arrayIndex; b++) {
                            const C = c.layers[b];
                            ri(C.id) === x && t.push(new me(s,n.id,`duplicate layer id "${n.id}", previously used at line ${C.id.__line__}`))
                        }
                    }
                    if ("ref"in n) {
                        let x;
                        ["type", "source", "source-layer", "filter", "layout"].forEach(b => {
                            b in n && t.push(new me(s,n[b],`"${b}" is prohibited for ref layers`))
                        }
                        ),
                        c.layers.forEach(b => {
                            ri(b.id) === g && (x = b)
                        }
                        ),
                        x ? x.ref ? t.push(new me(s,n.ref,"ref cannot reference another ref layer")) : p = ri(x.type) : t.push(new me(s,n.ref,`ref layer "${g}" not found`))
                    } else if (p !== "background")
                        if (n.source) {
                            const x = c.sources && c.sources[n.source]
                              , b = x && ri(x.type);
                            x ? b === "vector" && p === "raster" ? t.push(new me(s,n.source,`layer "${n.id}" requires a raster source`)) : b !== "raster-dem" && p === "hillshade" ? t.push(new me(s,n.source,`layer "${n.id}" requires a raster-dem source`)) : b === "raster" && p !== "raster" ? t.push(new me(s,n.source,`layer "${n.id}" requires a vector source`)) : b !== "vector" || n["source-layer"] ? b === "raster-dem" && p !== "hillshade" ? t.push(new me(s,n.source,"raster-dem source can only be used with layer type 'hillshade'.")) : p !== "line" || !n.paint || !n.paint["line-gradient"] || b === "geojson" && x.lineMetrics || t.push(new me(s,n,`layer "${n.id}" specifies a line-gradient, which requires a GeoJSON source with \`lineMetrics\` enabled.`)) : t.push(new me(s,n,`layer "${n.id}" must specify a "source-layer"`)) : t.push(new me(s,n.source,`source "${n.source}" not found`))
                        } else
                            t.push(new me(s,n,'missing required property "source"'));
                    return t = t.concat(Ar({
                        key: s,
                        value: n,
                        valueSpec: d.layer,
                        style: r.style,
                        styleSpec: r.styleSpec,
                        validateSpec: r.validateSpec,
                        objectElementValidators: {
                            "*": () => [],
                            type: () => r.validateSpec({
                                key: `${s}.type`,
                                value: n.type,
                                valueSpec: d.layer.type,
                                style: r.style,
                                styleSpec: r.styleSpec,
                                validateSpec: r.validateSpec,
                                object: n,
                                objectKey: "type"
                            }),
                            filter: Os,
                            layout: x => Ar({
                                layer: n,
                                key: x.key,
                                value: x.value,
                                style: x.style,
                                styleSpec: x.styleSpec,
                                validateSpec: x.validateSpec,
                                objectElementValidators: {
                                    "*": b => Wc(je({
                                        layerType: p
                                    }, b))
                                }
                            }),
                            paint: x => Ar({
                                layer: n,
                                key: x.key,
                                value: x.value,
                                style: x.style,
                                styleSpec: x.styleSpec,
                                validateSpec: x.validateSpec,
                                objectElementValidators: {
                                    "*": b => Cl(je({
                                        layerType: p
                                    }, b))
                                }
                            })
                        }
                    })),
                    t
                }
                function On(r) {
                    const t = r.value
                      , n = r.key
                      , s = xt(t);
                    return s !== "string" ? [new me(n,t,`string expected, ${s} found`)] : []
                }
                const Ns = {
                    promoteId: function({key: r, value: t}) {
                        if (xt(t) === "string")
                            return On({
                                key: r,
                                value: t
                            });
                        {
                            const n = [];
                            for (const s in t)
                                n.push(...On({
                                    key: `${r}.${s}`,
                                    value: t[s]
                                }));
                            return n
                        }
                    }
                };
                function Xc(r) {
                    const t = r.value
                      , n = r.key
                      , s = r.styleSpec
                      , c = r.style
                      , d = r.validateSpec;
                    if (!t.type)
                        return [new me(n,t,'"type" is required')];
                    const p = ri(t.type);
                    let g;
                    switch (p) {
                    case "vector":
                    case "raster":
                        return g = Ar({
                            key: n,
                            value: t,
                            valueSpec: s[`source_${p.replace("-", "_")}`],
                            style: r.style,
                            styleSpec: s,
                            objectElementValidators: Ns,
                            validateSpec: d
                        }),
                        g;
                    case "raster-dem":
                        return g = function(x) {
                            var b;
                            const C = (b = x.sourceName) !== null && b !== void 0 ? b : ""
                              , P = x.value
                              , D = x.styleSpec
                              , F = D.source_raster_dem
                              , B = x.style;
                            let j = [];
                            const G = xt(P);
                            if (P === void 0)
                                return j;
                            if (G !== "object")
                                return j.push(new me("source_raster_dem",P,`object expected, ${G} found`)),
                                j;
                            const X = ri(P.encoding) === "custom"
                              , ae = ["redFactor", "greenFactor", "blueFactor", "baseShift"]
                              , Q = x.value.encoding ? `"${x.value.encoding}"` : "Default";
                            for (const R in P)
                                !X && ae.includes(R) ? j.push(new me(R,P[R],`In "${C}": "${R}" is only valid when "encoding" is set to "custom". ${Q} encoding found`)) : F[R] ? j = j.concat(x.validateSpec({
                                    key: R,
                                    value: P[R],
                                    valueSpec: F[R],
                                    validateSpec: x.validateSpec,
                                    style: B,
                                    styleSpec: D
                                })) : j.push(new me(R,P[R],`unknown property "${R}"`));
                            return j
                        }({
                            sourceName: n,
                            value: t,
                            style: r.style,
                            styleSpec: s,
                            validateSpec: d
                        }),
                        g;
                    case "geojson":
                        if (g = Ar({
                            key: n,
                            value: t,
                            valueSpec: s.source_geojson,
                            style: c,
                            styleSpec: s,
                            validateSpec: d,
                            objectElementValidators: Ns
                        }),
                        t.cluster)
                            for (const x in t.clusterProperties) {
                                const [b,C] = t.clusterProperties[x]
                                  , P = typeof b == "string" ? [b, ["accumulated"], ["get", x]] : b;
                                g.push(...hs({
                                    key: `${n}.${x}.map`,
                                    value: C,
                                    expressionContext: "cluster-map"
                                })),
                                g.push(...hs({
                                    key: `${n}.${x}.reduce`,
                                    value: P,
                                    expressionContext: "cluster-reduce"
                                }))
                            }
                        return g;
                    case "video":
                        return Ar({
                            key: n,
                            value: t,
                            valueSpec: s.source_video,
                            style: c,
                            validateSpec: d,
                            styleSpec: s
                        });
                    case "image":
                        return Ar({
                            key: n,
                            value: t,
                            valueSpec: s.source_image,
                            style: c,
                            validateSpec: d,
                            styleSpec: s
                        });
                    case "canvas":
                        return [new me(n,null,"Please use runtime APIs to add canvas sources, rather than including them in stylesheets.","source.canvas")];
                    default:
                        return Bs({
                            key: `${n}.type`,
                            value: t.type,
                            valueSpec: {
                                values: ["vector", "raster", "raster-dem", "geojson", "video", "image"]
                            }
                        })
                    }
                }
                function Kc(r) {
                    const t = r.value
                      , n = r.styleSpec
                      , s = n.light
                      , c = r.style;
                    let d = [];
                    const p = xt(t);
                    if (t === void 0)
                        return d;
                    if (p !== "object")
                        return d = d.concat([new me("light",t,`object expected, ${p} found`)]),
                        d;
                    for (const g in t) {
                        const x = g.match(/^(.*)-transition$/);
                        d = d.concat(x && s[x[1]] && s[x[1]].transition ? r.validateSpec({
                            key: g,
                            value: t[g],
                            valueSpec: n.transition,
                            validateSpec: r.validateSpec,
                            style: c,
                            styleSpec: n
                        }) : s[g] ? r.validateSpec({
                            key: g,
                            value: t[g],
                            valueSpec: s[g],
                            validateSpec: r.validateSpec,
                            style: c,
                            styleSpec: n
                        }) : [new me(g,t[g],`unknown property "${g}"`)])
                    }
                    return d
                }
                function Jc(r) {
                    const t = r.value
                      , n = r.styleSpec
                      , s = n.sky
                      , c = r.style
                      , d = xt(t);
                    if (t === void 0)
                        return [];
                    if (d !== "object")
                        return [new me("sky",t,`object expected, ${d} found`)];
                    let p = [];
                    for (const g in t)
                        p = p.concat(s[g] ? r.validateSpec({
                            key: g,
                            value: t[g],
                            valueSpec: s[g],
                            style: c,
                            styleSpec: n
                        }) : [new me(g,t[g],`unknown property "${g}"`)]);
                    return p
                }
                function Yc(r) {
                    const t = r.value
                      , n = r.styleSpec
                      , s = n.terrain
                      , c = r.style;
                    let d = [];
                    const p = xt(t);
                    if (t === void 0)
                        return d;
                    if (p !== "object")
                        return d = d.concat([new me("terrain",t,`object expected, ${p} found`)]),
                        d;
                    for (const g in t)
                        d = d.concat(s[g] ? r.validateSpec({
                            key: g,
                            value: t[g],
                            valueSpec: s[g],
                            validateSpec: r.validateSpec,
                            style: c,
                            styleSpec: n
                        }) : [new me(g,t[g],`unknown property "${g}"`)]);
                    return d
                }
                function Qc(r) {
                    let t = [];
                    const n = r.value
                      , s = r.key;
                    if (Array.isArray(n)) {
                        const c = []
                          , d = [];
                        for (const p in n)
                            n[p].id && c.includes(n[p].id) && t.push(new me(s,n,`all the sprites' ids must be unique, but ${n[p].id} is duplicated`)),
                            c.push(n[p].id),
                            n[p].url && d.includes(n[p].url) && t.push(new me(s,n,`all the sprites' URLs must be unique, but ${n[p].url} is duplicated`)),
                            d.push(n[p].url),
                            t = t.concat(Ar({
                                key: `${s}[${p}]`,
                                value: n[p],
                                valueSpec: {
                                    id: {
                                        type: "string",
                                        required: !0
                                    },
                                    url: {
                                        type: "string",
                                        required: !0
                                    }
                                },
                                validateSpec: r.validateSpec
                            }));
                        return t
                    }
                    return On({
                        key: s,
                        value: n
                    })
                }
                const eu = {
                    "*": () => [],
                    array: wl,
                    boolean: function(r) {
                        const t = r.value
                          , n = r.key
                          , s = xt(t);
                        return s !== "boolean" ? [new me(n,t,`boolean expected, ${s} found`)] : []
                    },
                    number: Tl,
                    color: function(r) {
                        const t = r.key
                          , n = r.value
                          , s = xt(n);
                        return s !== "string" ? [new me(t,n,`color expected, ${s} found`)] : yt.parse(String(n)) ? [] : [new me(t,n,`color expected, "${n}" found`)]
                    },
                    constants: mo,
                    enum: Bs,
                    filter: Os,
                    function: qc,
                    layer: Pl,
                    object: Ar,
                    source: Xc,
                    light: Kc,
                    sky: Jc,
                    terrain: Yc,
                    projection: function(r) {
                        const t = r.value
                          , n = r.styleSpec
                          , s = n.projection
                          , c = r.style
                          , d = xt(t);
                        if (t === void 0)
                            return [];
                        if (d !== "object")
                            return [new me("projection",t,`object expected, ${d} found`)];
                        let p = [];
                        for (const g in t)
                            p = p.concat(s[g] ? r.validateSpec({
                                key: g,
                                value: t[g],
                                valueSpec: s[g],
                                style: c,
                                styleSpec: n
                            }) : [new me(g,t[g],`unknown property "${g}"`)]);
                        return p
                    },
                    projectionDefinition: function(r) {
                        const t = r.key;
                        let n = r.value;
                        n = n instanceof String ? n.valueOf() : n;
                        const s = xt(n);
                        return s !== "array" || function(c) {
                            return Array.isArray(c) && c.length === 3 && typeof c[0] == "string" && typeof c[1] == "string" && typeof c[2] == "number"
                        }(n) || function(c) {
                            return !!["interpolate", "step", "literal"].includes(c[0])
                        }(n) ? ["array", "string"].includes(s) ? [] : [new me(t,n,`projection expected, invalid type "${s}" found`)] : [new me(t,n,`projection expected, invalid array ${JSON.stringify(n)} found`)]
                    },
                    string: On,
                    formatted: function(r) {
                        return On(r).length === 0 ? [] : hs(r)
                    },
                    resolvedImage: function(r) {
                        return On(r).length === 0 ? [] : hs(r)
                    },
                    padding: function(r) {
                        const t = r.key
                          , n = r.value;
                        if (xt(n) === "array") {
                            if (n.length < 1 || n.length > 4)
                                return [new me(t,n,`padding requires 1 to 4 values; ${n.length} values found`)];
                            const s = {
                                type: "number"
                            };
                            let c = [];
                            for (let d = 0; d < n.length; d++)
                                c = c.concat(r.validateSpec({
                                    key: `${t}[${d}]`,
                                    value: n[d],
                                    validateSpec: r.validateSpec,
                                    valueSpec: s
                                }));
                            return c
                        }
                        return Tl({
                            key: t,
                            value: n,
                            valueSpec: {}
                        })
                    },
                    variableAnchorOffsetCollection: function(r) {
                        const t = r.key
                          , n = r.value
                          , s = xt(n)
                          , c = r.styleSpec;
                        if (s !== "array" || n.length < 1 || n.length % 2 != 0)
                            return [new me(t,n,"variableAnchorOffsetCollection requires a non-empty array of even length")];
                        let d = [];
                        for (let p = 0; p < n.length; p += 2)
                            d = d.concat(Bs({
                                key: `${t}[${p}]`,
                                value: n[p],
                                valueSpec: c.layout_symbol["text-anchor"]
                            })),
                            d = d.concat(wl({
                                key: `${t}[${p + 1}]`,
                                value: n[p + 1],
                                valueSpec: {
                                    length: 2,
                                    value: "number"
                                },
                                validateSpec: r.validateSpec,
                                style: r.style,
                                styleSpec: c
                            }));
                        return d
                    },
                    sprite: Qc
                };
                function Nn(r) {
                    const t = r.value
                      , n = r.valueSpec
                      , s = r.styleSpec;
                    return r.validateSpec = Nn,
                    n.expression && ea(ri(t)) ? qc(r) : n.expression && ta(us(t)) ? hs(r) : n.type && eu[n.type] ? eu[n.type](r) : Ar(je({}, r, {
                        valueSpec: n.type ? s[n.type] : n
                    }))
                }
                function js(r) {
                    const t = r.value
                      , n = r.key
                      , s = On(r);
                    return s.length || (t.indexOf("{fontstack}") === -1 && s.push(new me(n,t,'"glyphs" url must include a "{fontstack}" token')),
                    t.indexOf("{range}") === -1 && s.push(new me(n,t,'"glyphs" url must include a "{range}" token'))),
                    s
                }
                function Kt(r, t=E) {
                    let n = [];
                    return n = n.concat(Nn({
                        key: "",
                        value: r,
                        valueSpec: t.$root,
                        styleSpec: t,
                        style: r,
                        validateSpec: Nn,
                        objectElementValidators: {
                            glyphs: js,
                            "*": () => []
                        }
                    })),
                    r.constants && (n = n.concat(mo({
                        key: "constants",
                        value: r.constants
                    }))),
                    Sl(n)
                }
                function ir(r) {
                    return function(t) {
                        return r({
                            ...t,
                            validateSpec: Nn
                        })
                    }
                }
                function Sl(r) {
                    return [].concat(r).sort( (t, n) => t.line - n.line)
                }
                function nn(r) {
                    return function(...t) {
                        return Sl(r.apply(this, t))
                    }
                }
                Kt.source = nn(ir(Xc)),
                Kt.sprite = nn(ir(Qc)),
                Kt.glyphs = nn(ir(js)),
                Kt.light = nn(ir(Kc)),
                Kt.sky = nn(ir(Jc)),
                Kt.terrain = nn(ir(Yc)),
                Kt.layer = nn(ir(Pl)),
                Kt.filter = nn(ir(Os)),
                Kt.paintProperty = nn(ir(Cl)),
                Kt.layoutProperty = nn(ir(Wc));
                const Vs = Kt
                  , go = Vs.light
                  , tu = Vs.sky
                  , Il = Vs.paintProperty
                  , gh = Vs.layoutProperty;
                function aa(r, t) {
                    let n = !1;
                    if (t && t.length)
                        for (const s of t)
                            r.fire(new _n(new Error(s.message))),
                            n = !0;
                    return n
                }
                class _o {
                    constructor(t, n, s) {
                        const c = this.cells = [];
                        if (t instanceof ArrayBuffer) {
                            this.arrayBuffer = t;
                            const p = new Int32Array(this.arrayBuffer);
                            t = p[0],
                            this.d = (n = p[1]) + 2 * (s = p[2]);
                            for (let x = 0; x < this.d * this.d; x++) {
                                const b = p[3 + x]
                                  , C = p[3 + x + 1];
                                c.push(b === C ? null : p.subarray(b, C))
                            }
                            const g = p[3 + c.length + 1];
                            this.keys = p.subarray(p[3 + c.length], g),
                            this.bboxes = p.subarray(g),
                            this.insert = this._insertReadonly
                        } else {
                            this.d = n + 2 * s;
                            for (let p = 0; p < this.d * this.d; p++)
                                c.push([]);
                            this.keys = [],
                            this.bboxes = []
                        }
                        this.n = n,
                        this.extent = t,
                        this.padding = s,
                        this.scale = n / t,
                        this.uid = 0;
                        const d = s / n * t;
                        this.min = -d,
                        this.max = t + d
                    }
                    insert(t, n, s, c, d) {
                        this._forEachCell(n, s, c, d, this._insertCell, this.uid++, void 0, void 0),
                        this.keys.push(t),
                        this.bboxes.push(n),
                        this.bboxes.push(s),
                        this.bboxes.push(c),
                        this.bboxes.push(d)
                    }
                    _insertReadonly() {
                        throw new Error("Cannot insert into a GridIndex created from an ArrayBuffer.")
                    }
                    _insertCell(t, n, s, c, d, p) {
                        this.cells[d].push(p)
                    }
                    query(t, n, s, c, d) {
                        const p = this.min
                          , g = this.max;
                        if (t <= p && n <= p && g <= s && g <= c && !d)
                            return Array.prototype.slice.call(this.keys);
                        {
                            const x = [];
                            return this._forEachCell(t, n, s, c, this._queryCell, x, {}, d),
                            x
                        }
                    }
                    _queryCell(t, n, s, c, d, p, g, x) {
                        const b = this.cells[d];
                        if (b !== null) {
                            const C = this.keys
                              , P = this.bboxes;
                            for (let D = 0; D < b.length; D++) {
                                const F = b[D];
                                if (g[F] === void 0) {
                                    const B = 4 * F;
                                    (x ? x(P[B + 0], P[B + 1], P[B + 2], P[B + 3]) : t <= P[B + 2] && n <= P[B + 3] && s >= P[B + 0] && c >= P[B + 1]) ? (g[F] = !0,
                                    p.push(C[F])) : g[F] = !1
                                }
                            }
                        }
                    }
                    _forEachCell(t, n, s, c, d, p, g, x) {
                        const b = this._convertToCellCoord(t)
                          , C = this._convertToCellCoord(n)
                          , P = this._convertToCellCoord(s)
                          , D = this._convertToCellCoord(c);
                        for (let F = b; F <= P; F++)
                            for (let B = C; B <= D; B++) {
                                const j = this.d * B + F;
                                if ((!x || x(this._convertFromCellCoord(F), this._convertFromCellCoord(B), this._convertFromCellCoord(F + 1), this._convertFromCellCoord(B + 1))) && d.call(this, t, n, s, c, j, p, g, x))
                                    return
                            }
                    }
                    _convertFromCellCoord(t) {
                        return (t - this.padding) / this.scale
                    }
                    _convertToCellCoord(t) {
                        return Math.max(0, Math.min(this.d - 1, Math.floor(t * this.scale) + this.padding))
                    }
                    toArrayBuffer() {
                        if (this.arrayBuffer)
                            return this.arrayBuffer;
                        const t = this.cells
                          , n = 3 + this.cells.length + 1 + 1;
                        let s = 0;
                        for (let p = 0; p < this.cells.length; p++)
                            s += this.cells[p].length;
                        const c = new Int32Array(n + s + this.keys.length + this.bboxes.length);
                        c[0] = this.extent,
                        c[1] = this.n,
                        c[2] = this.padding;
                        let d = n;
                        for (let p = 0; p < t.length; p++) {
                            const g = t[p];
                            c[3 + p] = d,
                            c.set(g, d),
                            d += g.length
                        }
                        return c[3 + t.length] = d,
                        c.set(this.keys, d),
                        d += this.keys.length,
                        c[3 + t.length + 1] = d,
                        c.set(this.bboxes, d),
                        d += this.bboxes.length,
                        c.buffer
                    }
                    static serialize(t, n) {
                        const s = t.toArrayBuffer();
                        return n && n.push(s),
                        {
                            buffer: s
                        }
                    }
                    static deserialize(t) {
                        return new _o(t.buffer)
                    }
                }
                const ur = {};
                function Ve(r, t, n={}) {
                    if (ur[r])
                        throw new Error(`${r} is already registered.`);
                    Object.defineProperty(t, "_classRegistryKey", {
                        value: r,
                        writeable: !1
                    }),
                    ur[r] = {
                        klass: t,
                        omit: n.omit || [],
                        shallow: n.shallow || []
                    }
                }
                Ve("Object", Object),
                Ve("TransferableGridIndex", _o),
                Ve("Color", yt),
                Ve("Error", Error),
                Ve("AJAXError", mn),
                Ve("ResolvedImage", Ki),
                Ve("StylePropertyFunction", ra),
                Ve("StyleExpression", gl, {
                    omit: ["_evaluator"]
                }),
                Ve("ZoomDependentExpression", _l),
                Ve("ZoomConstantExpression", ia),
                Ve("CompoundExpression", Er, {
                    omit: ["_evaluate"]
                });
                for (const r in Ls)
                    Ls[r]._classRegistryKey || Ve(`Expression_${r}`, Ls[r]);
                function Us(r) {
                    return r && typeof ArrayBuffer < "u" && (r instanceof ArrayBuffer || r.constructor && r.constructor.name === "ArrayBuffer")
                }
                function El(r) {
                    return r.$name || r.constructor._classRegistryKey
                }
                function iu(r) {
                    return !function(t) {
                        if (t === null || typeof t != "object")
                            return !1;
                        const n = El(t);
                        return !(!n || n === "Object")
                    }(r) && (r == null || typeof r == "boolean" || typeof r == "number" || typeof r == "string" || r instanceof Boolean || r instanceof Number || r instanceof String || r instanceof Date || r instanceof RegExp || r instanceof Blob || r instanceof Error || Us(r) || Wn(r) || ArrayBuffer.isView(r) || r instanceof ImageData)
                }
                function jn(r, t) {
                    if (iu(r))
                        return (Us(r) || Wn(r)) && t && t.push(r),
                        ArrayBuffer.isView(r) && t && t.push(r.buffer),
                        r instanceof ImageData && t && t.push(r.data.buffer),
                        r;
                    if (Array.isArray(r)) {
                        const d = [];
                        for (const p of r)
                            d.push(jn(p, t));
                        return d
                    }
                    if (typeof r != "object")
                        throw new Error("can't serialize object of type " + typeof r);
                    const n = El(r);
                    if (!n)
                        throw new Error(`can't serialize object of unregistered class ${r.constructor.name}`);
                    if (!ur[n])
                        throw new Error(`${n} is not registered.`);
                    const {klass: s} = ur[n]
                      , c = s.serialize ? s.serialize(r, t) : {};
                    if (s.serialize) {
                        if (t && c === t[t.length - 1])
                            throw new Error("statically serialized object won't survive transfer of $name property")
                    } else {
                        for (const d in r) {
                            if (!r.hasOwnProperty(d) || ur[n].omit.indexOf(d) >= 0)
                                continue;
                            const p = r[d];
                            c[d] = ur[n].shallow.indexOf(d) >= 0 ? p : jn(p, t)
                        }
                        r instanceof Error && (c.message = r.message)
                    }
                    if (c.$name)
                        throw new Error("$name property is reserved for worker serialization logic.");
                    return n !== "Object" && (c.$name = n),
                    c
                }
                function yo(r) {
                    if (iu(r))
                        return r;
                    if (Array.isArray(r))
                        return r.map(yo);
                    if (typeof r != "object")
                        throw new Error("can't deserialize object of type " + typeof r);
                    const t = El(r) || "Object";
                    if (!ur[t])
                        throw new Error(`can't deserialize unregistered class ${t}`);
                    const {klass: n} = ur[t];
                    if (!n)
                        throw new Error(`can't deserialize unregistered class ${t}`);
                    if (n.deserialize)
                        return n.deserialize(r);
                    const s = Object.create(n.prototype);
                    for (const c of Object.keys(r)) {
                        if (c === "$name")
                            continue;
                        const d = r[c];
                        s[c] = ur[t].shallow.indexOf(c) >= 0 ? d : yo(d)
                    }
                    return s
                }
                class la {
                    constructor() {
                        this.first = !0
                    }
                    update(t, n) {
                        const s = Math.floor(t);
                        return this.first ? (this.first = !1,
                        this.lastIntegerZoom = s,
                        this.lastIntegerZoomTime = 0,
                        this.lastZoom = t,
                        this.lastFloorZoom = s,
                        !0) : (this.lastFloorZoom > s ? (this.lastIntegerZoom = s + 1,
                        this.lastIntegerZoomTime = n) : this.lastFloorZoom < s && (this.lastIntegerZoom = s,
                        this.lastIntegerZoomTime = n),
                        t !== this.lastZoom && (this.lastZoom = t,
                        this.lastFloorZoom = s,
                        !0))
                    }
                }
                const ct = {
                    "Latin-1 Supplement": r => r >= 128 && r <= 255,
                    "Hangul Jamo": r => r >= 4352 && r <= 4607,
                    Khmer: r => r >= 6016 && r <= 6143,
                    "General Punctuation": r => r >= 8192 && r <= 8303,
                    "Letterlike Symbols": r => r >= 8448 && r <= 8527,
                    "Number Forms": r => r >= 8528 && r <= 8591,
                    "Miscellaneous Technical": r => r >= 8960 && r <= 9215,
                    "Control Pictures": r => r >= 9216 && r <= 9279,
                    "Optical Character Recognition": r => r >= 9280 && r <= 9311,
                    "Enclosed Alphanumerics": r => r >= 9312 && r <= 9471,
                    "Geometric Shapes": r => r >= 9632 && r <= 9727,
                    "Miscellaneous Symbols": r => r >= 9728 && r <= 9983,
                    "Miscellaneous Symbols and Arrows": r => r >= 11008 && r <= 11263,
                    "Ideographic Description Characters": r => r >= 12272 && r <= 12287,
                    "CJK Symbols and Punctuation": r => r >= 12288 && r <= 12351,
                    Hiragana: r => r >= 12352 && r <= 12447,
                    Katakana: r => r >= 12448 && r <= 12543,
                    Kanbun: r => r >= 12688 && r <= 12703,
                    "CJK Strokes": r => r >= 12736 && r <= 12783,
                    "Enclosed CJK Letters and Months": r => r >= 12800 && r <= 13055,
                    "CJK Compatibility": r => r >= 13056 && r <= 13311,
                    "Yijing Hexagram Symbols": r => r >= 19904 && r <= 19967,
                    "CJK Unified Ideographs": r => r >= 19968 && r <= 40959,
                    "Hangul Syllables": r => r >= 44032 && r <= 55215,
                    "Private Use Area": r => r >= 57344 && r <= 63743,
                    "Vertical Forms": r => r >= 65040 && r <= 65055,
                    "CJK Compatibility Forms": r => r >= 65072 && r <= 65103,
                    "Small Form Variants": r => r >= 65104 && r <= 65135,
                    "Halfwidth and Fullwidth Forms": r => r >= 65280 && r <= 65519
                };
                function ca(r) {
                    for (const t of r)
                        if (kl(t.charCodeAt(0)))
                            return !0;
                    return !1
                }
                function ru(r) {
                    for (const t of r)
                        if (!Al(t.charCodeAt(0)))
                            return !1;
                    return !0
                }
                function ua(r) {
                    const t = r.map(n => {
                        try {
                            return new RegExp(`\\p{sc=${n}}`,"u").source
                        } catch {
                            return null
                        }
                    }
                    ).filter(n => n);
                    return new RegExp(t.join("|"),"u")
                }
                const nu = ua(["Arab", "Dupl", "Mong", "Ougr", "Syrc"]);
                function Al(r) {
                    return !nu.test(String.fromCodePoint(r))
                }
                const zl = ua(["Bopo", "Hani", "Hira", "Kana", "Kits", "Nshu", "Tang", "Yiii"]);
                function kl(r) {
                    return !(r !== 746 && r !== 747 && (r < 4352 || !(ct["CJK Compatibility Forms"](r) && !(r >= 65097 && r <= 65103) || ct["CJK Compatibility"](r) || ct["CJK Strokes"](r) || !(!ct["CJK Symbols and Punctuation"](r) || r >= 12296 && r <= 12305 || r >= 12308 && r <= 12319 || r === 12336) || ct["Enclosed CJK Letters and Months"](r) || ct["Ideographic Description Characters"](r) || ct.Kanbun(r) || ct.Katakana(r) && r !== 12540 || !(!ct["Halfwidth and Fullwidth Forms"](r) || r === 65288 || r === 65289 || r === 65293 || r >= 65306 && r <= 65310 || r === 65339 || r === 65341 || r === 65343 || r >= 65371 && r <= 65503 || r === 65507 || r >= 65512 && r <= 65519) || !(!ct["Small Form Variants"](r) || r >= 65112 && r <= 65118 || r >= 65123 && r <= 65126) || ct["Vertical Forms"](r) || ct["Yijing Hexagram Symbols"](r) || /\p{sc=Cans}/u.test(String.fromCodePoint(r)) || /\p{sc=Hang}/u.test(String.fromCodePoint(r)) || zl.test(String.fromCodePoint(r)))))
                }
                function Ll(r) {
                    return !(kl(r) || function(t) {
                        return !!(ct["Latin-1 Supplement"](t) && (t === 167 || t === 169 || t === 174 || t === 177 || t === 188 || t === 189 || t === 190 || t === 215 || t === 247) || ct["General Punctuation"](t) && (t === 8214 || t === 8224 || t === 8225 || t === 8240 || t === 8241 || t === 8251 || t === 8252 || t === 8258 || t === 8263 || t === 8264 || t === 8265 || t === 8273) || ct["Letterlike Symbols"](t) || ct["Number Forms"](t) || ct["Miscellaneous Technical"](t) && (t >= 8960 && t <= 8967 || t >= 8972 && t <= 8991 || t >= 8996 && t <= 9e3 || t === 9003 || t >= 9085 && t <= 9114 || t >= 9150 && t <= 9165 || t === 9167 || t >= 9169 && t <= 9179 || t >= 9186 && t <= 9215) || ct["Control Pictures"](t) && t !== 9251 || ct["Optical Character Recognition"](t) || ct["Enclosed Alphanumerics"](t) || ct["Geometric Shapes"](t) || ct["Miscellaneous Symbols"](t) && !(t >= 9754 && t <= 9759) || ct["Miscellaneous Symbols and Arrows"](t) && (t >= 11026 && t <= 11055 || t >= 11088 && t <= 11097 || t >= 11192 && t <= 11243) || ct["CJK Symbols and Punctuation"](t) || ct.Katakana(t) || ct["Private Use Area"](t) || ct["CJK Compatibility Forms"](t) || ct["Small Form Variants"](t) || ct["Halfwidth and Fullwidth Forms"](t) || t === 8734 || t === 8756 || t === 8757 || t >= 9984 && t <= 10087 || t >= 10102 && t <= 10131 || t === 65532 || t === 65533)
                    }(r))
                }
                const _h = ua(["Adlm", "Arab", "Armi", "Avst", "Chrs", "Cprt", "Egyp", "Elym", "Gara", "Hatr", "Hebr", "Hung", "Khar", "Lydi", "Mand", "Mani", "Mend", "Merc", "Mero", "Narb", "Nbat", "Nkoo", "Orkh", "Palm", "Phli", "Phlp", "Phnx", "Prti", "Rohg", "Samr", "Sarb", "Sogo", "Syrc", "Thaa", "Todr", "Yezi"]);
                function Dl(r) {
                    return _h.test(String.fromCodePoint(r))
                }
                function su(r, t) {
                    return !(!t && Dl(r) || r >= 2304 && r <= 3583 || r >= 3840 && r <= 4255 || ct.Khmer(r))
                }
                function ou(r) {
                    for (const t of r)
                        if (Dl(t.charCodeAt(0)))
                            return !0;
                    return !1
                }
                const Vn = new class {
                    constructor() {
                        this.TIMEOUT = 5e3,
                        this.applyArabicShaping = null,
                        this.processBidirectionalText = null,
                        this.processStyledBidirectionalText = null,
                        this.pluginStatus = "unavailable",
                        this.pluginURL = null,
                        this.loadScriptResolve = () => {}
                    }
                    setState(r) {
                        this.pluginStatus = r.pluginStatus,
                        this.pluginURL = r.pluginURL
                    }
                    getState() {
                        return {
                            pluginStatus: this.pluginStatus,
                            pluginURL: this.pluginURL
                        }
                    }
                    setMethods(r) {
                        if (Vn.isParsed())
                            throw new Error("RTL text plugin already registered.");
                        this.applyArabicShaping = r.applyArabicShaping,
                        this.processBidirectionalText = r.processBidirectionalText,
                        this.processStyledBidirectionalText = r.processStyledBidirectionalText,
                        this.loadScriptResolve()
                    }
                    isParsed() {
                        return this.applyArabicShaping != null && this.processBidirectionalText != null && this.processStyledBidirectionalText != null
                    }
                    getRTLTextPluginStatus() {
                        return this.pluginStatus
                    }
                    syncState(r, t) {
                        return l(this, void 0, void 0, function*() {
                            if (this.isParsed())
                                return this.getState();
                            if (r.pluginStatus !== "loading")
                                return this.setState(r),
                                r;
                            const n = r.pluginURL
                              , s = new Promise(d => {
                                this.loadScriptResolve = d
                            }
                            );
                            t(n);
                            const c = new Promise(d => setTimeout( () => d(), this.TIMEOUT));
                            if (yield Promise.race([s, c]),
                            this.isParsed()) {
                                const d = {
                                    pluginStatus: "loaded",
                                    pluginURL: n
                                };
                                return this.setState(d),
                                d
                            }
                            throw this.setState({
                                pluginStatus: "error",
                                pluginURL: ""
                            }),
                            new Error(`RTL Text Plugin failed to import scripts from ${n}`)
                        })
                    }
                }
                ;
                class Ut {
                    constructor(t, n) {
                        this.zoom = t,
                        n ? (this.now = n.now,
                        this.fadeDuration = n.fadeDuration,
                        this.zoomHistory = n.zoomHistory,
                        this.transition = n.transition) : (this.now = 0,
                        this.fadeDuration = 0,
                        this.zoomHistory = new la,
                        this.transition = {})
                    }
                    isSupportedScript(t) {
                        return function(n, s) {
                            for (const c of n)
                                if (!su(c.charCodeAt(0), s))
                                    return !1;
                            return !0
                        }(t, Vn.getRTLTextPluginStatus() === "loaded")
                    }
                    crossFadingFactor() {
                        return this.fadeDuration === 0 ? 1 : Math.min((this.now - this.zoomHistory.lastIntegerZoomTime) / this.fadeDuration, 1)
                    }
                    getCrossfadeParameters() {
                        const t = this.zoom
                          , n = t - Math.floor(t)
                          , s = this.crossFadingFactor();
                        return t > this.zoomHistory.lastIntegerZoom ? {
                            fromScale: 2,
                            toScale: 1,
                            t: n + (1 - n) * s
                        } : {
                            fromScale: .5,
                            toScale: 1,
                            t: 1 - (1 - s) * n
                        }
                    }
                }
                class xo {
                    constructor(t, n) {
                        this.property = t,
                        this.value = n,
                        this.expression = function(s, c) {
                            if (ea(s))
                                return new ra(s,c);
                            if (ta(s)) {
                                const d = Zc(s, c);
                                if (d.result === "error")
                                    throw new Error(d.value.map(p => `${p.key}: ${p.message}`).join(", "));
                                return d.value
                            }
                            {
                                let d = s;
                                return c.type === "color" && typeof s == "string" ? d = yt.parse(s) : c.type !== "padding" || typeof s != "number" && !Array.isArray(s) ? c.type === "variableAnchorOffsetCollection" && Array.isArray(s) ? d = Ii.parse(s) : c.type === "projectionDefinition" && typeof s == "string" && (d = er.parse(s)) : d = Si.parse(s),
                                {
                                    kind: "constant",
                                    evaluate: () => d
                                }
                            }
                        }(n === void 0 ? t.specification.default : n, t.specification)
                    }
                    isDataDriven() {
                        return this.expression.kind === "source" || this.expression.kind === "composite"
                    }
                    possiblyEvaluate(t, n, s) {
                        return this.property.possiblyEvaluate(this, t, n, s)
                    }
                }
                class ha {
                    constructor(t) {
                        this.property = t,
                        this.value = new xo(t,void 0)
                    }
                    transitioned(t, n) {
                        return new Fl(this.property,this.value,n,Ft({}, t.transition, this.transition),t.now)
                    }
                    untransitioned() {
                        return new Fl(this.property,this.value,null,{},0)
                    }
                }
                class Rl {
                    constructor(t) {
                        this._properties = t,
                        this._values = Object.create(t.defaultTransitionablePropertyValues)
                    }
                    getValue(t) {
                        return Vi(this._values[t].value.value)
                    }
                    setValue(t, n) {
                        Object.prototype.hasOwnProperty.call(this._values, t) || (this._values[t] = new ha(this._values[t].property)),
                        this._values[t].value = new xo(this._values[t].property,n === null ? void 0 : Vi(n))
                    }
                    getTransition(t) {
                        return Vi(this._values[t].transition)
                    }
                    setTransition(t, n) {
                        Object.prototype.hasOwnProperty.call(this._values, t) || (this._values[t] = new ha(this._values[t].property)),
                        this._values[t].transition = Vi(n) || void 0
                    }
                    serialize() {
                        const t = {};
                        for (const n of Object.keys(this._values)) {
                            const s = this.getValue(n);
                            s !== void 0 && (t[n] = s);
                            const c = this.getTransition(n);
                            c !== void 0 && (t[`${n}-transition`] = c)
                        }
                        return t
                    }
                    transitioned(t, n) {
                        const s = new vo(this._properties);
                        for (const c of Object.keys(this._values))
                            s._values[c] = this._values[c].transitioned(t, n._values[c]);
                        return s
                    }
                    untransitioned() {
                        const t = new vo(this._properties);
                        for (const n of Object.keys(this._values))
                            t._values[n] = this._values[n].untransitioned();
                        return t
                    }
                }
                class Fl {
                    constructor(t, n, s, c, d) {
                        this.property = t,
                        this.value = n,
                        this.begin = d + c.delay || 0,
                        this.end = this.begin + c.duration || 0,
                        t.specification.transition && (c.delay || c.duration) && (this.prior = s)
                    }
                    possiblyEvaluate(t, n, s) {
                        const c = t.now || 0
                          , d = this.value.possiblyEvaluate(t, n, s)
                          , p = this.prior;
                        if (p) {
                            if (c > this.end)
                                return this.prior = null,
                                d;
                            if (this.value.isDataDriven())
                                return this.prior = null,
                                d;
                            if (c < this.begin)
                                return p.possiblyEvaluate(t, n, s);
                            {
                                const g = (c - this.begin) / (this.end - this.begin);
                                return this.property.interpolate(p.possiblyEvaluate(t, n, s), d, wr(g))
                            }
                        }
                        return d
                    }
                }
                class vo {
                    constructor(t) {
                        this._properties = t,
                        this._values = Object.create(t.defaultTransitioningPropertyValues)
                    }
                    possiblyEvaluate(t, n, s) {
                        const c = new da(this._properties);
                        for (const d of Object.keys(this._values))
                            c._values[d] = this._values[d].possiblyEvaluate(t, n, s);
                        return c
                    }
                    hasTransition() {
                        for (const t of Object.keys(this._values))
                            if (this._values[t].prior)
                                return !0;
                        return !1
                    }
                }
                class yh {
                    constructor(t) {
                        this._properties = t,
                        this._values = Object.create(t.defaultPropertyValues)
                    }
                    hasValue(t) {
                        return this._values[t].value !== void 0
                    }
                    getValue(t) {
                        return Vi(this._values[t].value)
                    }
                    setValue(t, n) {
                        this._values[t] = new xo(this._values[t].property,n === null ? void 0 : Vi(n))
                    }
                    serialize() {
                        const t = {};
                        for (const n of Object.keys(this._values)) {
                            const s = this.getValue(n);
                            s !== void 0 && (t[n] = s)
                        }
                        return t
                    }
                    possiblyEvaluate(t, n, s) {
                        const c = new da(this._properties);
                        for (const d of Object.keys(this._values))
                            c._values[d] = this._values[d].possiblyEvaluate(t, n, s);
                        return c
                    }
                }
                class zr {
                    constructor(t, n, s) {
                        this.property = t,
                        this.value = n,
                        this.parameters = s
                    }
                    isConstant() {
                        return this.value.kind === "constant"
                    }
                    constantOr(t) {
                        return this.value.kind === "constant" ? this.value.value : t
                    }
                    evaluate(t, n, s, c) {
                        return this.property.evaluate(this.value, this.parameters, t, n, s, c)
                    }
                }
                class da {
                    constructor(t) {
                        this._properties = t,
                        this._values = Object.create(t.defaultPossiblyEvaluatedValues)
                    }
                    get(t) {
                        return this._values[t]
                    }
                }
                class Xe {
                    constructor(t) {
                        this.specification = t
                    }
                    possiblyEvaluate(t, n) {
                        if (t.isDataDriven())
                            throw new Error("Value should not be data driven");
                        return t.expression.evaluate(n)
                    }
                    interpolate(t, n, s) {
                        const c = cr[this.specification.type];
                        return c ? c(t, n, s) : t
                    }
                }
                class et {
                    constructor(t, n) {
                        this.specification = t,
                        this.overrides = n
                    }
                    possiblyEvaluate(t, n, s, c) {
                        return new zr(this,t.expression.kind === "constant" || t.expression.kind === "camera" ? {
                            kind: "constant",
                            value: t.expression.evaluate(n, null, {}, s, c)
                        } : t.expression,n)
                    }
                    interpolate(t, n, s) {
                        if (t.value.kind !== "constant" || n.value.kind !== "constant")
                            return t;
                        if (t.value.value === void 0 || n.value.value === void 0)
                            return new zr(this,{
                                kind: "constant",
                                value: void 0
                            },t.parameters);
                        const c = cr[this.specification.type];
                        if (c) {
                            const d = c(t.value.value, n.value.value, s);
                            return new zr(this,{
                                kind: "constant",
                                value: d
                            },t.parameters)
                        }
                        return t
                    }
                    evaluate(t, n, s, c, d, p) {
                        return t.kind === "constant" ? t.value : t.evaluate(n, s, c, d, p)
                    }
                }
                class bo extends et {
                    possiblyEvaluate(t, n, s, c) {
                        if (t.value === void 0)
                            return new zr(this,{
                                kind: "constant",
                                value: void 0
                            },n);
                        if (t.expression.kind === "constant") {
                            const d = t.expression.evaluate(n, null, {}, s, c)
                              , p = t.property.specification.type === "resolvedImage" && typeof d != "string" ? d.name : d
                              , g = this._calculate(p, p, p, n);
                            return new zr(this,{
                                kind: "constant",
                                value: g
                            },n)
                        }
                        if (t.expression.kind === "camera") {
                            const d = this._calculate(t.expression.evaluate({
                                zoom: n.zoom - 1
                            }), t.expression.evaluate({
                                zoom: n.zoom
                            }), t.expression.evaluate({
                                zoom: n.zoom + 1
                            }), n);
                            return new zr(this,{
                                kind: "constant",
                                value: d
                            },n)
                        }
                        return new zr(this,t.expression,n)
                    }
                    evaluate(t, n, s, c, d, p) {
                        if (t.kind === "source") {
                            const g = t.evaluate(n, s, c, d, p);
                            return this._calculate(g, g, g, n)
                        }
                        return t.kind === "composite" ? this._calculate(t.evaluate({
                            zoom: Math.floor(n.zoom) - 1
                        }, s, c), t.evaluate({
                            zoom: Math.floor(n.zoom)
                        }, s, c), t.evaluate({
                            zoom: Math.floor(n.zoom) + 1
                        }, s, c), n) : t.value
                    }
                    _calculate(t, n, s, c) {
                        return c.zoom > c.zoomHistory.lastIntegerZoom ? {
                            from: t,
                            to: n
                        } : {
                            from: s,
                            to: n
                        }
                    }
                    interpolate(t) {
                        return t
                    }
                }
                class pa {
                    constructor(t) {
                        this.specification = t
                    }
                    possiblyEvaluate(t, n, s, c) {
                        if (t.value !== void 0) {
                            if (t.expression.kind === "constant") {
                                const d = t.expression.evaluate(n, null, {}, s, c);
                                return this._calculate(d, d, d, n)
                            }
                            return this._calculate(t.expression.evaluate(new Ut(Math.floor(n.zoom - 1),n)), t.expression.evaluate(new Ut(Math.floor(n.zoom),n)), t.expression.evaluate(new Ut(Math.floor(n.zoom + 1),n)), n)
                        }
                    }
                    _calculate(t, n, s, c) {
                        return c.zoom > c.zoomHistory.lastIntegerZoom ? {
                            from: t,
                            to: n
                        } : {
                            from: s,
                            to: n
                        }
                    }
                    interpolate(t) {
                        return t
                    }
                }
                class Bl {
                    constructor(t) {
                        this.specification = t
                    }
                    possiblyEvaluate(t, n, s, c) {
                        return !!t.expression.evaluate(n, null, {}, s, c)
                    }
                    interpolate() {
                        return !1
                    }
                }
                class rr {
                    constructor(t) {
                        this.properties = t,
                        this.defaultPropertyValues = {},
                        this.defaultTransitionablePropertyValues = {},
                        this.defaultTransitioningPropertyValues = {},
                        this.defaultPossiblyEvaluatedValues = {},
                        this.overridableProperties = [];
                        for (const n in t) {
                            const s = t[n];
                            s.specification.overridable && this.overridableProperties.push(n);
                            const c = this.defaultPropertyValues[n] = new xo(s,void 0)
                              , d = this.defaultTransitionablePropertyValues[n] = new ha(s);
                            this.defaultTransitioningPropertyValues[n] = d.untransitioned(),
                            this.defaultPossiblyEvaluatedValues[n] = c.possiblyEvaluate({})
                        }
                    }
                }
                Ve("DataDrivenProperty", et),
                Ve("DataConstantProperty", Xe),
                Ve("CrossFadedDataDrivenProperty", bo),
                Ve("CrossFadedProperty", pa),
                Ve("ColorRampProperty", Bl);
                const au = "-transition";
                class sn extends pe {
                    constructor(t, n) {
                        if (super(),
                        this.id = t.id,
                        this.type = t.type,
                        this._featureFilter = {
                            filter: () => !0,
                            needGeometry: !1
                        },
                        t.type !== "custom" && (this.metadata = t.metadata,
                        this.minzoom = t.minzoom,
                        this.maxzoom = t.maxzoom,
                        t.type !== "background" && (this.source = t.source,
                        this.sourceLayer = t["source-layer"],
                        this.filter = t.filter),
                        n.layout && (this._unevaluatedLayout = new yh(n.layout)),
                        n.paint)) {
                            this._transitionablePaint = new Rl(n.paint);
                            for (const s in t.paint)
                                this.setPaintProperty(s, t.paint[s], {
                                    validate: !1
                                });
                            for (const s in t.layout)
                                this.setLayoutProperty(s, t.layout[s], {
                                    validate: !1
                                });
                            this._transitioningPaint = this._transitionablePaint.untransitioned(),
                            this.paint = new da(n.paint)
                        }
                    }
                    getCrossfadeParameters() {
                        return this._crossfadeParameters
                    }
                    getLayoutProperty(t) {
                        return t === "visibility" ? this.visibility : this._unevaluatedLayout.getValue(t)
                    }
                    setLayoutProperty(t, n, s={}) {
                        n != null && this._validate(gh, `layers.${this.id}.layout.${t}`, t, n, s) || (t !== "visibility" ? this._unevaluatedLayout.setValue(t, n) : this.visibility = n)
                    }
                    getPaintProperty(t) {
                        return t.endsWith(au) ? this._transitionablePaint.getTransition(t.slice(0, -11)) : this._transitionablePaint.getValue(t)
                    }
                    setPaintProperty(t, n, s={}) {
                        if (n != null && this._validate(Il, `layers.${this.id}.paint.${t}`, t, n, s))
                            return !1;
                        if (t.endsWith(au))
                            return this._transitionablePaint.setTransition(t.slice(0, -11), n || void 0),
                            !1;
                        {
                            const c = this._transitionablePaint._values[t]
                              , d = c.property.specification["property-type"] === "cross-faded-data-driven"
                              , p = c.value.isDataDriven()
                              , g = c.value;
                            this._transitionablePaint.setValue(t, n),
                            this._handleSpecialPaintPropertyUpdate(t);
                            const x = this._transitionablePaint._values[t].value;
                            return x.isDataDriven() || p || d || this._handleOverridablePaintPropertyUpdate(t, g, x)
                        }
                    }
                    _handleSpecialPaintPropertyUpdate(t) {}
                    _handleOverridablePaintPropertyUpdate(t, n, s) {
                        return !1
                    }
                    isHidden(t) {
                        return !!(this.minzoom && t < this.minzoom) || !!(this.maxzoom && t >= this.maxzoom) || this.visibility === "none"
                    }
                    updateTransitions(t) {
                        this._transitioningPaint = this._transitionablePaint.transitioned(t, this._transitioningPaint)
                    }
                    hasTransition() {
                        return this._transitioningPaint.hasTransition()
                    }
                    recalculate(t, n) {
                        t.getCrossfadeParameters && (this._crossfadeParameters = t.getCrossfadeParameters()),
                        this._unevaluatedLayout && (this.layout = this._unevaluatedLayout.possiblyEvaluate(t, void 0, n)),
                        this.paint = this._transitioningPaint.possiblyEvaluate(t, void 0, n)
                    }
                    serialize() {
                        const t = {
                            id: this.id,
                            type: this.type,
                            source: this.source,
                            "source-layer": this.sourceLayer,
                            metadata: this.metadata,
                            minzoom: this.minzoom,
                            maxzoom: this.maxzoom,
                            filter: this.filter,
                            layout: this._unevaluatedLayout && this._unevaluatedLayout.serialize(),
                            paint: this._transitionablePaint && this._transitionablePaint.serialize()
                        };
                        return this.visibility && (t.layout = t.layout || {},
                        t.layout.visibility = this.visibility),
                        en(t, (n, s) => !(n === void 0 || s === "layout" && !Object.keys(n).length || s === "paint" && !Object.keys(n).length))
                    }
                    _validate(t, n, s, c, d={}) {
                        return (!d || d.validate !== !1) && aa(this, t.call(Vs, {
                            key: n,
                            layerType: this.type,
                            objectKey: s,
                            value: c,
                            styleSpec: E,
                            style: {
                                glyphs: !0,
                                sprite: !0
                            }
                        }))
                    }
                    is3D() {
                        return !1
                    }
                    isTileClipped() {
                        return !1
                    }
                    hasOffscreenPass() {
                        return !1
                    }
                    resize() {}
                    isStateDependent() {
                        for (const t in this.paint._values) {
                            const n = this.paint.get(t);
                            if (n instanceof zr && Rs(n.property.specification) && (n.value.kind === "source" || n.value.kind === "composite") && n.value.isStateDependent)
                                return !0
                        }
                        return !1
                    }
                }
                const xh = {
                    Int8: Int8Array,
                    Uint8: Uint8Array,
                    Int16: Int16Array,
                    Uint16: Uint16Array,
                    Int32: Int32Array,
                    Uint32: Uint32Array,
                    Float32: Float32Array
                };
                class on {
                    constructor(t, n) {
                        this._structArray = t,
                        this._pos1 = n * this.size,
                        this._pos2 = this._pos1 / 2,
                        this._pos4 = this._pos1 / 4,
                        this._pos8 = this._pos1 / 8
                    }
                }
                class Jt {
                    constructor() {
                        this.isTransferred = !1,
                        this.capacity = -1,
                        this.resize(0)
                    }
                    static serialize(t, n) {
                        return t._trim(),
                        n && (t.isTransferred = !0,
                        n.push(t.arrayBuffer)),
                        {
                            length: t.length,
                            arrayBuffer: t.arrayBuffer
                        }
                    }
                    static deserialize(t) {
                        const n = Object.create(this.prototype);
                        return n.arrayBuffer = t.arrayBuffer,
                        n.length = t.length,
                        n.capacity = t.arrayBuffer.byteLength / n.bytesPerElement,
                        n._refreshViews(),
                        n
                    }
                    _trim() {
                        this.length !== this.capacity && (this.capacity = this.length,
                        this.arrayBuffer = this.arrayBuffer.slice(0, this.length * this.bytesPerElement),
                        this._refreshViews())
                    }
                    clear() {
                        this.length = 0
                    }
                    resize(t) {
                        this.reserve(t),
                        this.length = t
                    }
                    reserve(t) {
                        if (t > this.capacity) {
                            this.capacity = Math.max(t, Math.floor(5 * this.capacity), 128),
                            this.arrayBuffer = new ArrayBuffer(this.capacity * this.bytesPerElement);
                            const n = this.uint8;
                            this._refreshViews(),
                            n && this.uint8.set(n)
                        }
                    }
                    _refreshViews() {
                        throw new Error("_refreshViews() must be implemented by each concrete StructArray layout")
                    }
                }
                function li(r, t=1) {
                    let n = 0
                      , s = 0;
                    return {
                        members: r.map(c => {
                            const d = xh[c.type].BYTES_PER_ELEMENT
                              , p = n = lu(n, Math.max(t, d))
                              , g = c.components || 1;
                            return s = Math.max(s, d),
                            n += d * g,
                            {
                                name: c.name,
                                type: c.type,
                                components: g,
                                offset: p
                            }
                        }
                        ),
                        size: lu(n, Math.max(s, t)),
                        alignment: t
                    }
                }
                function lu(r, t) {
                    return Math.ceil(r / t) * t
                }
                class Zs extends Jt {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.int16 = new Int16Array(this.arrayBuffer)
                    }
                    emplaceBack(t, n) {
                        const s = this.length;
                        return this.resize(s + 1),
                        this.emplace(s, t, n)
                    }
                    emplace(t, n, s) {
                        const c = 2 * t;
                        return this.int16[c + 0] = n,
                        this.int16[c + 1] = s,
                        t
                    }
                }
                Zs.prototype.bytesPerElement = 4,
                Ve("StructArrayLayout2i4", Zs);
                class fa extends Jt {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.int16 = new Int16Array(this.arrayBuffer)
                    }
                    emplaceBack(t, n, s) {
                        const c = this.length;
                        return this.resize(c + 1),
                        this.emplace(c, t, n, s)
                    }
                    emplace(t, n, s, c) {
                        const d = 3 * t;
                        return this.int16[d + 0] = n,
                        this.int16[d + 1] = s,
                        this.int16[d + 2] = c,
                        t
                    }
                }
                fa.prototype.bytesPerElement = 6,
                Ve("StructArrayLayout3i6", fa);
                class Ol extends Jt {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.int16 = new Int16Array(this.arrayBuffer)
                    }
                    emplaceBack(t, n, s, c) {
                        const d = this.length;
                        return this.resize(d + 1),
                        this.emplace(d, t, n, s, c)
                    }
                    emplace(t, n, s, c, d) {
                        const p = 4 * t;
                        return this.int16[p + 0] = n,
                        this.int16[p + 1] = s,
                        this.int16[p + 2] = c,
                        this.int16[p + 3] = d,
                        t
                    }
                }
                Ol.prototype.bytesPerElement = 8,
                Ve("StructArrayLayout4i8", Ol);
                class xn extends Jt {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.int16 = new Int16Array(this.arrayBuffer)
                    }
                    emplaceBack(t, n, s, c, d, p) {
                        const g = this.length;
                        return this.resize(g + 1),
                        this.emplace(g, t, n, s, c, d, p)
                    }
                    emplace(t, n, s, c, d, p, g) {
                        const x = 6 * t;
                        return this.int16[x + 0] = n,
                        this.int16[x + 1] = s,
                        this.int16[x + 2] = c,
                        this.int16[x + 3] = d,
                        this.int16[x + 4] = p,
                        this.int16[x + 5] = g,
                        t
                    }
                }
                xn.prototype.bytesPerElement = 12,
                Ve("StructArrayLayout2i4i12", xn);
                class ma extends Jt {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.int16 = new Int16Array(this.arrayBuffer)
                    }
                    emplaceBack(t, n, s, c, d, p) {
                        const g = this.length;
                        return this.resize(g + 1),
                        this.emplace(g, t, n, s, c, d, p)
                    }
                    emplace(t, n, s, c, d, p, g) {
                        const x = 4 * t
                          , b = 8 * t;
                        return this.int16[x + 0] = n,
                        this.int16[x + 1] = s,
                        this.uint8[b + 4] = c,
                        this.uint8[b + 5] = d,
                        this.uint8[b + 6] = p,
                        this.uint8[b + 7] = g,
                        t
                    }
                }
                ma.prototype.bytesPerElement = 8,
                Ve("StructArrayLayout2i4ub8", ma);
                class ds extends Jt {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.float32 = new Float32Array(this.arrayBuffer)
                    }
                    emplaceBack(t, n) {
                        const s = this.length;
                        return this.resize(s + 1),
                        this.emplace(s, t, n)
                    }
                    emplace(t, n, s) {
                        const c = 2 * t;
                        return this.float32[c + 0] = n,
                        this.float32[c + 1] = s,
                        t
                    }
                }
                ds.prototype.bytesPerElement = 8,
                Ve("StructArrayLayout2f8", ds);
                class ga extends Jt {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.uint16 = new Uint16Array(this.arrayBuffer)
                    }
                    emplaceBack(t, n, s, c, d, p, g, x, b, C) {
                        const P = this.length;
                        return this.resize(P + 1),
                        this.emplace(P, t, n, s, c, d, p, g, x, b, C)
                    }
                    emplace(t, n, s, c, d, p, g, x, b, C, P) {
                        const D = 10 * t;
                        return this.uint16[D + 0] = n,
                        this.uint16[D + 1] = s,
                        this.uint16[D + 2] = c,
                        this.uint16[D + 3] = d,
                        this.uint16[D + 4] = p,
                        this.uint16[D + 5] = g,
                        this.uint16[D + 6] = x,
                        this.uint16[D + 7] = b,
                        this.uint16[D + 8] = C,
                        this.uint16[D + 9] = P,
                        t
                    }
                }
                ga.prototype.bytesPerElement = 20,
                Ve("StructArrayLayout10ui20", ga);
                class wo extends Jt {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.int16 = new Int16Array(this.arrayBuffer),
                        this.uint16 = new Uint16Array(this.arrayBuffer)
                    }
                    emplaceBack(t, n, s, c, d, p, g, x, b, C, P, D) {
                        const F = this.length;
                        return this.resize(F + 1),
                        this.emplace(F, t, n, s, c, d, p, g, x, b, C, P, D)
                    }
                    emplace(t, n, s, c, d, p, g, x, b, C, P, D, F) {
                        const B = 12 * t;
                        return this.int16[B + 0] = n,
                        this.int16[B + 1] = s,
                        this.int16[B + 2] = c,
                        this.int16[B + 3] = d,
                        this.uint16[B + 4] = p,
                        this.uint16[B + 5] = g,
                        this.uint16[B + 6] = x,
                        this.uint16[B + 7] = b,
                        this.int16[B + 8] = C,
                        this.int16[B + 9] = P,
                        this.int16[B + 10] = D,
                        this.int16[B + 11] = F,
                        t
                    }
                }
                wo.prototype.bytesPerElement = 24,
                Ve("StructArrayLayout4i4ui4i24", wo);
                class Nl extends Jt {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.float32 = new Float32Array(this.arrayBuffer)
                    }
                    emplaceBack(t, n, s) {
                        const c = this.length;
                        return this.resize(c + 1),
                        this.emplace(c, t, n, s)
                    }
                    emplace(t, n, s, c) {
                        const d = 3 * t;
                        return this.float32[d + 0] = n,
                        this.float32[d + 1] = s,
                        this.float32[d + 2] = c,
                        t
                    }
                }
                Nl.prototype.bytesPerElement = 12,
                Ve("StructArrayLayout3f12", Nl);
                class Gs extends Jt {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.uint32 = new Uint32Array(this.arrayBuffer)
                    }
                    emplaceBack(t) {
                        const n = this.length;
                        return this.resize(n + 1),
                        this.emplace(n, t)
                    }
                    emplace(t, n) {
                        return this.uint32[1 * t + 0] = n,
                        t
                    }
                }
                Gs.prototype.bytesPerElement = 4,
                Ve("StructArrayLayout1ul4", Gs);
                class ps extends Jt {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.int16 = new Int16Array(this.arrayBuffer),
                        this.uint32 = new Uint32Array(this.arrayBuffer),
                        this.uint16 = new Uint16Array(this.arrayBuffer)
                    }
                    emplaceBack(t, n, s, c, d, p, g, x, b) {
                        const C = this.length;
                        return this.resize(C + 1),
                        this.emplace(C, t, n, s, c, d, p, g, x, b)
                    }
                    emplace(t, n, s, c, d, p, g, x, b, C) {
                        const P = 10 * t
                          , D = 5 * t;
                        return this.int16[P + 0] = n,
                        this.int16[P + 1] = s,
                        this.int16[P + 2] = c,
                        this.int16[P + 3] = d,
                        this.int16[P + 4] = p,
                        this.int16[P + 5] = g,
                        this.uint32[D + 3] = x,
                        this.uint16[P + 8] = b,
                        this.uint16[P + 9] = C,
                        t
                    }
                }
                ps.prototype.bytesPerElement = 20,
                Ve("StructArrayLayout6i1ul2ui20", ps);
                class jl extends Jt {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.int16 = new Int16Array(this.arrayBuffer)
                    }
                    emplaceBack(t, n, s, c, d, p) {
                        const g = this.length;
                        return this.resize(g + 1),
                        this.emplace(g, t, n, s, c, d, p)
                    }
                    emplace(t, n, s, c, d, p, g) {
                        const x = 6 * t;
                        return this.int16[x + 0] = n,
                        this.int16[x + 1] = s,
                        this.int16[x + 2] = c,
                        this.int16[x + 3] = d,
                        this.int16[x + 4] = p,
                        this.int16[x + 5] = g,
                        t
                    }
                }
                jl.prototype.bytesPerElement = 12,
                Ve("StructArrayLayout2i2i2i12", jl);
                class _a extends Jt {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.float32 = new Float32Array(this.arrayBuffer),
                        this.int16 = new Int16Array(this.arrayBuffer)
                    }
                    emplaceBack(t, n, s, c, d) {
                        const p = this.length;
                        return this.resize(p + 1),
                        this.emplace(p, t, n, s, c, d)
                    }
                    emplace(t, n, s, c, d, p) {
                        const g = 4 * t
                          , x = 8 * t;
                        return this.float32[g + 0] = n,
                        this.float32[g + 1] = s,
                        this.float32[g + 2] = c,
                        this.int16[x + 6] = d,
                        this.int16[x + 7] = p,
                        t
                    }
                }
                _a.prototype.bytesPerElement = 16,
                Ve("StructArrayLayout2f1f2i16", _a);
                class fs extends Jt {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.float32 = new Float32Array(this.arrayBuffer),
                        this.int16 = new Int16Array(this.arrayBuffer)
                    }
                    emplaceBack(t, n, s, c, d, p) {
                        const g = this.length;
                        return this.resize(g + 1),
                        this.emplace(g, t, n, s, c, d, p)
                    }
                    emplace(t, n, s, c, d, p, g) {
                        const x = 16 * t
                          , b = 4 * t
                          , C = 8 * t;
                        return this.uint8[x + 0] = n,
                        this.uint8[x + 1] = s,
                        this.float32[b + 1] = c,
                        this.float32[b + 2] = d,
                        this.int16[C + 6] = p,
                        this.int16[C + 7] = g,
                        t
                    }
                }
                fs.prototype.bytesPerElement = 16,
                Ve("StructArrayLayout2ub2f2i16", fs);
                class ya extends Jt {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.uint16 = new Uint16Array(this.arrayBuffer)
                    }
                    emplaceBack(t, n, s) {
                        const c = this.length;
                        return this.resize(c + 1),
                        this.emplace(c, t, n, s)
                    }
                    emplace(t, n, s, c) {
                        const d = 3 * t;
                        return this.uint16[d + 0] = n,
                        this.uint16[d + 1] = s,
                        this.uint16[d + 2] = c,
                        t
                    }
                }
                ya.prototype.bytesPerElement = 6,
                Ve("StructArrayLayout3ui6", ya);
                class Vl extends Jt {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.int16 = new Int16Array(this.arrayBuffer),
                        this.uint16 = new Uint16Array(this.arrayBuffer),
                        this.uint32 = new Uint32Array(this.arrayBuffer),
                        this.float32 = new Float32Array(this.arrayBuffer)
                    }
                    emplaceBack(t, n, s, c, d, p, g, x, b, C, P, D, F, B, j, G, X) {
                        const ae = this.length;
                        return this.resize(ae + 1),
                        this.emplace(ae, t, n, s, c, d, p, g, x, b, C, P, D, F, B, j, G, X)
                    }
                    emplace(t, n, s, c, d, p, g, x, b, C, P, D, F, B, j, G, X, ae) {
                        const Q = 24 * t
                          , R = 12 * t
                          , Z = 48 * t;
                        return this.int16[Q + 0] = n,
                        this.int16[Q + 1] = s,
                        this.uint16[Q + 2] = c,
                        this.uint16[Q + 3] = d,
                        this.uint32[R + 2] = p,
                        this.uint32[R + 3] = g,
                        this.uint32[R + 4] = x,
                        this.uint16[Q + 10] = b,
                        this.uint16[Q + 11] = C,
                        this.uint16[Q + 12] = P,
                        this.float32[R + 7] = D,
                        this.float32[R + 8] = F,
                        this.uint8[Z + 36] = B,
                        this.uint8[Z + 37] = j,
                        this.uint8[Z + 38] = G,
                        this.uint32[R + 10] = X,
                        this.int16[Q + 22] = ae,
                        t
                    }
                }
                Vl.prototype.bytesPerElement = 48,
                Ve("StructArrayLayout2i2ui3ul3ui2f3ub1ul1i48", Vl);
                class xa extends Jt {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.int16 = new Int16Array(this.arrayBuffer),
                        this.uint16 = new Uint16Array(this.arrayBuffer),
                        this.uint32 = new Uint32Array(this.arrayBuffer),
                        this.float32 = new Float32Array(this.arrayBuffer)
                    }
                    emplaceBack(t, n, s, c, d, p, g, x, b, C, P, D, F, B, j, G, X, ae, Q, R, Z, ee, ye, Le, be, Me, Fe, Re) {
                        const Be = this.length;
                        return this.resize(Be + 1),
                        this.emplace(Be, t, n, s, c, d, p, g, x, b, C, P, D, F, B, j, G, X, ae, Q, R, Z, ee, ye, Le, be, Me, Fe, Re)
                    }
                    emplace(t, n, s, c, d, p, g, x, b, C, P, D, F, B, j, G, X, ae, Q, R, Z, ee, ye, Le, be, Me, Fe, Re, Be) {
                        const Ee = 32 * t
                          , Ue = 16 * t;
                        return this.int16[Ee + 0] = n,
                        this.int16[Ee + 1] = s,
                        this.int16[Ee + 2] = c,
                        this.int16[Ee + 3] = d,
                        this.int16[Ee + 4] = p,
                        this.int16[Ee + 5] = g,
                        this.int16[Ee + 6] = x,
                        this.int16[Ee + 7] = b,
                        this.uint16[Ee + 8] = C,
                        this.uint16[Ee + 9] = P,
                        this.uint16[Ee + 10] = D,
                        this.uint16[Ee + 11] = F,
                        this.uint16[Ee + 12] = B,
                        this.uint16[Ee + 13] = j,
                        this.uint16[Ee + 14] = G,
                        this.uint16[Ee + 15] = X,
                        this.uint16[Ee + 16] = ae,
                        this.uint16[Ee + 17] = Q,
                        this.uint16[Ee + 18] = R,
                        this.uint16[Ee + 19] = Z,
                        this.uint16[Ee + 20] = ee,
                        this.uint16[Ee + 21] = ye,
                        this.uint16[Ee + 22] = Le,
                        this.uint32[Ue + 12] = be,
                        this.float32[Ue + 13] = Me,
                        this.float32[Ue + 14] = Fe,
                        this.uint16[Ee + 30] = Re,
                        this.uint16[Ee + 31] = Be,
                        t
                    }
                }
                xa.prototype.bytesPerElement = 64,
                Ve("StructArrayLayout8i15ui1ul2f2ui64", xa);
                class va extends Jt {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.float32 = new Float32Array(this.arrayBuffer)
                    }
                    emplaceBack(t) {
                        const n = this.length;
                        return this.resize(n + 1),
                        this.emplace(n, t)
                    }
                    emplace(t, n) {
                        return this.float32[1 * t + 0] = n,
                        t
                    }
                }
                va.prototype.bytesPerElement = 4,
                Ve("StructArrayLayout1f4", va);
                class u extends Jt {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.uint16 = new Uint16Array(this.arrayBuffer),
                        this.float32 = new Float32Array(this.arrayBuffer)
                    }
                    emplaceBack(t, n, s) {
                        const c = this.length;
                        return this.resize(c + 1),
                        this.emplace(c, t, n, s)
                    }
                    emplace(t, n, s, c) {
                        const d = 3 * t;
                        return this.uint16[6 * t + 0] = n,
                        this.float32[d + 1] = s,
                        this.float32[d + 2] = c,
                        t
                    }
                }
                u.prototype.bytesPerElement = 12,
                Ve("StructArrayLayout1ui2f12", u);
                class e extends Jt {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.uint32 = new Uint32Array(this.arrayBuffer),
                        this.uint16 = new Uint16Array(this.arrayBuffer)
                    }
                    emplaceBack(t, n, s) {
                        const c = this.length;
                        return this.resize(c + 1),
                        this.emplace(c, t, n, s)
                    }
                    emplace(t, n, s, c) {
                        const d = 4 * t;
                        return this.uint32[2 * t + 0] = n,
                        this.uint16[d + 2] = s,
                        this.uint16[d + 3] = c,
                        t
                    }
                }
                e.prototype.bytesPerElement = 8,
                Ve("StructArrayLayout1ul2ui8", e);
                class i extends Jt {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.uint16 = new Uint16Array(this.arrayBuffer)
                    }
                    emplaceBack(t, n) {
                        const s = this.length;
                        return this.resize(s + 1),
                        this.emplace(s, t, n)
                    }
                    emplace(t, n, s) {
                        const c = 2 * t;
                        return this.uint16[c + 0] = n,
                        this.uint16[c + 1] = s,
                        t
                    }
                }
                i.prototype.bytesPerElement = 4,
                Ve("StructArrayLayout2ui4", i);
                class o extends Jt {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.uint16 = new Uint16Array(this.arrayBuffer)
                    }
                    emplaceBack(t) {
                        const n = this.length;
                        return this.resize(n + 1),
                        this.emplace(n, t)
                    }
                    emplace(t, n) {
                        return this.uint16[1 * t + 0] = n,
                        t
                    }
                }
                o.prototype.bytesPerElement = 2,
                Ve("StructArrayLayout1ui2", o);
                class a extends Jt {
                    _refreshViews() {
                        this.uint8 = new Uint8Array(this.arrayBuffer),
                        this.float32 = new Float32Array(this.arrayBuffer)
                    }
                    emplaceBack(t, n, s, c) {
                        const d = this.length;
                        return this.resize(d + 1),
                        this.emplace(d, t, n, s, c)
                    }
                    emplace(t, n, s, c, d) {
                        const p = 4 * t;
                        return this.float32[p + 0] = n,
                        this.float32[p + 1] = s,
                        this.float32[p + 2] = c,
                        this.float32[p + 3] = d,
                        t
                    }
                }
                a.prototype.bytesPerElement = 16,
                Ve("StructArrayLayout4f16", a);
                class h extends on {
                    get anchorPointX() {
                        return this._structArray.int16[this._pos2 + 0]
                    }
                    get anchorPointY() {
                        return this._structArray.int16[this._pos2 + 1]
                    }
                    get x1() {
                        return this._structArray.int16[this._pos2 + 2]
                    }
                    get y1() {
                        return this._structArray.int16[this._pos2 + 3]
                    }
                    get x2() {
                        return this._structArray.int16[this._pos2 + 4]
                    }
                    get y2() {
                        return this._structArray.int16[this._pos2 + 5]
                    }
                    get featureIndex() {
                        return this._structArray.uint32[this._pos4 + 3]
                    }
                    get sourceLayerIndex() {
                        return this._structArray.uint16[this._pos2 + 8]
                    }
                    get bucketIndex() {
                        return this._structArray.uint16[this._pos2 + 9]
                    }
                    get anchorPoint() {
                        return new Te(this.anchorPointX,this.anchorPointY)
                    }
                }
                h.prototype.size = 20;
                class m extends ps {
                    get(t) {
                        return new h(this,t)
                    }
                }
                Ve("CollisionBoxArray", m);
                class y extends on {
                    get anchorX() {
                        return this._structArray.int16[this._pos2 + 0]
                    }
                    get anchorY() {
                        return this._structArray.int16[this._pos2 + 1]
                    }
                    get glyphStartIndex() {
                        return this._structArray.uint16[this._pos2 + 2]
                    }
                    get numGlyphs() {
                        return this._structArray.uint16[this._pos2 + 3]
                    }
                    get vertexStartIndex() {
                        return this._structArray.uint32[this._pos4 + 2]
                    }
                    get lineStartIndex() {
                        return this._structArray.uint32[this._pos4 + 3]
                    }
                    get lineLength() {
                        return this._structArray.uint32[this._pos4 + 4]
                    }
                    get segment() {
                        return this._structArray.uint16[this._pos2 + 10]
                    }
                    get lowerSize() {
                        return this._structArray.uint16[this._pos2 + 11]
                    }
                    get upperSize() {
                        return this._structArray.uint16[this._pos2 + 12]
                    }
                    get lineOffsetX() {
                        return this._structArray.float32[this._pos4 + 7]
                    }
                    get lineOffsetY() {
                        return this._structArray.float32[this._pos4 + 8]
                    }
                    get writingMode() {
                        return this._structArray.uint8[this._pos1 + 36]
                    }
                    get placedOrientation() {
                        return this._structArray.uint8[this._pos1 + 37]
                    }
                    set placedOrientation(t) {
                        this._structArray.uint8[this._pos1 + 37] = t
                    }
                    get hidden() {
                        return this._structArray.uint8[this._pos1 + 38]
                    }
                    set hidden(t) {
                        this._structArray.uint8[this._pos1 + 38] = t
                    }
                    get crossTileID() {
                        return this._structArray.uint32[this._pos4 + 10]
                    }
                    set crossTileID(t) {
                        this._structArray.uint32[this._pos4 + 10] = t
                    }
                    get associatedIconIndex() {
                        return this._structArray.int16[this._pos2 + 22]
                    }
                }
                y.prototype.size = 48;
                class v extends Vl {
                    get(t) {
                        return new y(this,t)
                    }
                }
                Ve("PlacedSymbolArray", v);
                class T extends on {
                    get anchorX() {
                        return this._structArray.int16[this._pos2 + 0]
                    }
                    get anchorY() {
                        return this._structArray.int16[this._pos2 + 1]
                    }
                    get rightJustifiedTextSymbolIndex() {
                        return this._structArray.int16[this._pos2 + 2]
                    }
                    get centerJustifiedTextSymbolIndex() {
                        return this._structArray.int16[this._pos2 + 3]
                    }
                    get leftJustifiedTextSymbolIndex() {
                        return this._structArray.int16[this._pos2 + 4]
                    }
                    get verticalPlacedTextSymbolIndex() {
                        return this._structArray.int16[this._pos2 + 5]
                    }
                    get placedIconSymbolIndex() {
                        return this._structArray.int16[this._pos2 + 6]
                    }
                    get verticalPlacedIconSymbolIndex() {
                        return this._structArray.int16[this._pos2 + 7]
                    }
                    get key() {
                        return this._structArray.uint16[this._pos2 + 8]
                    }
                    get textBoxStartIndex() {
                        return this._structArray.uint16[this._pos2 + 9]
                    }
                    get textBoxEndIndex() {
                        return this._structArray.uint16[this._pos2 + 10]
                    }
                    get verticalTextBoxStartIndex() {
                        return this._structArray.uint16[this._pos2 + 11]
                    }
                    get verticalTextBoxEndIndex() {
                        return this._structArray.uint16[this._pos2 + 12]
                    }
                    get iconBoxStartIndex() {
                        return this._structArray.uint16[this._pos2 + 13]
                    }
                    get iconBoxEndIndex() {
                        return this._structArray.uint16[this._pos2 + 14]
                    }
                    get verticalIconBoxStartIndex() {
                        return this._structArray.uint16[this._pos2 + 15]
                    }
                    get verticalIconBoxEndIndex() {
                        return this._structArray.uint16[this._pos2 + 16]
                    }
                    get featureIndex() {
                        return this._structArray.uint16[this._pos2 + 17]
                    }
                    get numHorizontalGlyphVertices() {
                        return this._structArray.uint16[this._pos2 + 18]
                    }
                    get numVerticalGlyphVertices() {
                        return this._structArray.uint16[this._pos2 + 19]
                    }
                    get numIconVertices() {
                        return this._structArray.uint16[this._pos2 + 20]
                    }
                    get numVerticalIconVertices() {
                        return this._structArray.uint16[this._pos2 + 21]
                    }
                    get useRuntimeCollisionCircles() {
                        return this._structArray.uint16[this._pos2 + 22]
                    }
                    get crossTileID() {
                        return this._structArray.uint32[this._pos4 + 12]
                    }
                    set crossTileID(t) {
                        this._structArray.uint32[this._pos4 + 12] = t
                    }
                    get textBoxScale() {
                        return this._structArray.float32[this._pos4 + 13]
                    }
                    get collisionCircleDiameter() {
                        return this._structArray.float32[this._pos4 + 14]
                    }
                    get textAnchorOffsetStartIndex() {
                        return this._structArray.uint16[this._pos2 + 30]
                    }
                    get textAnchorOffsetEndIndex() {
                        return this._structArray.uint16[this._pos2 + 31]
                    }
                }
                T.prototype.size = 64;
                class S extends xa {
                    get(t) {
                        return new T(this,t)
                    }
                }
                Ve("SymbolInstanceArray", S);
                class A extends va {
                    getoffsetX(t) {
                        return this.float32[1 * t + 0]
                    }
                }
                Ve("GlyphOffsetArray", A);
                class k extends fa {
                    getx(t) {
                        return this.int16[3 * t + 0]
                    }
                    gety(t) {
                        return this.int16[3 * t + 1]
                    }
                    gettileUnitDistanceFromAnchor(t) {
                        return this.int16[3 * t + 2]
                    }
                }
                Ve("SymbolLineVertexArray", k);
                class O extends on {
                    get textAnchor() {
                        return this._structArray.uint16[this._pos2 + 0]
                    }
                    get textOffset0() {
                        return this._structArray.float32[this._pos4 + 1]
                    }
                    get textOffset1() {
                        return this._structArray.float32[this._pos4 + 2]
                    }
                }
                O.prototype.size = 12;
                class V extends u {
                    get(t) {
                        return new O(this,t)
                    }
                }
                Ve("TextAnchorOffsetArray", V);
                class H extends on {
                    get featureIndex() {
                        return this._structArray.uint32[this._pos4 + 0]
                    }
                    get sourceLayerIndex() {
                        return this._structArray.uint16[this._pos2 + 2]
                    }
                    get bucketIndex() {
                        return this._structArray.uint16[this._pos2 + 3]
                    }
                }
                H.prototype.size = 8;
                class q extends e {
                    get(t) {
                        return new H(this,t)
                    }
                }
                Ve("FeatureIndexArray", q);
                class W extends Zs {
                }
                class J extends Zs {
                }
                class te extends Zs {
                }
                class ie extends xn {
                }
                class ne extends ma {
                }
                class le extends ds {
                }
                class se extends ga {
                }
                class _e extends wo {
                }
                class xe extends Nl {
                }
                class Pe extends Gs {
                }
                class Ie extends jl {
                }
                class Ce extends fs {
                }
                class Ne extends ya {
                }
                class Oe extends i {
                }
                const De = li([{
                    name: "a_pos",
                    components: 2,
                    type: "Int16"
                }], 4)
                  , {members: $e} = De;
                class Ke {
                    constructor(t=[]) {
                        this._forceNewSegmentOnNextPrepare = !1,
                        this.segments = t
                    }
                    prepareSegment(t, n, s, c) {
                        const d = this.segments[this.segments.length - 1];
                        return t > Ke.MAX_VERTEX_ARRAY_LENGTH && yi(`Max vertices per segment is ${Ke.MAX_VERTEX_ARRAY_LENGTH}: bucket requested ${t}. Consider using the \`fillLargeMeshArrays\` function if you require meshes with more than ${Ke.MAX_VERTEX_ARRAY_LENGTH} vertices.`),
                        this._forceNewSegmentOnNextPrepare || !d || d.vertexLength + t > Ke.MAX_VERTEX_ARRAY_LENGTH || d.sortKey !== c ? this.createNewSegment(n, s, c) : d
                    }
                    createNewSegment(t, n, s) {
                        const c = {
                            vertexOffset: t.length,
                            primitiveOffset: n.length,
                            vertexLength: 0,
                            primitiveLength: 0,
                            vaos: {}
                        };
                        return s !== void 0 && (c.sortKey = s),
                        this._forceNewSegmentOnNextPrepare = !1,
                        this.segments.push(c),
                        c
                    }
                    getOrCreateLatestSegment(t, n, s) {
                        return this.prepareSegment(0, t, n, s)
                    }
                    forceNewSegmentOnNextPrepare() {
                        this._forceNewSegmentOnNextPrepare = !0
                    }
                    get() {
                        return this.segments
                    }
                    destroy() {
                        for (const t of this.segments)
                            for (const n in t.vaos)
                                t.vaos[n].destroy()
                    }
                    static simpleSegment(t, n, s, c) {
                        return new Ke([{
                            vertexOffset: t,
                            primitiveOffset: n,
                            vertexLength: s,
                            primitiveLength: c,
                            vaos: {},
                            sortKey: 0
                        }])
                    }
                }
                function wt(r, t) {
                    return 256 * (r = si(Math.floor(r), 0, 255)) + si(Math.floor(t), 0, 255)
                }
                Ke.MAX_VERTEX_ARRAY_LENGTH = Math.pow(2, 16) - 1,
                Ve("SegmentVector", Ke);
                const Dt = li([{
                    name: "a_pattern_from",
                    components: 4,
                    type: "Uint16"
                }, {
                    name: "a_pattern_to",
                    components: 4,
                    type: "Uint16"
                }, {
                    name: "a_pixel_ratio_from",
                    components: 1,
                    type: "Uint16"
                }, {
                    name: "a_pixel_ratio_to",
                    components: 1,
                    type: "Uint16"
                }]);
                var Et, Zt, Ot, Ct = {
                    exports: {}
                }, At = {
                    exports: {}
                }, Ei = {
                    exports: {}
                }, Ai = function() {
                    if (Ot)
                        return Ct.exports;
                    Ot = 1;
                    var r = (Et || (Et = 1,
                    At.exports = function(n, s) {
                        var c, d, p, g, x, b, C, P;
                        for (d = n.length - (c = 3 & n.length),
                        p = s,
                        x = 3432918353,
                        b = 461845907,
                        P = 0; P < d; )
                            C = 255 & n.charCodeAt(P) | (255 & n.charCodeAt(++P)) << 8 | (255 & n.charCodeAt(++P)) << 16 | (255 & n.charCodeAt(++P)) << 24,
                            ++P,
                            p = 27492 + (65535 & (g = 5 * (65535 & (p = (p ^= C = (65535 & (C = (C = (65535 & C) * x + (((C >>> 16) * x & 65535) << 16) & 4294967295) << 15 | C >>> 17)) * b + (((C >>> 16) * b & 65535) << 16) & 4294967295) << 13 | p >>> 19)) + ((5 * (p >>> 16) & 65535) << 16) & 4294967295)) + ((58964 + (g >>> 16) & 65535) << 16);
                        switch (C = 0,
                        c) {
                        case 3:
                            C ^= (255 & n.charCodeAt(P + 2)) << 16;
                        case 2:
                            C ^= (255 & n.charCodeAt(P + 1)) << 8;
                        case 1:
                            p ^= C = (65535 & (C = (C = (65535 & (C ^= 255 & n.charCodeAt(P))) * x + (((C >>> 16) * x & 65535) << 16) & 4294967295) << 15 | C >>> 17)) * b + (((C >>> 16) * b & 65535) << 16) & 4294967295
                        }
                        return p ^= n.length,
                        p = 2246822507 * (65535 & (p ^= p >>> 16)) + ((2246822507 * (p >>> 16) & 65535) << 16) & 4294967295,
                        p = 3266489909 * (65535 & (p ^= p >>> 13)) + ((3266489909 * (p >>> 16) & 65535) << 16) & 4294967295,
                        (p ^= p >>> 16) >>> 0
                    }
                    ),
                    At.exports)
                      , t = (Zt || (Zt = 1,
                    Ei.exports = function(n, s) {
                        for (var c, d = n.length, p = s ^ d, g = 0; d >= 4; )
                            c = 1540483477 * (65535 & (c = 255 & n.charCodeAt(g) | (255 & n.charCodeAt(++g)) << 8 | (255 & n.charCodeAt(++g)) << 16 | (255 & n.charCodeAt(++g)) << 24)) + ((1540483477 * (c >>> 16) & 65535) << 16),
                            p = 1540483477 * (65535 & p) + ((1540483477 * (p >>> 16) & 65535) << 16) ^ (c = 1540483477 * (65535 & (c ^= c >>> 24)) + ((1540483477 * (c >>> 16) & 65535) << 16)),
                            d -= 4,
                            ++g;
                        switch (d) {
                        case 3:
                            p ^= (255 & n.charCodeAt(g + 2)) << 16;
                        case 2:
                            p ^= (255 & n.charCodeAt(g + 1)) << 8;
                        case 1:
                            p = 1540483477 * (65535 & (p ^= 255 & n.charCodeAt(g))) + ((1540483477 * (p >>> 16) & 65535) << 16)
                        }
                        return p = 1540483477 * (65535 & (p ^= p >>> 13)) + ((1540483477 * (p >>> 16) & 65535) << 16),
                        (p ^= p >>> 15) >>> 0
                    }
                    ),
                    Ei.exports);
                    return Ct.exports = r,
                    Ct.exports.murmur3 = r,
                    Ct.exports.murmur2 = t,
                    Ct.exports
                }(), vi = ce(Ai);
                class Bi {
                    constructor() {
                        this.ids = [],
                        this.positions = [],
                        this.indexed = !1
                    }
                    add(t, n, s, c) {
                        this.ids.push(Un(t)),
                        this.positions.push(n, s, c)
                    }
                    getPositions(t) {
                        if (!this.indexed)
                            throw new Error("Trying to get index, but feature positions are not indexed");
                        const n = Un(t);
                        let s = 0
                          , c = this.ids.length - 1;
                        for (; s < c; ) {
                            const p = s + c >> 1;
                            this.ids[p] >= n ? c = p : s = p + 1
                        }
                        const d = [];
                        for (; this.ids[s] === n; )
                            d.push({
                                index: this.positions[3 * s],
                                start: this.positions[3 * s + 1],
                                end: this.positions[3 * s + 2]
                            }),
                            s++;
                        return d
                    }
                    static serialize(t, n) {
                        const s = new Float64Array(t.ids)
                          , c = new Uint32Array(t.positions);
                        return vn(s, c, 0, s.length - 1),
                        n && n.push(s.buffer, c.buffer),
                        {
                            ids: s,
                            positions: c
                        }
                    }
                    static deserialize(t) {
                        const n = new Bi;
                        return n.ids = t.ids,
                        n.positions = t.positions,
                        n.indexed = !0,
                        n
                    }
                }
                function Un(r) {
                    const t = +r;
                    return !isNaN(t) && t <= Number.MAX_SAFE_INTEGER ? t : vi(String(r))
                }
                function vn(r, t, n, s) {
                    for (; n < s; ) {
                        const c = r[n + s >> 1];
                        let d = n - 1
                          , p = s + 1;
                        for (; ; ) {
                            do
                                d++;
                            while (r[d] < c);
                            do
                                p--;
                            while (r[p] > c);
                            if (d >= p)
                                break;
                            an(r, d, p),
                            an(t, 3 * d, 3 * p),
                            an(t, 3 * d + 1, 3 * p + 1),
                            an(t, 3 * d + 2, 3 * p + 2)
                        }
                        p - n < s - p ? (vn(r, t, n, p),
                        n = p + 1) : (vn(r, t, p + 1, s),
                        s = p)
                    }
                }
                function an(r, t, n) {
                    const s = r[t];
                    r[t] = r[n],
                    r[n] = s
                }
                Ve("FeaturePositionMap", Bi);
                class kr {
                    constructor(t, n) {
                        this.gl = t.gl,
                        this.location = n
                    }
                }
                class ms extends kr {
                    constructor(t, n) {
                        super(t, n),
                        this.current = 0
                    }
                    set(t) {
                        this.current !== t && (this.current = t,
                        this.gl.uniform1f(this.location, t))
                    }
                }
                class To extends kr {
                    constructor(t, n) {
                        super(t, n),
                        this.current = [0, 0, 0, 0]
                    }
                    set(t) {
                        t[0] === this.current[0] && t[1] === this.current[1] && t[2] === this.current[2] && t[3] === this.current[3] || (this.current = t,
                        this.gl.uniform4f(this.location, t[0], t[1], t[2], t[3]))
                    }
                }
                class gs extends kr {
                    constructor(t, n) {
                        super(t, n),
                        this.current = yt.transparent
                    }
                    set(t) {
                        t.r === this.current.r && t.g === this.current.g && t.b === this.current.b && t.a === this.current.a || (this.current = t,
                        this.gl.uniform4f(this.location, t.r, t.g, t.b, t.a))
                    }
                }
                const Lr = new Float32Array(16);
                function ln(r) {
                    return [wt(255 * r.r, 255 * r.g), wt(255 * r.b, 255 * r.a)]
                }
                class Zr {
                    constructor(t, n, s) {
                        this.value = t,
                        this.uniformNames = n.map(c => `u_${c}`),
                        this.type = s
                    }
                    setUniform(t, n, s) {
                        t.set(s.constantOr(this.value))
                    }
                    getBinding(t, n, s) {
                        return this.type === "color" ? new gs(t,n) : new ms(t,n)
                    }
                }
                class cn {
                    constructor(t, n) {
                        this.uniformNames = n.map(s => `u_${s}`),
                        this.patternFrom = null,
                        this.patternTo = null,
                        this.pixelRatioFrom = 1,
                        this.pixelRatioTo = 1
                    }
                    setConstantPatternPositions(t, n) {
                        this.pixelRatioFrom = n.pixelRatio,
                        this.pixelRatioTo = t.pixelRatio,
                        this.patternFrom = n.tlbr,
                        this.patternTo = t.tlbr
                    }
                    setUniform(t, n, s, c) {
                        const d = c === "u_pattern_to" ? this.patternTo : c === "u_pattern_from" ? this.patternFrom : c === "u_pixel_ratio_to" ? this.pixelRatioTo : c === "u_pixel_ratio_from" ? this.pixelRatioFrom : null;
                        d && t.set(d)
                    }
                    getBinding(t, n, s) {
                        return s.substr(0, 9) === "u_pattern" ? new To(t,n) : new ms(t,n)
                    }
                }
                class Rt {
                    constructor(t, n, s, c) {
                        this.expression = t,
                        this.type = s,
                        this.maxValue = 0,
                        this.paintVertexAttributes = n.map(d => ({
                            name: `a_${d}`,
                            type: "Float32",
                            components: s === "color" ? 2 : 1,
                            offset: 0
                        })),
                        this.paintVertexArray = new c
                    }
                    populatePaintArray(t, n, s, c, d) {
                        const p = this.paintVertexArray.length
                          , g = this.expression.evaluate(new Ut(0), n, {}, c, [], d);
                        this.paintVertexArray.resize(t),
                        this._setPaintValue(p, t, g)
                    }
                    updatePaintArray(t, n, s, c) {
                        const d = this.expression.evaluate({
                            zoom: 0
                        }, s, c);
                        this._setPaintValue(t, n, d)
                    }
                    _setPaintValue(t, n, s) {
                        if (this.type === "color") {
                            const c = ln(s);
                            for (let d = t; d < n; d++)
                                this.paintVertexArray.emplace(d, c[0], c[1])
                        } else {
                            for (let c = t; c < n; c++)
                                this.paintVertexArray.emplace(c, s);
                            this.maxValue = Math.max(this.maxValue, Math.abs(s))
                        }
                    }
                    upload(t) {
                        this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent))
                    }
                    destroy() {
                        this.paintVertexBuffer && this.paintVertexBuffer.destroy()
                    }
                }
                class kt {
                    constructor(t, n, s, c, d, p) {
                        this.expression = t,
                        this.uniformNames = n.map(g => `u_${g}_t`),
                        this.type = s,
                        this.useIntegerZoom = c,
                        this.zoom = d,
                        this.maxValue = 0,
                        this.paintVertexAttributes = n.map(g => ({
                            name: `a_${g}`,
                            type: "Float32",
                            components: s === "color" ? 4 : 2,
                            offset: 0
                        })),
                        this.paintVertexArray = new p
                    }
                    populatePaintArray(t, n, s, c, d) {
                        const p = this.expression.evaluate(new Ut(this.zoom), n, {}, c, [], d)
                          , g = this.expression.evaluate(new Ut(this.zoom + 1), n, {}, c, [], d)
                          , x = this.paintVertexArray.length;
                        this.paintVertexArray.resize(t),
                        this._setPaintValue(x, t, p, g)
                    }
                    updatePaintArray(t, n, s, c) {
                        const d = this.expression.evaluate({
                            zoom: this.zoom
                        }, s, c)
                          , p = this.expression.evaluate({
                            zoom: this.zoom + 1
                        }, s, c);
                        this._setPaintValue(t, n, d, p)
                    }
                    _setPaintValue(t, n, s, c) {
                        if (this.type === "color") {
                            const d = ln(s)
                              , p = ln(c);
                            for (let g = t; g < n; g++)
                                this.paintVertexArray.emplace(g, d[0], d[1], p[0], p[1])
                        } else {
                            for (let d = t; d < n; d++)
                                this.paintVertexArray.emplace(d, s, c);
                            this.maxValue = Math.max(this.maxValue, Math.abs(s), Math.abs(c))
                        }
                    }
                    upload(t) {
                        this.paintVertexArray && this.paintVertexArray.arrayBuffer && (this.paintVertexBuffer && this.paintVertexBuffer.buffer ? this.paintVertexBuffer.updateData(this.paintVertexArray) : this.paintVertexBuffer = t.createVertexBuffer(this.paintVertexArray, this.paintVertexAttributes, this.expression.isStateDependent))
                    }
                    destroy() {
                        this.paintVertexBuffer && this.paintVertexBuffer.destroy()
                    }
                    setUniform(t, n) {
                        const s = this.useIntegerZoom ? Math.floor(n.zoom) : n.zoom
                          , c = si(this.expression.interpolationFactor(s, this.zoom, this.zoom + 1), 0, 1);
                        t.set(c)
                    }
                    getBinding(t, n, s) {
                        return new ms(t,n)
                    }
                }
                class bi {
                    constructor(t, n, s, c, d, p) {
                        this.expression = t,
                        this.type = n,
                        this.useIntegerZoom = s,
                        this.zoom = c,
                        this.layerId = p,
                        this.zoomInPaintVertexArray = new d,
                        this.zoomOutPaintVertexArray = new d
                    }
                    populatePaintArray(t, n, s) {
                        const c = this.zoomInPaintVertexArray.length;
                        this.zoomInPaintVertexArray.resize(t),
                        this.zoomOutPaintVertexArray.resize(t),
                        this._setPaintValues(c, t, n.patterns && n.patterns[this.layerId], s)
                    }
                    updatePaintArray(t, n, s, c, d) {
                        this._setPaintValues(t, n, s.patterns && s.patterns[this.layerId], d)
                    }
                    _setPaintValues(t, n, s, c) {
                        if (!c || !s)
                            return;
                        const {min: d, mid: p, max: g} = s
                          , x = c[d]
                          , b = c[p]
                          , C = c[g];
                        if (x && b && C)
                            for (let P = t; P < n; P++)
                                this.zoomInPaintVertexArray.emplace(P, b.tl[0], b.tl[1], b.br[0], b.br[1], x.tl[0], x.tl[1], x.br[0], x.br[1], b.pixelRatio, x.pixelRatio),
                                this.zoomOutPaintVertexArray.emplace(P, b.tl[0], b.tl[1], b.br[0], b.br[1], C.tl[0], C.tl[1], C.br[0], C.br[1], b.pixelRatio, C.pixelRatio)
                    }
                    upload(t) {
                        this.zoomInPaintVertexArray && this.zoomInPaintVertexArray.arrayBuffer && this.zoomOutPaintVertexArray && this.zoomOutPaintVertexArray.arrayBuffer && (this.zoomInPaintVertexBuffer = t.createVertexBuffer(this.zoomInPaintVertexArray, Dt.members, this.expression.isStateDependent),
                        this.zoomOutPaintVertexBuffer = t.createVertexBuffer(this.zoomOutPaintVertexArray, Dt.members, this.expression.isStateDependent))
                    }
                    destroy() {
                        this.zoomOutPaintVertexBuffer && this.zoomOutPaintVertexBuffer.destroy(),
                        this.zoomInPaintVertexBuffer && this.zoomInPaintVertexBuffer.destroy()
                    }
                }
                class wi {
                    constructor(t, n, s) {
                        this.binders = {},
                        this._buffers = [];
                        const c = [];
                        for (const d in t.paint._values) {
                            if (!s(d))
                                continue;
                            const p = t.paint.get(d);
                            if (!(p instanceof zr && Rs(p.property.specification)))
                                continue;
                            const g = vh(d, t.type)
                              , x = p.value
                              , b = p.property.specification.type
                              , C = p.property.useIntegerZoom
                              , P = p.property.specification["property-type"]
                              , D = P === "cross-faded" || P === "cross-faded-data-driven";
                            if (x.kind === "constant")
                                this.binders[d] = D ? new cn(x.value,g) : new Zr(x.value,g,b),
                                c.push(`/u_${d}`);
                            else if (x.kind === "source" || D) {
                                const F = cu(d, b, "source");
                                this.binders[d] = D ? new bi(x,b,C,n,F,t.id) : new Rt(x,g,b,F),
                                c.push(`/a_${d}`)
                            } else {
                                const F = cu(d, b, "composite");
                                this.binders[d] = new kt(x,g,b,C,n,F),
                                c.push(`/z_${d}`)
                            }
                        }
                        this.cacheKey = c.sort().join("")
                    }
                    getMaxValue(t) {
                        const n = this.binders[t];
                        return n instanceof Rt || n instanceof kt ? n.maxValue : 0
                    }
                    populatePaintArrays(t, n, s, c, d) {
                        for (const p in this.binders) {
                            const g = this.binders[p];
                            (g instanceof Rt || g instanceof kt || g instanceof bi) && g.populatePaintArray(t, n, s, c, d)
                        }
                    }
                    setConstantPatternPositions(t, n) {
                        for (const s in this.binders) {
                            const c = this.binders[s];
                            c instanceof cn && c.setConstantPatternPositions(t, n)
                        }
                    }
                    updatePaintArrays(t, n, s, c, d) {
                        let p = !1;
                        for (const g in t) {
                            const x = n.getPositions(g);
                            for (const b of x) {
                                const C = s.feature(b.index);
                                for (const P in this.binders) {
                                    const D = this.binders[P];
                                    if ((D instanceof Rt || D instanceof kt || D instanceof bi) && D.expression.isStateDependent === !0) {
                                        const F = c.paint.get(P);
                                        D.expression = F.value,
                                        D.updatePaintArray(b.start, b.end, C, t[g], d),
                                        p = !0
                                    }
                                }
                            }
                        }
                        return p
                    }
                    defines() {
                        const t = [];
                        for (const n in this.binders) {
                            const s = this.binders[n];
                            (s instanceof Zr || s instanceof cn) && t.push(...s.uniformNames.map(c => `#define HAS_UNIFORM_${c}`))
                        }
                        return t
                    }
                    getBinderAttributes() {
                        const t = [];
                        for (const n in this.binders) {
                            const s = this.binders[n];
                            if (s instanceof Rt || s instanceof kt)
                                for (let c = 0; c < s.paintVertexAttributes.length; c++)
                                    t.push(s.paintVertexAttributes[c].name);
                            else if (s instanceof bi)
                                for (let c = 0; c < Dt.members.length; c++)
                                    t.push(Dt.members[c].name)
                        }
                        return t
                    }
                    getBinderUniforms() {
                        const t = [];
                        for (const n in this.binders) {
                            const s = this.binders[n];
                            if (s instanceof Zr || s instanceof cn || s instanceof kt)
                                for (const c of s.uniformNames)
                                    t.push(c)
                        }
                        return t
                    }
                    getPaintVertexBuffers() {
                        return this._buffers
                    }
                    getUniforms(t, n) {
                        const s = [];
                        for (const c in this.binders) {
                            const d = this.binders[c];
                            if (d instanceof Zr || d instanceof cn || d instanceof kt) {
                                for (const p of d.uniformNames)
                                    if (n[p]) {
                                        const g = d.getBinding(t, n[p], p);
                                        s.push({
                                            name: p,
                                            property: c,
                                            binding: g
                                        })
                                    }
                            }
                        }
                        return s
                    }
                    setUniforms(t, n, s, c) {
                        for (const {name: d, property: p, binding: g} of n)
                            this.binders[p].setUniform(g, c, s.get(p), d)
                    }
                    updatePaintBuffers(t) {
                        this._buffers = [];
                        for (const n in this.binders) {
                            const s = this.binders[n];
                            if (t && s instanceof bi) {
                                const c = t.fromScale === 2 ? s.zoomInPaintVertexBuffer : s.zoomOutPaintVertexBuffer;
                                c && this._buffers.push(c)
                            } else
                                (s instanceof Rt || s instanceof kt) && s.paintVertexBuffer && this._buffers.push(s.paintVertexBuffer)
                        }
                    }
                    upload(t) {
                        for (const n in this.binders) {
                            const s = this.binders[n];
                            (s instanceof Rt || s instanceof kt || s instanceof bi) && s.upload(t)
                        }
                        this.updatePaintBuffers()
                    }
                    destroy() {
                        for (const t in this.binders) {
                            const n = this.binders[t];
                            (n instanceof Rt || n instanceof kt || n instanceof bi) && n.destroy()
                        }
                    }
                }
                class _s {
                    constructor(t, n, s= () => !0) {
                        this.programConfigurations = {};
                        for (const c of t)
                            this.programConfigurations[c.id] = new wi(c,n,s);
                        this.needsUpload = !1,
                        this._featureMap = new Bi,
                        this._bufferOffset = 0
                    }
                    populatePaintArrays(t, n, s, c, d, p) {
                        for (const g in this.programConfigurations)
                            this.programConfigurations[g].populatePaintArrays(t, n, c, d, p);
                        n.id !== void 0 && this._featureMap.add(n.id, s, this._bufferOffset, t),
                        this._bufferOffset = t,
                        this.needsUpload = !0
                    }
                    updatePaintArrays(t, n, s, c) {
                        for (const d of s)
                            this.needsUpload = this.programConfigurations[d.id].updatePaintArrays(t, this._featureMap, n, d, c) || this.needsUpload
                    }
                    get(t) {
                        return this.programConfigurations[t]
                    }
                    upload(t) {
                        if (this.needsUpload) {
                            for (const n in this.programConfigurations)
                                this.programConfigurations[n].upload(t);
                            this.needsUpload = !1
                        }
                    }
                    destroy() {
                        for (const t in this.programConfigurations)
                            this.programConfigurations[t].destroy()
                    }
                }
                function vh(r, t) {
                    return {
                        "text-opacity": ["opacity"],
                        "icon-opacity": ["opacity"],
                        "text-color": ["fill_color"],
                        "icon-color": ["fill_color"],
                        "text-halo-color": ["halo_color"],
                        "icon-halo-color": ["halo_color"],
                        "text-halo-blur": ["halo_blur"],
                        "icon-halo-blur": ["halo_blur"],
                        "text-halo-width": ["halo_width"],
                        "icon-halo-width": ["halo_width"],
                        "line-gap-width": ["gapwidth"],
                        "line-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"],
                        "fill-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"],
                        "fill-extrusion-pattern": ["pattern_to", "pattern_from", "pixel_ratio_to", "pixel_ratio_from"]
                    }[r] || [r.replace(`${t}-`, "").replace(/-/g, "_")]
                }
                function cu(r, t, n) {
                    const s = {
                        color: {
                            source: ds,
                            composite: a
                        },
                        number: {
                            source: va,
                            composite: ds
                        }
                    }
                      , c = function(d) {
                        return {
                            "line-pattern": {
                                source: se,
                                composite: se
                            },
                            "fill-pattern": {
                                source: se,
                                composite: se
                            },
                            "fill-extrusion-pattern": {
                                source: se,
                                composite: se
                            }
                        }[d]
                    }(r);
                    return c && c[n] || s[t][n]
                }
                Ve("ConstantBinder", Zr),
                Ve("CrossFadedConstantBinder", cn),
                Ve("SourceExpressionBinder", Rt),
                Ve("CrossFadedCompositeBinder", bi),
                Ve("CompositeExpressionBinder", kt),
                Ve("ProgramConfiguration", wi, {
                    omit: ["_buffers"]
                }),
                Ve("ProgramConfigurationSet", _s);
                const Ul = Math.pow(2, 14) - 1
                  , uu = -Ul - 1;
                function ys(r) {
                    const t = ut / r.extent
                      , n = r.loadGeometry();
                    for (let s = 0; s < n.length; s++) {
                        const c = n[s];
                        for (let d = 0; d < c.length; d++) {
                            const p = c[d]
                              , g = Math.round(p.x * t)
                              , x = Math.round(p.y * t);
                            p.x = si(g, uu, Ul),
                            p.y = si(x, uu, Ul),
                            (g < p.x || g > p.x + 1 || x < p.y || x > p.y + 1) && yi("Geometry exceeds allowed extent, reduce your vector tile buffer size")
                        }
                    }
                    return n
                }
                function hr(r, t) {
                    return {
                        type: r.type,
                        id: r.id,
                        properties: r.properties,
                        geometry: t ? ys(r) : []
                    }
                }
                const Zl = -32768;
                function hu(r, t, n, s, c) {
                    r.emplaceBack(Zl + 8 * t + s, Zl + 8 * n + c)
                }
                class ba {
                    constructor(t) {
                        this.zoom = t.zoom,
                        this.overscaling = t.overscaling,
                        this.layers = t.layers,
                        this.layerIds = this.layers.map(n => n.id),
                        this.index = t.index,
                        this.hasPattern = !1,
                        this.layoutVertexArray = new J,
                        this.indexArray = new Ne,
                        this.segments = new Ke,
                        this.programConfigurations = new _s(t.layers,t.zoom),
                        this.stateDependentLayerIds = this.layers.filter(n => n.isStateDependent()).map(n => n.id)
                    }
                    populate(t, n, s) {
                        const c = this.layers[0]
                          , d = [];
                        let p = null
                          , g = !1
                          , x = c.type === "heatmap";
                        if (c.type === "circle") {
                            const C = c;
                            p = C.layout.get("circle-sort-key"),
                            g = !p.isConstant(),
                            x = x || C.paint.get("circle-pitch-alignment") === "map"
                        }
                        const b = x ? n.subdivisionGranularity.circle : 1;
                        for (const {feature: C, id: P, index: D, sourceLayerIndex: F} of t) {
                            const B = this.layers[0]._featureFilter.needGeometry
                              , j = hr(C, B);
                            if (!this.layers[0]._featureFilter.filter(new Ut(this.zoom), j, s))
                                continue;
                            const G = g ? p.evaluate(j, {}, s) : void 0
                              , X = {
                                id: P,
                                properties: C.properties,
                                type: C.type,
                                sourceLayerIndex: F,
                                index: D,
                                geometry: B ? j.geometry : ys(C),
                                patterns: {},
                                sortKey: G
                            };
                            d.push(X)
                        }
                        g && d.sort( (C, P) => C.sortKey - P.sortKey);
                        for (const C of d) {
                            const {geometry: P, index: D, sourceLayerIndex: F} = C
                              , B = t[D].feature;
                            this.addFeature(C, P, D, s, b),
                            n.featureIndex.insert(B, P, D, F, this.index)
                        }
                    }
                    update(t, n, s) {
                        this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, n, this.stateDependentLayers, s)
                    }
                    isEmpty() {
                        return this.layoutVertexArray.length === 0
                    }
                    uploadPending() {
                        return !this.uploaded || this.programConfigurations.needsUpload
                    }
                    upload(t) {
                        this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, $e),
                        this.indexBuffer = t.createIndexBuffer(this.indexArray)),
                        this.programConfigurations.upload(t),
                        this.uploaded = !0
                    }
                    destroy() {
                        this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(),
                        this.indexBuffer.destroy(),
                        this.programConfigurations.destroy(),
                        this.segments.destroy())
                    }
                    addFeature(t, n, s, c, d=1) {
                        let p;
                        switch (d) {
                        case 1:
                            p = [0, 7];
                            break;
                        case 3:
                            p = [0, 2, 5, 7];
                            break;
                        case 5:
                            p = [0, 1, 3, 4, 6, 7];
                            break;
                        case 7:
                            p = [0, 1, 2, 3, 4, 5, 6, 7];
                            break;
                        default:
                            throw new Error(`Invalid circle bucket granularity: ${d}; valid values are 1, 3, 5, 7.`)
                        }
                        const g = p.length;
                        for (const x of n)
                            for (const b of x) {
                                const C = b.x
                                  , P = b.y;
                                if (C < 0 || C >= ut || P < 0 || P >= ut)
                                    continue;
                                const D = this.segments.prepareSegment(g * g, this.layoutVertexArray, this.indexArray, t.sortKey)
                                  , F = D.vertexLength;
                                for (let B = 0; B < g; B++)
                                    for (let j = 0; j < g; j++)
                                        hu(this.layoutVertexArray, C, P, p[j], p[B]);
                                for (let B = 0; B < g - 1; B++)
                                    for (let j = 0; j < g - 1; j++) {
                                        const G = F + B * g + j
                                          , X = F + (B + 1) * g + j;
                                        this.indexArray.emplaceBack(G, X + 1, G + 1),
                                        this.indexArray.emplaceBack(G, X, X + 1)
                                    }
                                D.vertexLength += g * g,
                                D.primitiveLength += (g - 1) * (g - 1) * 2
                            }
                        this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, s, {}, c)
                    }
                }
                function wa(r, t) {
                    for (let n = 0; n < r.length; n++)
                        if (Ma(t, r[n]))
                            return !0;
                    for (let n = 0; n < t.length; n++)
                        if (Ma(r, t[n]))
                            return !0;
                    return !!bh(r, t)
                }
                function du(r, t, n) {
                    return !!Ma(r, t) || !!wh(t, r, n)
                }
                function Ta(r, t) {
                    if (r.length === 1)
                        return $d(t, r[0]);
                    for (let n = 0; n < t.length; n++) {
                        const s = t[n];
                        for (let c = 0; c < s.length; c++)
                            if (Ma(r, s[c]))
                                return !0
                    }
                    for (let n = 0; n < r.length; n++)
                        if ($d(t, r[n]))
                            return !0;
                    for (let n = 0; n < t.length; n++)
                        if (bh(r, t[n]))
                            return !0;
                    return !1
                }
                function Vm(r, t, n) {
                    if (r.length > 1) {
                        if (bh(r, t))
                            return !0;
                        for (let s = 0; s < t.length; s++)
                            if (wh(t[s], r, n))
                                return !0
                    }
                    for (let s = 0; s < r.length; s++)
                        if (wh(r[s], t, n))
                            return !0;
                    return !1
                }
                function bh(r, t) {
                    if (r.length === 0 || t.length === 0)
                        return !1;
                    for (let n = 0; n < r.length - 1; n++) {
                        const s = r[n]
                          , c = r[n + 1];
                        for (let d = 0; d < t.length - 1; d++)
                            if (Um(s, c, t[d], t[d + 1]))
                                return !0
                    }
                    return !1
                }
                function Um(r, t, n, s) {
                    return ii(r, n, s) !== ii(t, n, s) && ii(r, t, n) !== ii(r, t, s)
                }
                function wh(r, t, n) {
                    const s = n * n;
                    if (t.length === 1)
                        return r.distSqr(t[0]) < s;
                    for (let c = 1; c < t.length; c++)
                        if (Gd(r, t[c - 1], t[c]) < s)
                            return !0;
                    return !1
                }
                function Gd(r, t, n) {
                    const s = t.distSqr(n);
                    if (s === 0)
                        return r.distSqr(t);
                    const c = ((r.x - t.x) * (n.x - t.x) + (r.y - t.y) * (n.y - t.y)) / s;
                    return r.distSqr(c < 0 ? t : c > 1 ? n : n.sub(t)._mult(c)._add(t))
                }
                function $d(r, t) {
                    let n, s, c, d = !1;
                    for (let p = 0; p < r.length; p++) {
                        n = r[p];
                        for (let g = 0, x = n.length - 1; g < n.length; x = g++)
                            s = n[g],
                            c = n[x],
                            s.y > t.y != c.y > t.y && t.x < (c.x - s.x) * (t.y - s.y) / (c.y - s.y) + s.x && (d = !d)
                    }
                    return d
                }
                function Ma(r, t) {
                    let n = !1;
                    for (let s = 0, c = r.length - 1; s < r.length; c = s++) {
                        const d = r[s]
                          , p = r[c];
                        d.y > t.y != p.y > t.y && t.x < (p.x - d.x) * (t.y - d.y) / (p.y - d.y) + d.x && (n = !n)
                    }
                    return n
                }
                function Zm(r, t, n) {
                    const s = n[0]
                      , c = n[2];
                    if (r.x < s.x && t.x < s.x || r.x > c.x && t.x > c.x || r.y < s.y && t.y < s.y || r.y > c.y && t.y > c.y)
                        return !1;
                    const d = ii(r, t, n[0]);
                    return d !== ii(r, t, n[1]) || d !== ii(r, t, n[2]) || d !== ii(r, t, n[3])
                }
                function Gl(r, t, n) {
                    const s = t.paint.get(r).value;
                    return s.kind === "constant" ? s.value : n.programConfigurations.get(t.id).getMaxValue(r)
                }
                function pu(r) {
                    return Math.sqrt(r[0] * r[0] + r[1] * r[1])
                }
                function fu(r, t, n, s, c) {
                    if (!t[0] && !t[1])
                        return r;
                    const d = Te.convert(t)._mult(c);
                    n === "viewport" && d._rotate(-s);
                    const p = [];
                    for (let g = 0; g < r.length; g++)
                        p.push(r[g].sub(d));
                    return p
                }
                let qd, Hd;
                Ve("CircleBucket", ba, {
                    omit: ["layers"]
                });
                var Gm = {
                    get paint() {
                        return Hd = Hd || new rr({
                            "circle-radius": new et(E.paint_circle["circle-radius"]),
                            "circle-color": new et(E.paint_circle["circle-color"]),
                            "circle-blur": new et(E.paint_circle["circle-blur"]),
                            "circle-opacity": new et(E.paint_circle["circle-opacity"]),
                            "circle-translate": new Xe(E.paint_circle["circle-translate"]),
                            "circle-translate-anchor": new Xe(E.paint_circle["circle-translate-anchor"]),
                            "circle-pitch-scale": new Xe(E.paint_circle["circle-pitch-scale"]),
                            "circle-pitch-alignment": new Xe(E.paint_circle["circle-pitch-alignment"]),
                            "circle-stroke-width": new et(E.paint_circle["circle-stroke-width"]),
                            "circle-stroke-color": new et(E.paint_circle["circle-stroke-color"]),
                            "circle-stroke-opacity": new et(E.paint_circle["circle-stroke-opacity"])
                        })
                    },
                    get layout() {
                        return qd = qd || new rr({
                            "circle-sort-key": new et(E.layout_circle["circle-sort-key"])
                        })
                    }
                };
                class $m extends sn {
                    constructor(t) {
                        super(t, Gm)
                    }
                    createBucket(t) {
                        return new ba(t)
                    }
                    queryRadius(t) {
                        const n = t;
                        return Gl("circle-radius", this, n) + Gl("circle-stroke-width", this, n) + pu(this.paint.get("circle-translate"))
                    }
                    queryIntersectsFeature({queryGeometry: t, feature: n, featureState: s, geometry: c, transform: d, pixelsToTileUnits: p, pixelPosMatrix: g}) {
                        const x = fu(t, this.paint.get("circle-translate"), this.paint.get("circle-translate-anchor"), -d.bearingInRadians, p)
                          , b = this.paint.get("circle-radius").evaluate(n, s) + this.paint.get("circle-stroke-width").evaluate(n, s)
                          , C = this.paint.get("circle-pitch-alignment") === "map"
                          , P = C ? x : function(F, B) {
                            return F.map(j => Wd(j, B))
                        }(x, g)
                          , D = C ? b * p : b;
                        for (const F of c)
                            for (const B of F) {
                                const j = C ? B : Wd(B, g);
                                let G = D;
                                const X = Wi([], [B.x, B.y, 0, 1], g);
                                if (this.paint.get("circle-pitch-scale") === "viewport" && this.paint.get("circle-pitch-alignment") === "map" ? G *= X[3] / d.cameraToCenterDistance : this.paint.get("circle-pitch-scale") === "map" && this.paint.get("circle-pitch-alignment") === "viewport" && (G *= d.cameraToCenterDistance / X[3]),
                                du(P, j, G))
                                    return !0
                            }
                        return !1
                    }
                }
                function Wd(r, t) {
                    const n = Wi([], [r.x, r.y, 0, 1], t);
                    return new Te(n[0] / n[3],n[1] / n[3])
                }
                class Xd extends ba {
                }
                let Kd;
                Ve("HeatmapBucket", Xd, {
                    omit: ["layers"]
                });
                var qm = {
                    get paint() {
                        return Kd = Kd || new rr({
                            "heatmap-radius": new et(E.paint_heatmap["heatmap-radius"]),
                            "heatmap-weight": new et(E.paint_heatmap["heatmap-weight"]),
                            "heatmap-intensity": new Xe(E.paint_heatmap["heatmap-intensity"]),
                            "heatmap-color": new Bl(E.paint_heatmap["heatmap-color"]),
                            "heatmap-opacity": new Xe(E.paint_heatmap["heatmap-opacity"])
                        })
                    }
                };
                function Th(r, {width: t, height: n}, s, c) {
                    if (c) {
                        if (c instanceof Uint8ClampedArray)
                            c = new Uint8Array(c.buffer);
                        else if (c.length !== t * n * s)
                            throw new RangeError(`mismatched image size. expected: ${c.length} but got: ${t * n * s}`)
                    } else
                        c = new Uint8Array(t * n * s);
                    return r.width = t,
                    r.height = n,
                    r.data = c,
                    r
                }
                function Jd(r, {width: t, height: n}, s) {
                    if (t === r.width && n === r.height)
                        return;
                    const c = Th({}, {
                        width: t,
                        height: n
                    }, s);
                    Mh(r, c, {
                        x: 0,
                        y: 0
                    }, {
                        x: 0,
                        y: 0
                    }, {
                        width: Math.min(r.width, t),
                        height: Math.min(r.height, n)
                    }, s),
                    r.width = t,
                    r.height = n,
                    r.data = c.data
                }
                function Mh(r, t, n, s, c, d) {
                    if (c.width === 0 || c.height === 0)
                        return t;
                    if (c.width > r.width || c.height > r.height || n.x > r.width - c.width || n.y > r.height - c.height)
                        throw new RangeError("out of range source coordinates for image copy");
                    if (c.width > t.width || c.height > t.height || s.x > t.width - c.width || s.y > t.height - c.height)
                        throw new RangeError("out of range destination coordinates for image copy");
                    const p = r.data
                      , g = t.data;
                    if (p === g)
                        throw new Error("srcData equals dstData, so image is already copied");
                    for (let x = 0; x < c.height; x++) {
                        const b = ((n.y + x) * r.width + n.x) * d
                          , C = ((s.y + x) * t.width + s.x) * d;
                        for (let P = 0; P < c.width * d; P++)
                            g[C + P] = p[b + P]
                    }
                    return t
                }
                class $l {
                    constructor(t, n) {
                        Th(this, t, 1, n)
                    }
                    resize(t) {
                        Jd(this, t, 1)
                    }
                    clone() {
                        return new $l({
                            width: this.width,
                            height: this.height
                        },new Uint8Array(this.data))
                    }
                    static copy(t, n, s, c, d) {
                        Mh(t, n, s, c, d, 1)
                    }
                }
                class Gr {
                    constructor(t, n) {
                        Th(this, t, 4, n)
                    }
                    resize(t) {
                        Jd(this, t, 4)
                    }
                    replace(t, n) {
                        n ? this.data.set(t) : this.data = t instanceof Uint8ClampedArray ? new Uint8Array(t.buffer) : t
                    }
                    clone() {
                        return new Gr({
                            width: this.width,
                            height: this.height
                        },new Uint8Array(this.data))
                    }
                    static copy(t, n, s, c, d) {
                        Mh(t, n, s, c, d, 4)
                    }
                }
                function Yd(r) {
                    const t = {}
                      , n = r.resolution || 256
                      , s = r.clips ? r.clips.length : 1
                      , c = r.image || new Gr({
                        width: n,
                        height: s
                    });
                    if (Math.log(n) / Math.LN2 % 1 != 0)
                        throw new Error(`width is not a power of 2 - ${n}`);
                    const d = (p, g, x) => {
                        t[r.evaluationKey] = x;
                        const b = r.expression.evaluate(t);
                        c.data[p + g + 0] = Math.floor(255 * b.r / b.a),
                        c.data[p + g + 1] = Math.floor(255 * b.g / b.a),
                        c.data[p + g + 2] = Math.floor(255 * b.b / b.a),
                        c.data[p + g + 3] = Math.floor(255 * b.a)
                    }
                    ;
                    if (r.clips)
                        for (let p = 0, g = 0; p < s; ++p,
                        g += 4 * n)
                            for (let x = 0, b = 0; x < n; x++,
                            b += 4) {
                                const C = x / (n - 1)
                                  , {start: P, end: D} = r.clips[p];
                                d(g, b, P * (1 - C) + D * C)
                            }
                    else
                        for (let p = 0, g = 0; p < n; p++,
                        g += 4)
                            d(0, g, p / (n - 1));
                    return c
                }
                Ve("AlphaImage", $l),
                Ve("RGBAImage", Gr);
                const Ch = "big-fb";
                class Hm extends sn {
                    createBucket(t) {
                        return new Xd(t)
                    }
                    constructor(t) {
                        super(t, qm),
                        this.heatmapFbos = new Map,
                        this._updateColorRamp()
                    }
                    _handleSpecialPaintPropertyUpdate(t) {
                        t === "heatmap-color" && this._updateColorRamp()
                    }
                    _updateColorRamp() {
                        this.colorRamp = Yd({
                            expression: this._transitionablePaint._values["heatmap-color"].value.expression,
                            evaluationKey: "heatmapDensity",
                            image: this.colorRamp
                        }),
                        this.colorRampTexture = null
                    }
                    resize() {
                        this.heatmapFbos.has(Ch) && this.heatmapFbos.delete(Ch)
                    }
                    queryRadius() {
                        return 0
                    }
                    queryIntersectsFeature() {
                        return !1
                    }
                    hasOffscreenPass() {
                        return this.paint.get("heatmap-opacity") !== 0 && this.visibility !== "none"
                    }
                }
                let Qd;
                var Wm = {
                    get paint() {
                        return Qd = Qd || new rr({
                            "hillshade-illumination-direction": new Xe(E.paint_hillshade["hillshade-illumination-direction"]),
                            "hillshade-illumination-anchor": new Xe(E.paint_hillshade["hillshade-illumination-anchor"]),
                            "hillshade-exaggeration": new Xe(E.paint_hillshade["hillshade-exaggeration"]),
                            "hillshade-shadow-color": new Xe(E.paint_hillshade["hillshade-shadow-color"]),
                            "hillshade-highlight-color": new Xe(E.paint_hillshade["hillshade-highlight-color"]),
                            "hillshade-accent-color": new Xe(E.paint_hillshade["hillshade-accent-color"])
                        })
                    }
                };
                class Xm extends sn {
                    constructor(t) {
                        super(t, Wm)
                    }
                    hasOffscreenPass() {
                        return this.paint.get("hillshade-exaggeration") !== 0 && this.visibility !== "none"
                    }
                }
                const Km = li([{
                    name: "a_pos",
                    components: 2,
                    type: "Int16"
                }], 4)
                  , {members: Jm} = Km;
                function Ph(r, t, n) {
                    const s = n.patternDependencies;
                    let c = !1;
                    for (const d of t) {
                        const p = d.paint.get(`${r}-pattern`);
                        p.isConstant() || (c = !0);
                        const g = p.constantOr(null);
                        g && (c = !0,
                        s[g.to] = !0,
                        s[g.from] = !0)
                    }
                    return c
                }
                function Sh(r, t, n, s, c) {
                    const d = c.patternDependencies;
                    for (const p of t) {
                        const g = p.paint.get(`${r}-pattern`).value;
                        if (g.kind !== "constant") {
                            let x = g.evaluate({
                                zoom: s - 1
                            }, n, {}, c.availableImages)
                              , b = g.evaluate({
                                zoom: s
                            }, n, {}, c.availableImages)
                              , C = g.evaluate({
                                zoom: s + 1
                            }, n, {}, c.availableImages);
                            x = x && x.name ? x.name : x,
                            b = b && b.name ? b.name : b,
                            C = C && C.name ? C.name : C,
                            d[x] = !0,
                            d[b] = !0,
                            d[C] = !0,
                            n.patterns[p.id] = {
                                min: x,
                                mid: b,
                                max: C
                            }
                        }
                    }
                    return n
                }
                function ep(r, t, n, s, c) {
                    let d;
                    if (c === function(p, g, x, b) {
                        let C = 0;
                        for (let P = g, D = x - b; P < x; P += b)
                            C += (p[D] - p[P]) * (p[P + 1] + p[D + 1]),
                            D = P;
                        return C
                    }(r, t, n, s) > 0)
                        for (let p = t; p < n; p += s)
                            d = np(p / s | 0, r[p], r[p + 1], d);
                    else
                        for (let p = n - s; p >= t; p -= s)
                            d = np(p / s | 0, r[p], r[p + 1], d);
                    return d && Ca(d, d.next) && (Xl(d),
                    d = d.next),
                    d
                }
                function Mo(r, t) {
                    if (!r)
                        return r;
                    t || (t = r);
                    let n, s = r;
                    do
                        if (n = !1,
                        s.steiner || !Ca(s, s.next) && ci(s.prev, s, s.next) !== 0)
                            s = s.next;
                        else {
                            if (Xl(s),
                            s = t = s.prev,
                            s === s.next)
                                break;
                            n = !0
                        }
                    while (n || s !== t);
                    return t
                }
                function ql(r, t, n, s, c, d, p) {
                    if (!r)
                        return;
                    !p && d && function(x, b, C, P) {
                        let D = x;
                        do
                            D.z === 0 && (D.z = Ih(D.x, D.y, b, C, P)),
                            D.prevZ = D.prev,
                            D.nextZ = D.next,
                            D = D.next;
                        while (D !== x);
                        D.prevZ.nextZ = null,
                        D.prevZ = null,
                        function(F) {
                            let B, j = 1;
                            do {
                                let G, X = F;
                                F = null;
                                let ae = null;
                                for (B = 0; X; ) {
                                    B++;
                                    let Q = X
                                      , R = 0;
                                    for (let ee = 0; ee < j && (R++,
                                    Q = Q.nextZ,
                                    Q); ee++)
                                        ;
                                    let Z = j;
                                    for (; R > 0 || Z > 0 && Q; )
                                        R !== 0 && (Z === 0 || !Q || X.z <= Q.z) ? (G = X,
                                        X = X.nextZ,
                                        R--) : (G = Q,
                                        Q = Q.nextZ,
                                        Z--),
                                        ae ? ae.nextZ = G : F = G,
                                        G.prevZ = ae,
                                        ae = G;
                                    X = Q
                                }
                                ae.nextZ = null,
                                j *= 2
                            } while (B > 1)
                        }(D)
                    }(r, s, c, d);
                    let g = r;
                    for (; r.prev !== r.next; ) {
                        const x = r.prev
                          , b = r.next;
                        if (d ? Qm(r, s, c, d) : Ym(r))
                            t.push(x.i, r.i, b.i),
                            Xl(r),
                            r = b.next,
                            g = b.next;
                        else if ((r = b) === g) {
                            p ? p === 1 ? ql(r = eg(Mo(r), t), t, n, s, c, d, 2) : p === 2 && tg(r, t, n, s, c, d) : ql(Mo(r), t, n, s, c, d, 1);
                            break
                        }
                    }
                }
                function Ym(r) {
                    const t = r.prev
                      , n = r
                      , s = r.next;
                    if (ci(t, n, s) >= 0)
                        return !1;
                    const c = t.x
                      , d = n.x
                      , p = s.x
                      , g = t.y
                      , x = n.y
                      , b = s.y
                      , C = Math.min(c, d, p)
                      , P = Math.min(g, x, b)
                      , D = Math.max(c, d, p)
                      , F = Math.max(g, x, b);
                    let B = s.next;
                    for (; B !== t; ) {
                        if (B.x >= C && B.x <= D && B.y >= P && B.y <= F && Hl(c, g, d, x, p, b, B.x, B.y) && ci(B.prev, B, B.next) >= 0)
                            return !1;
                        B = B.next
                    }
                    return !0
                }
                function Qm(r, t, n, s) {
                    const c = r.prev
                      , d = r
                      , p = r.next;
                    if (ci(c, d, p) >= 0)
                        return !1;
                    const g = c.x
                      , x = d.x
                      , b = p.x
                      , C = c.y
                      , P = d.y
                      , D = p.y
                      , F = Math.min(g, x, b)
                      , B = Math.min(C, P, D)
                      , j = Math.max(g, x, b)
                      , G = Math.max(C, P, D)
                      , X = Ih(F, B, t, n, s)
                      , ae = Ih(j, G, t, n, s);
                    let Q = r.prevZ
                      , R = r.nextZ;
                    for (; Q && Q.z >= X && R && R.z <= ae; ) {
                        if (Q.x >= F && Q.x <= j && Q.y >= B && Q.y <= G && Q !== c && Q !== p && Hl(g, C, x, P, b, D, Q.x, Q.y) && ci(Q.prev, Q, Q.next) >= 0 || (Q = Q.prevZ,
                        R.x >= F && R.x <= j && R.y >= B && R.y <= G && R !== c && R !== p && Hl(g, C, x, P, b, D, R.x, R.y) && ci(R.prev, R, R.next) >= 0))
                            return !1;
                        R = R.nextZ
                    }
                    for (; Q && Q.z >= X; ) {
                        if (Q.x >= F && Q.x <= j && Q.y >= B && Q.y <= G && Q !== c && Q !== p && Hl(g, C, x, P, b, D, Q.x, Q.y) && ci(Q.prev, Q, Q.next) >= 0)
                            return !1;
                        Q = Q.prevZ
                    }
                    for (; R && R.z <= ae; ) {
                        if (R.x >= F && R.x <= j && R.y >= B && R.y <= G && R !== c && R !== p && Hl(g, C, x, P, b, D, R.x, R.y) && ci(R.prev, R, R.next) >= 0)
                            return !1;
                        R = R.nextZ
                    }
                    return !0
                }
                function eg(r, t) {
                    let n = r;
                    do {
                        const s = n.prev
                          , c = n.next.next;
                        !Ca(s, c) && ip(s, n, n.next, c) && Wl(s, c) && Wl(c, s) && (t.push(s.i, n.i, c.i),
                        Xl(n),
                        Xl(n.next),
                        n = r = c),
                        n = n.next
                    } while (n !== r);
                    return Mo(n)
                }
                function tg(r, t, n, s, c, d) {
                    let p = r;
                    do {
                        let g = p.next.next;
                        for (; g !== p.prev; ) {
                            if (p.i !== g.i && og(p, g)) {
                                let x = rp(p, g);
                                return p = Mo(p, p.next),
                                x = Mo(x, x.next),
                                ql(p, t, n, s, c, d, 0),
                                void ql(x, t, n, s, c, d, 0)
                            }
                            g = g.next
                        }
                        p = p.next
                    } while (p !== r)
                }
                function ig(r, t) {
                    let n = r.x - t.x;
                    return n === 0 && (n = r.y - t.y,
                    n === 0) && (n = (r.next.y - r.y) / (r.next.x - r.x) - (t.next.y - t.y) / (t.next.x - t.x)),
                    n
                }
                function rg(r, t) {
                    const n = function(c, d) {
                        let p = d;
                        const g = c.x
                          , x = c.y;
                        let b, C = -1 / 0;
                        if (Ca(c, p))
                            return p;
                        do {
                            if (Ca(c, p.next))
                                return p.next;
                            if (x <= p.y && x >= p.next.y && p.next.y !== p.y) {
                                const j = p.x + (x - p.y) * (p.next.x - p.x) / (p.next.y - p.y);
                                if (j <= g && j > C && (C = j,
                                b = p.x < p.next.x ? p : p.next,
                                j === g))
                                    return b
                            }
                            p = p.next
                        } while (p !== d);
                        if (!b)
                            return null;
                        const P = b
                          , D = b.x
                          , F = b.y;
                        let B = 1 / 0;
                        p = b;
                        do {
                            if (g >= p.x && p.x >= D && g !== p.x && tp(x < F ? g : C, x, D, F, x < F ? C : g, x, p.x, p.y)) {
                                const j = Math.abs(x - p.y) / (g - p.x);
                                Wl(p, c) && (j < B || j === B && (p.x > b.x || p.x === b.x && ng(b, p))) && (b = p,
                                B = j)
                            }
                            p = p.next
                        } while (p !== P);
                        return b
                    }(r, t);
                    if (!n)
                        return t;
                    const s = rp(n, r);
                    return Mo(s, s.next),
                    Mo(n, n.next)
                }
                function ng(r, t) {
                    return ci(r.prev, r, t.prev) < 0 && ci(t.next, r, r.next) < 0
                }
                function Ih(r, t, n, s, c) {
                    return (r = 1431655765 & ((r = 858993459 & ((r = 252645135 & ((r = 16711935 & ((r = (r - n) * c | 0) | r << 8)) | r << 4)) | r << 2)) | r << 1)) | (t = 1431655765 & ((t = 858993459 & ((t = 252645135 & ((t = 16711935 & ((t = (t - s) * c | 0) | t << 8)) | t << 4)) | t << 2)) | t << 1)) << 1
                }
                function sg(r) {
                    let t = r
                      , n = r;
                    do
                        (t.x < n.x || t.x === n.x && t.y < n.y) && (n = t),
                        t = t.next;
                    while (t !== r);
                    return n
                }
                function tp(r, t, n, s, c, d, p, g) {
                    return (c - p) * (t - g) >= (r - p) * (d - g) && (r - p) * (s - g) >= (n - p) * (t - g) && (n - p) * (d - g) >= (c - p) * (s - g)
                }
                function Hl(r, t, n, s, c, d, p, g) {
                    return !(r === p && t === g) && tp(r, t, n, s, c, d, p, g)
                }
                function og(r, t) {
                    return r.next.i !== t.i && r.prev.i !== t.i && !function(n, s) {
                        let c = n;
                        do {
                            if (c.i !== n.i && c.next.i !== n.i && c.i !== s.i && c.next.i !== s.i && ip(c, c.next, n, s))
                                return !0;
                            c = c.next
                        } while (c !== n);
                        return !1
                    }(r, t) && (Wl(r, t) && Wl(t, r) && function(n, s) {
                        let c = n
                          , d = !1;
                        const p = (n.x + s.x) / 2
                          , g = (n.y + s.y) / 2;
                        do
                            c.y > g != c.next.y > g && c.next.y !== c.y && p < (c.next.x - c.x) * (g - c.y) / (c.next.y - c.y) + c.x && (d = !d),
                            c = c.next;
                        while (c !== n);
                        return d
                    }(r, t) && (ci(r.prev, r, t.prev) || ci(r, t.prev, t)) || Ca(r, t) && ci(r.prev, r, r.next) > 0 && ci(t.prev, t, t.next) > 0)
                }
                function ci(r, t, n) {
                    return (t.y - r.y) * (n.x - t.x) - (t.x - r.x) * (n.y - t.y)
                }
                function Ca(r, t) {
                    return r.x === t.x && r.y === t.y
                }
                function ip(r, t, n, s) {
                    const c = gu(ci(r, t, n))
                      , d = gu(ci(r, t, s))
                      , p = gu(ci(n, s, r))
                      , g = gu(ci(n, s, t));
                    return c !== d && p !== g || !(c !== 0 || !mu(r, n, t)) || !(d !== 0 || !mu(r, s, t)) || !(p !== 0 || !mu(n, r, s)) || !(g !== 0 || !mu(n, t, s))
                }
                function mu(r, t, n) {
                    return t.x <= Math.max(r.x, n.x) && t.x >= Math.min(r.x, n.x) && t.y <= Math.max(r.y, n.y) && t.y >= Math.min(r.y, n.y)
                }
                function gu(r) {
                    return r > 0 ? 1 : r < 0 ? -1 : 0
                }
                function Wl(r, t) {
                    return ci(r.prev, r, r.next) < 0 ? ci(r, t, r.next) >= 0 && ci(r, r.prev, t) >= 0 : ci(r, t, r.prev) < 0 || ci(r, r.next, t) < 0
                }
                function rp(r, t) {
                    const n = Eh(r.i, r.x, r.y)
                      , s = Eh(t.i, t.x, t.y)
                      , c = r.next
                      , d = t.prev;
                    return r.next = t,
                    t.prev = r,
                    n.next = c,
                    c.prev = n,
                    s.next = n,
                    n.prev = s,
                    d.next = s,
                    s.prev = d,
                    s
                }
                function np(r, t, n, s) {
                    const c = Eh(r, t, n);
                    return s ? (c.next = s.next,
                    c.prev = s,
                    s.next.prev = c,
                    s.next = c) : (c.prev = c,
                    c.next = c),
                    c
                }
                function Xl(r) {
                    r.next.prev = r.prev,
                    r.prev.next = r.next,
                    r.prevZ && (r.prevZ.nextZ = r.nextZ),
                    r.nextZ && (r.nextZ.prevZ = r.prevZ)
                }
                function Eh(r, t, n) {
                    return {
                        i: r,
                        x: t,
                        y: n,
                        prev: null,
                        next: null,
                        z: 0,
                        prevZ: null,
                        nextZ: null,
                        steiner: !1
                    }
                }
                class Pa {
                    constructor(t, n) {
                        if (n > t)
                            throw new Error("Min granularity must not be greater than base granularity.");
                        this._baseZoomGranularity = t,
                        this._minGranularity = n
                    }
                    getGranularityForZoomLevel(t) {
                        return Math.max(Math.floor(this._baseZoomGranularity / (1 << t)), this._minGranularity, 1)
                    }
                }
                class _u {
                    constructor(t) {
                        this.fill = t.fill,
                        this.line = t.line,
                        this.tile = t.tile,
                        this.stencil = t.stencil,
                        this.circle = t.circle
                    }
                }
                _u.noSubdivision = new _u({
                    fill: new Pa(0,0),
                    line: new Pa(0,0),
                    tile: new Pa(0,0),
                    stencil: new Pa(0,0),
                    circle: 1
                }),
                Ve("SubdivisionGranularityExpression", Pa),
                Ve("SubdivisionGranularitySetting", _u);
                const Sa = -32768
                  , Kl = 32767;
                class ag {
                    constructor(t, n) {
                        this._vertexBuffer = [],
                        this._vertexDictionary = new Map,
                        this._used = !1,
                        this._granularity = t,
                        this._granularityCellSize = ut / t,
                        this._canonical = n
                    }
                    _getKey(t, n) {
                        return (t += 32768) << 16 | (n += 32768) << 0
                    }
                    _vertexToIndex(t, n) {
                        if (t < -32768 || n < -32768 || t > 32767 || n > 32767)
                            throw new Error("Vertex coordinates are out of signed 16 bit integer range.");
                        const s = 0 | Math.round(t)
                          , c = 0 | Math.round(n)
                          , d = this._getKey(s, c);
                        if (this._vertexDictionary.has(d))
                            return this._vertexDictionary.get(d);
                        const p = this._vertexBuffer.length / 2;
                        return this._vertexDictionary.set(d, p),
                        this._vertexBuffer.push(s, c),
                        p
                    }
                    _subdivideTrianglesScanline(t) {
                        if (this._granularity < 2)
                            return function(c, d) {
                                const p = [];
                                for (let g = 0; g < d.length; g += 3) {
                                    const x = d[g]
                                      , b = d[g + 1]
                                      , C = d[g + 2]
                                      , P = c[2 * x]
                                      , D = c[2 * x + 1];
                                    (c[2 * b] - P) * (c[2 * C + 1] - D) - (c[2 * b + 1] - D) * (c[2 * C] - P) > 0 ? (p.push(x),
                                    p.push(C),
                                    p.push(b)) : (p.push(x),
                                    p.push(b),
                                    p.push(C))
                                }
                                return p
                            }(this._vertexBuffer, t);
                        const n = []
                          , s = t.length;
                        for (let c = 0; c < s; c += 3) {
                            const d = [t[c + 0], t[c + 1], t[c + 2]]
                              , p = [this._vertexBuffer[2 * t[c + 0] + 0], this._vertexBuffer[2 * t[c + 0] + 1], this._vertexBuffer[2 * t[c + 1] + 0], this._vertexBuffer[2 * t[c + 1] + 1], this._vertexBuffer[2 * t[c + 2] + 0], this._vertexBuffer[2 * t[c + 2] + 1]];
                            let g = 1 / 0
                              , x = 1 / 0
                              , b = -1 / 0
                              , C = -1 / 0;
                            for (let j = 0; j < 3; j++) {
                                const G = p[2 * j]
                                  , X = p[2 * j + 1];
                                g = Math.min(g, G),
                                b = Math.max(b, G),
                                x = Math.min(x, X),
                                C = Math.max(C, X)
                            }
                            if (g === b || x === C)
                                continue;
                            const P = Math.floor(g / this._granularityCellSize)
                              , D = Math.ceil(b / this._granularityCellSize)
                              , F = Math.floor(x / this._granularityCellSize)
                              , B = Math.ceil(C / this._granularityCellSize);
                            if (P !== D || F !== B)
                                for (let j = F; j < B; j++) {
                                    const G = this._scanlineGenerateVertexRingForCellRow(j, p, d);
                                    lg(this._vertexBuffer, G, n)
                                }
                            else
                                n.push(...d)
                        }
                        return n
                    }
                    _scanlineGenerateVertexRingForCellRow(t, n, s) {
                        const c = t * this._granularityCellSize
                          , d = c + this._granularityCellSize
                          , p = [];
                        for (let g = 0; g < 3; g++) {
                            const x = n[2 * g]
                              , b = n[2 * g + 1]
                              , C = n[2 * (g + 1) % 6]
                              , P = n[(2 * (g + 1) + 1) % 6]
                              , D = n[2 * (g + 2) % 6]
                              , F = n[(2 * (g + 2) + 1) % 6]
                              , B = C - x
                              , j = P - b
                              , G = B === 0
                              , X = j === 0
                              , ae = (c - b) / j
                              , Q = (d - b) / j
                              , R = Math.min(ae, Q)
                              , Z = Math.max(ae, Q);
                            if (!X && (R >= 1 || Z <= 0) || X && (b < c || b > d)) {
                                P >= c && P <= d && p.push(s[(g + 1) % 3]);
                                continue
                            }
                            !X && R > 0 && p.push(this._vertexToIndex(x + B * R, b + j * R));
                            const ee = x + B * Math.max(R, 0)
                              , ye = x + B * Math.min(Z, 1);
                            G || this._generateIntraEdgeVertices(p, x, b, C, P, ee, ye),
                            !X && Z < 1 && p.push(this._vertexToIndex(x + B * Z, b + j * Z)),
                            (X || P >= c && P <= d) && p.push(s[(g + 1) % 3]),
                            !X && (P <= c || P >= d) && this._generateInterEdgeVertices(p, x, b, C, P, D, F, ye, c, d)
                        }
                        return p
                    }
                    _generateIntraEdgeVertices(t, n, s, c, d, p, g) {
                        const x = c - n
                          , b = d - s
                          , C = b === 0
                          , P = C ? Math.min(n, c) : Math.min(p, g)
                          , D = C ? Math.max(n, c) : Math.max(p, g)
                          , F = Math.floor(P / this._granularityCellSize) + 1
                          , B = Math.ceil(D / this._granularityCellSize) - 1;
                        if (C ? n < c : p < g)
                            for (let j = F; j <= B; j++) {
                                const G = j * this._granularityCellSize;
                                t.push(this._vertexToIndex(G, s + b * (G - n) / x))
                            }
                        else
                            for (let j = B; j >= F; j--) {
                                const G = j * this._granularityCellSize;
                                t.push(this._vertexToIndex(G, s + b * (G - n) / x))
                            }
                    }
                    _generateInterEdgeVertices(t, n, s, c, d, p, g, x, b, C) {
                        const P = d - s
                          , D = p - c
                          , F = g - d
                          , B = (b - d) / F
                          , j = (C - d) / F
                          , G = Math.min(B, j)
                          , X = Math.max(B, j)
                          , ae = c + D * G;
                        let Q = Math.floor(Math.min(ae, x) / this._granularityCellSize) + 1
                          , R = Math.ceil(Math.max(ae, x) / this._granularityCellSize) - 1
                          , Z = x < ae;
                        const ee = F === 0;
                        if (ee && (g === b || g === C))
                            return;
                        if (ee || G >= 1 || X <= 0) {
                            const Le = s - g
                              , be = p + (n - p) * Math.min((b - g) / Le, (C - g) / Le);
                            Q = Math.floor(Math.min(be, x) / this._granularityCellSize) + 1,
                            R = Math.ceil(Math.max(be, x) / this._granularityCellSize) - 1,
                            Z = x < be
                        }
                        const ye = P > 0 ? C : b;
                        if (Z)
                            for (let Le = Q; Le <= R; Le++)
                                t.push(this._vertexToIndex(Le * this._granularityCellSize, ye));
                        else
                            for (let Le = R; Le >= Q; Le--)
                                t.push(this._vertexToIndex(Le * this._granularityCellSize, ye))
                    }
                    _generateOutline(t) {
                        const n = [];
                        for (const s of t) {
                            const c = Co(s, this._granularity, !0)
                              , d = this._pointArrayToIndices(c)
                              , p = [];
                            for (let g = 1; g < d.length; g++)
                                p.push(d[g - 1]),
                                p.push(d[g]);
                            n.push(p)
                        }
                        return n
                    }
                    _handlePoles(t) {
                        let n = !1
                          , s = !1;
                        this._canonical && (this._canonical.y === 0 && (n = !0),
                        this._canonical.y === (1 << this._canonical.z) - 1 && (s = !0)),
                        (n || s) && this._fillPoles(t, n, s)
                    }
                    _ensureNoPoleVertices() {
                        const t = this._vertexBuffer;
                        for (let n = 0; n < t.length; n += 2) {
                            const s = t[n + 1];
                            s === Sa && (t[n + 1] = -32767),
                            s === Kl && (t[n + 1] = 32766)
                        }
                    }
                    _generatePoleQuad(t, n, s, c, d, p) {
                        c > d != (p === Sa) ? (t.push(n),
                        t.push(s),
                        t.push(this._vertexToIndex(c, p)),
                        t.push(s),
                        t.push(this._vertexToIndex(d, p)),
                        t.push(this._vertexToIndex(c, p))) : (t.push(s),
                        t.push(n),
                        t.push(this._vertexToIndex(c, p)),
                        t.push(this._vertexToIndex(d, p)),
                        t.push(s),
                        t.push(this._vertexToIndex(c, p)))
                    }
                    _fillPoles(t, n, s) {
                        const c = this._vertexBuffer
                          , d = ut
                          , p = t.length;
                        for (let g = 2; g < p; g += 3) {
                            const x = t[g - 2]
                              , b = t[g - 1]
                              , C = t[g]
                              , P = c[2 * x]
                              , D = c[2 * x + 1]
                              , F = c[2 * b]
                              , B = c[2 * b + 1]
                              , j = c[2 * C]
                              , G = c[2 * C + 1];
                            n && (D === 0 && B === 0 && this._generatePoleQuad(t, x, b, P, F, Sa),
                            B === 0 && G === 0 && this._generatePoleQuad(t, b, C, F, j, Sa),
                            G === 0 && D === 0 && this._generatePoleQuad(t, C, x, j, P, Sa)),
                            s && (D === d && B === d && this._generatePoleQuad(t, x, b, P, F, Kl),
                            B === d && G === d && this._generatePoleQuad(t, b, C, F, j, Kl),
                            G === d && D === d && this._generatePoleQuad(t, C, x, j, P, Kl))
                        }
                    }
                    _initializeVertices(t) {
                        for (let n = 0; n < t.length; n += 2)
                            this._vertexToIndex(t[n], t[n + 1])
                    }
                    subdividePolygonInternal(t, n) {
                        if (this._used)
                            throw new Error("Subdivision: multiple use not allowed.");
                        this._used = !0;
                        const {flattened: s, holeIndices: c} = function(g) {
                            const x = []
                              , b = [];
                            for (const C of g)
                                if (C.length !== 0) {
                                    C !== g[0] && x.push(b.length / 2);
                                    for (let P = 0; P < C.length; P++)
                                        b.push(C[P].x),
                                        b.push(C[P].y)
                                }
                            return {
                                flattened: b,
                                holeIndices: x
                            }
                        }(t);
                        let d;
                        this._initializeVertices(s);
                        try {
                            const g = function(b, C, P=2) {
                                const D = C && C.length
                                  , F = D ? C[0] * P : b.length;
                                let B = ep(b, 0, F, P, !0);
                                const j = [];
                                if (!B || B.next === B.prev)
                                    return j;
                                let G, X, ae;
                                if (D && (B = function(Q, R, Z, ee) {
                                    const ye = [];
                                    for (let Le = 0, be = R.length; Le < be; Le++) {
                                        const Me = ep(Q, R[Le] * ee, Le < be - 1 ? R[Le + 1] * ee : Q.length, ee, !1);
                                        Me === Me.next && (Me.steiner = !0),
                                        ye.push(sg(Me))
                                    }
                                    ye.sort(ig);
                                    for (let Le = 0; Le < ye.length; Le++)
                                        Z = rg(ye[Le], Z);
                                    return Z
                                }(b, C, B, P)),
                                b.length > 80 * P) {
                                    G = 1 / 0,
                                    X = 1 / 0;
                                    let Q = -1 / 0
                                      , R = -1 / 0;
                                    for (let Z = P; Z < F; Z += P) {
                                        const ee = b[Z]
                                          , ye = b[Z + 1];
                                        ee < G && (G = ee),
                                        ye < X && (X = ye),
                                        ee > Q && (Q = ee),
                                        ye > R && (R = ye)
                                    }
                                    ae = Math.max(Q - G, R - X),
                                    ae = ae !== 0 ? 32767 / ae : 0
                                }
                                return ql(B, j, P, G, X, ae, 0),
                                j
                            }(s, c)
                              , x = this._convertIndices(s, g);
                            d = this._subdivideTrianglesScanline(x)
                        } catch (g) {
                            console.error(g)
                        }
                        let p = [];
                        return n && (p = this._generateOutline(t)),
                        this._ensureNoPoleVertices(),
                        this._handlePoles(d),
                        {
                            verticesFlattened: this._vertexBuffer,
                            indicesTriangles: d,
                            indicesLineList: p
                        }
                    }
                    _convertIndices(t, n) {
                        const s = [];
                        for (let c = 0; c < n.length; c++)
                            s.push(this._vertexToIndex(t[2 * n[c]], t[2 * n[c] + 1]));
                        return s
                    }
                    _pointArrayToIndices(t) {
                        const n = [];
                        for (let s = 0; s < t.length; s++) {
                            const c = t[s];
                            n.push(this._vertexToIndex(c.x, c.y))
                        }
                        return n
                    }
                }
                function sp(r, t, n, s=!0) {
                    return new ag(n,t).subdividePolygonInternal(r, s)
                }
                function Co(r, t, n=!1) {
                    if (!r || r.length < 1)
                        return [];
                    if (r.length < 2)
                        return [];
                    const s = r[0]
                      , c = r[r.length - 1]
                      , d = n && (s.x !== c.x || s.y !== c.y);
                    if (t < 2)
                        return d ? [...r, r[0]] : [...r];
                    const p = Math.floor(ut / t)
                      , g = [];
                    g.push(new Te(r[0].x,r[0].y));
                    const x = r.length
                      , b = d ? x : x - 1;
                    for (let C = 0; C < b; C++) {
                        const P = r[C]
                          , D = C < x - 1 ? r[C + 1] : r[0]
                          , F = P.x
                          , B = P.y
                          , j = D.x
                          , G = D.y
                          , X = F !== j
                          , ae = B !== G;
                        if (!X && !ae)
                            continue;
                        const Q = j - F
                          , R = G - B
                          , Z = Math.abs(Q)
                          , ee = Math.abs(R);
                        let ye = F
                          , Le = B;
                        for (; ; ) {
                            const Me = Q > 0 ? (Math.floor(ye / p) + 1) * p : (Math.ceil(ye / p) - 1) * p
                              , Fe = R > 0 ? (Math.floor(Le / p) + 1) * p : (Math.ceil(Le / p) - 1) * p
                              , Re = Math.abs(ye - Me)
                              , Be = Math.abs(Le - Fe)
                              , Ee = Math.abs(ye - j)
                              , Ue = Math.abs(Le - G)
                              , Qe = X ? Re / Z : Number.POSITIVE_INFINITY
                              , Ye = ae ? Be / ee : Number.POSITIVE_INFINITY;
                            if ((Ee <= Re || !X) && (Ue <= Be || !ae))
                                break;
                            if (Qe < Ye && X || !ae) {
                                ye = Me,
                                Le += R * Qe;
                                const qe = new Te(ye,Math.round(Le));
                                g[g.length - 1].x === qe.x && g[g.length - 1].y === qe.y || g.push(qe)
                            } else {
                                ye += Q * Ye,
                                Le = Fe;
                                const qe = new Te(Math.round(ye),Le);
                                g[g.length - 1].x === qe.x && g[g.length - 1].y === qe.y || g.push(qe)
                            }
                        }
                        const be = new Te(j,G);
                        g[g.length - 1].x === be.x && g[g.length - 1].y === be.y || g.push(be)
                    }
                    return g
                }
                function lg(r, t, n) {
                    if (t.length === 0)
                        throw new Error("Subdivision vertex ring is empty.");
                    let s = 0
                      , c = r[2 * t[0]];
                    for (let x = 1; x < t.length; x++) {
                        const b = r[2 * t[x]];
                        b < c && (c = b,
                        s = x)
                    }
                    const d = t.length;
                    let p = s
                      , g = (p + 1) % d;
                    for (; ; ) {
                        const x = p - 1 >= 0 ? p - 1 : d - 1
                          , b = (g + 1) % d
                          , C = r[2 * t[x]]
                          , P = r[2 * t[b]]
                          , D = r[2 * t[p]]
                          , F = r[2 * t[p] + 1]
                          , B = r[2 * t[g] + 1];
                        let j = !1;
                        if (C < P)
                            j = !0;
                        else if (C > P)
                            j = !1;
                        else {
                            const G = B - F
                              , X = -(r[2 * t[g]] - D)
                              , ae = F < B ? 1 : -1;
                            ((C - D) * G + (r[2 * t[x] + 1] - F) * X) * ae > ((P - D) * G + (r[2 * t[b] + 1] - F) * X) * ae && (j = !0)
                        }
                        if (j) {
                            const G = t[x]
                              , X = t[p]
                              , ae = t[g];
                            G !== X && G !== ae && X !== ae && n.push(ae, X, G),
                            p--,
                            p < 0 && (p = d - 1)
                        } else {
                            const G = t[b]
                              , X = t[p]
                              , ae = t[g];
                            G !== X && G !== ae && X !== ae && n.push(ae, X, G),
                            g++,
                            g >= d && (g = 0)
                        }
                        if (x === b)
                            break
                    }
                }
                function op(r, t, n, s, c, d, p, g, x) {
                    const b = c.length / 2
                      , C = p && g && x;
                    if (b < Ke.MAX_VERTEX_ARRAY_LENGTH) {
                        const P = t.prepareSegment(b, n, s)
                          , D = P.vertexLength;
                        for (let j = 0; j < d.length; j += 3)
                            s.emplaceBack(D + d[j], D + d[j + 1], D + d[j + 2]);
                        let F, B;
                        P.vertexLength += b,
                        P.primitiveLength += d.length / 3,
                        C && (B = p.prepareSegment(b, n, g),
                        F = B.vertexLength,
                        B.vertexLength += b);
                        for (let j = 0; j < c.length; j += 2)
                            r(c[j], c[j + 1]);
                        if (C)
                            for (let j = 0; j < x.length; j++) {
                                const G = x[j];
                                for (let X = 1; X < G.length; X += 2)
                                    g.emplaceBack(F + G[X - 1], F + G[X]);
                                B.primitiveLength += G.length / 2
                            }
                    } else
                        (function(P, D, F, B, j, G) {
                            const X = [];
                            for (let ee = 0; ee < B.length / 2; ee++)
                                X.push(-1);
                            const ae = {
                                count: 0
                            };
                            let Q = 0
                              , R = P.getOrCreateLatestSegment(D, F)
                              , Z = R.vertexLength;
                            for (let ee = 2; ee < j.length; ee += 3) {
                                const ye = j[ee - 2]
                                  , Le = j[ee - 1]
                                  , be = j[ee];
                                let Me = X[ye] < Q
                                  , Fe = X[Le] < Q
                                  , Re = X[be] < Q;
                                R.vertexLength + ((Me ? 1 : 0) + (Fe ? 1 : 0) + (Re ? 1 : 0)) > Ke.MAX_VERTEX_ARRAY_LENGTH && (R = P.createNewSegment(D, F),
                                Q = ae.count,
                                Me = !0,
                                Fe = !0,
                                Re = !0,
                                Z = 0);
                                const Be = Jl(X, B, G, ae, ye, Me, R)
                                  , Ee = Jl(X, B, G, ae, Le, Fe, R)
                                  , Ue = Jl(X, B, G, ae, be, Re, R);
                                F.emplaceBack(Z + Be - Q, Z + Ee - Q, Z + Ue - Q),
                                R.primitiveLength++
                            }
                        }
                        )(t, n, s, c, d, r),
                        C && function(P, D, F, B, j, G) {
                            const X = [];
                            for (let ee = 0; ee < B.length / 2; ee++)
                                X.push(-1);
                            const ae = {
                                count: 0
                            };
                            let Q = 0
                              , R = P.getOrCreateLatestSegment(D, F)
                              , Z = R.vertexLength;
                            for (let ee = 0; ee < j.length; ee++) {
                                const ye = j[ee];
                                for (let Le = 1; Le < j[ee].length; Le += 2) {
                                    const be = ye[Le - 1]
                                      , Me = ye[Le];
                                    let Fe = X[be] < Q
                                      , Re = X[Me] < Q;
                                    R.vertexLength + ((Fe ? 1 : 0) + (Re ? 1 : 0)) > Ke.MAX_VERTEX_ARRAY_LENGTH && (R = P.createNewSegment(D, F),
                                    Q = ae.count,
                                    Fe = !0,
                                    Re = !0,
                                    Z = 0);
                                    const Be = Jl(X, B, G, ae, be, Fe, R)
                                      , Ee = Jl(X, B, G, ae, Me, Re, R);
                                    F.emplaceBack(Z + Be - Q, Z + Ee - Q),
                                    R.primitiveLength++
                                }
                            }
                        }(p, n, g, c, x, r),
                        t.forceNewSegmentOnNextPrepare(),
                        p?.forceNewSegmentOnNextPrepare()
                }
                function Jl(r, t, n, s, c, d, p) {
                    if (d) {
                        const g = s.count;
                        return n(t[2 * c], t[2 * c + 1]),
                        r[c] = s.count,
                        s.count++,
                        p.vertexLength++,
                        g
                    }
                    return r[c]
                }
                class Ah {
                    constructor(t) {
                        this.zoom = t.zoom,
                        this.overscaling = t.overscaling,
                        this.layers = t.layers,
                        this.layerIds = this.layers.map(n => n.id),
                        this.index = t.index,
                        this.hasPattern = !1,
                        this.patternFeatures = [],
                        this.layoutVertexArray = new te,
                        this.indexArray = new Ne,
                        this.indexArray2 = new Oe,
                        this.programConfigurations = new _s(t.layers,t.zoom),
                        this.segments = new Ke,
                        this.segments2 = new Ke,
                        this.stateDependentLayerIds = this.layers.filter(n => n.isStateDependent()).map(n => n.id)
                    }
                    populate(t, n, s) {
                        this.hasPattern = Ph("fill", this.layers, n);
                        const c = this.layers[0].layout.get("fill-sort-key")
                          , d = !c.isConstant()
                          , p = [];
                        for (const {feature: g, id: x, index: b, sourceLayerIndex: C} of t) {
                            const P = this.layers[0]._featureFilter.needGeometry
                              , D = hr(g, P);
                            if (!this.layers[0]._featureFilter.filter(new Ut(this.zoom), D, s))
                                continue;
                            const F = d ? c.evaluate(D, {}, s, n.availableImages) : void 0
                              , B = {
                                id: x,
                                properties: g.properties,
                                type: g.type,
                                sourceLayerIndex: C,
                                index: b,
                                geometry: P ? D.geometry : ys(g),
                                patterns: {},
                                sortKey: F
                            };
                            p.push(B)
                        }
                        d && p.sort( (g, x) => g.sortKey - x.sortKey);
                        for (const g of p) {
                            const {geometry: x, index: b, sourceLayerIndex: C} = g;
                            if (this.hasPattern) {
                                const P = Sh("fill", this.layers, g, this.zoom, n);
                                this.patternFeatures.push(P)
                            } else
                                this.addFeature(g, x, b, s, {}, n.subdivisionGranularity);
                            n.featureIndex.insert(t[b].feature, x, b, C, this.index)
                        }
                    }
                    update(t, n, s) {
                        this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, n, this.stateDependentLayers, s)
                    }
                    addFeatures(t, n, s) {
                        for (const c of this.patternFeatures)
                            this.addFeature(c, c.geometry, c.index, n, s, t.subdivisionGranularity)
                    }
                    isEmpty() {
                        return this.layoutVertexArray.length === 0
                    }
                    uploadPending() {
                        return !this.uploaded || this.programConfigurations.needsUpload
                    }
                    upload(t) {
                        this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, Jm),
                        this.indexBuffer = t.createIndexBuffer(this.indexArray),
                        this.indexBuffer2 = t.createIndexBuffer(this.indexArray2)),
                        this.programConfigurations.upload(t),
                        this.uploaded = !0
                    }
                    destroy() {
                        this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(),
                        this.indexBuffer.destroy(),
                        this.indexBuffer2.destroy(),
                        this.programConfigurations.destroy(),
                        this.segments.destroy(),
                        this.segments2.destroy())
                    }
                    addFeature(t, n, s, c, d, p) {
                        for (const g of Go(n, 500)) {
                            const x = sp(g, c, p.fill.getGranularityForZoomLevel(c.z))
                              , b = this.layoutVertexArray;
                            op( (C, P) => {
                                b.emplaceBack(C, P)
                            }
                            , this.segments, this.layoutVertexArray, this.indexArray, x.verticesFlattened, x.indicesTriangles, this.segments2, this.indexArray2, x.indicesLineList)
                        }
                        this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, s, d, c)
                    }
                }
                let ap, lp;
                Ve("FillBucket", Ah, {
                    omit: ["layers", "patternFeatures"]
                });
                var cg = {
                    get paint() {
                        return lp = lp || new rr({
                            "fill-antialias": new Xe(E.paint_fill["fill-antialias"]),
                            "fill-opacity": new et(E.paint_fill["fill-opacity"]),
                            "fill-color": new et(E.paint_fill["fill-color"]),
                            "fill-outline-color": new et(E.paint_fill["fill-outline-color"]),
                            "fill-translate": new Xe(E.paint_fill["fill-translate"]),
                            "fill-translate-anchor": new Xe(E.paint_fill["fill-translate-anchor"]),
                            "fill-pattern": new bo(E.paint_fill["fill-pattern"])
                        })
                    },
                    get layout() {
                        return ap = ap || new rr({
                            "fill-sort-key": new et(E.layout_fill["fill-sort-key"])
                        })
                    }
                };
                class ug extends sn {
                    constructor(t) {
                        super(t, cg)
                    }
                    recalculate(t, n) {
                        super.recalculate(t, n);
                        const s = this.paint._values["fill-outline-color"];
                        s.value.kind === "constant" && s.value.value === void 0 && (this.paint._values["fill-outline-color"] = this.paint._values["fill-color"])
                    }
                    createBucket(t) {
                        return new Ah(t)
                    }
                    queryRadius() {
                        return pu(this.paint.get("fill-translate"))
                    }
                    queryIntersectsFeature({queryGeometry: t, geometry: n, transform: s, pixelsToTileUnits: c}) {
                        return Ta(fu(t, this.paint.get("fill-translate"), this.paint.get("fill-translate-anchor"), -s.bearingInRadians, c), n)
                    }
                    isTileClipped() {
                        return !0
                    }
                }
                const hg = li([{
                    name: "a_pos",
                    components: 2,
                    type: "Int16"
                }, {
                    name: "a_normal_ed",
                    components: 4,
                    type: "Int16"
                }], 4)
                  , dg = li([{
                    name: "a_centroid",
                    components: 2,
                    type: "Int16"
                }], 4)
                  , {members: pg} = hg;
                var zh, cp, kh, up, Lh, hp, dp, yu = {};
                function pp() {
                    if (cp)
                        return zh;
                    cp = 1;
                    var r = ze();
                    function t(c, d, p, g, x) {
                        this.properties = {},
                        this.extent = p,
                        this.type = 0,
                        this._pbf = c,
                        this._geometry = -1,
                        this._keys = g,
                        this._values = x,
                        c.readFields(n, this, d)
                    }
                    function n(c, d, p) {
                        c == 1 ? d.id = p.readVarint() : c == 2 ? function(g, x) {
                            for (var b = g.readVarint() + g.pos; g.pos < b; ) {
                                var C = x._keys[g.readVarint()]
                                  , P = x._values[g.readVarint()];
                                x.properties[C] = P
                            }
                        }(p, d) : c == 3 ? d.type = p.readVarint() : c == 4 && (d._geometry = p.pos)
                    }
                    function s(c) {
                        for (var d, p, g = 0, x = 0, b = c.length, C = b - 1; x < b; C = x++)
                            g += ((p = c[C]).x - (d = c[x]).x) * (d.y + p.y);
                        return g
                    }
                    return zh = t,
                    t.types = ["Unknown", "Point", "LineString", "Polygon"],
                    t.prototype.loadGeometry = function() {
                        var c = this._pbf;
                        c.pos = this._geometry;
                        for (var d, p = c.readVarint() + c.pos, g = 1, x = 0, b = 0, C = 0, P = []; c.pos < p; ) {
                            if (x <= 0) {
                                var D = c.readVarint();
                                g = 7 & D,
                                x = D >> 3
                            }
                            if (x--,
                            g === 1 || g === 2)
                                b += c.readSVarint(),
                                C += c.readSVarint(),
                                g === 1 && (d && P.push(d),
                                d = []),
                                d.push(new r(b,C));
                            else {
                                if (g !== 7)
                                    throw new Error("unknown command " + g);
                                d && d.push(d[0].clone())
                            }
                        }
                        return d && P.push(d),
                        P
                    }
                    ,
                    t.prototype.bbox = function() {
                        var c = this._pbf;
                        c.pos = this._geometry;
                        for (var d = c.readVarint() + c.pos, p = 1, g = 0, x = 0, b = 0, C = 1 / 0, P = -1 / 0, D = 1 / 0, F = -1 / 0; c.pos < d; ) {
                            if (g <= 0) {
                                var B = c.readVarint();
                                p = 7 & B,
                                g = B >> 3
                            }
                            if (g--,
                            p === 1 || p === 2)
                                (x += c.readSVarint()) < C && (C = x),
                                x > P && (P = x),
                                (b += c.readSVarint()) < D && (D = b),
                                b > F && (F = b);
                            else if (p !== 7)
                                throw new Error("unknown command " + p)
                        }
                        return [C, D, P, F]
                    }
                    ,
                    t.prototype.toGeoJSON = function(c, d, p) {
                        var g, x, b = this.extent * Math.pow(2, p), C = this.extent * c, P = this.extent * d, D = this.loadGeometry(), F = t.types[this.type];
                        function B(X) {
                            for (var ae = 0; ae < X.length; ae++) {
                                var Q = X[ae];
                                X[ae] = [360 * (Q.x + C) / b - 180, 360 / Math.PI * Math.atan(Math.exp((180 - 360 * (Q.y + P) / b) * Math.PI / 180)) - 90]
                            }
                        }
                        switch (this.type) {
                        case 1:
                            var j = [];
                            for (g = 0; g < D.length; g++)
                                j[g] = D[g][0];
                            B(D = j);
                            break;
                        case 2:
                            for (g = 0; g < D.length; g++)
                                B(D[g]);
                            break;
                        case 3:
                            for (D = function(X) {
                                var ae = X.length;
                                if (ae <= 1)
                                    return [X];
                                for (var Q, R, Z = [], ee = 0; ee < ae; ee++) {
                                    var ye = s(X[ee]);
                                    ye !== 0 && (R === void 0 && (R = ye < 0),
                                    R === ye < 0 ? (Q && Z.push(Q),
                                    Q = [X[ee]]) : Q.push(X[ee]))
                                }
                                return Q && Z.push(Q),
                                Z
                            }(D),
                            g = 0; g < D.length; g++)
                                for (x = 0; x < D[g].length; x++)
                                    B(D[g][x])
                        }
                        D.length === 1 ? D = D[0] : F = "Multi" + F;
                        var G = {
                            type: "Feature",
                            geometry: {
                                type: F,
                                coordinates: D
                            },
                            properties: this.properties
                        };
                        return "id"in this && (G.id = this.id),
                        G
                    }
                    ,
                    zh
                }
                function fp() {
                    if (up)
                        return kh;
                    up = 1;
                    var r = pp();
                    function t(s, c) {
                        this.version = 1,
                        this.name = null,
                        this.extent = 4096,
                        this.length = 0,
                        this._pbf = s,
                        this._keys = [],
                        this._values = [],
                        this._features = [],
                        s.readFields(n, this, c),
                        this.length = this._features.length
                    }
                    function n(s, c, d) {
                        s === 15 ? c.version = d.readVarint() : s === 1 ? c.name = d.readString() : s === 5 ? c.extent = d.readVarint() : s === 2 ? c._features.push(d.pos) : s === 3 ? c._keys.push(d.readString()) : s === 4 && c._values.push(function(p) {
                            for (var g = null, x = p.readVarint() + p.pos; p.pos < x; ) {
                                var b = p.readVarint() >> 3;
                                g = b === 1 ? p.readString() : b === 2 ? p.readFloat() : b === 3 ? p.readDouble() : b === 4 ? p.readVarint64() : b === 5 ? p.readVarint() : b === 6 ? p.readSVarint() : b === 7 ? p.readBoolean() : null
                            }
                            return g
                        }(d))
                    }
                    return kh = t,
                    t.prototype.feature = function(s) {
                        if (s < 0 || s >= this._features.length)
                            throw new Error("feature index out of bounds");
                        this._pbf.pos = this._features[s];
                        var c = this._pbf.readVarint() + this._pbf.pos;
                        return new r(this._pbf,c,this.extent,this._keys,this._values)
                    }
                    ,
                    kh
                }
                function mp() {
                    return dp || (dp = 1,
                    yu.VectorTile = function() {
                        if (hp)
                            return Lh;
                        hp = 1;
                        var r = fp();
                        function t(n, s, c) {
                            if (n === 3) {
                                var d = new r(c,c.readVarint() + c.pos);
                                d.length && (s[d.name] = d)
                            }
                        }
                        return Lh = function(n, s) {
                            this.layers = n.readFields(t, {}, s)
                        }
                        ,
                        Lh
                    }(),
                    yu.VectorTileFeature = pp(),
                    yu.VectorTileLayer = fp()),
                    yu
                }
                var Yl = ce(mp());
                const fg = Yl.VectorTileFeature.types
                  , Dh = Math.pow(2, 13);
                function Ql(r, t, n, s, c, d, p, g) {
                    r.emplaceBack(t, n, 2 * Math.floor(s * Dh) + p, c * Dh * 2, d * Dh * 2, Math.round(g))
                }
                class Rh {
                    constructor(t) {
                        this.zoom = t.zoom,
                        this.overscaling = t.overscaling,
                        this.layers = t.layers,
                        this.layerIds = this.layers.map(n => n.id),
                        this.index = t.index,
                        this.hasPattern = !1,
                        this.layoutVertexArray = new ie,
                        this.centroidVertexArray = new W,
                        this.indexArray = new Ne,
                        this.programConfigurations = new _s(t.layers,t.zoom),
                        this.segments = new Ke,
                        this.stateDependentLayerIds = this.layers.filter(n => n.isStateDependent()).map(n => n.id)
                    }
                    populate(t, n, s) {
                        this.features = [],
                        this.hasPattern = Ph("fill-extrusion", this.layers, n);
                        for (const {feature: c, id: d, index: p, sourceLayerIndex: g} of t) {
                            const x = this.layers[0]._featureFilter.needGeometry
                              , b = hr(c, x);
                            if (!this.layers[0]._featureFilter.filter(new Ut(this.zoom), b, s))
                                continue;
                            const C = {
                                id: d,
                                sourceLayerIndex: g,
                                index: p,
                                geometry: x ? b.geometry : ys(c),
                                properties: c.properties,
                                type: c.type,
                                patterns: {}
                            };
                            this.hasPattern ? this.features.push(Sh("fill-extrusion", this.layers, C, this.zoom, n)) : this.addFeature(C, C.geometry, p, s, {}, n.subdivisionGranularity),
                            n.featureIndex.insert(c, C.geometry, p, g, this.index, !0)
                        }
                    }
                    addFeatures(t, n, s) {
                        for (const c of this.features) {
                            const {geometry: d} = c;
                            this.addFeature(c, d, c.index, n, s, t.subdivisionGranularity)
                        }
                    }
                    update(t, n, s) {
                        this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, n, this.stateDependentLayers, s)
                    }
                    isEmpty() {
                        return this.layoutVertexArray.length === 0 && this.centroidVertexArray.length === 0
                    }
                    uploadPending() {
                        return !this.uploaded || this.programConfigurations.needsUpload
                    }
                    upload(t) {
                        this.uploaded || (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, pg),
                        this.centroidVertexBuffer = t.createVertexBuffer(this.centroidVertexArray, dg.members, !0),
                        this.indexBuffer = t.createIndexBuffer(this.indexArray)),
                        this.programConfigurations.upload(t),
                        this.uploaded = !0
                    }
                    destroy() {
                        this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(),
                        this.indexBuffer.destroy(),
                        this.programConfigurations.destroy(),
                        this.segments.destroy(),
                        this.centroidVertexBuffer.destroy())
                    }
                    addFeature(t, n, s, c, d, p) {
                        for (const g of Go(n, 500)) {
                            const x = {
                                x: 0,
                                y: 0,
                                sampleCount: 0
                            }
                              , b = this.layoutVertexArray.length;
                            this.processPolygon(x, c, t, g, p);
                            const C = this.layoutVertexArray.length - b
                              , P = Math.floor(x.x / x.sampleCount)
                              , D = Math.floor(x.y / x.sampleCount);
                            for (let F = 0; F < C; F++)
                                this.centroidVertexArray.emplaceBack(P, D)
                        }
                        this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, s, d, c)
                    }
                    processPolygon(t, n, s, c, d) {
                        if (c.length < 1 || gp(c[0]))
                            return;
                        for (const P of c)
                            P.length !== 0 && mg(t, P);
                        const p = {
                            segment: this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray)
                        }
                          , g = d.fill.getGranularityForZoomLevel(n.z)
                          , x = fg[s.type] === "Polygon";
                        for (const P of c) {
                            if (P.length === 0 || gp(P))
                                continue;
                            const D = Co(P, g, x);
                            this._generateSideFaces(D, p)
                        }
                        if (!x)
                            return;
                        const b = sp(c, n, g, !1)
                          , C = this.layoutVertexArray;
                        op( (P, D) => {
                            Ql(C, P, D, 0, 0, 1, 1, 0)
                        }
                        , this.segments, this.layoutVertexArray, this.indexArray, b.verticesFlattened, b.indicesTriangles)
                    }
                    _generateSideFaces(t, n) {
                        let s = 0;
                        for (let c = 1; c < t.length; c++) {
                            const d = t[c]
                              , p = t[c - 1];
                            if (gg(d, p))
                                continue;
                            n.segment.vertexLength + 4 > Ke.MAX_VERTEX_ARRAY_LENGTH && (n.segment = this.segments.prepareSegment(4, this.layoutVertexArray, this.indexArray));
                            const g = d.sub(p)._perp()._unit()
                              , x = p.dist(d);
                            s + x > 32768 && (s = 0),
                            Ql(this.layoutVertexArray, d.x, d.y, g.x, g.y, 0, 0, s),
                            Ql(this.layoutVertexArray, d.x, d.y, g.x, g.y, 0, 1, s),
                            s += x,
                            Ql(this.layoutVertexArray, p.x, p.y, g.x, g.y, 0, 0, s),
                            Ql(this.layoutVertexArray, p.x, p.y, g.x, g.y, 0, 1, s);
                            const b = n.segment.vertexLength;
                            this.indexArray.emplaceBack(b, b + 2, b + 1),
                            this.indexArray.emplaceBack(b + 1, b + 2, b + 3),
                            n.segment.vertexLength += 4,
                            n.segment.primitiveLength += 2
                        }
                    }
                }
                function mg(r, t) {
                    for (let n = 0; n < t.length; n++) {
                        const s = t[n];
                        n === t.length - 1 && t[0].x === s.x && t[0].y === s.y || (r.x += s.x,
                        r.y += s.y,
                        r.sampleCount++)
                    }
                }
                function gg(r, t) {
                    return r.x === t.x && (r.x < 0 || r.x > ut) || r.y === t.y && (r.y < 0 || r.y > ut)
                }
                function gp(r) {
                    return r.every(t => t.x < 0) || r.every(t => t.x > ut) || r.every(t => t.y < 0) || r.every(t => t.y > ut)
                }
                let _p;
                Ve("FillExtrusionBucket", Rh, {
                    omit: ["layers", "features"]
                });
                var _g = {
                    get paint() {
                        return _p = _p || new rr({
                            "fill-extrusion-opacity": new Xe(E["paint_fill-extrusion"]["fill-extrusion-opacity"]),
                            "fill-extrusion-color": new et(E["paint_fill-extrusion"]["fill-extrusion-color"]),
                            "fill-extrusion-translate": new Xe(E["paint_fill-extrusion"]["fill-extrusion-translate"]),
                            "fill-extrusion-translate-anchor": new Xe(E["paint_fill-extrusion"]["fill-extrusion-translate-anchor"]),
                            "fill-extrusion-pattern": new bo(E["paint_fill-extrusion"]["fill-extrusion-pattern"]),
                            "fill-extrusion-height": new et(E["paint_fill-extrusion"]["fill-extrusion-height"]),
                            "fill-extrusion-base": new et(E["paint_fill-extrusion"]["fill-extrusion-base"]),
                            "fill-extrusion-vertical-gradient": new Xe(E["paint_fill-extrusion"]["fill-extrusion-vertical-gradient"])
                        })
                    }
                };
                class yg extends sn {
                    constructor(t) {
                        super(t, _g)
                    }
                    createBucket(t) {
                        return new Rh(t)
                    }
                    queryRadius() {
                        return pu(this.paint.get("fill-extrusion-translate"))
                    }
                    is3D() {
                        return !0
                    }
                    queryIntersectsFeature({queryGeometry: t, feature: n, featureState: s, geometry: c, transform: d, pixelsToTileUnits: p, pixelPosMatrix: g}) {
                        const x = fu(t, this.paint.get("fill-extrusion-translate"), this.paint.get("fill-extrusion-translate-anchor"), -d.bearingInRadians, p)
                          , b = this.paint.get("fill-extrusion-height").evaluate(n, s)
                          , C = this.paint.get("fill-extrusion-base").evaluate(n, s)
                          , P = function(F, B, j) {
                            const G = [];
                            for (const X of F) {
                                const ae = [X.x, X.y, 0, 1];
                                Wi(ae, ae, B),
                                G.push(new Te(ae[0] / ae[3],ae[1] / ae[3]))
                            }
                            return G
                        }(x, g)
                          , D = function(F, B, j, G) {
                            const X = []
                              , ae = []
                              , Q = G[8] * B
                              , R = G[9] * B
                              , Z = G[10] * B
                              , ee = G[11] * B
                              , ye = G[8] * j
                              , Le = G[9] * j
                              , be = G[10] * j
                              , Me = G[11] * j;
                            for (const Fe of F) {
                                const Re = []
                                  , Be = [];
                                for (const Ee of Fe) {
                                    const Ue = Ee.x
                                      , Qe = Ee.y
                                      , Ye = G[0] * Ue + G[4] * Qe + G[12]
                                      , qe = G[1] * Ue + G[5] * Qe + G[13]
                                      , ht = G[2] * Ue + G[6] * Qe + G[14]
                                      , Yt = G[3] * Ue + G[7] * Qe + G[15]
                                      , Mi = ht + Z
                                      , $i = Yt + ee
                                      , qr = Ye + ye
                                      , pr = qe + Le
                                      , Oi = ht + be
                                      , qt = Yt + Me
                                      , zi = new Te((Ye + Q) / $i,(qe + R) / $i);
                                    zi.z = Mi / $i,
                                    Re.push(zi);
                                    const Ni = new Te(qr / qt,pr / qt);
                                    Ni.z = Oi / qt,
                                    Be.push(Ni)
                                }
                                X.push(Re),
                                ae.push(Be)
                            }
                            return [X, ae]
                        }(c, C, b, g);
                        return function(F, B, j) {
                            let G = 1 / 0;
                            Ta(j, B) && (G = yp(j, B[0]));
                            for (let X = 0; X < B.length; X++) {
                                const ae = B[X]
                                  , Q = F[X];
                                for (let R = 0; R < ae.length - 1; R++) {
                                    const Z = ae[R]
                                      , ee = [Z, ae[R + 1], Q[R + 1], Q[R], Z];
                                    wa(j, ee) && (G = Math.min(G, yp(j, ee)))
                                }
                            }
                            return G !== 1 / 0 && G
                        }(D[0], D[1], P)
                    }
                }
                function ec(r, t) {
                    return r.x * t.x + r.y * t.y
                }
                function yp(r, t) {
                    if (r.length === 1) {
                        let n = 0;
                        const s = t[n++];
                        let c;
                        for (; !c || s.equals(c); )
                            if (c = t[n++],
                            !c)
                                return 1 / 0;
                        for (; n < t.length; n++) {
                            const d = t[n]
                              , p = r[0]
                              , g = c.sub(s)
                              , x = d.sub(s)
                              , b = p.sub(s)
                              , C = ec(g, g)
                              , P = ec(g, x)
                              , D = ec(x, x)
                              , F = ec(b, g)
                              , B = ec(b, x)
                              , j = C * D - P * P
                              , G = (D * F - P * B) / j
                              , X = (C * B - P * F) / j
                              , ae = s.z * (1 - G - X) + c.z * G + d.z * X;
                            if (isFinite(ae))
                                return ae
                        }
                        return 1 / 0
                    }
                    {
                        let n = 1 / 0;
                        for (const s of t)
                            n = Math.min(n, s.z);
                        return n
                    }
                }
                const xg = li([{
                    name: "a_pos_normal",
                    components: 2,
                    type: "Int16"
                }, {
                    name: "a_data",
                    components: 4,
                    type: "Uint8"
                }], 4)
                  , {members: vg} = xg
                  , bg = li([{
                    name: "a_uv_x",
                    components: 1,
                    type: "Float32"
                }, {
                    name: "a_split_index",
                    components: 1,
                    type: "Float32"
                }])
                  , {members: wg} = bg
                  , Tg = Yl.VectorTileFeature.types
                  , Mg = Math.cos(Math.PI / 180 * 37.5)
                  , xp = Math.pow(2, 14) / .5;
                class Fh {
                    constructor(t) {
                        this.zoom = t.zoom,
                        this.overscaling = t.overscaling,
                        this.layers = t.layers,
                        this.layerIds = this.layers.map(n => n.id),
                        this.index = t.index,
                        this.hasPattern = !1,
                        this.patternFeatures = [],
                        this.lineClipsArray = [],
                        this.gradients = {},
                        this.layers.forEach(n => {
                            this.gradients[n.id] = {}
                        }
                        ),
                        this.layoutVertexArray = new ne,
                        this.layoutVertexArray2 = new le,
                        this.indexArray = new Ne,
                        this.programConfigurations = new _s(t.layers,t.zoom),
                        this.segments = new Ke,
                        this.maxLineLength = 0,
                        this.stateDependentLayerIds = this.layers.filter(n => n.isStateDependent()).map(n => n.id)
                    }
                    populate(t, n, s) {
                        this.hasPattern = Ph("line", this.layers, n);
                        const c = this.layers[0].layout.get("line-sort-key")
                          , d = !c.isConstant()
                          , p = [];
                        for (const {feature: g, id: x, index: b, sourceLayerIndex: C} of t) {
                            const P = this.layers[0]._featureFilter.needGeometry
                              , D = hr(g, P);
                            if (!this.layers[0]._featureFilter.filter(new Ut(this.zoom), D, s))
                                continue;
                            const F = d ? c.evaluate(D, {}, s) : void 0
                              , B = {
                                id: x,
                                properties: g.properties,
                                type: g.type,
                                sourceLayerIndex: C,
                                index: b,
                                geometry: P ? D.geometry : ys(g),
                                patterns: {},
                                sortKey: F
                            };
                            p.push(B)
                        }
                        d && p.sort( (g, x) => g.sortKey - x.sortKey);
                        for (const g of p) {
                            const {geometry: x, index: b, sourceLayerIndex: C} = g;
                            if (this.hasPattern) {
                                const P = Sh("line", this.layers, g, this.zoom, n);
                                this.patternFeatures.push(P)
                            } else
                                this.addFeature(g, x, b, s, {}, n.subdivisionGranularity);
                            n.featureIndex.insert(t[b].feature, x, b, C, this.index)
                        }
                    }
                    update(t, n, s) {
                        this.stateDependentLayers.length && this.programConfigurations.updatePaintArrays(t, n, this.stateDependentLayers, s)
                    }
                    addFeatures(t, n, s) {
                        for (const c of this.patternFeatures)
                            this.addFeature(c, c.geometry, c.index, n, s, t.subdivisionGranularity)
                    }
                    isEmpty() {
                        return this.layoutVertexArray.length === 0
                    }
                    uploadPending() {
                        return !this.uploaded || this.programConfigurations.needsUpload
                    }
                    upload(t) {
                        this.uploaded || (this.layoutVertexArray2.length !== 0 && (this.layoutVertexBuffer2 = t.createVertexBuffer(this.layoutVertexArray2, wg)),
                        this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, vg),
                        this.indexBuffer = t.createIndexBuffer(this.indexArray)),
                        this.programConfigurations.upload(t),
                        this.uploaded = !0
                    }
                    destroy() {
                        this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(),
                        this.indexBuffer.destroy(),
                        this.programConfigurations.destroy(),
                        this.segments.destroy())
                    }
                    lineFeatureClips(t) {
                        if (t.properties && Object.prototype.hasOwnProperty.call(t.properties, "mapbox_clip_start") && Object.prototype.hasOwnProperty.call(t.properties, "mapbox_clip_end"))
                            return {
                                start: +t.properties.mapbox_clip_start,
                                end: +t.properties.mapbox_clip_end
                            }
                    }
                    addFeature(t, n, s, c, d, p) {
                        const g = this.layers[0].layout
                          , x = g.get("line-join").evaluate(t, {})
                          , b = g.get("line-cap")
                          , C = g.get("line-miter-limit")
                          , P = g.get("line-round-limit");
                        this.lineClips = this.lineFeatureClips(t);
                        for (const D of n)
                            this.addLine(D, t, x, b, C, P, c, p);
                        this.programConfigurations.populatePaintArrays(this.layoutVertexArray.length, t, s, d, c)
                    }
                    addLine(t, n, s, c, d, p, g, x) {
                        if (this.distance = 0,
                        this.scaledDistance = 0,
                        this.totalDistance = 0,
                        t = Co(t, g ? x.line.getGranularityForZoomLevel(g.z) : 1),
                        this.lineClips) {
                            this.lineClipsArray.push(this.lineClips);
                            for (let Q = 0; Q < t.length - 1; Q++)
                                this.totalDistance += t[Q].dist(t[Q + 1]);
                            this.updateScaledDistance(),
                            this.maxLineLength = Math.max(this.maxLineLength, this.totalDistance)
                        }
                        const b = Tg[n.type] === "Polygon";
                        let C = t.length;
                        for (; C >= 2 && t[C - 1].equals(t[C - 2]); )
                            C--;
                        let P = 0;
                        for (; P < C - 1 && t[P].equals(t[P + 1]); )
                            P++;
                        if (C < (b ? 3 : 2))
                            return;
                        s === "bevel" && (d = 1.05);
                        const D = this.overscaling <= 16 ? 15 * ut / (512 * this.overscaling) : 0
                          , F = this.segments.prepareSegment(10 * C, this.layoutVertexArray, this.indexArray);
                        let B, j, G, X, ae;
                        this.e1 = this.e2 = -1,
                        b && (B = t[C - 2],
                        ae = t[P].sub(B)._unit()._perp());
                        for (let Q = P; Q < C; Q++) {
                            if (G = Q === C - 1 ? b ? t[P + 1] : void 0 : t[Q + 1],
                            G && t[Q].equals(G))
                                continue;
                            ae && (X = ae),
                            B && (j = B),
                            B = t[Q],
                            ae = G ? G.sub(B)._unit()._perp() : X,
                            X = X || ae;
                            let R = X.add(ae);
                            R.x === 0 && R.y === 0 || R._unit();
                            const Z = X.x * ae.x + X.y * ae.y
                              , ee = R.x * ae.x + R.y * ae.y
                              , ye = ee !== 0 ? 1 / ee : 1 / 0
                              , Le = 2 * Math.sqrt(2 - 2 * ee)
                              , be = ee < Mg && j && G
                              , Me = X.x * ae.y - X.y * ae.x > 0;
                            if (be && Q > P) {
                                const Be = B.dist(j);
                                if (Be > 2 * D) {
                                    const Ee = B.sub(B.sub(j)._mult(D / Be)._round());
                                    this.updateDistance(j, Ee),
                                    this.addCurrentVertex(Ee, X, 0, 0, F),
                                    j = Ee
                                }
                            }
                            const Fe = j && G;
                            let Re = Fe ? s : b ? "butt" : c;
                            if (Fe && Re === "round" && (ye < p ? Re = "miter" : ye <= 2 && (Re = "fakeround")),
                            Re === "miter" && ye > d && (Re = "bevel"),
                            Re === "bevel" && (ye > 2 && (Re = "flipbevel"),
                            ye < d && (Re = "miter")),
                            j && this.updateDistance(j, B),
                            Re === "miter")
                                R._mult(ye),
                                this.addCurrentVertex(B, R, 0, 0, F);
                            else if (Re === "flipbevel") {
                                if (ye > 100)
                                    R = ae.mult(-1);
                                else {
                                    const Be = ye * X.add(ae).mag() / X.sub(ae).mag();
                                    R._perp()._mult(Be * (Me ? -1 : 1))
                                }
                                this.addCurrentVertex(B, R, 0, 0, F),
                                this.addCurrentVertex(B, R.mult(-1), 0, 0, F)
                            } else if (Re === "bevel" || Re === "fakeround") {
                                const Be = -Math.sqrt(ye * ye - 1)
                                  , Ee = Me ? Be : 0
                                  , Ue = Me ? 0 : Be;
                                if (j && this.addCurrentVertex(B, X, Ee, Ue, F),
                                Re === "fakeround") {
                                    const Qe = Math.round(180 * Le / Math.PI / 20);
                                    for (let Ye = 1; Ye < Qe; Ye++) {
                                        let qe = Ye / Qe;
                                        if (qe !== .5) {
                                            const Yt = qe - .5;
                                            qe += qe * Yt * (qe - 1) * ((1.0904 + Z * (Z * (3.55645 - 1.43519 * Z) - 3.2452)) * Yt * Yt + (.848013 + Z * (.215638 * Z - 1.06021)))
                                        }
                                        const ht = ae.sub(X)._mult(qe)._add(X)._unit()._mult(Me ? -1 : 1);
                                        this.addHalfVertex(B, ht.x, ht.y, !1, Me, 0, F)
                                    }
                                }
                                G && this.addCurrentVertex(B, ae, -Ee, -Ue, F)
                            } else if (Re === "butt")
                                this.addCurrentVertex(B, R, 0, 0, F);
                            else if (Re === "square") {
                                const Be = j ? 1 : -1;
                                this.addCurrentVertex(B, R, Be, Be, F)
                            } else
                                Re === "round" && (j && (this.addCurrentVertex(B, X, 0, 0, F),
                                this.addCurrentVertex(B, X, 1, 1, F, !0)),
                                G && (this.addCurrentVertex(B, ae, -1, -1, F, !0),
                                this.addCurrentVertex(B, ae, 0, 0, F)));
                            if (be && Q < C - 1) {
                                const Be = B.dist(G);
                                if (Be > 2 * D) {
                                    const Ee = B.add(G.sub(B)._mult(D / Be)._round());
                                    this.updateDistance(B, Ee),
                                    this.addCurrentVertex(Ee, ae, 0, 0, F),
                                    B = Ee
                                }
                            }
                        }
                    }
                    addCurrentVertex(t, n, s, c, d, p=!1) {
                        const g = n.y * c - n.x
                          , x = -n.y - n.x * c;
                        this.addHalfVertex(t, n.x + n.y * s, n.y - n.x * s, p, !1, s, d),
                        this.addHalfVertex(t, g, x, p, !0, -c, d),
                        this.distance > xp / 2 && this.totalDistance === 0 && (this.distance = 0,
                        this.updateScaledDistance(),
                        this.addCurrentVertex(t, n, s, c, d, p))
                    }
                    addHalfVertex({x: t, y: n}, s, c, d, p, g, x) {
                        const b = .5 * (this.lineClips ? this.scaledDistance * (xp - 1) : this.scaledDistance);
                        this.layoutVertexArray.emplaceBack((t << 1) + (d ? 1 : 0), (n << 1) + (p ? 1 : 0), Math.round(63 * s) + 128, Math.round(63 * c) + 128, 1 + (g === 0 ? 0 : g < 0 ? -1 : 1) | (63 & b) << 2, b >> 6),
                        this.lineClips && this.layoutVertexArray2.emplaceBack((this.scaledDistance - this.lineClips.start) / (this.lineClips.end - this.lineClips.start), this.lineClipsArray.length);
                        const C = x.vertexLength++;
                        this.e1 >= 0 && this.e2 >= 0 && (this.indexArray.emplaceBack(this.e1, C, this.e2),
                        x.primitiveLength++),
                        p ? this.e2 = C : this.e1 = C
                    }
                    updateScaledDistance() {
                        this.scaledDistance = this.lineClips ? this.lineClips.start + (this.lineClips.end - this.lineClips.start) * this.distance / this.totalDistance : this.distance
                    }
                    updateDistance(t, n) {
                        this.distance += t.dist(n),
                        this.updateScaledDistance()
                    }
                }
                let vp, bp;
                Ve("LineBucket", Fh, {
                    omit: ["layers", "patternFeatures"]
                });
                var wp = {
                    get paint() {
                        return bp = bp || new rr({
                            "line-opacity": new et(E.paint_line["line-opacity"]),
                            "line-color": new et(E.paint_line["line-color"]),
                            "line-translate": new Xe(E.paint_line["line-translate"]),
                            "line-translate-anchor": new Xe(E.paint_line["line-translate-anchor"]),
                            "line-width": new et(E.paint_line["line-width"]),
                            "line-gap-width": new et(E.paint_line["line-gap-width"]),
                            "line-offset": new et(E.paint_line["line-offset"]),
                            "line-blur": new et(E.paint_line["line-blur"]),
                            "line-dasharray": new pa(E.paint_line["line-dasharray"]),
                            "line-pattern": new bo(E.paint_line["line-pattern"]),
                            "line-gradient": new Bl(E.paint_line["line-gradient"])
                        })
                    },
                    get layout() {
                        return vp = vp || new rr({
                            "line-cap": new Xe(E.layout_line["line-cap"]),
                            "line-join": new et(E.layout_line["line-join"]),
                            "line-miter-limit": new Xe(E.layout_line["line-miter-limit"]),
                            "line-round-limit": new Xe(E.layout_line["line-round-limit"]),
                            "line-sort-key": new et(E.layout_line["line-sort-key"])
                        })
                    }
                };
                class Cg extends et {
                    possiblyEvaluate(t, n) {
                        return n = new Ut(Math.floor(n.zoom),{
                            now: n.now,
                            fadeDuration: n.fadeDuration,
                            zoomHistory: n.zoomHistory,
                            transition: n.transition
                        }),
                        super.possiblyEvaluate(t, n)
                    }
                    evaluate(t, n, s, c) {
                        return n = Ft({}, n, {
                            zoom: Math.floor(n.zoom)
                        }),
                        super.evaluate(t, n, s, c)
                    }
                }
                let xu;
                class Pg extends sn {
                    constructor(t) {
                        super(t, wp),
                        this.gradientVersion = 0,
                        xu || (xu = new Cg(wp.paint.properties["line-width"].specification),
                        xu.useIntegerZoom = !0)
                    }
                    _handleSpecialPaintPropertyUpdate(t) {
                        if (t === "line-gradient") {
                            const n = this.gradientExpression();
                            this.stepInterpolant = !!function(s) {
                                return s._styleExpression !== void 0
                            }(n) && n._styleExpression.expression instanceof zs,
                            this.gradientVersion = (this.gradientVersion + 1) % Number.MAX_SAFE_INTEGER
                        }
                    }
                    gradientExpression() {
                        return this._transitionablePaint._values["line-gradient"].value.expression
                    }
                    recalculate(t, n) {
                        super.recalculate(t, n),
                        this.paint._values["line-floorwidth"] = xu.possiblyEvaluate(this._transitioningPaint._values["line-width"].value, t)
                    }
                    createBucket(t) {
                        return new Fh(t)
                    }
                    queryRadius(t) {
                        const n = t
                          , s = Tp(Gl("line-width", this, n), Gl("line-gap-width", this, n))
                          , c = Gl("line-offset", this, n);
                        return s / 2 + Math.abs(c) + pu(this.paint.get("line-translate"))
                    }
                    queryIntersectsFeature({queryGeometry: t, feature: n, featureState: s, geometry: c, transform: d, pixelsToTileUnits: p}) {
                        const g = fu(t, this.paint.get("line-translate"), this.paint.get("line-translate-anchor"), -d.bearingInRadians, p)
                          , x = p / 2 * Tp(this.paint.get("line-width").evaluate(n, s), this.paint.get("line-gap-width").evaluate(n, s))
                          , b = this.paint.get("line-offset").evaluate(n, s);
                        return b && (c = function(C, P) {
                            const D = [];
                            for (let F = 0; F < C.length; F++) {
                                const B = C[F]
                                  , j = [];
                                for (let G = 0; G < B.length; G++) {
                                    const X = B[G - 1]
                                      , ae = B[G]
                                      , Q = B[G + 1]
                                      , R = G === 0 ? new Te(0,0) : ae.sub(X)._unit()._perp()
                                      , Z = G === B.length - 1 ? new Te(0,0) : Q.sub(ae)._unit()._perp()
                                      , ee = R._add(Z)._unit()
                                      , ye = ee.x * Z.x + ee.y * Z.y;
                                    ye !== 0 && ee._mult(1 / ye),
                                    j.push(ee._mult(P)._add(ae))
                                }
                                D.push(j)
                            }
                            return D
                        }(c, b * p)),
                        function(C, P, D) {
                            for (let F = 0; F < P.length; F++) {
                                const B = P[F];
                                if (C.length >= 3) {
                                    for (let j = 0; j < B.length; j++)
                                        if (Ma(C, B[j]))
                                            return !0
                                }
                                if (Vm(C, B, D))
                                    return !0
                            }
                            return !1
                        }(g, c, x)
                    }
                    isTileClipped() {
                        return !0
                    }
                }
                function Tp(r, t) {
                    return t > 0 ? t + 2 * r : r
                }
                const Sg = li([{
                    name: "a_pos_offset",
                    components: 4,
                    type: "Int16"
                }, {
                    name: "a_data",
                    components: 4,
                    type: "Uint16"
                }, {
                    name: "a_pixeloffset",
                    components: 4,
                    type: "Int16"
                }], 4)
                  , Ig = li([{
                    name: "a_projected_pos",
                    components: 3,
                    type: "Float32"
                }], 4);
                li([{
                    name: "a_fade_opacity",
                    components: 1,
                    type: "Uint32"
                }], 4);
                const Eg = li([{
                    name: "a_placed",
                    components: 2,
                    type: "Uint8"
                }, {
                    name: "a_shift",
                    components: 2,
                    type: "Float32"
                }, {
                    name: "a_box_real",
                    components: 2,
                    type: "Int16"
                }]);
                li([{
                    type: "Int16",
                    name: "anchorPointX"
                }, {
                    type: "Int16",
                    name: "anchorPointY"
                }, {
                    type: "Int16",
                    name: "x1"
                }, {
                    type: "Int16",
                    name: "y1"
                }, {
                    type: "Int16",
                    name: "x2"
                }, {
                    type: "Int16",
                    name: "y2"
                }, {
                    type: "Uint32",
                    name: "featureIndex"
                }, {
                    type: "Uint16",
                    name: "sourceLayerIndex"
                }, {
                    type: "Uint16",
                    name: "bucketIndex"
                }]);
                const Mp = li([{
                    name: "a_pos",
                    components: 2,
                    type: "Int16"
                }, {
                    name: "a_anchor_pos",
                    components: 2,
                    type: "Int16"
                }, {
                    name: "a_extrude",
                    components: 2,
                    type: "Int16"
                }], 4)
                  , Ag = li([{
                    name: "a_pos",
                    components: 2,
                    type: "Float32"
                }, {
                    name: "a_radius",
                    components: 1,
                    type: "Float32"
                }, {
                    name: "a_flags",
                    components: 2,
                    type: "Int16"
                }], 4);
                function zg(r, t, n) {
                    return r.sections.forEach(s => {
                        s.text = function(c, d, p) {
                            const g = d.layout.get("text-transform").evaluate(p, {});
                            return g === "uppercase" ? c = c.toLocaleUpperCase() : g === "lowercase" && (c = c.toLocaleLowerCase()),
                            Vn.applyArabicShaping && (c = Vn.applyArabicShaping(c)),
                            c
                        }(s.text, t, n)
                    }
                    ),
                    r
                }
                li([{
                    name: "triangle",
                    components: 3,
                    type: "Uint16"
                }]),
                li([{
                    type: "Int16",
                    name: "anchorX"
                }, {
                    type: "Int16",
                    name: "anchorY"
                }, {
                    type: "Uint16",
                    name: "glyphStartIndex"
                }, {
                    type: "Uint16",
                    name: "numGlyphs"
                }, {
                    type: "Uint32",
                    name: "vertexStartIndex"
                }, {
                    type: "Uint32",
                    name: "lineStartIndex"
                }, {
                    type: "Uint32",
                    name: "lineLength"
                }, {
                    type: "Uint16",
                    name: "segment"
                }, {
                    type: "Uint16",
                    name: "lowerSize"
                }, {
                    type: "Uint16",
                    name: "upperSize"
                }, {
                    type: "Float32",
                    name: "lineOffsetX"
                }, {
                    type: "Float32",
                    name: "lineOffsetY"
                }, {
                    type: "Uint8",
                    name: "writingMode"
                }, {
                    type: "Uint8",
                    name: "placedOrientation"
                }, {
                    type: "Uint8",
                    name: "hidden"
                }, {
                    type: "Uint32",
                    name: "crossTileID"
                }, {
                    type: "Int16",
                    name: "associatedIconIndex"
                }]),
                li([{
                    type: "Int16",
                    name: "anchorX"
                }, {
                    type: "Int16",
                    name: "anchorY"
                }, {
                    type: "Int16",
                    name: "rightJustifiedTextSymbolIndex"
                }, {
                    type: "Int16",
                    name: "centerJustifiedTextSymbolIndex"
                }, {
                    type: "Int16",
                    name: "leftJustifiedTextSymbolIndex"
                }, {
                    type: "Int16",
                    name: "verticalPlacedTextSymbolIndex"
                }, {
                    type: "Int16",
                    name: "placedIconSymbolIndex"
                }, {
                    type: "Int16",
                    name: "verticalPlacedIconSymbolIndex"
                }, {
                    type: "Uint16",
                    name: "key"
                }, {
                    type: "Uint16",
                    name: "textBoxStartIndex"
                }, {
                    type: "Uint16",
                    name: "textBoxEndIndex"
                }, {
                    type: "Uint16",
                    name: "verticalTextBoxStartIndex"
                }, {
                    type: "Uint16",
                    name: "verticalTextBoxEndIndex"
                }, {
                    type: "Uint16",
                    name: "iconBoxStartIndex"
                }, {
                    type: "Uint16",
                    name: "iconBoxEndIndex"
                }, {
                    type: "Uint16",
                    name: "verticalIconBoxStartIndex"
                }, {
                    type: "Uint16",
                    name: "verticalIconBoxEndIndex"
                }, {
                    type: "Uint16",
                    name: "featureIndex"
                }, {
                    type: "Uint16",
                    name: "numHorizontalGlyphVertices"
                }, {
                    type: "Uint16",
                    name: "numVerticalGlyphVertices"
                }, {
                    type: "Uint16",
                    name: "numIconVertices"
                }, {
                    type: "Uint16",
                    name: "numVerticalIconVertices"
                }, {
                    type: "Uint16",
                    name: "useRuntimeCollisionCircles"
                }, {
                    type: "Uint32",
                    name: "crossTileID"
                }, {
                    type: "Float32",
                    name: "textBoxScale"
                }, {
                    type: "Float32",
                    name: "collisionCircleDiameter"
                }, {
                    type: "Uint16",
                    name: "textAnchorOffsetStartIndex"
                }, {
                    type: "Uint16",
                    name: "textAnchorOffsetEndIndex"
                }]),
                li([{
                    type: "Float32",
                    name: "offsetX"
                }]),
                li([{
                    type: "Int16",
                    name: "x"
                }, {
                    type: "Int16",
                    name: "y"
                }, {
                    type: "Int16",
                    name: "tileUnitDistanceFromAnchor"
                }]),
                li([{
                    type: "Uint16",
                    name: "textAnchor"
                }, {
                    type: "Float32",
                    components: 2,
                    name: "textOffset"
                }]);
                const tc = {
                    "!": "︕",
                    "#": "＃",
                    $: "＄",
                    "%": "％",
                    "&": "＆",
                    "(": "︵",
                    ")": "︶",
                    "*": "＊",
                    "+": "＋",
                    ",": "︐",
                    "-": "︲",
                    ".": "・",
                    "/": "／",
                    ":": "︓",
                    ";": "︔",
                    "<": "︿",
                    "=": "＝",
                    ">": "﹀",
                    "?": "︖",
                    "@": "＠",
                    "[": "﹇",
                    "\\": "＼",
                    "]": "﹈",
                    "^": "＾",
                    _: "︳",
                    "`": "｀",
                    "{": "︷",
                    "|": "―",
                    "}": "︸",
                    "~": "～",
                    "¢": "￠",
                    "£": "￡",
                    "¥": "￥",
                    "¦": "￤",
                    "¬": "￢",
                    "¯": "￣",
                    "–": "︲",
                    "—": "︱",
                    "‘": "﹃",
                    "’": "﹄",
                    "“": "﹁",
                    "”": "﹂",
                    "…": "︙",
                    "‧": "・",
                    "₩": "￦",
                    "、": "︑",
                    "。": "︒",
                    "〈": "︿",
                    "〉": "﹀",
                    "《": "︽",
                    "》": "︾",
                    "「": "﹁",
                    "」": "﹂",
                    "『": "﹃",
                    "』": "﹄",
                    "【": "︻",
                    "】": "︼",
                    "〔": "︹",
                    "〕": "︺",
                    "〖": "︗",
                    "〗": "︘",
                    "！": "︕",
                    "（": "︵",
                    "）": "︶",
                    "，": "︐",
                    "－": "︲",
                    "．": "・",
                    "：": "︓",
                    "；": "︔",
                    "＜": "︿",
                    "＞": "﹀",
                    "？": "︖",
                    "［": "﹇",
                    "］": "﹈",
                    "＿": "︳",
                    "｛": "︷",
                    "｜": "―",
                    "｝": "︸",
                    "｟": "︵",
                    "｠": "︶",
                    "｡": "︒",
                    "｢": "﹁",
                    "｣": "﹂"
                };
                var Cp, Bh, Pp, Ti = 24, Oh = {};
                function kg() {
                    return Cp || (Cp = 1,
                    Oh.read = function(r, t, n, s, c) {
                        var d, p, g = 8 * c - s - 1, x = (1 << g) - 1, b = x >> 1, C = -7, P = n ? c - 1 : 0, D = n ? -1 : 1, F = r[t + P];
                        for (P += D,
                        d = F & (1 << -C) - 1,
                        F >>= -C,
                        C += g; C > 0; d = 256 * d + r[t + P],
                        P += D,
                        C -= 8)
                            ;
                        for (p = d & (1 << -C) - 1,
                        d >>= -C,
                        C += s; C > 0; p = 256 * p + r[t + P],
                        P += D,
                        C -= 8)
                            ;
                        if (d === 0)
                            d = 1 - b;
                        else {
                            if (d === x)
                                return p ? NaN : 1 / 0 * (F ? -1 : 1);
                            p += Math.pow(2, s),
                            d -= b
                        }
                        return (F ? -1 : 1) * p * Math.pow(2, d - s)
                    }
                    ,
                    Oh.write = function(r, t, n, s, c, d) {
                        var p, g, x, b = 8 * d - c - 1, C = (1 << b) - 1, P = C >> 1, D = c === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0, F = s ? 0 : d - 1, B = s ? 1 : -1, j = t < 0 || t === 0 && 1 / t < 0 ? 1 : 0;
                        for (t = Math.abs(t),
                        isNaN(t) || t === 1 / 0 ? (g = isNaN(t) ? 1 : 0,
                        p = C) : (p = Math.floor(Math.log(t) / Math.LN2),
                        t * (x = Math.pow(2, -p)) < 1 && (p--,
                        x *= 2),
                        (t += p + P >= 1 ? D / x : D * Math.pow(2, 1 - P)) * x >= 2 && (p++,
                        x /= 2),
                        p + P >= C ? (g = 0,
                        p = C) : p + P >= 1 ? (g = (t * x - 1) * Math.pow(2, c),
                        p += P) : (g = t * Math.pow(2, P - 1) * Math.pow(2, c),
                        p = 0)); c >= 8; r[n + F] = 255 & g,
                        F += B,
                        g /= 256,
                        c -= 8)
                            ;
                        for (p = p << c | g,
                        b += c; b > 0; r[n + F] = 255 & p,
                        F += B,
                        p /= 256,
                        b -= 8)
                            ;
                        r[n + F - B] |= 128 * j
                    }
                    ),
                    Oh
                }
                function Sp() {
                    if (Pp)
                        return Bh;
                    Pp = 1,
                    Bh = t;
                    var r = kg();
                    function t(R) {
                        this.buf = ArrayBuffer.isView && ArrayBuffer.isView(R) ? R : new Uint8Array(R || 0),
                        this.pos = 0,
                        this.type = 0,
                        this.length = this.buf.length
                    }
                    t.Varint = 0,
                    t.Fixed64 = 1,
                    t.Bytes = 2,
                    t.Fixed32 = 5;
                    var n = 4294967296
                      , s = 1 / n
                      , c = typeof TextDecoder > "u" ? null : new TextDecoder("utf-8");
                    function d(R) {
                        return R.type === t.Bytes ? R.readVarint() + R.pos : R.pos + 1
                    }
                    function p(R, Z, ee) {
                        return ee ? 4294967296 * Z + (R >>> 0) : 4294967296 * (Z >>> 0) + (R >>> 0)
                    }
                    function g(R, Z, ee) {
                        var ye = Z <= 16383 ? 1 : Z <= 2097151 ? 2 : Z <= 268435455 ? 3 : Math.floor(Math.log(Z) / (7 * Math.LN2));
                        ee.realloc(ye);
                        for (var Le = ee.pos - 1; Le >= R; Le--)
                            ee.buf[Le + ye] = ee.buf[Le]
                    }
                    function x(R, Z) {
                        for (var ee = 0; ee < R.length; ee++)
                            Z.writeVarint(R[ee])
                    }
                    function b(R, Z) {
                        for (var ee = 0; ee < R.length; ee++)
                            Z.writeSVarint(R[ee])
                    }
                    function C(R, Z) {
                        for (var ee = 0; ee < R.length; ee++)
                            Z.writeFloat(R[ee])
                    }
                    function P(R, Z) {
                        for (var ee = 0; ee < R.length; ee++)
                            Z.writeDouble(R[ee])
                    }
                    function D(R, Z) {
                        for (var ee = 0; ee < R.length; ee++)
                            Z.writeBoolean(R[ee])
                    }
                    function F(R, Z) {
                        for (var ee = 0; ee < R.length; ee++)
                            Z.writeFixed32(R[ee])
                    }
                    function B(R, Z) {
                        for (var ee = 0; ee < R.length; ee++)
                            Z.writeSFixed32(R[ee])
                    }
                    function j(R, Z) {
                        for (var ee = 0; ee < R.length; ee++)
                            Z.writeFixed64(R[ee])
                    }
                    function G(R, Z) {
                        for (var ee = 0; ee < R.length; ee++)
                            Z.writeSFixed64(R[ee])
                    }
                    function X(R, Z) {
                        return (R[Z] | R[Z + 1] << 8 | R[Z + 2] << 16) + 16777216 * R[Z + 3]
                    }
                    function ae(R, Z, ee) {
                        R[ee] = Z,
                        R[ee + 1] = Z >>> 8,
                        R[ee + 2] = Z >>> 16,
                        R[ee + 3] = Z >>> 24
                    }
                    function Q(R, Z) {
                        return (R[Z] | R[Z + 1] << 8 | R[Z + 2] << 16) + (R[Z + 3] << 24)
                    }
                    return t.prototype = {
                        destroy: function() {
                            this.buf = null
                        },
                        readFields: function(R, Z, ee) {
                            for (ee = ee || this.length; this.pos < ee; ) {
                                var ye = this.readVarint()
                                  , Le = ye >> 3
                                  , be = this.pos;
                                this.type = 7 & ye,
                                R(Le, Z, this),
                                this.pos === be && this.skip(ye)
                            }
                            return Z
                        },
                        readMessage: function(R, Z) {
                            return this.readFields(R, Z, this.readVarint() + this.pos)
                        },
                        readFixed32: function() {
                            var R = X(this.buf, this.pos);
                            return this.pos += 4,
                            R
                        },
                        readSFixed32: function() {
                            var R = Q(this.buf, this.pos);
                            return this.pos += 4,
                            R
                        },
                        readFixed64: function() {
                            var R = X(this.buf, this.pos) + X(this.buf, this.pos + 4) * n;
                            return this.pos += 8,
                            R
                        },
                        readSFixed64: function() {
                            var R = X(this.buf, this.pos) + Q(this.buf, this.pos + 4) * n;
                            return this.pos += 8,
                            R
                        },
                        readFloat: function() {
                            var R = r.read(this.buf, this.pos, !0, 23, 4);
                            return this.pos += 4,
                            R
                        },
                        readDouble: function() {
                            var R = r.read(this.buf, this.pos, !0, 52, 8);
                            return this.pos += 8,
                            R
                        },
                        readVarint: function(R) {
                            var Z, ee, ye = this.buf;
                            return Z = 127 & (ee = ye[this.pos++]),
                            ee < 128 ? Z : (Z |= (127 & (ee = ye[this.pos++])) << 7,
                            ee < 128 ? Z : (Z |= (127 & (ee = ye[this.pos++])) << 14,
                            ee < 128 ? Z : (Z |= (127 & (ee = ye[this.pos++])) << 21,
                            ee < 128 ? Z : function(Le, be, Me) {
                                var Fe, Re, Be = Me.buf;
                                if (Fe = (112 & (Re = Be[Me.pos++])) >> 4,
                                Re < 128 || (Fe |= (127 & (Re = Be[Me.pos++])) << 3,
                                Re < 128) || (Fe |= (127 & (Re = Be[Me.pos++])) << 10,
                                Re < 128) || (Fe |= (127 & (Re = Be[Me.pos++])) << 17,
                                Re < 128) || (Fe |= (127 & (Re = Be[Me.pos++])) << 24,
                                Re < 128) || (Fe |= (1 & (Re = Be[Me.pos++])) << 31,
                                Re < 128))
                                    return p(Le, Fe, be);
                                throw new Error("Expected varint not more than 10 bytes")
                            }(Z |= (15 & (ee = ye[this.pos])) << 28, R, this))))
                        },
                        readVarint64: function() {
                            return this.readVarint(!0)
                        },
                        readSVarint: function() {
                            var R = this.readVarint();
                            return R % 2 == 1 ? (R + 1) / -2 : R / 2
                        },
                        readBoolean: function() {
                            return !!this.readVarint()
                        },
                        readString: function() {
                            var R = this.readVarint() + this.pos
                              , Z = this.pos;
                            return this.pos = R,
                            R - Z >= 12 && c ? function(ee, ye, Le) {
                                return c.decode(ee.subarray(ye, Le))
                            }(this.buf, Z, R) : function(ee, ye, Le) {
                                for (var be = "", Me = ye; Me < Le; ) {
                                    var Fe, Re, Be, Ee = ee[Me], Ue = null, Qe = Ee > 239 ? 4 : Ee > 223 ? 3 : Ee > 191 ? 2 : 1;
                                    if (Me + Qe > Le)
                                        break;
                                    Qe === 1 ? Ee < 128 && (Ue = Ee) : Qe === 2 ? (192 & (Fe = ee[Me + 1])) == 128 && (Ue = (31 & Ee) << 6 | 63 & Fe) <= 127 && (Ue = null) : Qe === 3 ? (Re = ee[Me + 2],
                                    (192 & (Fe = ee[Me + 1])) == 128 && (192 & Re) == 128 && ((Ue = (15 & Ee) << 12 | (63 & Fe) << 6 | 63 & Re) <= 2047 || Ue >= 55296 && Ue <= 57343) && (Ue = null)) : Qe === 4 && (Re = ee[Me + 2],
                                    Be = ee[Me + 3],
                                    (192 & (Fe = ee[Me + 1])) == 128 && (192 & Re) == 128 && (192 & Be) == 128 && ((Ue = (15 & Ee) << 18 | (63 & Fe) << 12 | (63 & Re) << 6 | 63 & Be) <= 65535 || Ue >= 1114112) && (Ue = null)),
                                    Ue === null ? (Ue = 65533,
                                    Qe = 1) : Ue > 65535 && (Ue -= 65536,
                                    be += String.fromCharCode(Ue >>> 10 & 1023 | 55296),
                                    Ue = 56320 | 1023 & Ue),
                                    be += String.fromCharCode(Ue),
                                    Me += Qe
                                }
                                return be
                            }(this.buf, Z, R)
                        },
                        readBytes: function() {
                            var R = this.readVarint() + this.pos
                              , Z = this.buf.subarray(this.pos, R);
                            return this.pos = R,
                            Z
                        },
                        readPackedVarint: function(R, Z) {
                            if (this.type !== t.Bytes)
                                return R.push(this.readVarint(Z));
                            var ee = d(this);
                            for (R = R || []; this.pos < ee; )
                                R.push(this.readVarint(Z));
                            return R
                        },
                        readPackedSVarint: function(R) {
                            if (this.type !== t.Bytes)
                                return R.push(this.readSVarint());
                            var Z = d(this);
                            for (R = R || []; this.pos < Z; )
                                R.push(this.readSVarint());
                            return R
                        },
                        readPackedBoolean: function(R) {
                            if (this.type !== t.Bytes)
                                return R.push(this.readBoolean());
                            var Z = d(this);
                            for (R = R || []; this.pos < Z; )
                                R.push(this.readBoolean());
                            return R
                        },
                        readPackedFloat: function(R) {
                            if (this.type !== t.Bytes)
                                return R.push(this.readFloat());
                            var Z = d(this);
                            for (R = R || []; this.pos < Z; )
                                R.push(this.readFloat());
                            return R
                        },
                        readPackedDouble: function(R) {
                            if (this.type !== t.Bytes)
                                return R.push(this.readDouble());
                            var Z = d(this);
                            for (R = R || []; this.pos < Z; )
                                R.push(this.readDouble());
                            return R
                        },
                        readPackedFixed32: function(R) {
                            if (this.type !== t.Bytes)
                                return R.push(this.readFixed32());
                            var Z = d(this);
                            for (R = R || []; this.pos < Z; )
                                R.push(this.readFixed32());
                            return R
                        },
                        readPackedSFixed32: function(R) {
                            if (this.type !== t.Bytes)
                                return R.push(this.readSFixed32());
                            var Z = d(this);
                            for (R = R || []; this.pos < Z; )
                                R.push(this.readSFixed32());
                            return R
                        },
                        readPackedFixed64: function(R) {
                            if (this.type !== t.Bytes)
                                return R.push(this.readFixed64());
                            var Z = d(this);
                            for (R = R || []; this.pos < Z; )
                                R.push(this.readFixed64());
                            return R
                        },
                        readPackedSFixed64: function(R) {
                            if (this.type !== t.Bytes)
                                return R.push(this.readSFixed64());
                            var Z = d(this);
                            for (R = R || []; this.pos < Z; )
                                R.push(this.readSFixed64());
                            return R
                        },
                        skip: function(R) {
                            var Z = 7 & R;
                            if (Z === t.Varint)
                                for (; this.buf[this.pos++] > 127; )
                                    ;
                            else if (Z === t.Bytes)
                                this.pos = this.readVarint() + this.pos;
                            else if (Z === t.Fixed32)
                                this.pos += 4;
                            else {
                                if (Z !== t.Fixed64)
                                    throw new Error("Unimplemented type: " + Z);
                                this.pos += 8
                            }
                        },
                        writeTag: function(R, Z) {
                            this.writeVarint(R << 3 | Z)
                        },
                        realloc: function(R) {
                            for (var Z = this.length || 16; Z < this.pos + R; )
                                Z *= 2;
                            if (Z !== this.length) {
                                var ee = new Uint8Array(Z);
                                ee.set(this.buf),
                                this.buf = ee,
                                this.length = Z
                            }
                        },
                        finish: function() {
                            return this.length = this.pos,
                            this.pos = 0,
                            this.buf.subarray(0, this.length)
                        },
                        writeFixed32: function(R) {
                            this.realloc(4),
                            ae(this.buf, R, this.pos),
                            this.pos += 4
                        },
                        writeSFixed32: function(R) {
                            this.realloc(4),
                            ae(this.buf, R, this.pos),
                            this.pos += 4
                        },
                        writeFixed64: function(R) {
                            this.realloc(8),
                            ae(this.buf, -1 & R, this.pos),
                            ae(this.buf, Math.floor(R * s), this.pos + 4),
                            this.pos += 8
                        },
                        writeSFixed64: function(R) {
                            this.realloc(8),
                            ae(this.buf, -1 & R, this.pos),
                            ae(this.buf, Math.floor(R * s), this.pos + 4),
                            this.pos += 8
                        },
                        writeVarint: function(R) {
                            (R = +R || 0) > 268435455 || R < 0 ? function(Z, ee) {
                                var ye, Le;
                                if (Z >= 0 ? (ye = Z % 4294967296 | 0,
                                Le = Z / 4294967296 | 0) : (Le = ~(-Z / 4294967296),
                                4294967295 ^ (ye = ~(-Z % 4294967296)) ? ye = ye + 1 | 0 : (ye = 0,
                                Le = Le + 1 | 0)),
                                Z >= 18446744073709552e3 || Z < -18446744073709552e3)
                                    throw new Error("Given varint doesn't fit into 10 bytes");
                                ee.realloc(10),
                                function(be, Me, Fe) {
                                    Fe.buf[Fe.pos++] = 127 & be | 128,
                                    be >>>= 7,
                                    Fe.buf[Fe.pos++] = 127 & be | 128,
                                    be >>>= 7,
                                    Fe.buf[Fe.pos++] = 127 & be | 128,
                                    be >>>= 7,
                                    Fe.buf[Fe.pos++] = 127 & be | 128,
                                    Fe.buf[Fe.pos] = 127 & (be >>>= 7)
                                }(ye, 0, ee),
                                function(be, Me) {
                                    var Fe = (7 & be) << 4;
                                    Me.buf[Me.pos++] |= Fe | ((be >>>= 3) ? 128 : 0),
                                    be && (Me.buf[Me.pos++] = 127 & be | ((be >>>= 7) ? 128 : 0),
                                    be && (Me.buf[Me.pos++] = 127 & be | ((be >>>= 7) ? 128 : 0),
                                    be && (Me.buf[Me.pos++] = 127 & be | ((be >>>= 7) ? 128 : 0),
                                    be && (Me.buf[Me.pos++] = 127 & be | ((be >>>= 7) ? 128 : 0),
                                    be && (Me.buf[Me.pos++] = 127 & be)))))
                                }(Le, ee)
                            }(R, this) : (this.realloc(4),
                            this.buf[this.pos++] = 127 & R | (R > 127 ? 128 : 0),
                            R <= 127 || (this.buf[this.pos++] = 127 & (R >>>= 7) | (R > 127 ? 128 : 0),
                            R <= 127 || (this.buf[this.pos++] = 127 & (R >>>= 7) | (R > 127 ? 128 : 0),
                            R <= 127 || (this.buf[this.pos++] = R >>> 7 & 127))))
                        },
                        writeSVarint: function(R) {
                            this.writeVarint(R < 0 ? 2 * -R - 1 : 2 * R)
                        },
                        writeBoolean: function(R) {
                            this.writeVarint(!!R)
                        },
                        writeString: function(R) {
                            R = String(R),
                            this.realloc(4 * R.length),
                            this.pos++;
                            var Z = this.pos;
                            this.pos = function(ye, Le, be) {
                                for (var Me, Fe, Re = 0; Re < Le.length; Re++) {
                                    if ((Me = Le.charCodeAt(Re)) > 55295 && Me < 57344) {
                                        if (!Fe) {
                                            Me > 56319 || Re + 1 === Le.length ? (ye[be++] = 239,
                                            ye[be++] = 191,
                                            ye[be++] = 189) : Fe = Me;
                                            continue
                                        }
                                        if (Me < 56320) {
                                            ye[be++] = 239,
                                            ye[be++] = 191,
                                            ye[be++] = 189,
                                            Fe = Me;
                                            continue
                                        }
                                        Me = Fe - 55296 << 10 | Me - 56320 | 65536,
                                        Fe = null
                                    } else
                                        Fe && (ye[be++] = 239,
                                        ye[be++] = 191,
                                        ye[be++] = 189,
                                        Fe = null);
                                    Me < 128 ? ye[be++] = Me : (Me < 2048 ? ye[be++] = Me >> 6 | 192 : (Me < 65536 ? ye[be++] = Me >> 12 | 224 : (ye[be++] = Me >> 18 | 240,
                                    ye[be++] = Me >> 12 & 63 | 128),
                                    ye[be++] = Me >> 6 & 63 | 128),
                                    ye[be++] = 63 & Me | 128)
                                }
                                return be
                            }(this.buf, R, this.pos);
                            var ee = this.pos - Z;
                            ee >= 128 && g(Z, ee, this),
                            this.pos = Z - 1,
                            this.writeVarint(ee),
                            this.pos += ee
                        },
                        writeFloat: function(R) {
                            this.realloc(4),
                            r.write(this.buf, R, this.pos, !0, 23, 4),
                            this.pos += 4
                        },
                        writeDouble: function(R) {
                            this.realloc(8),
                            r.write(this.buf, R, this.pos, !0, 52, 8),
                            this.pos += 8
                        },
                        writeBytes: function(R) {
                            var Z = R.length;
                            this.writeVarint(Z),
                            this.realloc(Z);
                            for (var ee = 0; ee < Z; ee++)
                                this.buf[this.pos++] = R[ee]
                        },
                        writeRawMessage: function(R, Z) {
                            this.pos++;
                            var ee = this.pos;
                            R(Z, this);
                            var ye = this.pos - ee;
                            ye >= 128 && g(ee, ye, this),
                            this.pos = ee - 1,
                            this.writeVarint(ye),
                            this.pos += ye
                        },
                        writeMessage: function(R, Z, ee) {
                            this.writeTag(R, t.Bytes),
                            this.writeRawMessage(Z, ee)
                        },
                        writePackedVarint: function(R, Z) {
                            Z.length && this.writeMessage(R, x, Z)
                        },
                        writePackedSVarint: function(R, Z) {
                            Z.length && this.writeMessage(R, b, Z)
                        },
                        writePackedBoolean: function(R, Z) {
                            Z.length && this.writeMessage(R, D, Z)
                        },
                        writePackedFloat: function(R, Z) {
                            Z.length && this.writeMessage(R, C, Z)
                        },
                        writePackedDouble: function(R, Z) {
                            Z.length && this.writeMessage(R, P, Z)
                        },
                        writePackedFixed32: function(R, Z) {
                            Z.length && this.writeMessage(R, F, Z)
                        },
                        writePackedSFixed32: function(R, Z) {
                            Z.length && this.writeMessage(R, B, Z)
                        },
                        writePackedFixed64: function(R, Z) {
                            Z.length && this.writeMessage(R, j, Z)
                        },
                        writePackedSFixed64: function(R, Z) {
                            Z.length && this.writeMessage(R, G, Z)
                        },
                        writeBytesField: function(R, Z) {
                            this.writeTag(R, t.Bytes),
                            this.writeBytes(Z)
                        },
                        writeFixed32Field: function(R, Z) {
                            this.writeTag(R, t.Fixed32),
                            this.writeFixed32(Z)
                        },
                        writeSFixed32Field: function(R, Z) {
                            this.writeTag(R, t.Fixed32),
                            this.writeSFixed32(Z)
                        },
                        writeFixed64Field: function(R, Z) {
                            this.writeTag(R, t.Fixed64),
                            this.writeFixed64(Z)
                        },
                        writeSFixed64Field: function(R, Z) {
                            this.writeTag(R, t.Fixed64),
                            this.writeSFixed64(Z)
                        },
                        writeVarintField: function(R, Z) {
                            this.writeTag(R, t.Varint),
                            this.writeVarint(Z)
                        },
                        writeSVarintField: function(R, Z) {
                            this.writeTag(R, t.Varint),
                            this.writeSVarint(Z)
                        },
                        writeStringField: function(R, Z) {
                            this.writeTag(R, t.Bytes),
                            this.writeString(Z)
                        },
                        writeFloatField: function(R, Z) {
                            this.writeTag(R, t.Fixed32),
                            this.writeFloat(Z)
                        },
                        writeDoubleField: function(R, Z) {
                            this.writeTag(R, t.Fixed64),
                            this.writeDouble(Z)
                        },
                        writeBooleanField: function(R, Z) {
                            this.writeVarintField(R, !!Z)
                        }
                    },
                    Bh
                }
                var Nh = ce(Sp());
                const jh = 3;
                function Lg(r, t, n) {
                    r === 1 && n.readMessage(Dg, t)
                }
                function Dg(r, t, n) {
                    if (r === 3) {
                        const {id: s, bitmap: c, width: d, height: p, left: g, top: x, advance: b} = n.readMessage(Rg, {});
                        t.push({
                            id: s,
                            bitmap: new $l({
                                width: d + 2 * jh,
                                height: p + 2 * jh
                            },c),
                            metrics: {
                                width: d,
                                height: p,
                                left: g,
                                top: x,
                                advance: b
                            }
                        })
                    }
                }
                function Rg(r, t, n) {
                    r === 1 ? t.id = n.readVarint() : r === 2 ? t.bitmap = n.readBytes() : r === 3 ? t.width = n.readVarint() : r === 4 ? t.height = n.readVarint() : r === 5 ? t.left = n.readSVarint() : r === 6 ? t.top = n.readSVarint() : r === 7 && (t.advance = n.readVarint())
                }
                const Fg = jh;
                function Ip(r) {
                    let t = 0
                      , n = 0;
                    for (const p of r)
                        t += p.w * p.h,
                        n = Math.max(n, p.w);
                    r.sort( (p, g) => g.h - p.h);
                    const s = [{
                        x: 0,
                        y: 0,
                        w: Math.max(Math.ceil(Math.sqrt(t / .95)), n),
                        h: 1 / 0
                    }];
                    let c = 0
                      , d = 0;
                    for (const p of r)
                        for (let g = s.length - 1; g >= 0; g--) {
                            const x = s[g];
                            if (!(p.w > x.w || p.h > x.h)) {
                                if (p.x = x.x,
                                p.y = x.y,
                                d = Math.max(d, p.y + p.h),
                                c = Math.max(c, p.x + p.w),
                                p.w === x.w && p.h === x.h) {
                                    const b = s.pop();
                                    g < s.length && (s[g] = b)
                                } else
                                    p.h === x.h ? (x.x += p.w,
                                    x.w -= p.w) : p.w === x.w ? (x.y += p.h,
                                    x.h -= p.h) : (s.push({
                                        x: x.x + p.w,
                                        y: x.y,
                                        w: x.w - p.w,
                                        h: p.h
                                    }),
                                    x.y += p.h,
                                    x.h -= p.h);
                                break
                            }
                        }
                    return {
                        w: c,
                        h: d,
                        fill: t / (c * d) || 0
                    }
                }
                const dr = 1;
                class Vh {
                    constructor(t, {pixelRatio: n, version: s, stretchX: c, stretchY: d, content: p, textFitWidth: g, textFitHeight: x}) {
                        this.paddedRect = t,
                        this.pixelRatio = n,
                        this.stretchX = c,
                        this.stretchY = d,
                        this.content = p,
                        this.version = s,
                        this.textFitWidth = g,
                        this.textFitHeight = x
                    }
                    get tl() {
                        return [this.paddedRect.x + dr, this.paddedRect.y + dr]
                    }
                    get br() {
                        return [this.paddedRect.x + this.paddedRect.w - dr, this.paddedRect.y + this.paddedRect.h - dr]
                    }
                    get tlbr() {
                        return this.tl.concat(this.br)
                    }
                    get displaySize() {
                        return [(this.paddedRect.w - 2 * dr) / this.pixelRatio, (this.paddedRect.h - 2 * dr) / this.pixelRatio]
                    }
                }
                class Ep {
                    constructor(t, n) {
                        const s = {}
                          , c = {};
                        this.haveRenderCallbacks = [];
                        const d = [];
                        this.addImages(t, s, d),
                        this.addImages(n, c, d);
                        const {w: p, h: g} = Ip(d)
                          , x = new Gr({
                            width: p || 1,
                            height: g || 1
                        });
                        for (const b in t) {
                            const C = t[b]
                              , P = s[b].paddedRect;
                            Gr.copy(C.data, x, {
                                x: 0,
                                y: 0
                            }, {
                                x: P.x + dr,
                                y: P.y + dr
                            }, C.data)
                        }
                        for (const b in n) {
                            const C = n[b]
                              , P = c[b].paddedRect
                              , D = P.x + dr
                              , F = P.y + dr
                              , B = C.data.width
                              , j = C.data.height;
                            Gr.copy(C.data, x, {
                                x: 0,
                                y: 0
                            }, {
                                x: D,
                                y: F
                            }, C.data),
                            Gr.copy(C.data, x, {
                                x: 0,
                                y: j - 1
                            }, {
                                x: D,
                                y: F - 1
                            }, {
                                width: B,
                                height: 1
                            }),
                            Gr.copy(C.data, x, {
                                x: 0,
                                y: 0
                            }, {
                                x: D,
                                y: F + j
                            }, {
                                width: B,
                                height: 1
                            }),
                            Gr.copy(C.data, x, {
                                x: B - 1,
                                y: 0
                            }, {
                                x: D - 1,
                                y: F
                            }, {
                                width: 1,
                                height: j
                            }),
                            Gr.copy(C.data, x, {
                                x: 0,
                                y: 0
                            }, {
                                x: D + B,
                                y: F
                            }, {
                                width: 1,
                                height: j
                            })
                        }
                        this.image = x,
                        this.iconPositions = s,
                        this.patternPositions = c
                    }
                    addImages(t, n, s) {
                        for (const c in t) {
                            const d = t[c]
                              , p = {
                                x: 0,
                                y: 0,
                                w: d.data.width + 2 * dr,
                                h: d.data.height + 2 * dr
                            };
                            s.push(p),
                            n[c] = new Vh(p,d),
                            d.hasRenderCallback && this.haveRenderCallbacks.push(c)
                        }
                    }
                    patchUpdatedImages(t, n) {
                        t.dispatchRenderCallbacks(this.haveRenderCallbacks);
                        for (const s in t.updatedImages)
                            this.patchUpdatedImage(this.iconPositions[s], t.getImage(s), n),
                            this.patchUpdatedImage(this.patternPositions[s], t.getImage(s), n)
                    }
                    patchUpdatedImage(t, n, s) {
                        if (!t || !n || t.version === n.version)
                            return;
                        t.version = n.version;
                        const [c,d] = t.tl;
                        s.update(n.data, void 0, {
                            x: c,
                            y: d
                        })
                    }
                }
                var $s;
                Ve("ImagePosition", Vh),
                Ve("ImageAtlas", Ep),
                M.ag = void 0,
                ($s = M.ag || (M.ag = {}))[$s.none = 0] = "none",
                $s[$s.horizontal = 1] = "horizontal",
                $s[$s.vertical = 2] = "vertical",
                $s[$s.horizontalOnly = 3] = "horizontalOnly";
                const vu = -17;
                class ic {
                    constructor() {
                        this.scale = 1,
                        this.fontStack = "",
                        this.imageName = null,
                        this.verticalAlign = "bottom"
                    }
                    static forText(t, n, s) {
                        const c = new ic;
                        return c.scale = t || 1,
                        c.fontStack = n,
                        c.verticalAlign = s || "bottom",
                        c
                    }
                    static forImage(t, n) {
                        const s = new ic;
                        return s.imageName = t,
                        s.verticalAlign = n || "bottom",
                        s
                    }
                }
                class Ia {
                    constructor() {
                        this.text = "",
                        this.sectionIndex = [],
                        this.sections = [],
                        this.imageSectionID = null
                    }
                    static fromFeature(t, n) {
                        const s = new Ia;
                        for (let c = 0; c < t.sections.length; c++) {
                            const d = t.sections[c];
                            d.image ? s.addImageSection(d) : s.addTextSection(d, n)
                        }
                        return s
                    }
                    length() {
                        return this.text.length
                    }
                    getSection(t) {
                        return this.sections[this.sectionIndex[t]]
                    }
                    getSectionIndex(t) {
                        return this.sectionIndex[t]
                    }
                    getCharCode(t) {
                        return this.text.charCodeAt(t)
                    }
                    verticalizePunctuation() {
                        this.text = function(t) {
                            let n = "";
                            for (let s = 0; s < t.length; s++) {
                                const c = t.charCodeAt(s + 1) || null
                                  , d = t.charCodeAt(s - 1) || null;
                                n += c && Ll(c) && !tc[t[s + 1]] || d && Ll(d) && !tc[t[s - 1]] || !tc[t[s]] ? t[s] : tc[t[s]]
                            }
                            return n
                        }(this.text)
                    }
                    trim() {
                        let t = 0;
                        for (let s = 0; s < this.text.length && wu[this.text.charCodeAt(s)]; s++)
                            t++;
                        let n = this.text.length;
                        for (let s = this.text.length - 1; s >= 0 && s >= t && wu[this.text.charCodeAt(s)]; s--)
                            n--;
                        this.text = this.text.substring(t, n),
                        this.sectionIndex = this.sectionIndex.slice(t, n)
                    }
                    substring(t, n) {
                        const s = new Ia;
                        return s.text = this.text.substring(t, n),
                        s.sectionIndex = this.sectionIndex.slice(t, n),
                        s.sections = this.sections,
                        s
                    }
                    toString() {
                        return this.text
                    }
                    getMaxScale() {
                        return this.sectionIndex.reduce( (t, n) => Math.max(t, this.sections[n].scale), 0)
                    }
                    getMaxImageSize(t) {
                        let n = 0
                          , s = 0;
                        for (let c = 0; c < this.length(); c++) {
                            const d = this.getSection(c);
                            if (d.imageName) {
                                const p = t[d.imageName];
                                if (!p)
                                    continue;
                                const g = p.displaySize;
                                n = Math.max(n, g[0]),
                                s = Math.max(s, g[1])
                            }
                        }
                        return {
                            maxImageWidth: n,
                            maxImageHeight: s
                        }
                    }
                    addTextSection(t, n) {
                        this.text += t.text,
                        this.sections.push(ic.forText(t.scale, t.fontStack || n, t.verticalAlign));
                        const s = this.sections.length - 1;
                        for (let c = 0; c < t.text.length; ++c)
                            this.sectionIndex.push(s)
                    }
                    addImageSection(t) {
                        const n = t.image ? t.image.name : "";
                        if (n.length === 0)
                            return void yi("Can't add FormattedSection with an empty image.");
                        const s = this.getNextImageSectionCharCode();
                        s ? (this.text += String.fromCharCode(s),
                        this.sections.push(ic.forImage(n, t.verticalAlign)),
                        this.sectionIndex.push(this.sections.length - 1)) : yi("Reached maximum number of images 6401")
                    }
                    getNextImageSectionCharCode() {
                        return this.imageSectionID ? this.imageSectionID >= 63743 ? null : ++this.imageSectionID : (this.imageSectionID = 57344,
                        this.imageSectionID)
                    }
                }
                function bu(r, t, n, s, c, d, p, g, x, b, C, P, D, F, B) {
                    const j = Ia.fromFeature(r, c);
                    let G;
                    P === M.ag.vertical && j.verticalizePunctuation();
                    const {processBidirectionalText: X, processStyledBidirectionalText: ae} = Vn;
                    if (X && j.sections.length === 1) {
                        G = [];
                        const Z = X(j.toString(), Uh(j, b, d, t, s, F));
                        for (const ee of Z) {
                            const ye = new Ia;
                            ye.text = ee,
                            ye.sections = j.sections;
                            for (let Le = 0; Le < ee.length; Le++)
                                ye.sectionIndex.push(0);
                            G.push(ye)
                        }
                    } else if (ae) {
                        G = [];
                        const Z = ae(j.text, j.sectionIndex, Uh(j, b, d, t, s, F));
                        for (const ee of Z) {
                            const ye = new Ia;
                            ye.text = ee[0],
                            ye.sectionIndex = ee[1],
                            ye.sections = j.sections,
                            G.push(ye)
                        }
                    } else
                        G = function(Z, ee) {
                            const ye = []
                              , Le = Z.text;
                            let be = 0;
                            for (const Me of ee)
                                ye.push(Z.substring(be, Me)),
                                be = Me;
                            return be < Le.length && ye.push(Z.substring(be, Le.length)),
                            ye
                        }(j, Uh(j, b, d, t, s, F));
                    const Q = []
                      , R = {
                        positionedLines: Q,
                        text: j.toString(),
                        top: C[1],
                        bottom: C[1],
                        left: C[0],
                        right: C[0],
                        writingMode: P,
                        iconsInText: !1,
                        verticalizable: !1
                    };
                    return function(Z, ee, ye, Le, be, Me, Fe, Re, Be, Ee, Ue, Qe) {
                        let Ye = 0
                          , qe = 0
                          , ht = 0
                          , Yt = 0;
                        const Mi = Re === "right" ? 1 : Re === "left" ? 0 : .5
                          , $i = Ti / Qe;
                        let qr = 0;
                        for (const qt of be) {
                            qt.trim();
                            const zi = qt.getMaxScale()
                              , Ni = {
                                positionedGlyphs: [],
                                lineOffset: 0
                            };
                            Z.positionedLines[qr] = Ni;
                            const ji = Ni.positionedGlyphs;
                            let nr = 0;
                            if (!qt.length()) {
                                qe += Me,
                                ++qr;
                                continue
                            }
                            const Hr = jg(Le, qt, $i);
                            for (let fr = 0; fr < qt.length(); fr++) {
                                const Ci = qt.getSection(fr)
                                  , Li = qt.getSectionIndex(fr)
                                  , Di = qt.getCharCode(fr)
                                  , di = Vg(Be, Ue, Di);
                                let Nt;
                                if (Ci.imageName) {
                                    if (Z.iconsInText = !0,
                                    Ci.scale = Ci.scale * $i,
                                    Nt = Zg(Ci, di, zi, Hr, Le),
                                    !Nt)
                                        continue;
                                    nr = Math.max(nr, Nt.imageOffset)
                                } else if (Nt = Ug(Ci, Di, di, Hr, ee, ye),
                                !Nt)
                                    continue;
                                const {rect: bn, metrics: ka, baselineOffset: wn} = Nt;
                                ji.push({
                                    glyph: Di,
                                    imageName: Ci.imageName,
                                    x: Ye,
                                    y: qe + wn + vu,
                                    vertical: di,
                                    scale: Ci.scale,
                                    fontStack: Ci.fontStack,
                                    sectionIndex: Li,
                                    metrics: ka,
                                    rect: bn
                                }),
                                di ? (Z.verticalizable = !0,
                                Ye += (Ci.imageName ? ka.advance : Ti) * Ci.scale + Ee) : Ye += ka.advance * Ci.scale + Ee
                            }
                            ji.length !== 0 && (ht = Math.max(Ye - Ee, ht),
                            Gg(ji, 0, ji.length - 1, Mi)),
                            Ye = 0,
                            Ni.lineOffset = Math.max(nr, (zi - 1) * Ti);
                            const ki = Me * zi + nr;
                            qe += ki,
                            Yt = Math.max(ki, Yt),
                            ++qr
                        }
                        const {horizontalAlign: pr, verticalAlign: Oi} = Zh(Fe);
                        (function(qt, zi, Ni, ji, nr, Hr, ki, fr, Ci) {
                            const Li = (zi - Ni) * nr;
                            let Di = 0;
                            Di = Hr !== ki ? -fr * ji - vu : -ji * Ci * ki + .5 * ki;
                            for (const di of qt)
                                for (const Nt of di.positionedGlyphs)
                                    Nt.x += Li,
                                    Nt.y += Di
                        }
                        )(Z.positionedLines, Mi, pr, Oi, ht, Yt, Me, qe, be.length),
                        Z.top += -Oi * qe,
                        Z.bottom = Z.top + qe,
                        Z.left += -pr * ht,
                        Z.right = Z.left + ht
                    }(R, t, n, s, G, p, g, x, P, b, D, B),
                    !function(Z) {
                        for (const ee of Z)
                            if (ee.positionedGlyphs.length !== 0)
                                return !1;
                        return !0
                    }(Q) && R
                }
                const wu = {
                    9: !0,
                    10: !0,
                    11: !0,
                    12: !0,
                    13: !0,
                    32: !0
                }
                  , Bg = {
                    10: !0,
                    32: !0,
                    38: !0,
                    41: !0,
                    43: !0,
                    45: !0,
                    47: !0,
                    173: !0,
                    183: !0,
                    8203: !0,
                    8208: !0,
                    8211: !0,
                    8231: !0
                }
                  , Og = {
                    40: !0
                };
                function Ap(r, t, n, s, c, d) {
                    if (t.imageName) {
                        const p = s[t.imageName];
                        return p ? p.displaySize[0] * t.scale * Ti / d + c : 0
                    }
                    {
                        const p = n[t.fontStack]
                          , g = p && p[r];
                        return g ? g.metrics.advance * t.scale + c : 0
                    }
                }
                function zp(r, t, n, s) {
                    const c = Math.pow(r - t, 2);
                    return s ? r < t ? c / 2 : 2 * c : c + Math.abs(n) * n
                }
                function Ng(r, t, n) {
                    let s = 0;
                    return r === 10 && (s -= 1e4),
                    n && (s += 150),
                    r !== 40 && r !== 65288 || (s += 50),
                    t !== 41 && t !== 65289 || (s += 50),
                    s
                }
                function kp(r, t, n, s, c, d) {
                    let p = null
                      , g = zp(t, n, c, d);
                    for (const x of s) {
                        const b = zp(t - x.x, n, c, d) + x.badness;
                        b <= g && (p = x,
                        g = b)
                    }
                    return {
                        index: r,
                        x: t,
                        priorBreak: p,
                        badness: g
                    }
                }
                function Lp(r) {
                    return r ? Lp(r.priorBreak).concat(r.index) : []
                }
                function Uh(r, t, n, s, c, d) {
                    if (!r)
                        return [];
                    const p = []
                      , g = function(P, D, F, B, j, G) {
                        let X = 0;
                        for (let ae = 0; ae < P.length(); ae++) {
                            const Q = P.getSection(ae);
                            X += Ap(P.getCharCode(ae), Q, B, j, D, G)
                        }
                        return X / Math.max(1, Math.ceil(X / F))
                    }(r, t, n, s, c, d)
                      , x = r.text.indexOf("​") >= 0;
                    let b = 0;
                    for (let P = 0; P < r.length(); P++) {
                        const D = r.getSection(P)
                          , F = r.getCharCode(P);
                        if (wu[F] || (b += Ap(F, D, s, c, t, d)),
                        P < r.length() - 1) {
                            const B = !((C = F) < 11904) && (!!ct["CJK Compatibility Forms"](C) || !!ct["CJK Compatibility"](C) || !!ct["CJK Strokes"](C) || !!ct["CJK Symbols and Punctuation"](C) || !!ct["Enclosed CJK Letters and Months"](C) || !!ct["Halfwidth and Fullwidth Forms"](C) || !!ct["Ideographic Description Characters"](C) || !!ct["Vertical Forms"](C) || zl.test(String.fromCodePoint(C)));
                            (Bg[F] || B || D.imageName || P !== r.length() - 2 && Og[r.getCharCode(P + 1)]) && p.push(kp(P + 1, b, g, p, Ng(F, r.getCharCode(P + 1), B && x), !1))
                        }
                    }
                    var C;
                    return Lp(kp(r.length(), b, g, p, 0, !0))
                }
                function Zh(r) {
                    let t = .5
                      , n = .5;
                    switch (r) {
                    case "right":
                    case "top-right":
                    case "bottom-right":
                        t = 1;
                        break;
                    case "left":
                    case "top-left":
                    case "bottom-left":
                        t = 0
                    }
                    switch (r) {
                    case "bottom":
                    case "bottom-right":
                    case "bottom-left":
                        n = 1;
                        break;
                    case "top":
                    case "top-right":
                    case "top-left":
                        n = 0
                    }
                    return {
                        horizontalAlign: t,
                        verticalAlign: n
                    }
                }
                function jg(r, t, n) {
                    const s = t.getMaxScale() * Ti
                      , {maxImageWidth: c, maxImageHeight: d} = t.getMaxImageSize(r)
                      , p = Math.max(s, d * n);
                    return {
                        verticalLineContentWidth: Math.max(s, c * n),
                        horizontalLineContentHeight: p
                    }
                }
                function Dp(r) {
                    switch (r) {
                    case "top":
                        return 0;
                    case "center":
                        return .5;
                    default:
                        return 1
                    }
                }
                function Vg(r, t, n) {
                    return !(r === M.ag.horizontal || !t && !kl(n) || t && (wu[n] || (s = n,
                    /\p{sc=Arab}/u.test(String.fromCodePoint(s)))));
                    var s
                }
                function Ug(r, t, n, s, c, d) {
                    const p = d[r.fontStack]
                      , g = function(b, C, P, D) {
                        if (b && b.rect)
                            return b;
                        const F = C[P.fontStack]
                          , B = F && F[D];
                        return B ? {
                            rect: null,
                            metrics: B.metrics
                        } : null
                    }(p && p[t], c, r, t);
                    if (g === null)
                        return null;
                    let x;
                    if (n)
                        x = s.verticalLineContentWidth - r.scale * Ti;
                    else {
                        const b = Dp(r.verticalAlign);
                        x = (s.horizontalLineContentHeight - r.scale * Ti) * b
                    }
                    return {
                        rect: g.rect,
                        metrics: g.metrics,
                        baselineOffset: x
                    }
                }
                function Zg(r, t, n, s, c) {
                    const d = c[r.imageName];
                    if (!d)
                        return null;
                    const p = d.paddedRect
                      , g = d.displaySize
                      , x = {
                        width: g[0],
                        height: g[1],
                        left: dr,
                        top: -3,
                        advance: t ? g[1] : g[0]
                    };
                    let b;
                    if (t)
                        b = s.verticalLineContentWidth - g[1] * r.scale;
                    else {
                        const C = Dp(r.verticalAlign);
                        b = (s.horizontalLineContentHeight - g[1] * r.scale) * C
                    }
                    return {
                        rect: p,
                        metrics: x,
                        baselineOffset: b,
                        imageOffset: (t ? g[0] : g[1]) * r.scale - Ti * n
                    }
                }
                function Gg(r, t, n, s) {
                    if (s === 0)
                        return;
                    const c = r[n]
                      , d = (r[n].x + c.metrics.advance * c.scale) * s;
                    for (let p = t; p <= n; p++)
                        r[p].x -= d
                }
                function $g(r, t, n) {
                    const {horizontalAlign: s, verticalAlign: c} = Zh(n)
                      , d = t[0] - r.displaySize[0] * s
                      , p = t[1] - r.displaySize[1] * c;
                    return {
                        image: r,
                        top: p,
                        bottom: p + r.displaySize[1],
                        left: d,
                        right: d + r.displaySize[0]
                    }
                }
                function Rp(r) {
                    var t, n;
                    let s = r.left
                      , c = r.top
                      , d = r.right - s
                      , p = r.bottom - c;
                    const g = (t = r.image.textFitWidth) !== null && t !== void 0 ? t : "stretchOrShrink"
                      , x = (n = r.image.textFitHeight) !== null && n !== void 0 ? n : "stretchOrShrink"
                      , b = (r.image.content[2] - r.image.content[0]) / (r.image.content[3] - r.image.content[1]);
                    if (x === "proportional") {
                        if (g === "stretchOnly" && d / p < b || g === "proportional") {
                            const C = Math.ceil(p * b);
                            s *= C / d,
                            d = C
                        }
                    } else if (g === "proportional" && x === "stretchOnly" && b !== 0 && d / p > b) {
                        const C = Math.ceil(d / b);
                        c *= C / p,
                        p = C
                    }
                    return {
                        x1: s,
                        y1: c,
                        x2: s + d,
                        y2: c + p
                    }
                }
                function Fp(r, t, n, s, c, d) {
                    const p = r.image;
                    let g;
                    if (p.content) {
                        const G = p.content
                          , X = p.pixelRatio || 1;
                        g = [G[0] / X, G[1] / X, p.displaySize[0] - G[2] / X, p.displaySize[1] - G[3] / X]
                    }
                    const x = t.left * d
                      , b = t.right * d;
                    let C, P, D, F;
                    n === "width" || n === "both" ? (F = c[0] + x - s[3],
                    P = c[0] + b + s[1]) : (F = c[0] + (x + b - p.displaySize[0]) / 2,
                    P = F + p.displaySize[0]);
                    const B = t.top * d
                      , j = t.bottom * d;
                    return n === "height" || n === "both" ? (C = c[1] + B - s[0],
                    D = c[1] + j + s[2]) : (C = c[1] + (B + j - p.displaySize[1]) / 2,
                    D = C + p.displaySize[1]),
                    {
                        image: p,
                        top: C,
                        right: P,
                        bottom: D,
                        left: F,
                        collisionPadding: g
                    }
                }
                const rc = 255
                  , Zn = 128
                  , qs = rc * Zn;
                function Bp(r, t) {
                    const {expression: n} = t;
                    if (n.kind === "constant")
                        return {
                            kind: "constant",
                            layoutSize: n.evaluate(new Ut(r + 1))
                        };
                    if (n.kind === "source")
                        return {
                            kind: "source"
                        };
                    {
                        const {zoomStops: s, interpolationType: c} = n;
                        let d = 0;
                        for (; d < s.length && s[d] <= r; )
                            d++;
                        d = Math.max(0, d - 1);
                        let p = d;
                        for (; p < s.length && s[p] < r + 1; )
                            p++;
                        p = Math.min(s.length - 1, p);
                        const g = s[d]
                          , x = s[p];
                        return n.kind === "composite" ? {
                            kind: "composite",
                            minZoom: g,
                            maxZoom: x,
                            interpolationType: c
                        } : {
                            kind: "camera",
                            minZoom: g,
                            maxZoom: x,
                            minSize: n.evaluate(new Ut(g)),
                            maxSize: n.evaluate(new Ut(x)),
                            interpolationType: c
                        }
                    }
                }
                function Gh(r, t, n) {
                    let s = "never";
                    const c = r.get(t);
                    return c ? s = c : r.get(n) && (s = "always"),
                    s
                }
                const qg = Yl.VectorTileFeature.types
                  , Hg = [{
                    name: "a_fade_opacity",
                    components: 1,
                    type: "Uint8",
                    offset: 0
                }];
                function Tu(r, t, n, s, c, d, p, g, x, b, C, P, D) {
                    const F = g ? Math.min(qs, Math.round(g[0])) : 0
                      , B = g ? Math.min(qs, Math.round(g[1])) : 0;
                    r.emplaceBack(t, n, Math.round(32 * s), Math.round(32 * c), d, p, (F << 1) + (x ? 1 : 0), B, 16 * b, 16 * C, 256 * P, 256 * D)
                }
                function $h(r, t, n) {
                    r.emplaceBack(t.x, t.y, n),
                    r.emplaceBack(t.x, t.y, n),
                    r.emplaceBack(t.x, t.y, n),
                    r.emplaceBack(t.x, t.y, n)
                }
                function Wg(r) {
                    for (const t of r.sections)
                        if (ou(t.text))
                            return !0;
                    return !1
                }
                class qh {
                    constructor(t) {
                        this.layoutVertexArray = new _e,
                        this.indexArray = new Ne,
                        this.programConfigurations = t,
                        this.segments = new Ke,
                        this.dynamicLayoutVertexArray = new xe,
                        this.opacityVertexArray = new Pe,
                        this.hasVisibleVertices = !1,
                        this.placedSymbolArray = new v
                    }
                    isEmpty() {
                        return this.layoutVertexArray.length === 0 && this.indexArray.length === 0 && this.dynamicLayoutVertexArray.length === 0 && this.opacityVertexArray.length === 0
                    }
                    upload(t, n, s, c) {
                        this.isEmpty() || (s && (this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, Sg.members),
                        this.indexBuffer = t.createIndexBuffer(this.indexArray, n),
                        this.dynamicLayoutVertexBuffer = t.createVertexBuffer(this.dynamicLayoutVertexArray, Ig.members, !0),
                        this.opacityVertexBuffer = t.createVertexBuffer(this.opacityVertexArray, Hg, !0),
                        this.opacityVertexBuffer.itemSize = 1),
                        (s || c) && this.programConfigurations.upload(t))
                    }
                    destroy() {
                        this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(),
                        this.indexBuffer.destroy(),
                        this.programConfigurations.destroy(),
                        this.segments.destroy(),
                        this.dynamicLayoutVertexBuffer.destroy(),
                        this.opacityVertexBuffer.destroy())
                    }
                }
                Ve("SymbolBuffers", qh);
                class Hh {
                    constructor(t, n, s) {
                        this.layoutVertexArray = new t,
                        this.layoutAttributes = n,
                        this.indexArray = new s,
                        this.segments = new Ke,
                        this.collisionVertexArray = new Ce
                    }
                    upload(t) {
                        this.layoutVertexBuffer = t.createVertexBuffer(this.layoutVertexArray, this.layoutAttributes),
                        this.indexBuffer = t.createIndexBuffer(this.indexArray),
                        this.collisionVertexBuffer = t.createVertexBuffer(this.collisionVertexArray, Eg.members, !0)
                    }
                    destroy() {
                        this.layoutVertexBuffer && (this.layoutVertexBuffer.destroy(),
                        this.indexBuffer.destroy(),
                        this.segments.destroy(),
                        this.collisionVertexBuffer.destroy())
                    }
                }
                Ve("CollisionBuffers", Hh);
                class Ea {
                    constructor(t) {
                        this.collisionBoxArray = t.collisionBoxArray,
                        this.zoom = t.zoom,
                        this.overscaling = t.overscaling,
                        this.layers = t.layers,
                        this.layerIds = this.layers.map(p => p.id),
                        this.index = t.index,
                        this.pixelRatio = t.pixelRatio,
                        this.sourceLayerIndex = t.sourceLayerIndex,
                        this.hasPattern = !1,
                        this.hasRTLText = !1,
                        this.sortKeyRanges = [],
                        this.collisionCircleArray = [];
                        const n = this.layers[0]._unevaluatedLayout._values;
                        this.textSizeData = Bp(this.zoom, n["text-size"]),
                        this.iconSizeData = Bp(this.zoom, n["icon-size"]);
                        const s = this.layers[0].layout
                          , c = s.get("symbol-sort-key")
                          , d = s.get("symbol-z-order");
                        this.canOverlap = Gh(s, "text-overlap", "text-allow-overlap") !== "never" || Gh(s, "icon-overlap", "icon-allow-overlap") !== "never" || s.get("text-ignore-placement") || s.get("icon-ignore-placement"),
                        this.sortFeaturesByKey = d !== "viewport-y" && !c.isConstant(),
                        this.sortFeaturesByY = (d === "viewport-y" || d === "auto" && !this.sortFeaturesByKey) && this.canOverlap,
                        s.get("symbol-placement") === "point" && (this.writingModes = s.get("text-writing-mode").map(p => M.ag[p])),
                        this.stateDependentLayerIds = this.layers.filter(p => p.isStateDependent()).map(p => p.id),
                        this.sourceID = t.sourceID
                    }
                    createArrays() {
                        this.text = new qh(new _s(this.layers,this.zoom,t => /^text/.test(t))),
                        this.icon = new qh(new _s(this.layers,this.zoom,t => /^icon/.test(t))),
                        this.glyphOffsetArray = new A,
                        this.lineVertexArray = new k,
                        this.symbolInstances = new S,
                        this.textAnchorOffsets = new V
                    }
                    calculateGlyphDependencies(t, n, s, c, d) {
                        for (let p = 0; p < t.length; p++)
                            if (n[t.charCodeAt(p)] = !0,
                            (s || c) && d) {
                                const g = tc[t.charAt(p)];
                                g && (n[g.charCodeAt(0)] = !0)
                            }
                    }
                    populate(t, n, s) {
                        const c = this.layers[0]
                          , d = c.layout
                          , p = d.get("text-font")
                          , g = d.get("text-field")
                          , x = d.get("icon-image")
                          , b = (g.value.kind !== "constant" || g.value.value instanceof Fi && !g.value.value.isEmpty() || g.value.value.toString().length > 0) && (p.value.kind !== "constant" || p.value.value.length > 0)
                          , C = x.value.kind !== "constant" || !!x.value.value || Object.keys(x.parameters).length > 0
                          , P = d.get("symbol-sort-key");
                        if (this.features = [],
                        !b && !C)
                            return;
                        const D = n.iconDependencies
                          , F = n.glyphDependencies
                          , B = n.availableImages
                          , j = new Ut(this.zoom);
                        for (const {feature: G, id: X, index: ae, sourceLayerIndex: Q} of t) {
                            const R = c._featureFilter.needGeometry
                              , Z = hr(G, R);
                            if (!c._featureFilter.filter(j, Z, s))
                                continue;
                            let ee, ye;
                            if (R || (Z.geometry = ys(G)),
                            b) {
                                const be = c.getValueAndResolveTokens("text-field", Z, s, B)
                                  , Me = Fi.factory(be)
                                  , Fe = this.hasRTLText = this.hasRTLText || Wg(Me);
                                (!Fe || Vn.getRTLTextPluginStatus() === "unavailable" || Fe && Vn.isParsed()) && (ee = zg(Me, c, Z))
                            }
                            if (C) {
                                const be = c.getValueAndResolveTokens("icon-image", Z, s, B);
                                ye = be instanceof Ki ? be : Ki.fromString(be)
                            }
                            if (!ee && !ye)
                                continue;
                            const Le = this.sortFeaturesByKey ? P.evaluate(Z, {}, s) : void 0;
                            if (this.features.push({
                                id: X,
                                text: ee,
                                icon: ye,
                                index: ae,
                                sourceLayerIndex: Q,
                                geometry: Z.geometry,
                                properties: G.properties,
                                type: qg[G.type],
                                sortKey: Le
                            }),
                            ye && (D[ye.name] = !0),
                            ee) {
                                const be = p.evaluate(Z, {}, s).join(",")
                                  , Me = d.get("text-rotation-alignment") !== "viewport" && d.get("symbol-placement") !== "point";
                                this.allowVerticalPlacement = this.writingModes && this.writingModes.indexOf(M.ag.vertical) >= 0;
                                for (const Fe of ee.sections)
                                    if (Fe.image)
                                        D[Fe.image.name] = !0;
                                    else {
                                        const Re = ca(ee.toString())
                                          , Be = Fe.fontStack || be
                                          , Ee = F[Be] = F[Be] || {};
                                        this.calculateGlyphDependencies(Fe.text, Ee, Me, this.allowVerticalPlacement, Re)
                                    }
                            }
                        }
                        d.get("symbol-placement") === "line" && (this.features = function(G) {
                            const X = {}
                              , ae = {}
                              , Q = [];
                            let R = 0;
                            function Z(be) {
                                Q.push(G[be]),
                                R++
                            }
                            function ee(be, Me, Fe) {
                                const Re = ae[be];
                                return delete ae[be],
                                ae[Me] = Re,
                                Q[Re].geometry[0].pop(),
                                Q[Re].geometry[0] = Q[Re].geometry[0].concat(Fe[0]),
                                Re
                            }
                            function ye(be, Me, Fe) {
                                const Re = X[Me];
                                return delete X[Me],
                                X[be] = Re,
                                Q[Re].geometry[0].shift(),
                                Q[Re].geometry[0] = Fe[0].concat(Q[Re].geometry[0]),
                                Re
                            }
                            function Le(be, Me, Fe) {
                                const Re = Fe ? Me[0][Me[0].length - 1] : Me[0][0];
                                return `${be}:${Re.x}:${Re.y}`
                            }
                            for (let be = 0; be < G.length; be++) {
                                const Me = G[be]
                                  , Fe = Me.geometry
                                  , Re = Me.text ? Me.text.toString() : null;
                                if (!Re) {
                                    Z(be);
                                    continue
                                }
                                const Be = Le(Re, Fe)
                                  , Ee = Le(Re, Fe, !0);
                                if (Be in ae && Ee in X && ae[Be] !== X[Ee]) {
                                    const Ue = ye(Be, Ee, Fe)
                                      , Qe = ee(Be, Ee, Q[Ue].geometry);
                                    delete X[Be],
                                    delete ae[Ee],
                                    ae[Le(Re, Q[Qe].geometry, !0)] = Qe,
                                    Q[Ue].geometry = null
                                } else
                                    Be in ae ? ee(Be, Ee, Fe) : Ee in X ? ye(Be, Ee, Fe) : (Z(be),
                                    X[Be] = R - 1,
                                    ae[Ee] = R - 1)
                            }
                            return Q.filter(be => be.geometry)
                        }(this.features)),
                        this.sortFeaturesByKey && this.features.sort( (G, X) => G.sortKey - X.sortKey)
                    }
                    update(t, n, s) {
                        this.stateDependentLayers.length && (this.text.programConfigurations.updatePaintArrays(t, n, this.layers, s),
                        this.icon.programConfigurations.updatePaintArrays(t, n, this.layers, s))
                    }
                    isEmpty() {
                        return this.symbolInstances.length === 0 && !this.hasRTLText
                    }
                    uploadPending() {
                        return !this.uploaded || this.text.programConfigurations.needsUpload || this.icon.programConfigurations.needsUpload
                    }
                    upload(t) {
                        !this.uploaded && this.hasDebugData() && (this.textCollisionBox.upload(t),
                        this.iconCollisionBox.upload(t)),
                        this.text.upload(t, this.sortFeaturesByY, !this.uploaded, this.text.programConfigurations.needsUpload),
                        this.icon.upload(t, this.sortFeaturesByY, !this.uploaded, this.icon.programConfigurations.needsUpload),
                        this.uploaded = !0
                    }
                    destroyDebugData() {
                        this.textCollisionBox.destroy(),
                        this.iconCollisionBox.destroy()
                    }
                    destroy() {
                        this.text.destroy(),
                        this.icon.destroy(),
                        this.hasDebugData() && this.destroyDebugData()
                    }
                    addToLineVertexArray(t, n) {
                        const s = this.lineVertexArray.length;
                        if (t.segment !== void 0) {
                            let c = t.dist(n[t.segment + 1])
                              , d = t.dist(n[t.segment]);
                            const p = {};
                            for (let g = t.segment + 1; g < n.length; g++)
                                p[g] = {
                                    x: n[g].x,
                                    y: n[g].y,
                                    tileUnitDistanceFromAnchor: c
                                },
                                g < n.length - 1 && (c += n[g + 1].dist(n[g]));
                            for (let g = t.segment || 0; g >= 0; g--)
                                p[g] = {
                                    x: n[g].x,
                                    y: n[g].y,
                                    tileUnitDistanceFromAnchor: d
                                },
                                g > 0 && (d += n[g - 1].dist(n[g]));
                            for (let g = 0; g < n.length; g++) {
                                const x = p[g];
                                this.lineVertexArray.emplaceBack(x.x, x.y, x.tileUnitDistanceFromAnchor)
                            }
                        }
                        return {
                            lineStartIndex: s,
                            lineLength: this.lineVertexArray.length - s
                        }
                    }
                    addSymbols(t, n, s, c, d, p, g, x, b, C, P, D) {
                        const F = t.indexArray
                          , B = t.layoutVertexArray
                          , j = t.segments.prepareSegment(4 * n.length, B, F, this.canOverlap ? p.sortKey : void 0)
                          , G = this.glyphOffsetArray.length
                          , X = j.vertexLength
                          , ae = this.allowVerticalPlacement && g === M.ag.vertical ? Math.PI / 2 : 0
                          , Q = p.text && p.text.sections;
                        for (let R = 0; R < n.length; R++) {
                            const {tl: Z, tr: ee, bl: ye, br: Le, tex: be, pixelOffsetTL: Me, pixelOffsetBR: Fe, minFontScaleX: Re, minFontScaleY: Be, glyphOffset: Ee, isSDF: Ue, sectionIndex: Qe} = n[R]
                              , Ye = j.vertexLength
                              , qe = Ee[1];
                            Tu(B, x.x, x.y, Z.x, qe + Z.y, be.x, be.y, s, Ue, Me.x, Me.y, Re, Be),
                            Tu(B, x.x, x.y, ee.x, qe + ee.y, be.x + be.w, be.y, s, Ue, Fe.x, Me.y, Re, Be),
                            Tu(B, x.x, x.y, ye.x, qe + ye.y, be.x, be.y + be.h, s, Ue, Me.x, Fe.y, Re, Be),
                            Tu(B, x.x, x.y, Le.x, qe + Le.y, be.x + be.w, be.y + be.h, s, Ue, Fe.x, Fe.y, Re, Be),
                            $h(t.dynamicLayoutVertexArray, x, ae),
                            F.emplaceBack(Ye, Ye + 2, Ye + 1),
                            F.emplaceBack(Ye + 1, Ye + 2, Ye + 3),
                            j.vertexLength += 4,
                            j.primitiveLength += 2,
                            this.glyphOffsetArray.emplaceBack(Ee[0]),
                            R !== n.length - 1 && Qe === n[R + 1].sectionIndex || t.programConfigurations.populatePaintArrays(B.length, p, p.index, {}, D, Q && Q[Qe])
                        }
                        t.placedSymbolArray.emplaceBack(x.x, x.y, G, this.glyphOffsetArray.length - G, X, b, C, x.segment, s ? s[0] : 0, s ? s[1] : 0, c[0], c[1], g, 0, !1, 0, P)
                    }
                    _addCollisionDebugVertex(t, n, s, c, d, p) {
                        return n.emplaceBack(0, 0),
                        t.emplaceBack(s.x, s.y, c, d, Math.round(p.x), Math.round(p.y))
                    }
                    addCollisionDebugVertices(t, n, s, c, d, p, g) {
                        const x = d.segments.prepareSegment(4, d.layoutVertexArray, d.indexArray)
                          , b = x.vertexLength
                          , C = d.layoutVertexArray
                          , P = d.collisionVertexArray
                          , D = g.anchorX
                          , F = g.anchorY;
                        this._addCollisionDebugVertex(C, P, p, D, F, new Te(t,n)),
                        this._addCollisionDebugVertex(C, P, p, D, F, new Te(s,n)),
                        this._addCollisionDebugVertex(C, P, p, D, F, new Te(s,c)),
                        this._addCollisionDebugVertex(C, P, p, D, F, new Te(t,c)),
                        x.vertexLength += 4;
                        const B = d.indexArray;
                        B.emplaceBack(b, b + 1),
                        B.emplaceBack(b + 1, b + 2),
                        B.emplaceBack(b + 2, b + 3),
                        B.emplaceBack(b + 3, b),
                        x.primitiveLength += 4
                    }
                    addDebugCollisionBoxes(t, n, s, c) {
                        for (let d = t; d < n; d++) {
                            const p = this.collisionBoxArray.get(d);
                            this.addCollisionDebugVertices(p.x1, p.y1, p.x2, p.y2, c ? this.textCollisionBox : this.iconCollisionBox, p.anchorPoint, s)
                        }
                    }
                    generateCollisionDebugBuffers() {
                        this.hasDebugData() && this.destroyDebugData(),
                        this.textCollisionBox = new Hh(Ie,Mp.members,Oe),
                        this.iconCollisionBox = new Hh(Ie,Mp.members,Oe);
                        for (let t = 0; t < this.symbolInstances.length; t++) {
                            const n = this.symbolInstances.get(t);
                            this.addDebugCollisionBoxes(n.textBoxStartIndex, n.textBoxEndIndex, n, !0),
                            this.addDebugCollisionBoxes(n.verticalTextBoxStartIndex, n.verticalTextBoxEndIndex, n, !0),
                            this.addDebugCollisionBoxes(n.iconBoxStartIndex, n.iconBoxEndIndex, n, !1),
                            this.addDebugCollisionBoxes(n.verticalIconBoxStartIndex, n.verticalIconBoxEndIndex, n, !1)
                        }
                    }
                    _deserializeCollisionBoxesForSymbol(t, n, s, c, d, p, g, x, b) {
                        const C = {};
                        for (let P = n; P < s; P++) {
                            const D = t.get(P);
                            C.textBox = {
                                x1: D.x1,
                                y1: D.y1,
                                x2: D.x2,
                                y2: D.y2,
                                anchorPointX: D.anchorPointX,
                                anchorPointY: D.anchorPointY
                            },
                            C.textFeatureIndex = D.featureIndex;
                            break
                        }
                        for (let P = c; P < d; P++) {
                            const D = t.get(P);
                            C.verticalTextBox = {
                                x1: D.x1,
                                y1: D.y1,
                                x2: D.x2,
                                y2: D.y2,
                                anchorPointX: D.anchorPointX,
                                anchorPointY: D.anchorPointY
                            },
                            C.verticalTextFeatureIndex = D.featureIndex;
                            break
                        }
                        for (let P = p; P < g; P++) {
                            const D = t.get(P);
                            C.iconBox = {
                                x1: D.x1,
                                y1: D.y1,
                                x2: D.x2,
                                y2: D.y2,
                                anchorPointX: D.anchorPointX,
                                anchorPointY: D.anchorPointY
                            },
                            C.iconFeatureIndex = D.featureIndex;
                            break
                        }
                        for (let P = x; P < b; P++) {
                            const D = t.get(P);
                            C.verticalIconBox = {
                                x1: D.x1,
                                y1: D.y1,
                                x2: D.x2,
                                y2: D.y2,
                                anchorPointX: D.anchorPointX,
                                anchorPointY: D.anchorPointY
                            },
                            C.verticalIconFeatureIndex = D.featureIndex;
                            break
                        }
                        return C
                    }
                    deserializeCollisionBoxes(t) {
                        this.collisionArrays = [];
                        for (let n = 0; n < this.symbolInstances.length; n++) {
                            const s = this.symbolInstances.get(n);
                            this.collisionArrays.push(this._deserializeCollisionBoxesForSymbol(t, s.textBoxStartIndex, s.textBoxEndIndex, s.verticalTextBoxStartIndex, s.verticalTextBoxEndIndex, s.iconBoxStartIndex, s.iconBoxEndIndex, s.verticalIconBoxStartIndex, s.verticalIconBoxEndIndex))
                        }
                    }
                    hasTextData() {
                        return this.text.segments.get().length > 0
                    }
                    hasIconData() {
                        return this.icon.segments.get().length > 0
                    }
                    hasDebugData() {
                        return this.textCollisionBox && this.iconCollisionBox
                    }
                    hasTextCollisionBoxData() {
                        return this.hasDebugData() && this.textCollisionBox.segments.get().length > 0
                    }
                    hasIconCollisionBoxData() {
                        return this.hasDebugData() && this.iconCollisionBox.segments.get().length > 0
                    }
                    addIndicesForPlacedSymbol(t, n) {
                        const s = t.placedSymbolArray.get(n)
                          , c = s.vertexStartIndex + 4 * s.numGlyphs;
                        for (let d = s.vertexStartIndex; d < c; d += 4)
                            t.indexArray.emplaceBack(d, d + 2, d + 1),
                            t.indexArray.emplaceBack(d + 1, d + 2, d + 3)
                    }
                    getSortedSymbolIndexes(t) {
                        if (this.sortedAngle === t && this.symbolInstanceIndexes !== void 0)
                            return this.symbolInstanceIndexes;
                        const n = Math.sin(t)
                          , s = Math.cos(t)
                          , c = []
                          , d = []
                          , p = [];
                        for (let g = 0; g < this.symbolInstances.length; ++g) {
                            p.push(g);
                            const x = this.symbolInstances.get(g);
                            c.push(0 | Math.round(n * x.anchorX + s * x.anchorY)),
                            d.push(x.featureIndex)
                        }
                        return p.sort( (g, x) => c[g] - c[x] || d[x] - d[g]),
                        p
                    }
                    addToSortKeyRanges(t, n) {
                        const s = this.sortKeyRanges[this.sortKeyRanges.length - 1];
                        s && s.sortKey === n ? s.symbolInstanceEnd = t + 1 : this.sortKeyRanges.push({
                            sortKey: n,
                            symbolInstanceStart: t,
                            symbolInstanceEnd: t + 1
                        })
                    }
                    sortFeatures(t) {
                        if (this.sortFeaturesByY && this.sortedAngle !== t && !(this.text.segments.get().length > 1 || this.icon.segments.get().length > 1)) {
                            this.symbolInstanceIndexes = this.getSortedSymbolIndexes(t),
                            this.sortedAngle = t,
                            this.text.indexArray.clear(),
                            this.icon.indexArray.clear(),
                            this.featureSortOrder = [];
                            for (const n of this.symbolInstanceIndexes) {
                                const s = this.symbolInstances.get(n);
                                this.featureSortOrder.push(s.featureIndex),
                                [s.rightJustifiedTextSymbolIndex, s.centerJustifiedTextSymbolIndex, s.leftJustifiedTextSymbolIndex].forEach( (c, d, p) => {
                                    c >= 0 && p.indexOf(c) === d && this.addIndicesForPlacedSymbol(this.text, c)
                                }
                                ),
                                s.verticalPlacedTextSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.text, s.verticalPlacedTextSymbolIndex),
                                s.placedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, s.placedIconSymbolIndex),
                                s.verticalPlacedIconSymbolIndex >= 0 && this.addIndicesForPlacedSymbol(this.icon, s.verticalPlacedIconSymbolIndex)
                            }
                            this.text.indexBuffer && this.text.indexBuffer.updateData(this.text.indexArray),
                            this.icon.indexBuffer && this.icon.indexBuffer.updateData(this.icon.indexArray)
                        }
                    }
                }
                let Op, Np;
                Ve("SymbolBucket", Ea, {
                    omit: ["layers", "collisionBoxArray", "features", "compareText"]
                }),
                Ea.MAX_GLYPHS = 65535,
                Ea.addDynamicAttributes = $h;
                var Wh = {
                    get paint() {
                        return Np = Np || new rr({
                            "icon-opacity": new et(E.paint_symbol["icon-opacity"]),
                            "icon-color": new et(E.paint_symbol["icon-color"]),
                            "icon-halo-color": new et(E.paint_symbol["icon-halo-color"]),
                            "icon-halo-width": new et(E.paint_symbol["icon-halo-width"]),
                            "icon-halo-blur": new et(E.paint_symbol["icon-halo-blur"]),
                            "icon-translate": new Xe(E.paint_symbol["icon-translate"]),
                            "icon-translate-anchor": new Xe(E.paint_symbol["icon-translate-anchor"]),
                            "text-opacity": new et(E.paint_symbol["text-opacity"]),
                            "text-color": new et(E.paint_symbol["text-color"],{
                                runtimeType: at,
                                getOverride: r => r.textColor,
                                hasOverride: r => !!r.textColor
                            }),
                            "text-halo-color": new et(E.paint_symbol["text-halo-color"]),
                            "text-halo-width": new et(E.paint_symbol["text-halo-width"]),
                            "text-halo-blur": new et(E.paint_symbol["text-halo-blur"]),
                            "text-translate": new Xe(E.paint_symbol["text-translate"]),
                            "text-translate-anchor": new Xe(E.paint_symbol["text-translate-anchor"])
                        })
                    },
                    get layout() {
                        return Op = Op || new rr({
                            "symbol-placement": new Xe(E.layout_symbol["symbol-placement"]),
                            "symbol-spacing": new Xe(E.layout_symbol["symbol-spacing"]),
                            "symbol-avoid-edges": new Xe(E.layout_symbol["symbol-avoid-edges"]),
                            "symbol-sort-key": new et(E.layout_symbol["symbol-sort-key"]),
                            "symbol-z-order": new Xe(E.layout_symbol["symbol-z-order"]),
                            "icon-allow-overlap": new Xe(E.layout_symbol["icon-allow-overlap"]),
                            "icon-overlap": new Xe(E.layout_symbol["icon-overlap"]),
                            "icon-ignore-placement": new Xe(E.layout_symbol["icon-ignore-placement"]),
                            "icon-optional": new Xe(E.layout_symbol["icon-optional"]),
                            "icon-rotation-alignment": new Xe(E.layout_symbol["icon-rotation-alignment"]),
                            "icon-size": new et(E.layout_symbol["icon-size"]),
                            "icon-text-fit": new Xe(E.layout_symbol["icon-text-fit"]),
                            "icon-text-fit-padding": new Xe(E.layout_symbol["icon-text-fit-padding"]),
                            "icon-image": new et(E.layout_symbol["icon-image"]),
                            "icon-rotate": new et(E.layout_symbol["icon-rotate"]),
                            "icon-padding": new et(E.layout_symbol["icon-padding"]),
                            "icon-keep-upright": new Xe(E.layout_symbol["icon-keep-upright"]),
                            "icon-offset": new et(E.layout_symbol["icon-offset"]),
                            "icon-anchor": new et(E.layout_symbol["icon-anchor"]),
                            "icon-pitch-alignment": new Xe(E.layout_symbol["icon-pitch-alignment"]),
                            "text-pitch-alignment": new Xe(E.layout_symbol["text-pitch-alignment"]),
                            "text-rotation-alignment": new Xe(E.layout_symbol["text-rotation-alignment"]),
                            "text-field": new et(E.layout_symbol["text-field"]),
                            "text-font": new et(E.layout_symbol["text-font"]),
                            "text-size": new et(E.layout_symbol["text-size"]),
                            "text-max-width": new et(E.layout_symbol["text-max-width"]),
                            "text-line-height": new Xe(E.layout_symbol["text-line-height"]),
                            "text-letter-spacing": new et(E.layout_symbol["text-letter-spacing"]),
                            "text-justify": new et(E.layout_symbol["text-justify"]),
                            "text-radial-offset": new et(E.layout_symbol["text-radial-offset"]),
                            "text-variable-anchor": new Xe(E.layout_symbol["text-variable-anchor"]),
                            "text-variable-anchor-offset": new et(E.layout_symbol["text-variable-anchor-offset"]),
                            "text-anchor": new et(E.layout_symbol["text-anchor"]),
                            "text-max-angle": new Xe(E.layout_symbol["text-max-angle"]),
                            "text-writing-mode": new Xe(E.layout_symbol["text-writing-mode"]),
                            "text-rotate": new et(E.layout_symbol["text-rotate"]),
                            "text-padding": new Xe(E.layout_symbol["text-padding"]),
                            "text-keep-upright": new Xe(E.layout_symbol["text-keep-upright"]),
                            "text-transform": new et(E.layout_symbol["text-transform"]),
                            "text-offset": new et(E.layout_symbol["text-offset"]),
                            "text-allow-overlap": new Xe(E.layout_symbol["text-allow-overlap"]),
                            "text-overlap": new Xe(E.layout_symbol["text-overlap"]),
                            "text-ignore-placement": new Xe(E.layout_symbol["text-ignore-placement"]),
                            "text-optional": new Xe(E.layout_symbol["text-optional"])
                        })
                    }
                };
                class jp {
                    constructor(t) {
                        if (t.property.overrides === void 0)
                            throw new Error("overrides must be provided to instantiate FormatSectionOverride class");
                        this.type = t.property.overrides ? t.property.overrides.runtimeType : tt,
                        this.defaultValue = t
                    }
                    evaluate(t) {
                        if (t.formattedSection) {
                            const n = this.defaultValue.property.overrides;
                            if (n && n.hasOverride(t.formattedSection))
                                return n.getOverride(t.formattedSection)
                        }
                        return t.feature && t.featureState ? this.defaultValue.evaluate(t.feature, t.featureState) : this.defaultValue.property.specification.default
                    }
                    eachChild(t) {
                        this.defaultValue.isConstant() || t(this.defaultValue.value._styleExpression.expression)
                    }
                    outputDefined() {
                        return !1
                    }
                    serialize() {
                        return null
                    }
                }
                Ve("FormatSectionOverride", jp, {
                    omit: ["defaultValue"]
                });
                class Mu extends sn {
                    constructor(t) {
                        super(t, Wh)
                    }
                    recalculate(t, n) {
                        if (super.recalculate(t, n),
                        this.layout.get("icon-rotation-alignment") === "auto" && (this.layout._values["icon-rotation-alignment"] = this.layout.get("symbol-placement") !== "point" ? "map" : "viewport"),
                        this.layout.get("text-rotation-alignment") === "auto" && (this.layout._values["text-rotation-alignment"] = this.layout.get("symbol-placement") !== "point" ? "map" : "viewport"),
                        this.layout.get("text-pitch-alignment") === "auto" && (this.layout._values["text-pitch-alignment"] = this.layout.get("text-rotation-alignment") === "map" ? "map" : "viewport"),
                        this.layout.get("icon-pitch-alignment") === "auto" && (this.layout._values["icon-pitch-alignment"] = this.layout.get("icon-rotation-alignment")),
                        this.layout.get("symbol-placement") === "point") {
                            const s = this.layout.get("text-writing-mode");
                            if (s) {
                                const c = [];
                                for (const d of s)
                                    c.indexOf(d) < 0 && c.push(d);
                                this.layout._values["text-writing-mode"] = c
                            } else
                                this.layout._values["text-writing-mode"] = ["horizontal"]
                        }
                        this._setPaintOverrides()
                    }
                    getValueAndResolveTokens(t, n, s, c) {
                        const d = this.layout.get(t).evaluate(n, {}, s, c)
                          , p = this._unevaluatedLayout._values[t];
                        return p.isDataDriven() || ta(p.value) || !d ? d : function(g, x) {
                            return x.replace(/{([^{}]+)}/g, (b, C) => g && C in g ? String(g[C]) : "")
                        }(n.properties, d)
                    }
                    createBucket(t) {
                        return new Ea(t)
                    }
                    queryRadius() {
                        return 0
                    }
                    queryIntersectsFeature() {
                        throw new Error("Should take a different path in FeatureIndex")
                    }
                    _setPaintOverrides() {
                        for (const t of Wh.paint.overridableProperties) {
                            if (!Mu.hasPaintOverride(this.layout, t))
                                continue;
                            const n = this.paint.get(t)
                              , s = new jp(n)
                              , c = new gl(s,n.property.specification);
                            let d = null;
                            d = n.value.kind === "constant" || n.value.kind === "source" ? new ia("source",c) : new _l("composite",c,n.value.zoomStops),
                            this.paint._values[t] = new zr(n.property,d,n.parameters)
                        }
                    }
                    _handleOverridablePaintPropertyUpdate(t, n, s) {
                        return !(!this.layout || n.isDataDriven() || s.isDataDriven()) && Mu.hasPaintOverride(this.layout, t)
                    }
                    static hasPaintOverride(t, n) {
                        const s = t.get("text-field")
                          , c = Wh.paint.properties[n];
                        let d = !1;
                        const p = g => {
                            for (const x of g)
                                if (c.overrides && c.overrides.hasOverride(x))
                                    return void (d = !0)
                        }
                        ;
                        if (s.value.kind === "constant" && s.value.value instanceof Fi)
                            p(s.value.value.sections);
                        else if (s.value.kind === "source") {
                            const g = b => {
                                d || (b instanceof Pr && hi(b.value) === ui ? p(b.value.sections) : b instanceof is ? p(b.sections) : b.eachChild(g))
                            }
                              , x = s.value;
                            x._styleExpression && g(x._styleExpression.expression)
                        }
                        return d
                    }
                }
                let Vp;
                var Xg = {
                    get paint() {
                        return Vp = Vp || new rr({
                            "background-color": new Xe(E.paint_background["background-color"]),
                            "background-pattern": new pa(E.paint_background["background-pattern"]),
                            "background-opacity": new Xe(E.paint_background["background-opacity"])
                        })
                    }
                };
                class Kg extends sn {
                    constructor(t) {
                        super(t, Xg)
                    }
                }
                let Up;
                var Jg = {
                    get paint() {
                        return Up = Up || new rr({
                            "raster-opacity": new Xe(E.paint_raster["raster-opacity"]),
                            "raster-hue-rotate": new Xe(E.paint_raster["raster-hue-rotate"]),
                            "raster-brightness-min": new Xe(E.paint_raster["raster-brightness-min"]),
                            "raster-brightness-max": new Xe(E.paint_raster["raster-brightness-max"]),
                            "raster-saturation": new Xe(E.paint_raster["raster-saturation"]),
                            "raster-contrast": new Xe(E.paint_raster["raster-contrast"]),
                            "raster-resampling": new Xe(E.paint_raster["raster-resampling"]),
                            "raster-fade-duration": new Xe(E.paint_raster["raster-fade-duration"])
                        })
                    }
                };
                class Yg extends sn {
                    constructor(t) {
                        super(t, Jg)
                    }
                }
                class Qg extends sn {
                    constructor(t) {
                        super(t, {}),
                        this.onAdd = n => {
                            this.implementation.onAdd && this.implementation.onAdd(n, n.painter.context.gl)
                        }
                        ,
                        this.onRemove = n => {
                            this.implementation.onRemove && this.implementation.onRemove(n, n.painter.context.gl)
                        }
                        ,
                        this.implementation = t
                    }
                    is3D() {
                        return this.implementation.renderingMode === "3d"
                    }
                    hasOffscreenPass() {
                        return this.implementation.prerender !== void 0
                    }
                    recalculate() {}
                    updateTransitions() {}
                    hasTransition() {
                        return !1
                    }
                    serialize() {
                        throw new Error("Custom layers cannot be serialized")
                    }
                }
                class e_ {
                    constructor(t) {
                        this._methodToThrottle = t,
                        this._triggered = !1,
                        typeof MessageChannel < "u" && (this._channel = new MessageChannel,
                        this._channel.port2.onmessage = () => {
                            this._triggered = !1,
                            this._methodToThrottle()
                        }
                        )
                    }
                    trigger() {
                        this._triggered || (this._triggered = !0,
                        this._channel ? this._channel.port1.postMessage(!0) : setTimeout( () => {
                            this._triggered = !1,
                            this._methodToThrottle()
                        }
                        , 0))
                    }
                    remove() {
                        delete this._channel,
                        this._methodToThrottle = () => {}
                    }
                }
                const t_ = {
                    once: !0
                }
                  , Xh = 63710088e-1;
                class Hs {
                    constructor(t, n) {
                        if (isNaN(t) || isNaN(n))
                            throw new Error(`Invalid LngLat object: (${t}, ${n})`);
                        if (this.lng = +t,
                        this.lat = +n,
                        this.lat > 90 || this.lat < -90)
                            throw new Error("Invalid LngLat latitude value: must be between -90 and 90")
                    }
                    wrap() {
                        return new Hs(_i(this.lng, -180, 180),this.lat)
                    }
                    toArray() {
                        return [this.lng, this.lat]
                    }
                    toString() {
                        return `LngLat(${this.lng}, ${this.lat})`
                    }
                    distanceTo(t) {
                        const n = Math.PI / 180
                          , s = this.lat * n
                          , c = t.lat * n
                          , d = Math.sin(s) * Math.sin(c) + Math.cos(s) * Math.cos(c) * Math.cos((t.lng - this.lng) * n);
                        return Xh * Math.acos(Math.min(d, 1))
                    }
                    static convert(t) {
                        if (t instanceof Hs)
                            return t;
                        if (Array.isArray(t) && (t.length === 2 || t.length === 3))
                            return new Hs(Number(t[0]),Number(t[1]));
                        if (!Array.isArray(t) && typeof t == "object" && t !== null)
                            return new Hs(Number("lng"in t ? t.lng : t.lon),Number(t.lat));
                        throw new Error("`LngLatLike` argument must be specified as a LngLat instance, an object {lng: <lng>, lat: <lat>}, an object {lon: <lng>, lat: <lat>}, or an array of [<lng>, <lat>]")
                    }
                }
                const Zp = 2 * Math.PI * Xh;
                function Gp(r) {
                    return Zp * Math.cos(r * Math.PI / 180)
                }
                function $p(r) {
                    return (180 + r) / 360
                }
                function qp(r) {
                    return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + r * Math.PI / 360))) / 360
                }
                function Hp(r, t) {
                    return r / Gp(t)
                }
                function Kh(r) {
                    return 360 / Math.PI * Math.atan(Math.exp((180 - 360 * r) * Math.PI / 180)) - 90
                }
                function Wp(r, t) {
                    return r * Gp(Kh(t))
                }
                class nc {
                    constructor(t, n, s=0) {
                        this.x = +t,
                        this.y = +n,
                        this.z = +s
                    }
                    static fromLngLat(t, n=0) {
                        const s = Hs.convert(t);
                        return new nc($p(s.lng),qp(s.lat),Hp(n, s.lat))
                    }
                    toLngLat() {
                        return new Hs(360 * this.x - 180,Kh(this.y))
                    }
                    toAltitude() {
                        return Wp(this.z, this.y)
                    }
                    meterInMercatorCoordinateUnits() {
                        return 1 / Zp * (t = Kh(this.y),
                        1 / Math.cos(t * Math.PI / 180));
                        var t
                    }
                }
                function Xp(r, t, n) {
                    var s = 2 * Math.PI * 6378137 / 256 / Math.pow(2, n);
                    return [r * s - 2 * Math.PI * 6378137 / 2, t * s - 2 * Math.PI * 6378137 / 2]
                }
                class Jh {
                    constructor(t, n, s) {
                        if (!function(c, d, p) {
                            return !(c < 0 || c > 25 || p < 0 || p >= Math.pow(2, c) || d < 0 || d >= Math.pow(2, c))
                        }(t, n, s))
                            throw new Error(`x=${n}, y=${s}, z=${t} outside of bounds. 0<=x<${Math.pow(2, t)}, 0<=y<${Math.pow(2, t)} 0<=z<=25 `);
                        this.z = t,
                        this.x = n,
                        this.y = s,
                        this.key = Aa(0, t, t, n, s)
                    }
                    equals(t) {
                        return this.z === t.z && this.x === t.x && this.y === t.y
                    }
                    url(t, n, s) {
                        const c = (p = this.y,
                        g = this.z,
                        x = Xp(256 * (d = this.x), 256 * (p = Math.pow(2, g) - p - 1), g),
                        b = Xp(256 * (d + 1), 256 * (p + 1), g),
                        x[0] + "," + x[1] + "," + b[0] + "," + b[1]);
                        var d, p, g, x, b;
                        const C = function(P, D, F) {
                            let B, j = "";
                            for (let G = P; G > 0; G--)
                                B = 1 << G - 1,
                                j += (D & B ? 1 : 0) + (F & B ? 2 : 0);
                            return j
                        }(this.z, this.x, this.y);
                        return t[(this.x + this.y) % t.length].replace(/{prefix}/g, (this.x % 16).toString(16) + (this.y % 16).toString(16)).replace(/{z}/g, String(this.z)).replace(/{x}/g, String(this.x)).replace(/{y}/g, String(s === "tms" ? Math.pow(2, this.z) - this.y - 1 : this.y)).replace(/{ratio}/g, n > 1 ? "@2x" : "").replace(/{quadkey}/g, C).replace(/{bbox-epsg-3857}/g, c)
                    }
                    isChildOf(t) {
                        const n = this.z - t.z;
                        return n > 0 && t.x === this.x >> n && t.y === this.y >> n
                    }
                    getTilePoint(t) {
                        const n = Math.pow(2, this.z);
                        return new Te((t.x * n - this.x) * ut,(t.y * n - this.y) * ut)
                    }
                    toString() {
                        return `${this.z}/${this.x}/${this.y}`
                    }
                }
                class Kp {
                    constructor(t, n) {
                        this.wrap = t,
                        this.canonical = n,
                        this.key = Aa(t, n.z, n.z, n.x, n.y)
                    }
                }
                class $r {
                    constructor(t, n, s, c, d) {
                        if (this.terrainRttPosMatrix32f = null,
                        t < s)
                            throw new Error(`overscaledZ should be >= z; overscaledZ = ${t}; z = ${s}`);
                        this.overscaledZ = t,
                        this.wrap = n,
                        this.canonical = new Jh(s,+c,+d),
                        this.key = Aa(n, t, s, c, d)
                    }
                    clone() {
                        return new $r(this.overscaledZ,this.wrap,this.canonical.z,this.canonical.x,this.canonical.y)
                    }
                    equals(t) {
                        return this.overscaledZ === t.overscaledZ && this.wrap === t.wrap && this.canonical.equals(t.canonical)
                    }
                    scaledTo(t) {
                        if (t > this.overscaledZ)
                            throw new Error(`targetZ > this.overscaledZ; targetZ = ${t}; overscaledZ = ${this.overscaledZ}`);
                        const n = this.canonical.z - t;
                        return t > this.canonical.z ? new $r(t,this.wrap,this.canonical.z,this.canonical.x,this.canonical.y) : new $r(t,this.wrap,t,this.canonical.x >> n,this.canonical.y >> n)
                    }
                    calculateScaledKey(t, n) {
                        if (t > this.overscaledZ)
                            throw new Error(`targetZ > this.overscaledZ; targetZ = ${t}; overscaledZ = ${this.overscaledZ}`);
                        const s = this.canonical.z - t;
                        return t > this.canonical.z ? Aa(this.wrap * +n, t, this.canonical.z, this.canonical.x, this.canonical.y) : Aa(this.wrap * +n, t, t, this.canonical.x >> s, this.canonical.y >> s)
                    }
                    isChildOf(t) {
                        if (t.wrap !== this.wrap)
                            return !1;
                        const n = this.canonical.z - t.canonical.z;
                        return t.overscaledZ === 0 || t.overscaledZ < this.overscaledZ && t.canonical.x === this.canonical.x >> n && t.canonical.y === this.canonical.y >> n
                    }
                    children(t) {
                        if (this.overscaledZ >= t)
                            return [new $r(this.overscaledZ + 1,this.wrap,this.canonical.z,this.canonical.x,this.canonical.y)];
                        const n = this.canonical.z + 1
                          , s = 2 * this.canonical.x
                          , c = 2 * this.canonical.y;
                        return [new $r(n,this.wrap,n,s,c), new $r(n,this.wrap,n,s + 1,c), new $r(n,this.wrap,n,s,c + 1), new $r(n,this.wrap,n,s + 1,c + 1)]
                    }
                    isLessThan(t) {
                        return this.wrap < t.wrap || !(this.wrap > t.wrap) && (this.overscaledZ < t.overscaledZ || !(this.overscaledZ > t.overscaledZ) && (this.canonical.x < t.canonical.x || !(this.canonical.x > t.canonical.x) && this.canonical.y < t.canonical.y))
                    }
                    wrapped() {
                        return new $r(this.overscaledZ,0,this.canonical.z,this.canonical.x,this.canonical.y)
                    }
                    unwrapTo(t) {
                        return new $r(this.overscaledZ,t,this.canonical.z,this.canonical.x,this.canonical.y)
                    }
                    overscaleFactor() {
                        return Math.pow(2, this.overscaledZ - this.canonical.z)
                    }
                    toUnwrapped() {
                        return new Kp(this.wrap,this.canonical)
                    }
                    toString() {
                        return `${this.overscaledZ}/${this.canonical.x}/${this.canonical.y}`
                    }
                    getTilePoint(t) {
                        return this.canonical.getTilePoint(new nc(t.x - this.wrap,t.y))
                    }
                }
                function Aa(r, t, n, s, c) {
                    (r *= 2) < 0 && (r = -1 * r - 1);
                    const d = 1 << n;
                    return (d * d * r + d * c + s).toString(36) + n.toString(36) + t.toString(36)
                }
                Ve("CanonicalTileID", Jh),
                Ve("OverscaledTileID", $r, {
                    omit: ["terrainRttPosMatrix32f"]
                });
                class Jp {
                    constructor(t, n, s, c=1, d=1, p=1, g=0) {
                        if (this.uid = t,
                        n.height !== n.width)
                            throw new RangeError("DEM tiles must be square");
                        if (s && !["mapbox", "terrarium", "custom"].includes(s))
                            return void yi(`"${s}" is not a valid encoding type. Valid types include "mapbox", "terrarium" and "custom".`);
                        this.stride = n.height;
                        const x = this.dim = n.height - 2;
                        switch (this.data = new Uint32Array(n.data.buffer),
                        s) {
                        case "terrarium":
                            this.redFactor = 256,
                            this.greenFactor = 1,
                            this.blueFactor = 1 / 256,
                            this.baseShift = 32768;
                            break;
                        case "custom":
                            this.redFactor = c,
                            this.greenFactor = d,
                            this.blueFactor = p,
                            this.baseShift = g;
                            break;
                        default:
                            this.redFactor = 6553.6,
                            this.greenFactor = 25.6,
                            this.blueFactor = .1,
                            this.baseShift = 1e4
                        }
                        for (let b = 0; b < x; b++)
                            this.data[this._idx(-1, b)] = this.data[this._idx(0, b)],
                            this.data[this._idx(x, b)] = this.data[this._idx(x - 1, b)],
                            this.data[this._idx(b, -1)] = this.data[this._idx(b, 0)],
                            this.data[this._idx(b, x)] = this.data[this._idx(b, x - 1)];
                        this.data[this._idx(-1, -1)] = this.data[this._idx(0, 0)],
                        this.data[this._idx(x, -1)] = this.data[this._idx(x - 1, 0)],
                        this.data[this._idx(-1, x)] = this.data[this._idx(0, x - 1)],
                        this.data[this._idx(x, x)] = this.data[this._idx(x - 1, x - 1)],
                        this.min = Number.MAX_SAFE_INTEGER,
                        this.max = Number.MIN_SAFE_INTEGER;
                        for (let b = 0; b < x; b++)
                            for (let C = 0; C < x; C++) {
                                const P = this.get(b, C);
                                P > this.max && (this.max = P),
                                P < this.min && (this.min = P)
                            }
                    }
                    get(t, n) {
                        const s = new Uint8Array(this.data.buffer)
                          , c = 4 * this._idx(t, n);
                        return this.unpack(s[c], s[c + 1], s[c + 2])
                    }
                    getUnpackVector() {
                        return [this.redFactor, this.greenFactor, this.blueFactor, this.baseShift]
                    }
                    _idx(t, n) {
                        if (t < -1 || t >= this.dim + 1 || n < -1 || n >= this.dim + 1)
                            throw new RangeError("out of range source coordinates for DEM data");
                        return (n + 1) * this.stride + (t + 1)
                    }
                    unpack(t, n, s) {
                        return t * this.redFactor + n * this.greenFactor + s * this.blueFactor - this.baseShift
                    }
                    getPixels() {
                        return new Gr({
                            width: this.stride,
                            height: this.stride
                        },new Uint8Array(this.data.buffer))
                    }
                    backfillBorder(t, n, s) {
                        if (this.dim !== t.dim)
                            throw new Error("dem dimension mismatch");
                        let c = n * this.dim
                          , d = n * this.dim + this.dim
                          , p = s * this.dim
                          , g = s * this.dim + this.dim;
                        switch (n) {
                        case -1:
                            c = d - 1;
                            break;
                        case 1:
                            d = c + 1
                        }
                        switch (s) {
                        case -1:
                            p = g - 1;
                            break;
                        case 1:
                            g = p + 1
                        }
                        const x = -n * this.dim
                          , b = -s * this.dim;
                        for (let C = p; C < g; C++)
                            for (let P = c; P < d; P++)
                                this.data[this._idx(P, C)] = t.data[this._idx(P + x, C + b)]
                    }
                }
                Ve("DEMData", Jp);
                class Yp {
                    constructor(t) {
                        this._stringToNumber = {},
                        this._numberToString = [];
                        for (let n = 0; n < t.length; n++) {
                            const s = t[n];
                            this._stringToNumber[s] = n,
                            this._numberToString[n] = s
                        }
                    }
                    encode(t) {
                        return this._stringToNumber[t]
                    }
                    decode(t) {
                        if (t >= this._numberToString.length)
                            throw new Error(`Out of bounds. Index requested n=${t} can't be >= this._numberToString.length ${this._numberToString.length}`);
                        return this._numberToString[t]
                    }
                }
                class Qp {
                    constructor(t, n, s, c, d) {
                        this.type = "Feature",
                        this._vectorTileFeature = t,
                        t._z = n,
                        t._x = s,
                        t._y = c,
                        this.properties = t.properties,
                        this.id = d
                    }
                    get geometry() {
                        return this._geometry === void 0 && (this._geometry = this._vectorTileFeature.toGeoJSON(this._vectorTileFeature._x, this._vectorTileFeature._y, this._vectorTileFeature._z).geometry),
                        this._geometry
                    }
                    set geometry(t) {
                        this._geometry = t
                    }
                    toJSON() {
                        const t = {
                            geometry: this.geometry
                        };
                        for (const n in this)
                            n !== "_geometry" && n !== "_vectorTileFeature" && (t[n] = this[n]);
                        return t
                    }
                }
                class ef {
                    constructor(t, n) {
                        this.tileID = t,
                        this.x = t.canonical.x,
                        this.y = t.canonical.y,
                        this.z = t.canonical.z,
                        this.grid = new _o(ut,16,0),
                        this.grid3D = new _o(ut,16,0),
                        this.featureIndexArray = new q,
                        this.promoteId = n
                    }
                    insert(t, n, s, c, d, p) {
                        const g = this.featureIndexArray.length;
                        this.featureIndexArray.emplaceBack(s, c, d);
                        const x = p ? this.grid3D : this.grid;
                        for (let b = 0; b < n.length; b++) {
                            const C = n[b]
                              , P = [1 / 0, 1 / 0, -1 / 0, -1 / 0];
                            for (let D = 0; D < C.length; D++) {
                                const F = C[D];
                                P[0] = Math.min(P[0], F.x),
                                P[1] = Math.min(P[1], F.y),
                                P[2] = Math.max(P[2], F.x),
                                P[3] = Math.max(P[3], F.y)
                            }
                            P[0] < ut && P[1] < ut && P[2] >= 0 && P[3] >= 0 && x.insert(g, P[0], P[1], P[2], P[3])
                        }
                    }
                    loadVTLayers() {
                        return this.vtLayers || (this.vtLayers = new Yl.VectorTile(new Nh(this.rawTileData)).layers,
                        this.sourceLayerCoder = new Yp(this.vtLayers ? Object.keys(this.vtLayers).sort() : ["_geojsonTileLayer"])),
                        this.vtLayers
                    }
                    query(t, n, s, c) {
                        this.loadVTLayers();
                        const d = t.params
                          , p = ut / t.tileSize / t.scale
                          , g = sa(d.filter)
                          , x = t.queryGeometry
                          , b = t.queryPadding * p
                          , C = rf(x)
                          , P = this.grid.query(C.minX - b, C.minY - b, C.maxX + b, C.maxY + b)
                          , D = rf(t.cameraQueryGeometry)
                          , F = this.grid3D.query(D.minX - b, D.minY - b, D.maxX + b, D.maxY + b, (G, X, ae, Q) => function(R, Z, ee, ye, Le) {
                            for (const Me of R)
                                if (Z <= Me.x && ee <= Me.y && ye >= Me.x && Le >= Me.y)
                                    return !0;
                            const be = [new Te(Z,ee), new Te(Z,Le), new Te(ye,Le), new Te(ye,ee)];
                            if (R.length > 2) {
                                for (const Me of be)
                                    if (Ma(R, Me))
                                        return !0
                            }
                            for (let Me = 0; Me < R.length - 1; Me++)
                                if (Zm(R[Me], R[Me + 1], be))
                                    return !0;
                            return !1
                        }(t.cameraQueryGeometry, G - b, X - b, ae + b, Q + b));
                        for (const G of F)
                            P.push(G);
                        P.sort(i_);
                        const B = {};
                        let j;
                        for (let G = 0; G < P.length; G++) {
                            const X = P[G];
                            if (X === j)
                                continue;
                            j = X;
                            const ae = this.featureIndexArray.get(X);
                            let Q = null;
                            this.loadMatchingFeature(B, ae.bucketIndex, ae.sourceLayerIndex, ae.featureIndex, g, d.layers, d.availableImages, n, s, c, (R, Z, ee) => (Q || (Q = ys(R)),
                            Z.queryIntersectsFeature({
                                queryGeometry: x,
                                feature: R,
                                featureState: ee,
                                geometry: Q,
                                zoom: this.z,
                                transform: t.transform,
                                pixelsToTileUnits: p,
                                pixelPosMatrix: t.pixelPosMatrix
                            })))
                        }
                        return B
                    }
                    loadMatchingFeature(t, n, s, c, d, p, g, x, b, C, P) {
                        const D = this.bucketLayerIDs[n];
                        if (p && !D.some(G => p.has(G)))
                            return;
                        const F = this.sourceLayerCoder.decode(s)
                          , B = this.vtLayers[F].feature(c);
                        if (d.needGeometry) {
                            const G = hr(B, !0);
                            if (!d.filter(new Ut(this.tileID.overscaledZ), G, this.tileID.canonical))
                                return
                        } else if (!d.filter(new Ut(this.tileID.overscaledZ), B))
                            return;
                        const j = this.getId(B, F);
                        for (let G = 0; G < D.length; G++) {
                            const X = D[G];
                            if (p && !p.has(X))
                                continue;
                            const ae = x[X];
                            if (!ae)
                                continue;
                            let Q = {};
                            j && C && (Q = C.getState(ae.sourceLayer || "_geojsonTileLayer", j));
                            const R = Ft({}, b[X]);
                            R.paint = tf(R.paint, ae.paint, B, Q, g),
                            R.layout = tf(R.layout, ae.layout, B, Q, g);
                            const Z = !P || P(B, ae, Q);
                            if (!Z)
                                continue;
                            const ee = new Qp(B,this.z,this.x,this.y,j);
                            ee.layer = R;
                            let ye = t[X];
                            ye === void 0 && (ye = t[X] = []),
                            ye.push({
                                featureIndex: c,
                                feature: ee,
                                intersectionZ: Z
                            })
                        }
                    }
                    lookupSymbolFeatures(t, n, s, c, d, p, g, x) {
                        const b = {};
                        this.loadVTLayers();
                        const C = sa(d);
                        for (const P of t)
                            this.loadMatchingFeature(b, s, c, P, C, p, g, x, n);
                        return b
                    }
                    hasLayer(t) {
                        for (const n of this.bucketLayerIDs)
                            for (const s of n)
                                if (t === s)
                                    return !0;
                        return !1
                    }
                    getId(t, n) {
                        var s;
                        let c = t.id;
                        return this.promoteId && (c = t.properties[typeof this.promoteId == "string" ? this.promoteId : this.promoteId[n]],
                        typeof c == "boolean" && (c = Number(c)),
                        c === void 0 && (!((s = t.properties) === null || s === void 0) && s.cluster) && this.promoteId && (c = Number(t.properties.cluster_id))),
                        c
                    }
                }
                function tf(r, t, n, s, c) {
                    return Xi(r, (d, p) => {
                        const g = t instanceof da ? t.get(p) : null;
                        return g && g.evaluate ? g.evaluate(n, s, c) : g
                    }
                    )
                }
                function rf(r) {
                    let t = 1 / 0
                      , n = 1 / 0
                      , s = -1 / 0
                      , c = -1 / 0;
                    for (const d of r)
                        t = Math.min(t, d.x),
                        n = Math.min(n, d.y),
                        s = Math.max(s, d.x),
                        c = Math.max(c, d.y);
                    return {
                        minX: t,
                        minY: n,
                        maxX: s,
                        maxY: c
                    }
                }
                function i_(r, t) {
                    return t - r
                }
                function nf(r, t, n, s, c) {
                    const d = [];
                    for (let p = 0; p < r.length; p++) {
                        const g = r[p];
                        let x;
                        for (let b = 0; b < g.length - 1; b++) {
                            let C = g[b]
                              , P = g[b + 1];
                            C.x < t && P.x < t || (C.x < t ? C = new Te(t,C.y + (t - C.x) / (P.x - C.x) * (P.y - C.y))._round() : P.x < t && (P = new Te(t,C.y + (t - C.x) / (P.x - C.x) * (P.y - C.y))._round()),
                            C.y < n && P.y < n || (C.y < n ? C = new Te(C.x + (n - C.y) / (P.y - C.y) * (P.x - C.x),n)._round() : P.y < n && (P = new Te(C.x + (n - C.y) / (P.y - C.y) * (P.x - C.x),n)._round()),
                            C.x >= s && P.x >= s || (C.x >= s ? C = new Te(s,C.y + (s - C.x) / (P.x - C.x) * (P.y - C.y))._round() : P.x >= s && (P = new Te(s,C.y + (s - C.x) / (P.x - C.x) * (P.y - C.y))._round()),
                            C.y >= c && P.y >= c || (C.y >= c ? C = new Te(C.x + (c - C.y) / (P.y - C.y) * (P.x - C.x),c)._round() : P.y >= c && (P = new Te(C.x + (c - C.y) / (P.y - C.y) * (P.x - C.x),c)._round()),
                            x && C.equals(x[x.length - 1]) || (x = [C],
                            d.push(x)),
                            x.push(P)))))
                        }
                    }
                    return d
                }
                Ve("FeatureIndex", ef, {
                    omit: ["rawTileData", "sourceLayerCoder"]
                });
                class Ws extends Te {
                    constructor(t, n, s, c) {
                        super(t, n),
                        this.angle = s,
                        c !== void 0 && (this.segment = c)
                    }
                    clone() {
                        return new Ws(this.x,this.y,this.angle,this.segment)
                    }
                }
                function sf(r, t, n, s, c) {
                    if (t.segment === void 0 || n === 0)
                        return !0;
                    let d = t
                      , p = t.segment + 1
                      , g = 0;
                    for (; g > -n / 2; ) {
                        if (p--,
                        p < 0)
                            return !1;
                        g -= r[p].dist(d),
                        d = r[p]
                    }
                    g += r[p].dist(r[p + 1]),
                    p++;
                    const x = [];
                    let b = 0;
                    for (; g < n / 2; ) {
                        const C = r[p]
                          , P = r[p + 1];
                        if (!P)
                            return !1;
                        let D = r[p - 1].angleTo(C) - C.angleTo(P);
                        for (D = Math.abs((D + 3 * Math.PI) % (2 * Math.PI) - Math.PI),
                        x.push({
                            distance: g,
                            angleDelta: D
                        }),
                        b += D; g - x[0].distance > s; )
                            b -= x.shift().angleDelta;
                        if (b > c)
                            return !1;
                        p++,
                        g += C.dist(P)
                    }
                    return !0
                }
                function of(r) {
                    let t = 0;
                    for (let n = 0; n < r.length - 1; n++)
                        t += r[n].dist(r[n + 1]);
                    return t
                }
                function af(r, t, n) {
                    return r ? .6 * t * n : 0
                }
                function lf(r, t) {
                    return Math.max(r ? r.right - r.left : 0, t ? t.right - t.left : 0)
                }
                function r_(r, t, n, s, c, d) {
                    const p = af(n, c, d)
                      , g = lf(n, s) * d;
                    let x = 0;
                    const b = of(r) / 2;
                    for (let C = 0; C < r.length - 1; C++) {
                        const P = r[C]
                          , D = r[C + 1]
                          , F = P.dist(D);
                        if (x + F > b) {
                            const B = (b - x) / F
                              , j = cr.number(P.x, D.x, B)
                              , G = cr.number(P.y, D.y, B)
                              , X = new Ws(j,G,D.angleTo(P),C);
                            return X._round(),
                            !p || sf(r, X, g, p, t) ? X : void 0
                        }
                        x += F
                    }
                }
                function n_(r, t, n, s, c, d, p, g, x) {
                    const b = af(s, d, p)
                      , C = lf(s, c)
                      , P = C * p
                      , D = r[0].x === 0 || r[0].x === x || r[0].y === 0 || r[0].y === x;
                    return t - P < t / 4 && (t = P + t / 4),
                    cf(r, D ? t / 2 * g % t : (C / 2 + 2 * d) * p * g % t, t, b, n, P, D, !1, x)
                }
                function cf(r, t, n, s, c, d, p, g, x) {
                    const b = d / 2
                      , C = of(r);
                    let P = 0
                      , D = t - n
                      , F = [];
                    for (let B = 0; B < r.length - 1; B++) {
                        const j = r[B]
                          , G = r[B + 1]
                          , X = j.dist(G)
                          , ae = G.angleTo(j);
                        for (; D + n < P + X; ) {
                            D += n;
                            const Q = (D - P) / X
                              , R = cr.number(j.x, G.x, Q)
                              , Z = cr.number(j.y, G.y, Q);
                            if (R >= 0 && R < x && Z >= 0 && Z < x && D - b >= 0 && D + b <= C) {
                                const ee = new Ws(R,Z,ae,B);
                                ee._round(),
                                s && !sf(r, ee, d, s, c) || F.push(ee)
                            }
                        }
                        P += X
                    }
                    return g || F.length || p || (F = cf(r, P / 2, n, s, c, d, p, !0, x)),
                    F
                }
                Ve("Anchor", Ws);
                const sc = dr;
                function uf(r, t, n, s) {
                    const c = []
                      , d = r.image
                      , p = d.pixelRatio
                      , g = d.paddedRect.w - 2 * sc
                      , x = d.paddedRect.h - 2 * sc;
                    let b = {
                        x1: r.left,
                        y1: r.top,
                        x2: r.right,
                        y2: r.bottom
                    };
                    const C = d.stretchX || [[0, g]]
                      , P = d.stretchY || [[0, x]]
                      , D = (Ee, Ue) => Ee + Ue[1] - Ue[0]
                      , F = C.reduce(D, 0)
                      , B = P.reduce(D, 0)
                      , j = g - F
                      , G = x - B;
                    let X = 0
                      , ae = F
                      , Q = 0
                      , R = B
                      , Z = 0
                      , ee = j
                      , ye = 0
                      , Le = G;
                    if (d.content && s) {
                        const Ee = d.content
                          , Ue = Ee[2] - Ee[0]
                          , Qe = Ee[3] - Ee[1];
                        (d.textFitWidth || d.textFitHeight) && (b = Rp(r)),
                        X = Cu(C, 0, Ee[0]),
                        Q = Cu(P, 0, Ee[1]),
                        ae = Cu(C, Ee[0], Ee[2]),
                        R = Cu(P, Ee[1], Ee[3]),
                        Z = Ee[0] - X,
                        ye = Ee[1] - Q,
                        ee = Ue - ae,
                        Le = Qe - R
                    }
                    const be = b.x1
                      , Me = b.y1
                      , Fe = b.x2 - be
                      , Re = b.y2 - Me
                      , Be = (Ee, Ue, Qe, Ye) => {
                        const qe = Pu(Ee.stretch - X, ae, Fe, be)
                          , ht = Su(Ee.fixed - Z, ee, Ee.stretch, F)
                          , Yt = Pu(Ue.stretch - Q, R, Re, Me)
                          , Mi = Su(Ue.fixed - ye, Le, Ue.stretch, B)
                          , $i = Pu(Qe.stretch - X, ae, Fe, be)
                          , qr = Su(Qe.fixed - Z, ee, Qe.stretch, F)
                          , pr = Pu(Ye.stretch - Q, R, Re, Me)
                          , Oi = Su(Ye.fixed - ye, Le, Ye.stretch, B)
                          , qt = new Te(qe,Yt)
                          , zi = new Te($i,Yt)
                          , Ni = new Te($i,pr)
                          , ji = new Te(qe,pr)
                          , nr = new Te(ht / p,Mi / p)
                          , Hr = new Te(qr / p,Oi / p)
                          , ki = t * Math.PI / 180;
                        if (ki) {
                            const Li = Math.sin(ki)
                              , Di = Math.cos(ki)
                              , di = [Di, -Li, Li, Di];
                            qt._matMult(di),
                            zi._matMult(di),
                            ji._matMult(di),
                            Ni._matMult(di)
                        }
                        const fr = Ee.stretch + Ee.fixed
                          , Ci = Ue.stretch + Ue.fixed;
                        return {
                            tl: qt,
                            tr: zi,
                            bl: ji,
                            br: Ni,
                            tex: {
                                x: d.paddedRect.x + sc + fr,
                                y: d.paddedRect.y + sc + Ci,
                                w: Qe.stretch + Qe.fixed - fr,
                                h: Ye.stretch + Ye.fixed - Ci
                            },
                            writingMode: void 0,
                            glyphOffset: [0, 0],
                            sectionIndex: 0,
                            pixelOffsetTL: nr,
                            pixelOffsetBR: Hr,
                            minFontScaleX: ee / p / Fe,
                            minFontScaleY: Le / p / Re,
                            isSDF: n
                        }
                    }
                    ;
                    if (s && (d.stretchX || d.stretchY)) {
                        const Ee = hf(C, j, F)
                          , Ue = hf(P, G, B);
                        for (let Qe = 0; Qe < Ee.length - 1; Qe++) {
                            const Ye = Ee[Qe]
                              , qe = Ee[Qe + 1];
                            for (let ht = 0; ht < Ue.length - 1; ht++)
                                c.push(Be(Ye, Ue[ht], qe, Ue[ht + 1]))
                        }
                    } else
                        c.push(Be({
                            fixed: 0,
                            stretch: -1
                        }, {
                            fixed: 0,
                            stretch: -1
                        }, {
                            fixed: 0,
                            stretch: g + 1
                        }, {
                            fixed: 0,
                            stretch: x + 1
                        }));
                    return c
                }
                function Cu(r, t, n) {
                    let s = 0;
                    for (const c of r)
                        s += Math.max(t, Math.min(n, c[1])) - Math.max(t, Math.min(n, c[0]));
                    return s
                }
                function hf(r, t, n) {
                    const s = [{
                        fixed: -1,
                        stretch: 0
                    }];
                    for (const [c,d] of r) {
                        const p = s[s.length - 1];
                        s.push({
                            fixed: c - p.stretch,
                            stretch: p.stretch
                        }),
                        s.push({
                            fixed: c - p.stretch,
                            stretch: p.stretch + (d - c)
                        })
                    }
                    return s.push({
                        fixed: t + sc,
                        stretch: n
                    }),
                    s
                }
                function Pu(r, t, n, s) {
                    return r / t * n + s
                }
                function Su(r, t, n, s) {
                    return r - t * n / s
                }
                class Iu {
                    constructor(t, n, s, c, d, p, g, x, b, C) {
                        var P;
                        if (this.boxStartIndex = t.length,
                        b) {
                            let D = p.top
                              , F = p.bottom;
                            const B = p.collisionPadding;
                            B && (D -= B[1],
                            F += B[3]);
                            let j = F - D;
                            j > 0 && (j = Math.max(10, j),
                            this.circleDiameter = j)
                        } else {
                            const D = !((P = p.image) === null || P === void 0) && P.content && (p.image.textFitWidth || p.image.textFitHeight) ? Rp(p) : {
                                x1: p.left,
                                y1: p.top,
                                x2: p.right,
                                y2: p.bottom
                            };
                            D.y1 = D.y1 * g - x[0],
                            D.y2 = D.y2 * g + x[2],
                            D.x1 = D.x1 * g - x[3],
                            D.x2 = D.x2 * g + x[1];
                            const F = p.collisionPadding;
                            if (F && (D.x1 -= F[0] * g,
                            D.y1 -= F[1] * g,
                            D.x2 += F[2] * g,
                            D.y2 += F[3] * g),
                            C) {
                                const B = new Te(D.x1,D.y1)
                                  , j = new Te(D.x2,D.y1)
                                  , G = new Te(D.x1,D.y2)
                                  , X = new Te(D.x2,D.y2)
                                  , ae = C * Math.PI / 180;
                                B._rotate(ae),
                                j._rotate(ae),
                                G._rotate(ae),
                                X._rotate(ae),
                                D.x1 = Math.min(B.x, j.x, G.x, X.x),
                                D.x2 = Math.max(B.x, j.x, G.x, X.x),
                                D.y1 = Math.min(B.y, j.y, G.y, X.y),
                                D.y2 = Math.max(B.y, j.y, G.y, X.y)
                            }
                            t.emplaceBack(n.x, n.y, D.x1, D.y1, D.x2, D.y2, s, c, d)
                        }
                        this.boxEndIndex = t.length
                    }
                }
                class s_ {
                    constructor(t=[], n= (s, c) => s < c ? -1 : s > c ? 1 : 0) {
                        if (this.data = t,
                        this.length = this.data.length,
                        this.compare = n,
                        this.length > 0)
                            for (let s = (this.length >> 1) - 1; s >= 0; s--)
                                this._down(s)
                    }
                    push(t) {
                        this.data.push(t),
                        this._up(this.length++)
                    }
                    pop() {
                        if (this.length === 0)
                            return;
                        const t = this.data[0]
                          , n = this.data.pop();
                        return --this.length > 0 && (this.data[0] = n,
                        this._down(0)),
                        t
                    }
                    peek() {
                        return this.data[0]
                    }
                    _up(t) {
                        const {data: n, compare: s} = this
                          , c = n[t];
                        for (; t > 0; ) {
                            const d = t - 1 >> 1
                              , p = n[d];
                            if (s(c, p) >= 0)
                                break;
                            n[t] = p,
                            t = d
                        }
                        n[t] = c
                    }
                    _down(t) {
                        const {data: n, compare: s} = this
                          , c = this.length >> 1
                          , d = n[t];
                        for (; t < c; ) {
                            let p = 1 + (t << 1);
                            const g = p + 1;
                            if (g < this.length && s(n[g], n[p]) < 0 && (p = g),
                            s(n[p], d) >= 0)
                                break;
                            n[t] = n[p],
                            t = p
                        }
                        n[t] = d
                    }
                }
                function o_(r, t=1, n=!1) {
                    let s = 1 / 0
                      , c = 1 / 0
                      , d = -1 / 0
                      , p = -1 / 0;
                    const g = r[0];
                    for (let F = 0; F < g.length; F++) {
                        const B = g[F];
                        (!F || B.x < s) && (s = B.x),
                        (!F || B.y < c) && (c = B.y),
                        (!F || B.x > d) && (d = B.x),
                        (!F || B.y > p) && (p = B.y)
                    }
                    const x = Math.min(d - s, p - c);
                    let b = x / 2;
                    const C = new s_([],a_);
                    if (x === 0)
                        return new Te(s,c);
                    for (let F = s; F < d; F += x)
                        for (let B = c; B < p; B += x)
                            C.push(new za(F + b,B + b,b,r));
                    let P = function(F) {
                        let B = 0
                          , j = 0
                          , G = 0;
                        const X = F[0];
                        for (let ae = 0, Q = X.length, R = Q - 1; ae < Q; R = ae++) {
                            const Z = X[ae]
                              , ee = X[R]
                              , ye = Z.x * ee.y - ee.x * Z.y;
                            j += (Z.x + ee.x) * ye,
                            G += (Z.y + ee.y) * ye,
                            B += 3 * ye
                        }
                        return new za(j / B,G / B,0,F)
                    }(r)
                      , D = C.length;
                    for (; C.length; ) {
                        const F = C.pop();
                        (F.d > P.d || !P.d) && (P = F,
                        n && console.log("found best %d after %d probes", Math.round(1e4 * F.d) / 1e4, D)),
                        F.max - P.d <= t || (b = F.h / 2,
                        C.push(new za(F.p.x - b,F.p.y - b,b,r)),
                        C.push(new za(F.p.x + b,F.p.y - b,b,r)),
                        C.push(new za(F.p.x - b,F.p.y + b,b,r)),
                        C.push(new za(F.p.x + b,F.p.y + b,b,r)),
                        D += 4)
                    }
                    return n && (console.log(`num probes: ${D}`),
                    console.log(`best distance: ${P.d}`)),
                    P.p
                }
                function a_(r, t) {
                    return t.max - r.max
                }
                function za(r, t, n, s) {
                    this.p = new Te(r,t),
                    this.h = n,
                    this.d = function(c, d) {
                        let p = !1
                          , g = 1 / 0;
                        for (let x = 0; x < d.length; x++) {
                            const b = d[x];
                            for (let C = 0, P = b.length, D = P - 1; C < P; D = C++) {
                                const F = b[C]
                                  , B = b[D];
                                F.y > c.y != B.y > c.y && c.x < (B.x - F.x) * (c.y - F.y) / (B.y - F.y) + F.x && (p = !p),
                                g = Math.min(g, Gd(c, F, B))
                            }
                        }
                        return (p ? 1 : -1) * Math.sqrt(g)
                    }(this.p, s),
                    this.max = this.d + this.h * Math.SQRT2
                }
                var Gi;
                M.ax = void 0,
                (Gi = M.ax || (M.ax = {}))[Gi.center = 1] = "center",
                Gi[Gi.left = 2] = "left",
                Gi[Gi.right = 3] = "right",
                Gi[Gi.top = 4] = "top",
                Gi[Gi.bottom = 5] = "bottom",
                Gi[Gi["top-left"] = 6] = "top-left",
                Gi[Gi["top-right"] = 7] = "top-right",
                Gi[Gi["bottom-left"] = 8] = "bottom-left",
                Gi[Gi["bottom-right"] = 9] = "bottom-right";
                const Xs = 7
                  , Yh = Number.POSITIVE_INFINITY;
                function df(r, t) {
                    return t[1] !== Yh ? function(n, s, c) {
                        let d = 0
                          , p = 0;
                        switch (s = Math.abs(s),
                        c = Math.abs(c),
                        n) {
                        case "top-right":
                        case "top-left":
                        case "top":
                            p = c - Xs;
                            break;
                        case "bottom-right":
                        case "bottom-left":
                        case "bottom":
                            p = -c + Xs
                        }
                        switch (n) {
                        case "top-right":
                        case "bottom-right":
                        case "right":
                            d = -s;
                            break;
                        case "top-left":
                        case "bottom-left":
                        case "left":
                            d = s
                        }
                        return [d, p]
                    }(r, t[0], t[1]) : function(n, s) {
                        let c = 0
                          , d = 0;
                        s < 0 && (s = 0);
                        const p = s / Math.SQRT2;
                        switch (n) {
                        case "top-right":
                        case "top-left":
                            d = p - Xs;
                            break;
                        case "bottom-right":
                        case "bottom-left":
                            d = -p + Xs;
                            break;
                        case "bottom":
                            d = -s + Xs;
                            break;
                        case "top":
                            d = s - Xs
                        }
                        switch (n) {
                        case "top-right":
                        case "bottom-right":
                            c = -p;
                            break;
                        case "top-left":
                        case "bottom-left":
                            c = p;
                            break;
                        case "left":
                            c = s;
                            break;
                        case "right":
                            c = -s
                        }
                        return [c, d]
                    }(r, t[0])
                }
                function pf(r, t, n) {
                    var s;
                    const c = r.layout
                      , d = (s = c.get("text-variable-anchor-offset")) === null || s === void 0 ? void 0 : s.evaluate(t, {}, n);
                    if (d) {
                        const g = d.values
                          , x = [];
                        for (let b = 0; b < g.length; b += 2) {
                            const C = x[b] = g[b]
                              , P = g[b + 1].map(D => D * Ti);
                            C.startsWith("top") ? P[1] -= Xs : C.startsWith("bottom") && (P[1] += Xs),
                            x[b + 1] = P
                        }
                        return new Ii(x)
                    }
                    const p = c.get("text-variable-anchor");
                    if (p) {
                        let g;
                        g = r._unevaluatedLayout.getValue("text-radial-offset") !== void 0 ? [c.get("text-radial-offset").evaluate(t, {}, n) * Ti, Yh] : c.get("text-offset").evaluate(t, {}, n).map(b => b * Ti);
                        const x = [];
                        for (const b of p)
                            x.push(b, df(b, g));
                        return new Ii(x)
                    }
                    return null
                }
                function Qh(r) {
                    switch (r) {
                    case "right":
                    case "top-right":
                    case "bottom-right":
                        return "right";
                    case "left":
                    case "top-left":
                    case "bottom-left":
                        return "left"
                    }
                    return "center"
                }
                function l_(r, t, n, s, c, d, p, g, x, b, C, P) {
                    let D = d.textMaxSize.evaluate(t, {});
                    D === void 0 && (D = p);
                    const F = r.layers[0].layout
                      , B = F.get("icon-offset").evaluate(t, {}, C)
                      , j = mf(n.horizontal)
                      , G = p / 24
                      , X = r.tilePixelRatio * G
                      , ae = r.tilePixelRatio * D / 24
                      , Q = r.tilePixelRatio * g
                      , R = r.tilePixelRatio * F.get("symbol-spacing")
                      , Z = F.get("text-padding") * r.tilePixelRatio
                      , ee = function(Qe, Ye, qe, ht=1) {
                        const Yt = Qe.get("icon-padding").evaluate(Ye, {}, qe)
                          , Mi = Yt && Yt.values;
                        return [Mi[0] * ht, Mi[1] * ht, Mi[2] * ht, Mi[3] * ht]
                    }(F, t, C, r.tilePixelRatio)
                      , ye = F.get("text-max-angle") / 180 * Math.PI
                      , Le = F.get("text-rotation-alignment") !== "viewport" && F.get("symbol-placement") !== "point"
                      , be = F.get("icon-rotation-alignment") === "map" && F.get("symbol-placement") !== "point"
                      , Me = F.get("symbol-placement")
                      , Fe = R / 2
                      , Re = F.get("icon-text-fit");
                    let Be;
                    s && Re !== "none" && (r.allowVerticalPlacement && n.vertical && (Be = Fp(s, n.vertical, Re, F.get("icon-text-fit-padding"), B, G)),
                    j && (s = Fp(s, j, Re, F.get("icon-text-fit-padding"), B, G)));
                    const Ee = C ? P.line.getGranularityForZoomLevel(C.z) : 1
                      , Ue = (Qe, Ye) => {
                        Ye.x < 0 || Ye.x >= ut || Ye.y < 0 || Ye.y >= ut || function(qe, ht, Yt, Mi, $i, qr, pr, Oi, qt, zi, Ni, ji, nr, Hr, ki, fr, Ci, Li, Di, di, Nt, bn, ka, wn, h_) {
                            const La = qe.addToLineVertexArray(ht, Yt);
                            let Po, Da, Ra, Fa, xf = 0, vf = 0, bf = 0, wf = 0, ad = -1, ld = -1;
                            const xs = {};
                            let Tf = vi("");
                            if (qe.allowVerticalPlacement && Mi.vertical) {
                                const Ji = Oi.layout.get("text-rotate").evaluate(Nt, {}, wn) + 90;
                                Ra = new Iu(qt,ht,zi,Ni,ji,Mi.vertical,nr,Hr,ki,Ji),
                                pr && (Fa = new Iu(qt,ht,zi,Ni,ji,pr,Ci,Li,ki,Ji))
                            }
                            if ($i) {
                                const Ji = Oi.layout.get("icon-rotate").evaluate(Nt, {})
                                  , Wr = Oi.layout.get("icon-text-fit") !== "none"
                                  , So = uf($i, Ji, ka, Wr)
                                  , Mn = pr ? uf(pr, Ji, ka, Wr) : void 0;
                                Da = new Iu(qt,ht,zi,Ni,ji,$i,Ci,Li,!1,Ji),
                                xf = 4 * So.length;
                                const Io = qe.iconSizeData;
                                let Gn = null;
                                Io.kind === "source" ? (Gn = [Zn * Oi.layout.get("icon-size").evaluate(Nt, {})],
                                Gn[0] > qs && yi(`${qe.layerIds[0]}: Value for "icon-size" is >= ${rc}. Reduce your "icon-size".`)) : Io.kind === "composite" && (Gn = [Zn * bn.compositeIconSizes[0].evaluate(Nt, {}, wn), Zn * bn.compositeIconSizes[1].evaluate(Nt, {}, wn)],
                                (Gn[0] > qs || Gn[1] > qs) && yi(`${qe.layerIds[0]}: Value for "icon-size" is >= ${rc}. Reduce your "icon-size".`)),
                                qe.addSymbols(qe.icon, So, Gn, di, Di, Nt, M.ag.none, ht, La.lineStartIndex, La.lineLength, -1, wn),
                                ad = qe.icon.placedSymbolArray.length - 1,
                                Mn && (vf = 4 * Mn.length,
                                qe.addSymbols(qe.icon, Mn, Gn, di, Di, Nt, M.ag.vertical, ht, La.lineStartIndex, La.lineLength, -1, wn),
                                ld = qe.icon.placedSymbolArray.length - 1)
                            }
                            const Mf = Object.keys(Mi.horizontal);
                            for (const Ji of Mf) {
                                const Wr = Mi.horizontal[Ji];
                                if (!Po) {
                                    Tf = vi(Wr.text);
                                    const Mn = Oi.layout.get("text-rotate").evaluate(Nt, {}, wn);
                                    Po = new Iu(qt,ht,zi,Ni,ji,Wr,nr,Hr,ki,Mn)
                                }
                                const So = Wr.positionedLines.length === 1;
                                if (bf += ff(qe, ht, Wr, qr, Oi, ki, Nt, fr, La, Mi.vertical ? M.ag.horizontal : M.ag.horizontalOnly, So ? Mf : [Ji], xs, ad, bn, wn),
                                So)
                                    break
                            }
                            Mi.vertical && (wf += ff(qe, ht, Mi.vertical, qr, Oi, ki, Nt, fr, La, M.ag.vertical, ["vertical"], xs, ld, bn, wn));
                            const d_ = Po ? Po.boxStartIndex : qe.collisionBoxArray.length
                              , p_ = Po ? Po.boxEndIndex : qe.collisionBoxArray.length
                              , f_ = Ra ? Ra.boxStartIndex : qe.collisionBoxArray.length
                              , m_ = Ra ? Ra.boxEndIndex : qe.collisionBoxArray.length
                              , g_ = Da ? Da.boxStartIndex : qe.collisionBoxArray.length
                              , __ = Da ? Da.boxEndIndex : qe.collisionBoxArray.length
                              , y_ = Fa ? Fa.boxStartIndex : qe.collisionBoxArray.length
                              , x_ = Fa ? Fa.boxEndIndex : qe.collisionBoxArray.length;
                            let Tn = -1;
                            const Au = (Ji, Wr) => Ji && Ji.circleDiameter ? Math.max(Ji.circleDiameter, Wr) : Wr;
                            Tn = Au(Po, Tn),
                            Tn = Au(Ra, Tn),
                            Tn = Au(Da, Tn),
                            Tn = Au(Fa, Tn);
                            const Cf = Tn > -1 ? 1 : 0;
                            Cf && (Tn *= h_ / Ti),
                            qe.glyphOffsetArray.length >= Ea.MAX_GLYPHS && yi("Too many glyphs being rendered in a tile. See https://github.com/mapbox/mapbox-gl-js/issues/2907"),
                            Nt.sortKey !== void 0 && qe.addToSortKeyRanges(qe.symbolInstances.length, Nt.sortKey);
                            const v_ = pf(Oi, Nt, wn)
                              , [b_,w_] = function(Ji, Wr) {
                                const So = Ji.length
                                  , Mn = Wr?.values;
                                if (Mn?.length > 0)
                                    for (let Io = 0; Io < Mn.length; Io += 2) {
                                        const Gn = Mn[Io + 1];
                                        Ji.emplaceBack(M.ax[Mn[Io]], Gn[0], Gn[1])
                                    }
                                return [So, Ji.length]
                            }(qe.textAnchorOffsets, v_);
                            qe.symbolInstances.emplaceBack(ht.x, ht.y, xs.right >= 0 ? xs.right : -1, xs.center >= 0 ? xs.center : -1, xs.left >= 0 ? xs.left : -1, xs.vertical || -1, ad, ld, Tf, d_, p_, f_, m_, g_, __, y_, x_, zi, bf, wf, xf, vf, Cf, 0, nr, Tn, b_, w_)
                        }(r, Ye, Qe, n, s, c, Be, r.layers[0], r.collisionBoxArray, t.index, t.sourceLayerIndex, r.index, X, [Z, Z, Z, Z], Le, x, Q, ee, be, B, t, d, b, C, p)
                    }
                    ;
                    if (Me === "line")
                        for (const Qe of nf(t.geometry, 0, 0, ut, ut)) {
                            const Ye = Co(Qe, Ee)
                              , qe = n_(Ye, R, ye, n.vertical || j, s, 24, ae, r.overscaling, ut);
                            for (const ht of qe)
                                j && c_(r, j.text, Fe, ht) || Ue(Ye, ht)
                        }
                    else if (Me === "line-center") {
                        for (const Qe of t.geometry)
                            if (Qe.length > 1) {
                                const Ye = Co(Qe, Ee)
                                  , qe = r_(Ye, ye, n.vertical || j, s, 24, ae);
                                qe && Ue(Ye, qe)
                            }
                    } else if (t.type === "Polygon")
                        for (const Qe of Go(t.geometry, 0)) {
                            const Ye = o_(Qe, 16);
                            Ue(Co(Qe[0], Ee, !0), new Ws(Ye.x,Ye.y,0))
                        }
                    else if (t.type === "LineString")
                        for (const Qe of t.geometry) {
                            const Ye = Co(Qe, Ee);
                            Ue(Ye, new Ws(Ye[0].x,Ye[0].y,0))
                        }
                    else if (t.type === "Point")
                        for (const Qe of t.geometry)
                            for (const Ye of Qe)
                                Ue([Ye], new Ws(Ye.x,Ye.y,0))
                }
                function ff(r, t, n, s, c, d, p, g, x, b, C, P, D, F, B) {
                    const j = function(ae, Q, R, Z, ee, ye, Le, be) {
                        const Me = Z.layout.get("text-rotate").evaluate(ye, {}) * Math.PI / 180
                          , Fe = [];
                        for (const Re of Q.positionedLines)
                            for (const Be of Re.positionedGlyphs) {
                                if (!Be.rect)
                                    continue;
                                const Ee = Be.rect || {};
                                let Ue = Fg + 1
                                  , Qe = !0
                                  , Ye = 1
                                  , qe = 0;
                                const ht = (ee || be) && Be.vertical
                                  , Yt = Be.metrics.advance * Be.scale / 2;
                                if (be && Q.verticalizable && (qe = Re.lineOffset / 2 - (Be.imageName ? -(Ti - Be.metrics.width * Be.scale) / 2 : (Be.scale - 1) * Ti)),
                                Be.imageName) {
                                    const Li = Le[Be.imageName];
                                    Qe = Li.sdf,
                                    Ye = Li.pixelRatio,
                                    Ue = dr / Ye
                                }
                                const Mi = ee ? [Be.x + Yt, Be.y] : [0, 0];
                                let $i = ee ? [0, 0] : [Be.x + Yt + R[0], Be.y + R[1] - qe]
                                  , qr = [0, 0];
                                ht && (qr = $i,
                                $i = [0, 0]);
                                const pr = Be.metrics.isDoubleResolution ? 2 : 1
                                  , Oi = (Be.metrics.left - Ue) * Be.scale - Yt + $i[0]
                                  , qt = (-Be.metrics.top - Ue) * Be.scale + $i[1]
                                  , zi = Oi + Ee.w / pr * Be.scale / Ye
                                  , Ni = qt + Ee.h / pr * Be.scale / Ye
                                  , ji = new Te(Oi,qt)
                                  , nr = new Te(zi,qt)
                                  , Hr = new Te(Oi,Ni)
                                  , ki = new Te(zi,Ni);
                                if (ht) {
                                    const Li = new Te(-Yt,Yt - vu)
                                      , Di = -Math.PI / 2
                                      , di = Ti / 2 - Yt
                                      , Nt = new Te(5 - vu - di,-(Be.imageName ? di : 0))
                                      , bn = new Te(...qr);
                                    ji._rotateAround(Di, Li)._add(Nt)._add(bn),
                                    nr._rotateAround(Di, Li)._add(Nt)._add(bn),
                                    Hr._rotateAround(Di, Li)._add(Nt)._add(bn),
                                    ki._rotateAround(Di, Li)._add(Nt)._add(bn)
                                }
                                if (Me) {
                                    const Li = Math.sin(Me)
                                      , Di = Math.cos(Me)
                                      , di = [Di, -Li, Li, Di];
                                    ji._matMult(di),
                                    nr._matMult(di),
                                    Hr._matMult(di),
                                    ki._matMult(di)
                                }
                                const fr = new Te(0,0)
                                  , Ci = new Te(0,0);
                                Fe.push({
                                    tl: ji,
                                    tr: nr,
                                    bl: Hr,
                                    br: ki,
                                    tex: Ee,
                                    writingMode: Q.writingMode,
                                    glyphOffset: Mi,
                                    sectionIndex: Be.sectionIndex,
                                    isSDF: Qe,
                                    pixelOffsetTL: fr,
                                    pixelOffsetBR: Ci,
                                    minFontScaleX: 0,
                                    minFontScaleY: 0
                                })
                            }
                        return Fe
                    }(0, n, g, c, d, p, s, r.allowVerticalPlacement)
                      , G = r.textSizeData;
                    let X = null;
                    G.kind === "source" ? (X = [Zn * c.layout.get("text-size").evaluate(p, {})],
                    X[0] > qs && yi(`${r.layerIds[0]}: Value for "text-size" is >= ${rc}. Reduce your "text-size".`)) : G.kind === "composite" && (X = [Zn * F.compositeTextSizes[0].evaluate(p, {}, B), Zn * F.compositeTextSizes[1].evaluate(p, {}, B)],
                    (X[0] > qs || X[1] > qs) && yi(`${r.layerIds[0]}: Value for "text-size" is >= ${rc}. Reduce your "text-size".`)),
                    r.addSymbols(r.text, j, X, g, d, p, b, t, x.lineStartIndex, x.lineLength, D, B);
                    for (const ae of C)
                        P[ae] = r.text.placedSymbolArray.length - 1;
                    return 4 * j.length
                }
                function mf(r) {
                    for (const t in r)
                        return r[t];
                    return null
                }
                function c_(r, t, n, s) {
                    const c = r.compareText;
                    if (t in c) {
                        const d = c[t];
                        for (let p = d.length - 1; p >= 0; p--)
                            if (s.dist(d[p]) < n)
                                return !0
                    } else
                        c[t] = [];
                    return c[t].push(s),
                    !1
                }
                const gf = [Int8Array, Uint8Array, Uint8ClampedArray, Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array];
                class ed {
                    static from(t) {
                        if (!(t instanceof ArrayBuffer))
                            throw new Error("Data must be an instance of ArrayBuffer.");
                        const [n,s] = new Uint8Array(t,0,2);
                        if (n !== 219)
                            throw new Error("Data does not appear to be in a KDBush format.");
                        const c = s >> 4;
                        if (c !== 1)
                            throw new Error(`Got v${c} data when expected v1.`);
                        const d = gf[15 & s];
                        if (!d)
                            throw new Error("Unrecognized array type.");
                        const [p] = new Uint16Array(t,2,1)
                          , [g] = new Uint32Array(t,4,1);
                        return new ed(g,p,d,t)
                    }
                    constructor(t, n=64, s=Float64Array, c) {
                        if (isNaN(t) || t < 0)
                            throw new Error(`Unpexpected numItems value: ${t}.`);
                        this.numItems = +t,
                        this.nodeSize = Math.min(Math.max(+n, 2), 65535),
                        this.ArrayType = s,
                        this.IndexArrayType = t < 65536 ? Uint16Array : Uint32Array;
                        const d = gf.indexOf(this.ArrayType)
                          , p = 2 * t * this.ArrayType.BYTES_PER_ELEMENT
                          , g = t * this.IndexArrayType.BYTES_PER_ELEMENT
                          , x = (8 - g % 8) % 8;
                        if (d < 0)
                            throw new Error(`Unexpected typed array class: ${s}.`);
                        c && c instanceof ArrayBuffer ? (this.data = c,
                        this.ids = new this.IndexArrayType(this.data,8,t),
                        this.coords = new this.ArrayType(this.data,8 + g + x,2 * t),
                        this._pos = 2 * t,
                        this._finished = !0) : (this.data = new ArrayBuffer(8 + p + g + x),
                        this.ids = new this.IndexArrayType(this.data,8,t),
                        this.coords = new this.ArrayType(this.data,8 + g + x,2 * t),
                        this._pos = 0,
                        this._finished = !1,
                        new Uint8Array(this.data,0,2).set([219, 16 + d]),
                        new Uint16Array(this.data,2,1)[0] = n,
                        new Uint32Array(this.data,4,1)[0] = t)
                    }
                    add(t, n) {
                        const s = this._pos >> 1;
                        return this.ids[s] = s,
                        this.coords[this._pos++] = t,
                        this.coords[this._pos++] = n,
                        s
                    }
                    finish() {
                        const t = this._pos >> 1;
                        if (t !== this.numItems)
                            throw new Error(`Added ${t} items when expected ${this.numItems}.`);
                        return td(this.ids, this.coords, this.nodeSize, 0, this.numItems - 1, 0),
                        this._finished = !0,
                        this
                    }
                    range(t, n, s, c) {
                        if (!this._finished)
                            throw new Error("Data not yet indexed - call index.finish().");
                        const {ids: d, coords: p, nodeSize: g} = this
                          , x = [0, d.length - 1, 0]
                          , b = [];
                        for (; x.length; ) {
                            const C = x.pop() || 0
                              , P = x.pop() || 0
                              , D = x.pop() || 0;
                            if (P - D <= g) {
                                for (let G = D; G <= P; G++) {
                                    const X = p[2 * G]
                                      , ae = p[2 * G + 1];
                                    X >= t && X <= s && ae >= n && ae <= c && b.push(d[G])
                                }
                                continue
                            }
                            const F = D + P >> 1
                              , B = p[2 * F]
                              , j = p[2 * F + 1];
                            B >= t && B <= s && j >= n && j <= c && b.push(d[F]),
                            (C === 0 ? t <= B : n <= j) && (x.push(D),
                            x.push(F - 1),
                            x.push(1 - C)),
                            (C === 0 ? s >= B : c >= j) && (x.push(F + 1),
                            x.push(P),
                            x.push(1 - C))
                        }
                        return b
                    }
                    within(t, n, s) {
                        if (!this._finished)
                            throw new Error("Data not yet indexed - call index.finish().");
                        const {ids: c, coords: d, nodeSize: p} = this
                          , g = [0, c.length - 1, 0]
                          , x = []
                          , b = s * s;
                        for (; g.length; ) {
                            const C = g.pop() || 0
                              , P = g.pop() || 0
                              , D = g.pop() || 0;
                            if (P - D <= p) {
                                for (let G = D; G <= P; G++)
                                    yf(d[2 * G], d[2 * G + 1], t, n) <= b && x.push(c[G]);
                                continue
                            }
                            const F = D + P >> 1
                              , B = d[2 * F]
                              , j = d[2 * F + 1];
                            yf(B, j, t, n) <= b && x.push(c[F]),
                            (C === 0 ? t - s <= B : n - s <= j) && (g.push(D),
                            g.push(F - 1),
                            g.push(1 - C)),
                            (C === 0 ? t + s >= B : n + s >= j) && (g.push(F + 1),
                            g.push(P),
                            g.push(1 - C))
                        }
                        return x
                    }
                }
                function td(r, t, n, s, c, d) {
                    if (c - s <= n)
                        return;
                    const p = s + c >> 1;
                    _f(r, t, p, s, c, d),
                    td(r, t, n, s, p - 1, 1 - d),
                    td(r, t, n, p + 1, c, 1 - d)
                }
                function _f(r, t, n, s, c, d) {
                    for (; c > s; ) {
                        if (c - s > 600) {
                            const b = c - s + 1
                              , C = n - s + 1
                              , P = Math.log(b)
                              , D = .5 * Math.exp(2 * P / 3)
                              , F = .5 * Math.sqrt(P * D * (b - D) / b) * (C - b / 2 < 0 ? -1 : 1);
                            _f(r, t, n, Math.max(s, Math.floor(n - C * D / b + F)), Math.min(c, Math.floor(n + (b - C) * D / b + F)), d)
                        }
                        const p = t[2 * n + d];
                        let g = s
                          , x = c;
                        for (oc(r, t, s, n),
                        t[2 * c + d] > p && oc(r, t, s, c); g < x; ) {
                            for (oc(r, t, g, x),
                            g++,
                            x--; t[2 * g + d] < p; )
                                g++;
                            for (; t[2 * x + d] > p; )
                                x--
                        }
                        t[2 * s + d] === p ? oc(r, t, s, x) : (x++,
                        oc(r, t, x, c)),
                        x <= n && (s = x + 1),
                        n <= x && (c = x - 1)
                    }
                }
                function oc(r, t, n, s) {
                    id(r, n, s),
                    id(t, 2 * n, 2 * s),
                    id(t, 2 * n + 1, 2 * s + 1)
                }
                function id(r, t, n) {
                    const s = r[t];
                    r[t] = r[n],
                    r[n] = s
                }
                function yf(r, t, n, s) {
                    const c = r - n
                      , d = t - s;
                    return c * c + d * d
                }
                var rd;
                M.cg = void 0,
                (rd = M.cg || (M.cg = {})).create = "create",
                rd.load = "load",
                rd.fullLoad = "fullLoad";
                let Eu = null
                  , ac = [];
                const nd = 1e3 / 60
                  , sd = "loadTime"
                  , od = "fullLoadTime"
                  , u_ = {
                    mark(r) {
                        performance.mark(r)
                    },
                    frame(r) {
                        const t = r;
                        Eu != null && ac.push(t - Eu),
                        Eu = t
                    },
                    clearMetrics() {
                        Eu = null,
                        ac = [],
                        performance.clearMeasures(sd),
                        performance.clearMeasures(od);
                        for (const r in M.cg)
                            performance.clearMarks(M.cg[r])
                    },
                    getPerformanceMetrics() {
                        performance.measure(sd, M.cg.create, M.cg.load),
                        performance.measure(od, M.cg.create, M.cg.fullLoad);
                        const r = performance.getEntriesByName(sd)[0].duration
                          , t = performance.getEntriesByName(od)[0].duration
                          , n = ac.length
                          , s = 1 / (ac.reduce( (d, p) => d + p, 0) / n / 1e3)
                          , c = ac.filter(d => d > nd).reduce( (d, p) => d + (p - nd) / nd, 0);
                        return {
                            loadTime: r,
                            fullLoadTime: t,
                            fps: s,
                            percentDroppedFrames: c / (n + c) * 100,
                            totalFrames: n
                        }
                    }
                };
                M.$ = nc,
                M.A = gt,
                M.B = cr,
                M.C = Ut,
                M.D = Xe,
                M.E = pe,
                M.F = tu,
                M.G = function(r) {
                    if (oi == null) {
                        const t = r.navigator ? r.navigator.userAgent : null;
                        oi = !!r.safari || !(!t || !(/\b(iPad|iPhone|iPod)\b/.test(t) || t.match("Safari") && !t.match("Chrome")))
                    }
                    return oi
                }
                ,
                M.H = class {
                    constructor(r, t) {
                        this.target = r,
                        this.mapId = t,
                        this.resolveRejects = {},
                        this.tasks = {},
                        this.taskQueue = [],
                        this.abortControllers = {},
                        this.messageHandlers = {},
                        this.invoker = new e_( () => this.process()),
                        this.subscription = tn(this.target, "message", n => this.receive(n), !1),
                        this.globalScope = Tr(self) ? r : window
                    }
                    registerMessageHandler(r, t) {
                        this.messageHandlers[r] = t
                    }
                    sendAsync(r, t) {
                        return new Promise( (n, s) => {
                            const c = Math.round(1e18 * Math.random()).toString(36).substring(0, 10)
                              , d = t ? tn(t.signal, "abort", () => {
                                d?.unsubscribe(),
                                delete this.resolveRejects[c];
                                const x = {
                                    id: c,
                                    type: "<cancel>",
                                    origin: location.origin,
                                    targetMapId: r.targetMapId,
                                    sourceMapId: this.mapId
                                };
                                this.target.postMessage(x)
                            }
                            , t_) : null;
                            this.resolveRejects[c] = {
                                resolve: x => {
                                    d?.unsubscribe(),
                                    n(x)
                                }
                                ,
                                reject: x => {
                                    d?.unsubscribe(),
                                    s(x)
                                }
                            };
                            const p = []
                              , g = Object.assign(Object.assign({}, r), {
                                id: c,
                                sourceMapId: this.mapId,
                                origin: location.origin,
                                data: jn(r.data, p)
                            });
                            this.target.postMessage(g, {
                                transfer: p
                            })
                        }
                        )
                    }
                    receive(r) {
                        const t = r.data
                          , n = t.id;
                        if (!(t.origin !== "file://" && location.origin !== "file://" && t.origin !== "resource://android" && location.origin !== "resource://android" && t.origin !== location.origin || t.targetMapId && this.mapId !== t.targetMapId)) {
                            if (t.type === "<cancel>") {
                                delete this.tasks[n];
                                const s = this.abortControllers[n];
                                return delete this.abortControllers[n],
                                void (s && s.abort())
                            }
                            if (Tr(self) || t.mustQueue)
                                return this.tasks[n] = t,
                                this.taskQueue.push(n),
                                void this.invoker.trigger();
                            this.processTask(n, t)
                        }
                    }
                    process() {
                        if (this.taskQueue.length === 0)
                            return;
                        const r = this.taskQueue.shift()
                          , t = this.tasks[r];
                        delete this.tasks[r],
                        this.taskQueue.length > 0 && this.invoker.trigger(),
                        t && this.processTask(r, t)
                    }
                    processTask(r, t) {
                        return l(this, void 0, void 0, function*() {
                            if (t.type === "<response>") {
                                const c = this.resolveRejects[r];
                                return delete this.resolveRejects[r],
                                c ? void (t.error ? c.reject(yo(t.error)) : c.resolve(yo(t.data))) : void 0
                            }
                            if (!this.messageHandlers[t.type])
                                return void this.completeTask(r, new Error(`Could not find a registered handler for ${t.type}, map ID: ${this.mapId}, available handlers: ${Object.keys(this.messageHandlers).join(", ")}`));
                            const n = yo(t.data)
                              , s = new AbortController;
                            this.abortControllers[r] = s;
                            try {
                                const c = yield this.messageHandlers[t.type](t.sourceMapId, n, s);
                                this.completeTask(r, null, c)
                            } catch (c) {
                                this.completeTask(r, c)
                            }
                        })
                    }
                    completeTask(r, t, n) {
                        const s = [];
                        delete this.abortControllers[r];
                        const c = {
                            id: r,
                            type: "<response>",
                            sourceMapId: this.mapId,
                            origin: location.origin,
                            error: t ? jn(t) : null,
                            data: jn(n, s)
                        };
                        this.target.postMessage(c, {
                            transfer: s
                        })
                    }
                    remove() {
                        this.invoker.remove(),
                        this.subscription.unsubscribe()
                    }
                }
                ,
                M.I = Vh,
                M.J = Yn,
                M.K = function() {
                    var r = new gt(16);
                    return gt != Float32Array && (r[1] = 0,
                    r[2] = 0,
                    r[3] = 0,
                    r[4] = 0,
                    r[6] = 0,
                    r[7] = 0,
                    r[8] = 0,
                    r[9] = 0,
                    r[11] = 0,
                    r[12] = 0,
                    r[13] = 0,
                    r[14] = 0),
                    r[0] = 1,
                    r[5] = 1,
                    r[10] = 1,
                    r[15] = 1,
                    r
                }
                ,
                M.L = function(r, t, n) {
                    var s, c, d, p, g, x, b, C, P, D, F, B, j = n[0], G = n[1], X = n[2];
                    return t === r ? (r[12] = t[0] * j + t[4] * G + t[8] * X + t[12],
                    r[13] = t[1] * j + t[5] * G + t[9] * X + t[13],
                    r[14] = t[2] * j + t[6] * G + t[10] * X + t[14],
                    r[15] = t[3] * j + t[7] * G + t[11] * X + t[15]) : (c = t[1],
                    d = t[2],
                    p = t[3],
                    g = t[4],
                    x = t[5],
                    b = t[6],
                    C = t[7],
                    P = t[8],
                    D = t[9],
                    F = t[10],
                    B = t[11],
                    r[0] = s = t[0],
                    r[1] = c,
                    r[2] = d,
                    r[3] = p,
                    r[4] = g,
                    r[5] = x,
                    r[6] = b,
                    r[7] = C,
                    r[8] = P,
                    r[9] = D,
                    r[10] = F,
                    r[11] = B,
                    r[12] = s * j + g * G + P * X + t[12],
                    r[13] = c * j + x * G + D * X + t[13],
                    r[14] = d * j + b * G + F * X + t[14],
                    r[15] = p * j + C * G + B * X + t[15]),
                    r
                }
                ,
                M.M = function(r, t, n) {
                    var s = n[0]
                      , c = n[1]
                      , d = n[2];
                    return r[0] = t[0] * s,
                    r[1] = t[1] * s,
                    r[2] = t[2] * s,
                    r[3] = t[3] * s,
                    r[4] = t[4] * c,
                    r[5] = t[5] * c,
                    r[6] = t[6] * c,
                    r[7] = t[7] * c,
                    r[8] = t[8] * d,
                    r[9] = t[9] * d,
                    r[10] = t[10] * d,
                    r[11] = t[11] * d,
                    r[12] = t[12],
                    r[13] = t[13],
                    r[14] = t[14],
                    r[15] = t[15],
                    r
                }
                ,
                M.N = function(r, t, n) {
                    var s = t[0]
                      , c = t[1]
                      , d = t[2]
                      , p = t[3]
                      , g = t[4]
                      , x = t[5]
                      , b = t[6]
                      , C = t[7]
                      , P = t[8]
                      , D = t[9]
                      , F = t[10]
                      , B = t[11]
                      , j = t[12]
                      , G = t[13]
                      , X = t[14]
                      , ae = t[15]
                      , Q = n[0]
                      , R = n[1]
                      , Z = n[2]
                      , ee = n[3];
                    return r[0] = Q * s + R * g + Z * P + ee * j,
                    r[1] = Q * c + R * x + Z * D + ee * G,
                    r[2] = Q * d + R * b + Z * F + ee * X,
                    r[3] = Q * p + R * C + Z * B + ee * ae,
                    r[4] = (Q = n[4]) * s + (R = n[5]) * g + (Z = n[6]) * P + (ee = n[7]) * j,
                    r[5] = Q * c + R * x + Z * D + ee * G,
                    r[6] = Q * d + R * b + Z * F + ee * X,
                    r[7] = Q * p + R * C + Z * B + ee * ae,
                    r[8] = (Q = n[8]) * s + (R = n[9]) * g + (Z = n[10]) * P + (ee = n[11]) * j,
                    r[9] = Q * c + R * x + Z * D + ee * G,
                    r[10] = Q * d + R * b + Z * F + ee * X,
                    r[11] = Q * p + R * C + Z * B + ee * ae,
                    r[12] = (Q = n[12]) * s + (R = n[13]) * g + (Z = n[14]) * P + (ee = n[15]) * j,
                    r[13] = Q * c + R * x + Z * D + ee * G,
                    r[14] = Q * d + R * b + Z * F + ee * X,
                    r[15] = Q * p + R * C + Z * B + ee * ae,
                    r
                }
                ,
                M.O = function(r, t) {
                    const n = {};
                    for (let s = 0; s < t.length; s++) {
                        const c = t[s];
                        c in r && (n[c] = r[c])
                    }
                    return n
                }
                ,
                M.P = Te,
                M.Q = Hs,
                M.R = Gr,
                M.S = qp,
                M.T = Rl,
                M.U = $p,
                M.V = St,
                M.W = Wt,
                M.X = Or,
                M.Y = $r,
                M.Z = ut,
                M._ = l,
                M.a = Jn,
                M.a$ = function() {
                    const r = new Float32Array(16);
                    return Pi(r),
                    r
                }
                ,
                M.a0 = Jh,
                M.a1 = r => {
                    const t = window.document.createElement("video");
                    return t.muted = !0,
                    new Promise(n => {
                        t.onloadstart = () => {
                            n(t)
                        }
                        ;
                        for (const s of r) {
                            const c = window.document.createElement("source");
                            Dn(s) || (t.crossOrigin = "Anonymous"),
                            c.src = s,
                            t.appendChild(c)
                        }
                    }
                    )
                }
                ,
                M.a2 = me,
                M.a3 = function() {
                    return Yi++
                }
                ,
                M.a4 = m,
                M.a5 = Ea,
                M.a6 = sa,
                M.a7 = hr,
                M.a8 = Qp,
                M.a9 = function(r) {
                    const t = {};
                    if (r.replace(/(?:^|(?:\s*\,\s*))([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)(?:\=(?:([^\x00-\x20\(\)<>@\,;\:\\"\/\[\]\?\=\{\}\x7F]+)|(?:\"((?:[^"\\]|\\.)*)\")))?/g, (n, s, c, d) => {
                        const p = c || d;
                        return t[s] = !p || p.toLowerCase(),
                        ""
                    }
                    ),
                    t["max-age"]) {
                        const n = parseInt(t["max-age"], 10);
                        isNaN(n) ? delete t["max-age"] : t["max-age"] = n
                    }
                    return t
                }
                ,
                M.aA = Zh,
                M.aB = ed,
                M.aC = li,
                M.aD = _u,
                M.aE = W,
                M.aF = Ke,
                M.aG = Ne,
                M.aH = function(r) {
                    return Math.pow(2, r)
                }
                ,
                M.aI = 85.051129,
                M.aJ = Hp,
                M.aK = _i,
                M.aL = Nr,
                M.aM = Wp,
                M.aN = function(r, t, n) {
                    return r[0] = t[0] * n,
                    r[1] = t[1] * n,
                    r[2] = t[2] * n,
                    r
                }
                ,
                M.aO = function(r, t, n) {
                    return r[0] = t[0] + n[0],
                    r[1] = t[1] + n[1],
                    r[2] = t[2] + n[2],
                    r
                }
                ,
                M.aP = function(r) {
                    var t = new gt(3);
                    return t[0] = r[0],
                    t[1] = r[1],
                    t[2] = r[2],
                    t
                }
                ,
                M.aQ = function(r, t, n) {
                    return r[0] = t[0] * n[0],
                    r[1] = t[1] * n[1],
                    r[2] = t[2] * n[2],
                    r[3] = t[3] * n[3],
                    r
                }
                ,
                M.aR = function(r, t, n) {
                    return r[0] = t[0] - n[0],
                    r[1] = t[1] - n[1],
                    r[2] = t[2] - n[2],
                    r
                }
                ,
                M.aS = function(r, t) {
                    var n = t[0]
                      , s = t[1]
                      , c = t[2]
                      , d = n * n + s * s + c * c;
                    return d > 0 && (d = 1 / Math.sqrt(d)),
                    r[0] = t[0] * d,
                    r[1] = t[1] * d,
                    r[2] = t[2] * d,
                    r
                }
                ,
                M.aT = function(r, t, n) {
                    var s = t[0]
                      , c = t[1]
                      , d = t[2]
                      , p = n[0]
                      , g = n[1]
                      , x = n[2];
                    return r[0] = c * x - d * g,
                    r[1] = d * p - s * x,
                    r[2] = s * g - c * p,
                    r
                }
                ,
                M.aU = function(r, t) {
                    return r[0] * t[0] + r[1] * t[1] + r[2] * t[2]
                }
                ,
                M.aV = Kp,
                M.aW = Aa,
                M.aX = function(r, t, n, s, c) {
                    var d, p = 1 / Math.tan(t / 2);
                    return r[0] = p / n,
                    r[1] = 0,
                    r[2] = 0,
                    r[3] = 0,
                    r[4] = 0,
                    r[5] = p,
                    r[6] = 0,
                    r[7] = 0,
                    r[8] = 0,
                    r[9] = 0,
                    r[11] = -1,
                    r[12] = 0,
                    r[13] = 0,
                    r[15] = 0,
                    c != null && c !== 1 / 0 ? (r[10] = (c + s) * (d = 1 / (s - c)),
                    r[14] = 2 * c * s * d) : (r[10] = -1,
                    r[14] = -2 * s),
                    r
                }
                ,
                M.aY = function(r) {
                    var t = new gt(16);
                    return t[0] = r[0],
                    t[1] = r[1],
                    t[2] = r[2],
                    t[3] = r[3],
                    t[4] = r[4],
                    t[5] = r[5],
                    t[6] = r[6],
                    t[7] = r[7],
                    t[8] = r[8],
                    t[9] = r[9],
                    t[10] = r[10],
                    t[11] = r[11],
                    t[12] = r[12],
                    t[13] = r[13],
                    t[14] = r[14],
                    t[15] = r[15],
                    t
                }
                ,
                M.aZ = function(r, t, n) {
                    var s = Math.sin(n)
                      , c = Math.cos(n)
                      , d = t[0]
                      , p = t[1]
                      , g = t[2]
                      , x = t[3]
                      , b = t[4]
                      , C = t[5]
                      , P = t[6]
                      , D = t[7];
                    return t !== r && (r[8] = t[8],
                    r[9] = t[9],
                    r[10] = t[10],
                    r[11] = t[11],
                    r[12] = t[12],
                    r[13] = t[13],
                    r[14] = t[14],
                    r[15] = t[15]),
                    r[0] = d * c + b * s,
                    r[1] = p * c + C * s,
                    r[2] = g * c + P * s,
                    r[3] = x * c + D * s,
                    r[4] = b * c - d * s,
                    r[5] = C * c - p * s,
                    r[6] = P * c - g * s,
                    r[7] = D * c - x * s,
                    r
                }
                ,
                M.a_ = function(r, t, n) {
                    var s = Math.sin(n)
                      , c = Math.cos(n)
                      , d = t[4]
                      , p = t[5]
                      , g = t[6]
                      , x = t[7]
                      , b = t[8]
                      , C = t[9]
                      , P = t[10]
                      , D = t[11];
                    return t !== r && (r[0] = t[0],
                    r[1] = t[1],
                    r[2] = t[2],
                    r[3] = t[3],
                    r[12] = t[12],
                    r[13] = t[13],
                    r[14] = t[14],
                    r[15] = t[15]),
                    r[4] = d * c + b * s,
                    r[5] = p * c + C * s,
                    r[6] = g * c + P * s,
                    r[7] = x * c + D * s,
                    r[8] = b * c - d * s,
                    r[9] = C * c - p * s,
                    r[10] = P * c - g * s,
                    r[11] = D * c - x * s,
                    r
                }
                ,
                M.aa = function(r) {
                    return Math.log(r) / Math.LN2
                }
                ,
                M.ab = function(r) {
                    var t = r[0]
                      , n = r[1];
                    return t * t + n * n
                }
                ,
                M.ac = function(r) {
                    return r * Math.PI / 180
                }
                ,
                M.ad = si,
                M.ae = function(r, t) {
                    const n = [];
                    for (const s in r)
                        s in t || n.push(s);
                    return n
                }
                ,
                M.af = function(r, t) {
                    let n = 0
                      , s = 0;
                    if (r.kind === "constant")
                        s = r.layoutSize;
                    else if (r.kind !== "source") {
                        const {interpolationType: c, minZoom: d, maxZoom: p} = r
                          , g = c ? si(Zi.interpolationFactor(c, t, d, p), 0, 1) : 0;
                        r.kind === "camera" ? s = cr.number(r.minSize, r.maxSize, g) : n = g
                    }
                    return {
                        uSizeT: n,
                        uSize: s
                    }
                }
                ,
                M.ah = function(r, {uSize: t, uSizeT: n}, {lowerSize: s, upperSize: c}) {
                    return r.kind === "source" ? s / Zn : r.kind === "composite" ? cr.number(s / Zn, c / Zn, n) : t
                }
                ,
                M.ai = function(r, t) {
                    var n = t[0]
                      , s = t[1]
                      , c = t[2]
                      , d = t[3]
                      , p = t[4]
                      , g = t[5]
                      , x = t[6]
                      , b = t[7]
                      , C = t[8]
                      , P = t[9]
                      , D = t[10]
                      , F = t[11]
                      , B = t[12]
                      , j = t[13]
                      , G = t[14]
                      , X = t[15]
                      , ae = n * g - s * p
                      , Q = n * x - c * p
                      , R = n * b - d * p
                      , Z = s * x - c * g
                      , ee = s * b - d * g
                      , ye = c * b - d * x
                      , Le = C * j - P * B
                      , be = C * G - D * B
                      , Me = C * X - F * B
                      , Fe = P * G - D * j
                      , Re = P * X - F * j
                      , Be = D * X - F * G
                      , Ee = ae * Be - Q * Re + R * Fe + Z * Me - ee * be + ye * Le;
                    return Ee ? (r[0] = (g * Be - x * Re + b * Fe) * (Ee = 1 / Ee),
                    r[1] = (c * Re - s * Be - d * Fe) * Ee,
                    r[2] = (j * ye - G * ee + X * Z) * Ee,
                    r[3] = (D * ee - P * ye - F * Z) * Ee,
                    r[4] = (x * Me - p * Be - b * be) * Ee,
                    r[5] = (n * Be - c * Me + d * be) * Ee,
                    r[6] = (G * R - B * ye - X * Q) * Ee,
                    r[7] = (C * ye - D * R + F * Q) * Ee,
                    r[8] = (p * Re - g * Me + b * Le) * Ee,
                    r[9] = (s * Me - n * Re - d * Le) * Ee,
                    r[10] = (B * ee - j * R + X * ae) * Ee,
                    r[11] = (P * R - C * ee - F * ae) * Ee,
                    r[12] = (g * be - p * Fe - x * Le) * Ee,
                    r[13] = (n * Fe - s * be + c * Le) * Ee,
                    r[14] = (j * Q - B * Z - G * ae) * Ee,
                    r[15] = (C * Z - P * Q + D * ae) * Ee,
                    r) : null
                }
                ,
                M.aj = ti,
                M.ak = function(r) {
                    return Math.hypot(r[0], r[1])
                }
                ,
                M.al = function(r) {
                    return r[0] = 0,
                    r[1] = 0,
                    r
                }
                ,
                M.am = function(r, t, n) {
                    return r[0] = t[0] * n,
                    r[1] = t[1] * n,
                    r
                }
                ,
                M.an = $h,
                M.ao = Wi,
                M.ap = function(r, t, n, s) {
                    const c = t.y - r.y
                      , d = t.x - r.x
                      , p = s.y - n.y
                      , g = s.x - n.x
                      , x = p * d - g * c;
                    if (x === 0)
                        return null;
                    const b = (g * (r.y - n.y) - p * (r.x - n.x)) / x;
                    return new Te(r.x + b * d,r.y + b * c)
                }
                ,
                M.aq = nf,
                M.ar = wa,
                M.as = Pi,
                M.at = function(r) {
                    let t = 1 / 0
                      , n = 1 / 0
                      , s = -1 / 0
                      , c = -1 / 0;
                    for (const d of r)
                        t = Math.min(t, d.x),
                        n = Math.min(n, d.y),
                        s = Math.max(s, d.x),
                        c = Math.max(c, d.y);
                    return [t, n, s, c]
                }
                ,
                M.au = Ti,
                M.av = or,
                M.aw = function(r, t, n, s, c=!1) {
                    if (!n[0] && !n[1])
                        return [0, 0];
                    const d = c ? s === "map" ? -r.bearingInRadians : 0 : s === "viewport" ? r.bearingInRadians : 0;
                    if (d) {
                        const p = Math.sin(d)
                          , g = Math.cos(d);
                        n = [n[0] * g - n[1] * p, n[0] * p + n[1] * g]
                    }
                    return [c ? n[0] : or(t, n[0], r.zoom), c ? n[1] : or(t, n[1], r.zoom)]
                }
                ,
                M.ay = Gh,
                M.az = Qh,
                M.b = Wn,
                M.b$ = r => r.type === "circle",
                M.b0 = function() {
                    const r = new Float64Array(16);
                    return Pi(r),
                    r
                }
                ,
                M.b1 = function() {
                    return new Float64Array(16)
                }
                ,
                M.b2 = function(r, t, n) {
                    const s = new Float64Array(4);
                    return function(c, d, p, g) {
                        var x = .5 * Math.PI / 180;
                        d *= x,
                        p *= x,
                        g *= x;
                        var b = Math.sin(d)
                          , C = Math.cos(d)
                          , P = Math.sin(p)
                          , D = Math.cos(p)
                          , F = Math.sin(g)
                          , B = Math.cos(g);
                        c[0] = b * D * B - C * P * F,
                        c[1] = C * P * B + b * D * F,
                        c[2] = C * D * F - b * P * B,
                        c[3] = C * D * B + b * P * F
                    }(s, r, t - 90, n),
                    s
                }
                ,
                M.b3 = function(r, t, n, s) {
                    var c, d, p, g, x, b = t[0], C = t[1], P = t[2], D = t[3], F = n[0], B = n[1], j = n[2], G = n[3];
                    return (d = b * F + C * B + P * j + D * G) < 0 && (d = -d,
                    F = -F,
                    B = -B,
                    j = -j,
                    G = -G),
                    1 - d > Mt ? (c = Math.acos(d),
                    p = Math.sin(c),
                    g = Math.sin((1 - s) * c) / p,
                    x = Math.sin(s * c) / p) : (g = 1 - s,
                    x = s),
                    r[0] = g * b + x * F,
                    r[1] = g * C + x * B,
                    r[2] = g * P + x * j,
                    r[3] = g * D + x * G,
                    r
                }
                ,
                M.b4 = function(r) {
                    const t = new Float64Array(9);
                    var n, s, c, d, p, g, x, b, C, P, D, F, B, j, G, X, ae, Q;
                    P = (c = (s = r)[0]) * (x = c + c),
                    D = (d = s[1]) * x,
                    B = (p = s[2]) * x,
                    j = p * (b = d + d),
                    X = (g = s[3]) * x,
                    ae = g * b,
                    Q = g * (C = p + p),
                    (n = t)[0] = 1 - (F = d * b) - (G = p * C),
                    n[3] = D - Q,
                    n[6] = B + ae,
                    n[1] = D + Q,
                    n[4] = 1 - P - G,
                    n[7] = j - X,
                    n[2] = B - ae,
                    n[5] = j + X,
                    n[8] = 1 - P - F;
                    const R = Nr(-Math.asin(si(t[2], -1, 1)));
                    let Z, ee;
                    return Math.hypot(t[5], t[8]) < .001 ? (Z = 0,
                    ee = -Nr(Math.atan2(t[3], t[4]))) : (Z = Nr(t[5] === 0 && t[8] === 0 ? 0 : Math.atan2(t[5], t[8])),
                    ee = Nr(t[1] === 0 && t[0] === 0 ? 0 : Math.atan2(t[1], t[0]))),
                    {
                        roll: Z,
                        pitch: R + 90,
                        bearing: ee
                    }
                }
                ,
                M.b5 = function(r, t) {
                    return r.roll == t.roll && r.pitch == t.pitch && r.bearing == t.bearing
                }
                ,
                M.b6 = yt,
                M.b7 = ms,
                M.b8 = Sa,
                M.b9 = Kl,
                M.bA = function(r) {
                    const t = []
                      , n = r.id;
                    return n === void 0 && t.push({
                        message: `layers.${n}: missing required property "id"`
                    }),
                    r.render === void 0 && t.push({
                        message: `layers.${n}: missing required method "render"`
                    }),
                    r.renderingMode && r.renderingMode !== "2d" && r.renderingMode !== "3d" && t.push({
                        message: `layers.${n}: property "renderingMode" must be either "2d" or "3d"`
                    }),
                    t
                }
                ,
                M.bB = function r(t, n) {
                    if (Array.isArray(t)) {
                        if (!Array.isArray(n) || t.length !== n.length)
                            return !1;
                        for (let s = 0; s < t.length; s++)
                            if (!r(t[s], n[s]))
                                return !1;
                        return !0
                    }
                    if (typeof t == "object" && t !== null && n !== null) {
                        if (typeof n != "object" || Object.keys(t).length !== Object.keys(n).length)
                            return !1;
                        for (const s in t)
                            if (!r(t[s], n[s]))
                                return !1;
                        return !0
                    }
                    return t === n
                }
                ,
                M.bC = Xi,
                M.bD = en,
                M.bE = class extends kr {
                    constructor(r, t) {
                        super(r, t),
                        this.current = 0
                    }
                    set(r) {
                        this.current !== r && (this.current = r,
                        this.gl.uniform1i(this.location, r))
                    }
                }
                ,
                M.bF = gs,
                M.bG = class extends kr {
                    constructor(r, t) {
                        super(r, t),
                        this.current = Lr
                    }
                    set(r) {
                        if (r[12] !== this.current[12] || r[0] !== this.current[0])
                            return this.current = r,
                            void this.gl.uniformMatrix4fv(this.location, !1, r);
                        for (let t = 1; t < 16; t++)
                            if (r[t] !== this.current[t]) {
                                this.current = r,
                                this.gl.uniformMatrix4fv(this.location, !1, r);
                                break
                            }
                    }
                }
                ,
                M.bH = To,
                M.bI = class extends kr {
                    constructor(r, t) {
                        super(r, t),
                        this.current = [0, 0, 0]
                    }
                    set(r) {
                        r[0] === this.current[0] && r[1] === this.current[1] && r[2] === this.current[2] || (this.current = r,
                        this.gl.uniform3f(this.location, r[0], r[1], r[2]))
                    }
                }
                ,
                M.bJ = class extends kr {
                    constructor(r, t) {
                        super(r, t),
                        this.current = [0, 0]
                    }
                    set(r) {
                        r[0] === this.current[0] && r[1] === this.current[1] || (this.current = r,
                        this.gl.uniform2f(this.location, r[0], r[1]))
                    }
                }
                ,
                M.bK = It,
                M.bL = function(r, t) {
                    var n = Math.sin(t)
                      , s = Math.cos(t);
                    return r[0] = s,
                    r[1] = n,
                    r[2] = 0,
                    r[3] = -n,
                    r[4] = s,
                    r[5] = 0,
                    r[6] = 0,
                    r[7] = 0,
                    r[8] = 1,
                    r
                }
                ,
                M.bM = function(r, t, n) {
                    var s = t[0]
                      , c = t[1]
                      , d = t[2];
                    return r[0] = s * n[0] + c * n[3] + d * n[6],
                    r[1] = s * n[1] + c * n[4] + d * n[7],
                    r[2] = s * n[2] + c * n[5] + d * n[8],
                    r
                }
                ,
                M.bN = function(r, t, n, s, c, d, p) {
                    var g = 1 / (t - n)
                      , x = 1 / (s - c)
                      , b = 1 / (d - p);
                    return r[0] = -2 * g,
                    r[1] = 0,
                    r[2] = 0,
                    r[3] = 0,
                    r[4] = 0,
                    r[5] = -2 * x,
                    r[6] = 0,
                    r[7] = 0,
                    r[8] = 0,
                    r[9] = 0,
                    r[10] = 2 * b,
                    r[11] = 0,
                    r[12] = (t + n) * g,
                    r[13] = (c + s) * x,
                    r[14] = (p + d) * b,
                    r[15] = 1,
                    r
                }
                ,
                M.bO = class extends _a {
                }
                ,
                M.bP = Ag,
                M.bQ = class extends ya {
                }
                ,
                M.bR = Ch,
                M.bS = function(r) {
                    return r <= 1 ? 1 : Math.pow(2, Math.ceil(Math.log(r) / Math.LN2))
                }
                ,
                M.bT = Yd,
                M.bU = function(r, t, n) {
                    var s = t[0]
                      , c = t[1]
                      , d = t[2]
                      , p = n[3] * s + n[7] * c + n[11] * d + n[15];
                    return r[0] = (n[0] * s + n[4] * c + n[8] * d + n[12]) / (p = p || 1),
                    r[1] = (n[1] * s + n[5] * c + n[9] * d + n[13]) / p,
                    r[2] = (n[2] * s + n[6] * c + n[10] * d + n[14]) / p,
                    r
                }
                ,
                M.bV = class extends Ol {
                }
                ,
                M.bW = class extends o {
                }
                ,
                M.bX = function(r, t) {
                    return r[0] === t[0] && r[1] === t[1] && r[2] === t[2] && r[3] === t[3] && r[4] === t[4] && r[5] === t[5] && r[6] === t[6] && r[7] === t[7] && r[8] === t[8] && r[9] === t[9] && r[10] === t[10] && r[11] === t[11] && r[12] === t[12] && r[13] === t[13] && r[14] === t[14] && r[15] === t[15]
                }
                ,
                M.bY = function(r, t) {
                    var n = r[0]
                      , s = r[1]
                      , c = r[2]
                      , d = r[3]
                      , p = r[4]
                      , g = r[5]
                      , x = r[6]
                      , b = r[7]
                      , C = r[8]
                      , P = r[9]
                      , D = r[10]
                      , F = r[11]
                      , B = r[12]
                      , j = r[13]
                      , G = r[14]
                      , X = r[15]
                      , ae = t[0]
                      , Q = t[1]
                      , R = t[2]
                      , Z = t[3]
                      , ee = t[4]
                      , ye = t[5]
                      , Le = t[6]
                      , be = t[7]
                      , Me = t[8]
                      , Fe = t[9]
                      , Re = t[10]
                      , Be = t[11]
                      , Ee = t[12]
                      , Ue = t[13]
                      , Qe = t[14]
                      , Ye = t[15];
                    return Math.abs(n - ae) <= Mt * Math.max(1, Math.abs(n), Math.abs(ae)) && Math.abs(s - Q) <= Mt * Math.max(1, Math.abs(s), Math.abs(Q)) && Math.abs(c - R) <= Mt * Math.max(1, Math.abs(c), Math.abs(R)) && Math.abs(d - Z) <= Mt * Math.max(1, Math.abs(d), Math.abs(Z)) && Math.abs(p - ee) <= Mt * Math.max(1, Math.abs(p), Math.abs(ee)) && Math.abs(g - ye) <= Mt * Math.max(1, Math.abs(g), Math.abs(ye)) && Math.abs(x - Le) <= Mt * Math.max(1, Math.abs(x), Math.abs(Le)) && Math.abs(b - be) <= Mt * Math.max(1, Math.abs(b), Math.abs(be)) && Math.abs(C - Me) <= Mt * Math.max(1, Math.abs(C), Math.abs(Me)) && Math.abs(P - Fe) <= Mt * Math.max(1, Math.abs(P), Math.abs(Fe)) && Math.abs(D - Re) <= Mt * Math.max(1, Math.abs(D), Math.abs(Re)) && Math.abs(F - Be) <= Mt * Math.max(1, Math.abs(F), Math.abs(Be)) && Math.abs(B - Ee) <= Mt * Math.max(1, Math.abs(B), Math.abs(Ee)) && Math.abs(j - Ue) <= Mt * Math.max(1, Math.abs(j), Math.abs(Ue)) && Math.abs(G - Qe) <= Mt * Math.max(1, Math.abs(G), Math.abs(Qe)) && Math.abs(X - Ye) <= Mt * Math.max(1, Math.abs(X), Math.abs(Ye))
                }
                ,
                M.bZ = function(r, t) {
                    return r[0] = t[0],
                    r[1] = t[1],
                    r[2] = t[2],
                    r[3] = t[3],
                    r[4] = t[4],
                    r[5] = t[5],
                    r[6] = t[6],
                    r[7] = t[7],
                    r[8] = t[8],
                    r[9] = t[9],
                    r[10] = t[10],
                    r[11] = t[11],
                    r[12] = t[12],
                    r[13] = t[13],
                    r[14] = t[14],
                    r[15] = t[15],
                    r
                }
                ,
                M.b_ = r => r.type === "symbol",
                M.ba = Pa,
                M.bb = mi,
                M.bc = wr,
                M.bd = er,
                M.be = function(r, t, n, s, c) {
                    return mi(s, c, si((r - t) / (n - t), 0, 1))
                }
                ,
                M.bf = ar,
                M.bg = function() {
                    return new Float64Array(4)
                }
                ,
                M.bh = function() {
                    return new Float64Array(3)
                }
                ,
                M.bi = function(r, t, n, s) {
                    var c = []
                      , d = [];
                    return c[0] = t[0] - n[0],
                    c[1] = t[1] - n[1],
                    c[2] = t[2] - n[2],
                    d[0] = c[0] * Math.cos(s) - c[1] * Math.sin(s),
                    d[1] = c[0] * Math.sin(s) + c[1] * Math.cos(s),
                    d[2] = c[2],
                    r[0] = d[0] + n[0],
                    r[1] = d[1] + n[1],
                    r[2] = d[2] + n[2],
                    r
                }
                ,
                M.bj = function(r, t, n, s) {
                    var c = []
                      , d = [];
                    return c[0] = t[0] - n[0],
                    c[1] = t[1] - n[1],
                    c[2] = t[2] - n[2],
                    d[0] = c[0],
                    d[1] = c[1] * Math.cos(s) - c[2] * Math.sin(s),
                    d[2] = c[1] * Math.sin(s) + c[2] * Math.cos(s),
                    r[0] = d[0] + n[0],
                    r[1] = d[1] + n[1],
                    r[2] = d[2] + n[2],
                    r
                }
                ,
                M.bk = function(r, t, n, s) {
                    var c = []
                      , d = [];
                    return c[0] = t[0] - n[0],
                    c[1] = t[1] - n[1],
                    c[2] = t[2] - n[2],
                    d[0] = c[2] * Math.sin(s) + c[0] * Math.cos(s),
                    d[1] = c[1],
                    d[2] = c[2] * Math.cos(s) - c[0] * Math.sin(s),
                    r[0] = d[0] + n[0],
                    r[1] = d[1] + n[1],
                    r[2] = d[2] + n[2],
                    r
                }
                ,
                M.bl = function(r, t, n) {
                    var s = Math.sin(n)
                      , c = Math.cos(n)
                      , d = t[0]
                      , p = t[1]
                      , g = t[2]
                      , x = t[3]
                      , b = t[8]
                      , C = t[9]
                      , P = t[10]
                      , D = t[11];
                    return t !== r && (r[4] = t[4],
                    r[5] = t[5],
                    r[6] = t[6],
                    r[7] = t[7],
                    r[12] = t[12],
                    r[13] = t[13],
                    r[14] = t[14],
                    r[15] = t[15]),
                    r[0] = d * c - b * s,
                    r[1] = p * c - C * s,
                    r[2] = g * c - P * s,
                    r[3] = x * c - D * s,
                    r[8] = d * s + b * c,
                    r[9] = p * s + C * c,
                    r[10] = g * s + P * c,
                    r[11] = x * s + D * c,
                    r
                }
                ,
                M.bm = function(r, t) {
                    const n = ar(r, 360)
                      , s = ar(t, 360)
                      , c = s - n
                      , d = s > n ? c - 360 : c + 360;
                    return Math.abs(c) < Math.abs(d) ? c : d
                }
                ,
                M.bn = function(r) {
                    return r[0] = 0,
                    r[1] = 0,
                    r[2] = 0,
                    r
                }
                ,
                M.bo = function(r, t, n, s) {
                    const c = Math.sqrt(r * r + t * t)
                      , d = Math.sqrt(n * n + s * s);
                    r /= c,
                    t /= c,
                    n /= d,
                    s /= d;
                    const p = Math.acos(r * n + t * s);
                    return -t * n + r * s > 0 ? p : -p
                }
                ,
                M.bp = function(r, t) {
                    return r[0] * t[0] + r[1] * t[1] + r[2] * t[2] + r[3]
                }
                ,
                M.bq = Xh,
                M.br = function(r, t) {
                    const n = ar(r, 2 * Math.PI)
                      , s = ar(t, 2 * Math.PI);
                    return Math.min(Math.abs(n - s), Math.abs(n - s + 2 * Math.PI), Math.abs(n - s - 2 * Math.PI))
                }
                ,
                M.bs = function(r) {
                    return Math.hypot(r[0], r[1], r[2])
                }
                ,
                M.bt = function() {
                    const r = {}
                      , t = E.$version;
                    for (const n in E.$root) {
                        const s = E.$root[n];
                        if (s.required) {
                            let c = null;
                            c = n === "version" ? t : s.type === "array" ? [] : {},
                            c != null && (r[n] = c)
                        }
                    }
                    return r
                }
                ,
                M.bu = la,
                M.bv = gn,
                M.bw = function(r) {
                    r = r.slice();
                    const t = Object.create(null);
                    for (let n = 0; n < r.length; n++)
                        t[r[n].id] = r[n];
                    for (let n = 0; n < r.length; n++)
                        "ref"in r[n] && (r[n] = $(r[n], t[r[n].ref]));
                    return r
                }
                ,
                M.bx = function(r) {
                    if (r.type === "custom")
                        return new Qg(r);
                    switch (r.type) {
                    case "background":
                        return new Kg(r);
                    case "circle":
                        return new $m(r);
                    case "fill":
                        return new ug(r);
                    case "fill-extrusion":
                        return new yg(r);
                    case "heatmap":
                        return new Hm(r);
                    case "hillshade":
                        return new Xm(r);
                    case "line":
                        return new Pg(r);
                    case "raster":
                        return new Yg(r);
                    case "symbol":
                        return new Mu(r)
                    }
                }
                ,
                M.by = Vi,
                M.bz = function(r, t) {
                    if (!r)
                        return [{
                            command: "setStyle",
                            args: [t]
                        }];
                    let n = [];
                    try {
                        if (!K(r.version, t.version))
                            return [{
                                command: "setStyle",
                                args: [t]
                            }];
                        K(r.center, t.center) || n.push({
                            command: "setCenter",
                            args: [t.center]
                        }),
                        K(r.centerAltitude, t.centerAltitude) || n.push({
                            command: "setCenterAltitude",
                            args: [t.centerAltitude]
                        }),
                        K(r.zoom, t.zoom) || n.push({
                            command: "setZoom",
                            args: [t.zoom]
                        }),
                        K(r.bearing, t.bearing) || n.push({
                            command: "setBearing",
                            args: [t.bearing]
                        }),
                        K(r.pitch, t.pitch) || n.push({
                            command: "setPitch",
                            args: [t.pitch]
                        }),
                        K(r.roll, t.roll) || n.push({
                            command: "setRoll",
                            args: [t.roll]
                        }),
                        K(r.sprite, t.sprite) || n.push({
                            command: "setSprite",
                            args: [t.sprite]
                        }),
                        K(r.glyphs, t.glyphs) || n.push({
                            command: "setGlyphs",
                            args: [t.glyphs]
                        }),
                        K(r.transition, t.transition) || n.push({
                            command: "setTransition",
                            args: [t.transition]
                        }),
                        K(r.light, t.light) || n.push({
                            command: "setLight",
                            args: [t.light]
                        }),
                        K(r.terrain, t.terrain) || n.push({
                            command: "setTerrain",
                            args: [t.terrain]
                        }),
                        K(r.sky, t.sky) || n.push({
                            command: "setSky",
                            args: [t.sky]
                        }),
                        K(r.projection, t.projection) || n.push({
                            command: "setProjection",
                            args: [t.projection]
                        });
                        const s = {}
                          , c = [];
                        (function(p, g, x, b) {
                            let C;
                            for (C in g = g || {},
                            p = p || {})
                                Object.prototype.hasOwnProperty.call(p, C) && (Object.prototype.hasOwnProperty.call(g, C) || ve(C, x, b));
                            for (C in g)
                                Object.prototype.hasOwnProperty.call(g, C) && (Object.prototype.hasOwnProperty.call(p, C) ? K(p[C], g[C]) || (p[C].type === "geojson" && g[C].type === "geojson" && Se(p, g, C) ? re(x, {
                                    command: "setGeoJSONSourceData",
                                    args: [C, g[C].data]
                                }) : ue(C, g, x, b)) : he(C, g, x))
                        }
                        )(r.sources, t.sources, c, s);
                        const d = [];
                        r.layers && r.layers.forEach(p => {
                            "source"in p && s[p.source] ? n.push({
                                command: "removeLayer",
                                args: [p.id]
                            }) : d.push(p)
                        }
                        ),
                        n = n.concat(c),
                        function(p, g, x) {
                            g = g || [];
                            const b = (p = p || []).map(fe)
                              , C = g.map(fe)
                              , P = p.reduce(ke, {})
                              , D = g.reduce(ke, {})
                              , F = b.slice()
                              , B = Object.create(null);
                            let j, G, X, ae, Q;
                            for (let R = 0, Z = 0; R < b.length; R++)
                                j = b[R],
                                Object.prototype.hasOwnProperty.call(D, j) ? Z++ : (re(x, {
                                    command: "removeLayer",
                                    args: [j]
                                }),
                                F.splice(F.indexOf(j, Z), 1));
                            for (let R = 0, Z = 0; R < C.length; R++)
                                j = C[C.length - 1 - R],
                                F[F.length - 1 - R] !== j && (Object.prototype.hasOwnProperty.call(P, j) ? (re(x, {
                                    command: "removeLayer",
                                    args: [j]
                                }),
                                F.splice(F.lastIndexOf(j, F.length - Z), 1)) : Z++,
                                ae = F[F.length - R],
                                re(x, {
                                    command: "addLayer",
                                    args: [D[j], ae]
                                }),
                                F.splice(F.length - R, 0, j),
                                B[j] = !0);
                            for (let R = 0; R < C.length; R++)
                                if (j = C[R],
                                G = P[j],
                                X = D[j],
                                !B[j] && !K(G, X))
                                    if (K(G.source, X.source) && K(G["source-layer"], X["source-layer"]) && K(G.type, X.type)) {
                                        for (Q in we(G.layout, X.layout, x, j, null, "setLayoutProperty"),
                                        we(G.paint, X.paint, x, j, null, "setPaintProperty"),
                                        K(G.filter, X.filter) || re(x, {
                                            command: "setFilter",
                                            args: [j, X.filter]
                                        }),
                                        K(G.minzoom, X.minzoom) && K(G.maxzoom, X.maxzoom) || re(x, {
                                            command: "setLayerZoomRange",
                                            args: [j, X.minzoom, X.maxzoom]
                                        }),
                                        G)
                                            Object.prototype.hasOwnProperty.call(G, Q) && Q !== "layout" && Q !== "paint" && Q !== "filter" && Q !== "metadata" && Q !== "minzoom" && Q !== "maxzoom" && (Q.indexOf("paint.") === 0 ? we(G[Q], X[Q], x, j, Q.slice(6), "setPaintProperty") : K(G[Q], X[Q]) || re(x, {
                                                command: "setLayerProperty",
                                                args: [j, Q, X[Q]]
                                            }));
                                        for (Q in X)
                                            Object.prototype.hasOwnProperty.call(X, Q) && !Object.prototype.hasOwnProperty.call(G, Q) && Q !== "layout" && Q !== "paint" && Q !== "filter" && Q !== "metadata" && Q !== "minzoom" && Q !== "maxzoom" && (Q.indexOf("paint.") === 0 ? we(G[Q], X[Q], x, j, Q.slice(6), "setPaintProperty") : K(G[Q], X[Q]) || re(x, {
                                                command: "setLayerProperty",
                                                args: [j, Q, X[Q]]
                                            }))
                                    } else
                                        re(x, {
                                            command: "removeLayer",
                                            args: [j]
                                        }),
                                        ae = F[F.lastIndexOf(j) + 1],
                                        re(x, {
                                            command: "addLayer",
                                            args: [X, ae]
                                        })
                        }(d, t.layers, n)
                    } catch (s) {
                        console.warn("Unable to compute style diff:", s),
                        n = [{
                            command: "setStyle",
                            args: [t]
                        }]
                    }
                    return n
                }
                ,
                M.c = Kn,
                M.c0 = r => r.type === "heatmap",
                M.c1 = r => r.type === "line",
                M.c2 = r => r.type === "fill",
                M.c3 = r => r.type === "fill-extrusion",
                M.c4 = r => r.type === "hillshade",
                M.c5 = r => r.type === "raster",
                M.c6 = r => r.type === "background",
                M.c7 = r => r.type === "custom",
                M.c8 = Br,
                M.c9 = function(r, t, n) {
                    const s = fi(t.x - n.x, t.y - n.y)
                      , c = fi(r.x - n.x, r.y - n.y);
                    var d, p;
                    return Nr(Math.atan2(s[0] * c[1] - s[1] * c[0], (d = s)[0] * (p = c)[0] + d[1] * p[1]))
                }
                ,
                M.cA = ze,
                M.cB = mp,
                M.cC = Sp,
                M.cD = cs,
                M.cE = Vn,
                M.ca = gi,
                M.cb = function(r, t, n) {
                    var s = t[0]
                      , c = t[1];
                    return r[0] = n[0] * s + n[4] * c + n[12],
                    r[1] = n[1] * s + n[5] * c + n[13],
                    r
                }
                ,
                M.cc = function(r, t) {
                    const {x: n, y: s} = nc.fromLngLat(t);
                    return !(r < 0 || r > 25 || s < 0 || s >= 1 || n < 0 || n >= 1)
                }
                ,
                M.cd = function(r, t) {
                    return r[0] = t[0],
                    r[1] = 0,
                    r[2] = 0,
                    r[3] = 0,
                    r[4] = 0,
                    r[5] = t[1],
                    r[6] = 0,
                    r[7] = 0,
                    r[8] = 0,
                    r[9] = 0,
                    r[10] = t[2],
                    r[11] = 0,
                    r[12] = 0,
                    r[13] = 0,
                    r[14] = 0,
                    r[15] = 1,
                    r
                }
                ,
                M.ce = class extends fa {
                }
                ,
                M.cf = u_,
                M.ch = function(r) {
                    return r.message === ws
                }
                ,
                M.ci = mn,
                M.cj = function(r, t) {
                    Jn.REGISTERED_PROTOCOLS[r] = t
                }
                ,
                M.ck = function(r) {
                    delete Jn.REGISTERED_PROTOCOLS[r]
                }
                ,
                M.cl = function(r, t) {
                    const n = {};
                    for (let c = 0; c < r.length; c++) {
                        const d = t && t[r[c].id] || bl(r[c]);
                        t && (t[r[c].id] = d);
                        let p = n[d];
                        p || (p = n[d] = []),
                        p.push(r[c])
                    }
                    const s = [];
                    for (const c in n)
                        s.push(n[c]);
                    return s
                }
                ,
                M.cm = Ve,
                M.cn = Yp,
                M.co = ef,
                M.cp = Ep,
                M.cq = function(r) {
                    r.bucket.createArrays(),
                    r.bucket.tilePixelRatio = ut / (512 * r.bucket.overscaling),
                    r.bucket.compareText = {},
                    r.bucket.iconsNeedLinear = !1;
                    const t = r.bucket.layers[0]
                      , n = t.layout
                      , s = t._unevaluatedLayout._values
                      , c = {
                        layoutIconSize: s["icon-size"].possiblyEvaluate(new Ut(r.bucket.zoom + 1), r.canonical),
                        layoutTextSize: s["text-size"].possiblyEvaluate(new Ut(r.bucket.zoom + 1), r.canonical),
                        textMaxSize: s["text-size"].possiblyEvaluate(new Ut(18))
                    };
                    if (r.bucket.textSizeData.kind === "composite") {
                        const {minZoom: b, maxZoom: C} = r.bucket.textSizeData;
                        c.compositeTextSizes = [s["text-size"].possiblyEvaluate(new Ut(b), r.canonical), s["text-size"].possiblyEvaluate(new Ut(C), r.canonical)]
                    }
                    if (r.bucket.iconSizeData.kind === "composite") {
                        const {minZoom: b, maxZoom: C} = r.bucket.iconSizeData;
                        c.compositeIconSizes = [s["icon-size"].possiblyEvaluate(new Ut(b), r.canonical), s["icon-size"].possiblyEvaluate(new Ut(C), r.canonical)]
                    }
                    const d = n.get("text-line-height") * Ti
                      , p = n.get("text-rotation-alignment") !== "viewport" && n.get("symbol-placement") !== "point"
                      , g = n.get("text-keep-upright")
                      , x = n.get("text-size");
                    for (const b of r.bucket.features) {
                        const C = n.get("text-font").evaluate(b, {}, r.canonical).join(",")
                          , P = x.evaluate(b, {}, r.canonical)
                          , D = c.layoutTextSize.evaluate(b, {}, r.canonical)
                          , F = c.layoutIconSize.evaluate(b, {}, r.canonical)
                          , B = {
                            horizontal: {},
                            vertical: void 0
                        }
                          , j = b.text;
                        let G, X = [0, 0];
                        if (j) {
                            const R = j.toString()
                              , Z = n.get("text-letter-spacing").evaluate(b, {}, r.canonical) * Ti
                              , ee = ru(R) ? Z : 0
                              , ye = n.get("text-anchor").evaluate(b, {}, r.canonical)
                              , Le = pf(t, b, r.canonical);
                            if (!Le) {
                                const Re = n.get("text-radial-offset").evaluate(b, {}, r.canonical);
                                X = Re ? df(ye, [Re * Ti, Yh]) : n.get("text-offset").evaluate(b, {}, r.canonical).map(Be => Be * Ti)
                            }
                            let be = p ? "center" : n.get("text-justify").evaluate(b, {}, r.canonical);
                            const Me = n.get("symbol-placement") === "point" ? n.get("text-max-width").evaluate(b, {}, r.canonical) * Ti : 1 / 0
                              , Fe = () => {
                                r.bucket.allowVerticalPlacement && ca(R) && (B.vertical = bu(j, r.glyphMap, r.glyphPositions, r.imagePositions, C, Me, d, ye, "left", ee, X, M.ag.vertical, !0, D, P))
                            }
                            ;
                            if (!p && Le) {
                                const Re = new Set;
                                if (be === "auto")
                                    for (let Ee = 0; Ee < Le.values.length; Ee += 2)
                                        Re.add(Qh(Le.values[Ee]));
                                else
                                    Re.add(be);
                                let Be = !1;
                                for (const Ee of Re)
                                    if (!B.horizontal[Ee])
                                        if (Be)
                                            B.horizontal[Ee] = B.horizontal[0];
                                        else {
                                            const Ue = bu(j, r.glyphMap, r.glyphPositions, r.imagePositions, C, Me, d, "center", Ee, ee, X, M.ag.horizontal, !1, D, P);
                                            Ue && (B.horizontal[Ee] = Ue,
                                            Be = Ue.positionedLines.length === 1)
                                        }
                                Fe()
                            } else {
                                be === "auto" && (be = Qh(ye));
                                const Re = bu(j, r.glyphMap, r.glyphPositions, r.imagePositions, C, Me, d, ye, be, ee, X, M.ag.horizontal, !1, D, P);
                                Re && (B.horizontal[be] = Re),
                                Fe(),
                                ca(R) && p && g && (B.vertical = bu(j, r.glyphMap, r.glyphPositions, r.imagePositions, C, Me, d, ye, be, ee, X, M.ag.vertical, !1, D, P))
                            }
                        }
                        let ae = !1;
                        if (b.icon && b.icon.name) {
                            const R = r.imageMap[b.icon.name];
                            R && (G = $g(r.imagePositions[b.icon.name], n.get("icon-offset").evaluate(b, {}, r.canonical), n.get("icon-anchor").evaluate(b, {}, r.canonical)),
                            ae = !!R.sdf,
                            r.bucket.sdfIcons === void 0 ? r.bucket.sdfIcons = ae : r.bucket.sdfIcons !== ae && yi("Style sheet warning: Cannot mix SDF and non-SDF icons in one buffer"),
                            (R.pixelRatio !== r.bucket.pixelRatio || n.get("icon-rotate").constantOr(1) !== 0) && (r.bucket.iconsNeedLinear = !0))
                        }
                        const Q = mf(B.horizontal) || B.vertical;
                        r.bucket.iconsInText = !!Q && Q.iconsInText,
                        (Q || G) && l_(r.bucket, b, B, G, r.imageMap, c, D, F, X, ae, r.canonical, r.subdivisionGranularity)
                    }
                    r.showCollisionBoxes && r.bucket.generateCollisionDebugBuffers()
                }
                ,
                M.cr = Fh,
                M.cs = Ah,
                M.ct = Rh,
                M.cu = Yl,
                M.cv = Nh,
                M.cw = class {
                    constructor(r) {
                        this._marks = {
                            start: [r.url, "start"].join("#"),
                            end: [r.url, "end"].join("#"),
                            measure: r.url.toString()
                        },
                        performance.mark(this._marks.start)
                    }
                    finish() {
                        performance.mark(this._marks.end);
                        let r = performance.getEntriesByName(this._marks.measure);
                        return r.length === 0 && (performance.measure(this._marks.measure, this._marks.start, this._marks.end),
                        r = performance.getEntriesByName(this._marks.measure),
                        performance.clearMarks(this._marks.start),
                        performance.clearMarks(this._marks.end),
                        performance.clearMeasures(this._marks.measure)),
                        r
                    }
                }
                ,
                M.cx = function(r, t, n, s, c) {
                    return l(this, void 0, void 0, function*() {
                        if (Wt())
                            try {
                                return yield Or(r, t, n, s, c)
                            } catch {}
                        return function(d, p, g, x, b) {
                            const C = d.width
                              , P = d.height;
                            zn && kn || (zn = new OffscreenCanvas(C,P),
                            kn = zn.getContext("2d", {
                                willReadFrequently: !0
                            })),
                            zn.width = C,
                            zn.height = P,
                            kn.drawImage(d, 0, 0, C, P);
                            const D = kn.getImageData(p, g, x, b);
                            return kn.clearRect(0, 0, C, P),
                            D.data
                        }(r, t, n, s, c)
                    })
                }
                ,
                M.cy = Jp,
                M.cz = ce,
                M.d = Dn,
                M.e = Ft,
                M.f = r => l(void 0, void 0, void 0, function*() {
                    if (r.byteLength === 0)
                        return createImageBitmap(new ImageData(1,1));
                    const t = new Blob([new Uint8Array(r)],{
                        type: "image/png"
                    });
                    try {
                        return createImageBitmap(t)
                    } catch (n) {
                        throw new Error(`Could not load image because of ${n.message}. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported.`)
                    }
                }),
                M.g = Ts,
                M.h = r => new Promise( (t, n) => {
                    const s = new Image;
                    s.onload = () => {
                        t(s),
                        URL.revokeObjectURL(s.src),
                        s.onload = null,
                        window.requestAnimationFrame( () => {
                            s.src = Xn
                        }
                        )
                    }
                    ,
                    s.onerror = () => n(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."));
                    const c = new Blob([new Uint8Array(r)],{
                        type: "image/png"
                    });
                    s.src = r.byteLength ? URL.createObjectURL(c) : Xn
                }
                ),
                M.i = Tr,
                M.j = (r, t) => Ln(Ft(r, {
                    type: "json"
                }), t),
                M.k = _n,
                M.l = to,
                M.m = Ln,
                M.n = (r, t) => Ln(Ft(r, {
                    type: "arrayBuffer"
                }), t),
                M.o = function(r) {
                    return new Nh(r).readFields(Lg, [])
                }
                ,
                M.p = Ip,
                M.q = $l,
                M.r = rr,
                M.s = tn,
                M.t = go,
                M.u = ct,
                M.v = E,
                M.w = yi,
                M.x = aa,
                M.y = Vs,
                M.z = function([r,t,n]) {
                    return t += 90,
                    t *= Math.PI / 180,
                    n *= Math.PI / 180,
                    {
                        x: r * Math.cos(t) * Math.sin(n),
                        y: r * Math.sin(t) * Math.sin(n),
                        z: r * Math.cos(n)
                    }
                }
            }),
            z("worker", ["./shared"], function(M) {
                class l {
                    constructor(E) {
                        this.keyCache = {},
                        E && this.replace(E)
                    }
                    replace(E) {
                        this._layerConfigs = {},
                        this._layers = {},
                        this.update(E, [])
                    }
                    update(E, U) {
                        for (const K of E) {
                            this._layerConfigs[K.id] = K;
                            const re = this._layers[K.id] = M.bx(K);
                            re._featureFilter = M.a6(re.filter),
                            this.keyCache[K.id] && delete this.keyCache[K.id]
                        }
                        for (const K of U)
                            delete this.keyCache[K],
                            delete this._layerConfigs[K],
                            delete this._layers[K];
                        this.familiesBySource = {};
                        const $ = M.cl(Object.values(this._layerConfigs), this.keyCache);
                        for (const K of $) {
                            const re = K.map(fe => this._layers[fe.id])
                              , he = re[0];
                            if (he.visibility === "none")
                                continue;
                            const ve = he.source || "";
                            let ue = this.familiesBySource[ve];
                            ue || (ue = this.familiesBySource[ve] = {});
                            const Se = he.sourceLayer || "_geojsonTileLayer";
                            let we = ue[Se];
                            we || (we = ue[Se] = []),
                            we.push(re)
                        }
                    }
                }
                class ce {
                    constructor(E) {
                        const U = {}
                          , $ = [];
                        for (const ve in E) {
                            const ue = E[ve]
                              , Se = U[ve] = {};
                            for (const we in ue) {
                                const fe = ue[+we];
                                if (!fe || fe.bitmap.width === 0 || fe.bitmap.height === 0)
                                    continue;
                                const ke = {
                                    x: 0,
                                    y: 0,
                                    w: fe.bitmap.width + 2,
                                    h: fe.bitmap.height + 2
                                };
                                $.push(ke),
                                Se[we] = {
                                    rect: ke,
                                    metrics: fe.metrics
                                }
                            }
                        }
                        const {w: K, h: re} = M.p($)
                          , he = new M.q({
                            width: K || 1,
                            height: re || 1
                        });
                        for (const ve in E) {
                            const ue = E[ve];
                            for (const Se in ue) {
                                const we = ue[+Se];
                                if (!we || we.bitmap.width === 0 || we.bitmap.height === 0)
                                    continue;
                                const fe = U[ve][Se].rect;
                                M.q.copy(we.bitmap, he, {
                                    x: 0,
                                    y: 0
                                }, {
                                    x: fe.x + 1,
                                    y: fe.y + 1
                                }, we.bitmap)
                            }
                        }
                        this.image = he,
                        this.positions = U
                    }
                }
                M.cm("GlyphAtlas", ce);
                class de {
                    constructor(E) {
                        this.tileID = new M.Y(E.tileID.overscaledZ,E.tileID.wrap,E.tileID.canonical.z,E.tileID.canonical.x,E.tileID.canonical.y),
                        this.uid = E.uid,
                        this.zoom = E.zoom,
                        this.pixelRatio = E.pixelRatio,
                        this.tileSize = E.tileSize,
                        this.source = E.source,
                        this.overscaling = this.tileID.overscaleFactor(),
                        this.showCollisionBoxes = E.showCollisionBoxes,
                        this.collectResourceTiming = !!E.collectResourceTiming,
                        this.returnDependencies = !!E.returnDependencies,
                        this.promoteId = E.promoteId,
                        this.inFlightDependencies = []
                    }
                    parse(E, U, $, K, re) {
                        return M._(this, void 0, void 0, function*() {
                            this.status = "parsing",
                            this.data = E,
                            this.collisionBoxArray = new M.a4;
                            const he = new M.cn(Object.keys(E.layers).sort())
                              , ve = new M.co(this.tileID,this.promoteId);
                            ve.bucketLayerIDs = [];
                            const ue = {}
                              , Se = {
                                featureIndex: ve,
                                iconDependencies: {},
                                patternDependencies: {},
                                glyphDependencies: {},
                                availableImages: $,
                                subdivisionGranularity: re
                            }
                              , we = U.familiesBySource[this.source];
                            for (const it in we) {
                                const lt = E.layers[it];
                                if (!lt)
                                    continue;
                                lt.version === 1 && M.w(`Vector tile source "${this.source}" layer "${it}" does not use vector tile spec v2 and therefore may have some rendering errors.`);
                                const Je = he.encode(it)
                                  , Qn = [];
                                for (let ui = 0; ui < lt.length; ui++) {
                                    const xi = lt.feature(ui)
                                      , Bt = ve.getId(xi, it);
                                    Qn.push({
                                        feature: xi,
                                        id: Bt,
                                        index: ui,
                                        sourceLayerIndex: Je
                                    })
                                }
                                for (const ui of we[it]) {
                                    const xi = ui[0];
                                    xi.source !== this.source && M.w(`layer.source = ${xi.source} does not equal this.source = ${this.source}`),
                                    xi.minzoom && this.zoom < Math.floor(xi.minzoom) || xi.maxzoom && this.zoom >= xi.maxzoom || xi.visibility !== "none" && (ge(ui, this.zoom, $),
                                    (ue[xi.id] = xi.createBucket({
                                        index: ve.bucketLayerIDs.length,
                                        layers: ui,
                                        zoom: this.zoom,
                                        pixelRatio: this.pixelRatio,
                                        overscaling: this.overscaling,
                                        collisionBoxArray: this.collisionBoxArray,
                                        sourceLayerIndex: Je,
                                        sourceID: this.source
                                    })).populate(Qn, Se, this.tileID.canonical),
                                    ve.bucketLayerIDs.push(ui.map(Bt => Bt.id)))
                                }
                            }
                            const fe = M.bC(Se.glyphDependencies, it => Object.keys(it).map(Number));
                            this.inFlightDependencies.forEach(it => it?.abort()),
                            this.inFlightDependencies = [];
                            let ke = Promise.resolve({});
                            if (Object.keys(fe).length) {
                                const it = new AbortController;
                                this.inFlightDependencies.push(it),
                                ke = K.sendAsync({
                                    type: "GG",
                                    data: {
                                        stacks: fe,
                                        source: this.source,
                                        tileID: this.tileID,
                                        type: "glyphs"
                                    }
                                }, it)
                            }
                            const me = Object.keys(Se.iconDependencies);
                            let je = Promise.resolve({});
                            if (me.length) {
                                const it = new AbortController;
                                this.inFlightDependencies.push(it),
                                je = K.sendAsync({
                                    type: "GI",
                                    data: {
                                        icons: me,
                                        source: this.source,
                                        tileID: this.tileID,
                                        type: "icons"
                                    }
                                }, it)
                            }
                            const We = Object.keys(Se.patternDependencies);
                            let st = Promise.resolve({});
                            if (We.length) {
                                const it = new AbortController;
                                this.inFlightDependencies.push(it),
                                st = K.sendAsync({
                                    type: "GI",
                                    data: {
                                        icons: We,
                                        source: this.source,
                                        tileID: this.tileID,
                                        type: "patterns"
                                    }
                                }, it)
                            }
                            const [tt,Ae,Ge] = yield Promise.all([ke, je, st])
                              , Ze = new ce(tt)
                              , at = new M.cp(Ae,Ge);
                            for (const it in ue) {
                                const lt = ue[it];
                                lt instanceof M.a5 ? (ge(lt.layers, this.zoom, $),
                                M.cq({
                                    bucket: lt,
                                    glyphMap: tt,
                                    glyphPositions: Ze.positions,
                                    imageMap: Ae,
                                    imagePositions: at.iconPositions,
                                    showCollisionBoxes: this.showCollisionBoxes,
                                    canonical: this.tileID.canonical,
                                    subdivisionGranularity: Se.subdivisionGranularity
                                })) : lt.hasPattern && (lt instanceof M.cr || lt instanceof M.cs || lt instanceof M.ct) && (ge(lt.layers, this.zoom, $),
                                lt.addFeatures(Se, this.tileID.canonical, at.patternPositions))
                            }
                            return this.status = "done",
                            {
                                buckets: Object.values(ue).filter(it => !it.isEmpty()),
                                featureIndex: ve,
                                collisionBoxArray: this.collisionBoxArray,
                                glyphAtlasImage: Ze.image,
                                imageAtlas: at,
                                glyphMap: this.returnDependencies ? tt : null,
                                iconMap: this.returnDependencies ? Ae : null,
                                glyphPositions: this.returnDependencies ? Ze.positions : null
                            }
                        })
                    }
                }
                function ge(pe, E, U) {
                    const $ = new M.C(E);
                    for (const K of pe)
                        K.recalculate($, U)
                }
                class ze {
                    constructor(E, U, $) {
                        this.actor = E,
                        this.layerIndex = U,
                        this.availableImages = $,
                        this.fetching = {},
                        this.loading = {},
                        this.loaded = {}
                    }
                    loadVectorTile(E, U) {
                        return M._(this, void 0, void 0, function*() {
                            const $ = yield M.n(E.request, U);
                            try {
                                return {
                                    vectorTile: new M.cu.VectorTile(new M.cv($.data)),
                                    rawData: $.data,
                                    cacheControl: $.cacheControl,
                                    expires: $.expires
                                }
                            } catch (K) {
                                const re = new Uint8Array($.data);
                                let he = `Unable to parse the tile at ${E.request.url}, `;
                                throw he += re[0] === 31 && re[1] === 139 ? "please make sure the data is not gzipped and that you have configured the relevant header in the server" : `got error: ${K.message}`,
                                new Error(he)
                            }
                        })
                    }
                    loadTile(E) {
                        return M._(this, void 0, void 0, function*() {
                            const U = E.uid
                              , $ = !!(E && E.request && E.request.collectResourceTiming) && new M.cw(E.request)
                              , K = new de(E);
                            this.loading[U] = K;
                            const re = new AbortController;
                            K.abort = re;
                            try {
                                const he = yield this.loadVectorTile(E, re);
                                if (delete this.loading[U],
                                !he)
                                    return null;
                                const ve = he.rawData
                                  , ue = {};
                                he.expires && (ue.expires = he.expires),
                                he.cacheControl && (ue.cacheControl = he.cacheControl);
                                const Se = {};
                                if ($) {
                                    const fe = $.finish();
                                    fe && (Se.resourceTiming = JSON.parse(JSON.stringify(fe)))
                                }
                                K.vectorTile = he.vectorTile;
                                const we = K.parse(he.vectorTile, this.layerIndex, this.availableImages, this.actor, E.subdivisionGranularity);
                                this.loaded[U] = K,
                                this.fetching[U] = {
                                    rawTileData: ve,
                                    cacheControl: ue,
                                    resourceTiming: Se
                                };
                                try {
                                    const fe = yield we;
                                    return M.e({
                                        rawTileData: ve.slice(0)
                                    }, fe, ue, Se)
                                } finally {
                                    delete this.fetching[U]
                                }
                            } catch (he) {
                                throw delete this.loading[U],
                                K.status = "done",
                                this.loaded[U] = K,
                                he
                            }
                        })
                    }
                    reloadTile(E) {
                        return M._(this, void 0, void 0, function*() {
                            const U = E.uid;
                            if (!this.loaded || !this.loaded[U])
                                throw new Error("Should not be trying to reload a tile that was never loaded or has been removed");
                            const $ = this.loaded[U];
                            if ($.showCollisionBoxes = E.showCollisionBoxes,
                            $.status === "parsing") {
                                const K = yield $.parse($.vectorTile, this.layerIndex, this.availableImages, this.actor, E.subdivisionGranularity);
                                let re;
                                if (this.fetching[U]) {
                                    const {rawTileData: he, cacheControl: ve, resourceTiming: ue} = this.fetching[U];
                                    delete this.fetching[U],
                                    re = M.e({
                                        rawTileData: he.slice(0)
                                    }, K, ve, ue)
                                } else
                                    re = K;
                                return re
                            }
                            if ($.status === "done" && $.vectorTile)
                                return $.parse($.vectorTile, this.layerIndex, this.availableImages, this.actor, E.subdivisionGranularity)
                        })
                    }
                    abortTile(E) {
                        return M._(this, void 0, void 0, function*() {
                            const U = this.loading
                              , $ = E.uid;
                            U && U[$] && U[$].abort && (U[$].abort.abort(),
                            delete U[$])
                        })
                    }
                    removeTile(E) {
                        return M._(this, void 0, void 0, function*() {
                            this.loaded && this.loaded[E.uid] && delete this.loaded[E.uid]
                        })
                    }
                }
                class oe {
                    constructor() {
                        this.loaded = {}
                    }
                    loadTile(E) {
                        return M._(this, void 0, void 0, function*() {
                            const {uid: U, encoding: $, rawImageData: K, redFactor: re, greenFactor: he, blueFactor: ve, baseShift: ue} = E
                              , Se = K.width + 2
                              , we = K.height + 2
                              , fe = M.b(K) ? new M.R({
                                width: Se,
                                height: we
                            },yield M.cx(K, -1, -1, Se, we)) : K
                              , ke = new M.cy(U,fe,$,re,he,ve,ue);
                            return this.loaded = this.loaded || {},
                            this.loaded[U] = ke,
                            ke
                        })
                    }
                    removeTile(E) {
                        const U = this.loaded
                          , $ = E.uid;
                        U && U[$] && delete U[$]
                    }
                }
                var Y, Te, He = function() {
                    if (Te)
                        return Y;
                    function pe(U, $) {
                        if (U.length !== 0) {
                            E(U[0], $);
                            for (var K = 1; K < U.length; K++)
                                E(U[K], !$)
                        }
                    }
                    function E(U, $) {
                        for (var K = 0, re = 0, he = 0, ve = U.length, ue = ve - 1; he < ve; ue = he++) {
                            var Se = (U[he][0] - U[ue][0]) * (U[ue][1] + U[he][1])
                              , we = K + Se;
                            re += Math.abs(K) >= Math.abs(Se) ? K - we + Se : Se - we + K,
                            K = we
                        }
                        K + re >= 0 != !!$ && U.reverse()
                    }
                    return Te = 1,
                    Y = function U($, K) {
                        var re, he = $ && $.type;
                        if (he === "FeatureCollection")
                            for (re = 0; re < $.features.length; re++)
                                U($.features[re], K);
                        else if (he === "GeometryCollection")
                            for (re = 0; re < $.geometries.length; re++)
                                U($.geometries[re], K);
                        else if (he === "Feature")
                            U($.geometry, K);
                        else if (he === "Polygon")
                            pe($.coordinates, K);
                        else if (he === "MultiPolygon")
                            for (re = 0; re < $.coordinates.length; re++)
                                pe($.coordinates[re], K);
                        return $
                    }
                }(), ft = M.cz(He);
                const Pt = M.cu.VectorTileFeature.prototype.toGeoJSON;
                class vt {
                    constructor(E) {
                        this._feature = E,
                        this.extent = M.Z,
                        this.type = E.type,
                        this.properties = E.tags,
                        "id"in E && !isNaN(E.id) && (this.id = parseInt(E.id, 10))
                    }
                    loadGeometry() {
                        if (this._feature.type === 1) {
                            const E = [];
                            for (const U of this._feature.geometry)
                                E.push([new M.P(U[0],U[1])]);
                            return E
                        }
                        {
                            const E = [];
                            for (const U of this._feature.geometry) {
                                const $ = [];
                                for (const K of U)
                                    $.push(new M.P(K[0],K[1]));
                                E.push($)
                            }
                            return E
                        }
                    }
                    toGeoJSON(E, U, $) {
                        return Pt.call(this, E, U, $)
                    }
                }
                class St {
                    constructor(E) {
                        this.layers = {
                            _geojsonTileLayer: this
                        },
                        this.name = "_geojsonTileLayer",
                        this.extent = M.Z,
                        this.length = E.length,
                        this._features = E
                    }
                    feature(E) {
                        return new vt(this._features[E])
                    }
                }
                var Wt, pi, Mt, gt = {
                    exports: {}
                }, It = function() {
                    if (Mt)
                        return gt.exports;
                    Mt = 1;
                    var pe = M.cC()
                      , E = function() {
                        if (pi)
                            return Wt;
                        pi = 1;
                        var we = M.cA()
                          , fe = M.cB().VectorTileFeature;
                        function ke(je, We) {
                            this.options = We || {},
                            this.features = je,
                            this.length = je.length
                        }
                        function me(je, We) {
                            this.id = typeof je.id == "number" ? je.id : void 0,
                            this.type = je.type,
                            this.rawGeometry = je.type === 1 ? [je.geometry] : je.geometry,
                            this.properties = je.tags,
                            this.extent = We || 4096
                        }
                        return Wt = ke,
                        ke.prototype.feature = function(je) {
                            return new me(this.features[je],this.options.extent)
                        }
                        ,
                        me.prototype.loadGeometry = function() {
                            var je = this.rawGeometry;
                            this.geometry = [];
                            for (var We = 0; We < je.length; We++) {
                                for (var st = je[We], tt = [], Ae = 0; Ae < st.length; Ae++)
                                    tt.push(new we(st[Ae][0],st[Ae][1]));
                                this.geometry.push(tt)
                            }
                            return this.geometry
                        }
                        ,
                        me.prototype.bbox = function() {
                            this.geometry || this.loadGeometry();
                            for (var je = this.geometry, We = 1 / 0, st = -1 / 0, tt = 1 / 0, Ae = -1 / 0, Ge = 0; Ge < je.length; Ge++)
                                for (var Ze = je[Ge], at = 0; at < Ze.length; at++) {
                                    var it = Ze[at];
                                    We = Math.min(We, it.x),
                                    st = Math.max(st, it.x),
                                    tt = Math.min(tt, it.y),
                                    Ae = Math.max(Ae, it.y)
                                }
                            return [We, tt, st, Ae]
                        }
                        ,
                        me.prototype.toGeoJSON = fe.prototype.toGeoJSON,
                        Wt
                    }();
                    function U(we) {
                        var fe = new pe;
                        return function(ke, me) {
                            for (var je in ke.layers)
                                me.writeMessage(3, $, ke.layers[je])
                        }(we, fe),
                        fe.finish()
                    }
                    function $(we, fe) {
                        var ke;
                        fe.writeVarintField(15, we.version || 1),
                        fe.writeStringField(1, we.name || ""),
                        fe.writeVarintField(5, we.extent || 4096);
                        var me = {
                            keys: [],
                            values: [],
                            keycache: {},
                            valuecache: {}
                        };
                        for (ke = 0; ke < we.length; ke++)
                            me.feature = we.feature(ke),
                            fe.writeMessage(2, K, me);
                        var je = me.keys;
                        for (ke = 0; ke < je.length; ke++)
                            fe.writeStringField(3, je[ke]);
                        var We = me.values;
                        for (ke = 0; ke < We.length; ke++)
                            fe.writeMessage(4, Se, We[ke])
                    }
                    function K(we, fe) {
                        var ke = we.feature;
                        ke.id !== void 0 && fe.writeVarintField(1, ke.id),
                        fe.writeMessage(2, re, we),
                        fe.writeVarintField(3, ke.type),
                        fe.writeMessage(4, ue, ke)
                    }
                    function re(we, fe) {
                        var ke = we.feature
                          , me = we.keys
                          , je = we.values
                          , We = we.keycache
                          , st = we.valuecache;
                        for (var tt in ke.properties) {
                            var Ae = ke.properties[tt]
                              , Ge = We[tt];
                            if (Ae !== null) {
                                Ge === void 0 && (me.push(tt),
                                We[tt] = Ge = me.length - 1),
                                fe.writeVarint(Ge);
                                var Ze = typeof Ae;
                                Ze !== "string" && Ze !== "boolean" && Ze !== "number" && (Ae = JSON.stringify(Ae));
                                var at = Ze + ":" + Ae
                                  , it = st[at];
                                it === void 0 && (je.push(Ae),
                                st[at] = it = je.length - 1),
                                fe.writeVarint(it)
                            }
                        }
                    }
                    function he(we, fe) {
                        return (fe << 3) + (7 & we)
                    }
                    function ve(we) {
                        return we << 1 ^ we >> 31
                    }
                    function ue(we, fe) {
                        for (var ke = we.loadGeometry(), me = we.type, je = 0, We = 0, st = ke.length, tt = 0; tt < st; tt++) {
                            var Ae = ke[tt]
                              , Ge = 1;
                            me === 1 && (Ge = Ae.length),
                            fe.writeVarint(he(1, Ge));
                            for (var Ze = me === 3 ? Ae.length - 1 : Ae.length, at = 0; at < Ze; at++) {
                                at === 1 && me !== 1 && fe.writeVarint(he(2, Ze - 1));
                                var it = Ae[at].x - je
                                  , lt = Ae[at].y - We;
                                fe.writeVarint(ve(it)),
                                fe.writeVarint(ve(lt)),
                                je += it,
                                We += lt
                            }
                            me === 3 && fe.writeVarint(he(7, 1))
                        }
                    }
                    function Se(we, fe) {
                        var ke = typeof we;
                        ke === "string" ? fe.writeStringField(1, we) : ke === "boolean" ? fe.writeBooleanField(7, we) : ke === "number" && (we % 1 != 0 ? fe.writeDoubleField(3, we) : we < 0 ? fe.writeSVarintField(6, we) : fe.writeVarintField(5, we))
                    }
                    return gt.exports = U,
                    gt.exports.fromVectorTileJs = U,
                    gt.exports.fromGeojsonVt = function(we, fe) {
                        fe = fe || {};
                        var ke = {};
                        for (var me in we)
                            ke[me] = new E(we[me].features,fe),
                            ke[me].name = me,
                            ke[me].version = fe.version,
                            ke[me].extent = fe.extent;
                        return U({
                            layers: ke
                        })
                    }
                    ,
                    gt.exports.GeoJSONWrapper = E,
                    gt.exports
                }(), Pi = M.cz(It);
                const ei = {
                    minZoom: 0,
                    maxZoom: 16,
                    minPoints: 2,
                    radius: 40,
                    extent: 512,
                    nodeSize: 64,
                    log: !1,
                    generateId: !1,
                    reduce: null,
                    map: pe => pe
                }
                  , nt = Math.fround || (Wi = new Float32Array(1),
                pe => (Wi[0] = +pe,
                Wi[0]));
                var Wi;
                const Lt = 3
                  , ti = 5
                  , fi = 6;
                class ut {
                    constructor(E) {
                        this.options = Object.assign(Object.create(ei), E),
                        this.trees = new Array(this.options.maxZoom + 1),
                        this.stride = this.options.reduce ? 7 : 6,
                        this.clusterProps = []
                    }
                    load(E) {
                        const {log: U, minZoom: $, maxZoom: K} = this.options;
                        U && console.time("total time");
                        const re = `prepare ${E.length} points`;
                        U && console.time(re),
                        this.points = E;
                        const he = [];
                        for (let ue = 0; ue < E.length; ue++) {
                            const Se = E[ue];
                            if (!Se.geometry)
                                continue;
                            const [we,fe] = Se.geometry.coordinates
                              , ke = nt(mi(we))
                              , me = nt(wr(fe));
                            he.push(ke, me, 1 / 0, ue, -1, 1),
                            this.options.reduce && he.push(0)
                        }
                        let ve = this.trees[K + 1] = this._createTree(he);
                        U && console.timeEnd(re);
                        for (let ue = K; ue >= $; ue--) {
                            const Se = +Date.now();
                            ve = this.trees[ue] = this._createTree(this._cluster(ve, ue)),
                            U && console.log("z%d: %d clusters in %dms", ue, ve.numItems, +Date.now() - Se)
                        }
                        return U && console.timeEnd("total time"),
                        this
                    }
                    getClusters(E, U) {
                        let $ = ((E[0] + 180) % 360 + 360) % 360 - 180;
                        const K = Math.max(-90, Math.min(90, E[1]));
                        let re = E[2] === 180 ? 180 : ((E[2] + 180) % 360 + 360) % 360 - 180;
                        const he = Math.max(-90, Math.min(90, E[3]));
                        if (E[2] - E[0] >= 360)
                            $ = -180,
                            re = 180;
                        else if ($ > re) {
                            const fe = this.getClusters([$, K, 180, he], U)
                              , ke = this.getClusters([-180, K, re, he], U);
                            return fe.concat(ke)
                        }
                        const ve = this.trees[this._limitZoom(U)]
                          , ue = ve.range(mi($), wr(he), mi(re), wr(K))
                          , Se = ve.data
                          , we = [];
                        for (const fe of ue) {
                            const ke = this.stride * fe;
                            we.push(Se[ke + ti] > 1 ? or(Se, ke, this.clusterProps) : this.points[Se[ke + Lt]])
                        }
                        return we
                    }
                    getChildren(E) {
                        const U = this._getOriginId(E)
                          , $ = this._getOriginZoom(E)
                          , K = "No cluster with the specified id."
                          , re = this.trees[$];
                        if (!re)
                            throw new Error(K);
                        const he = re.data;
                        if (U * this.stride >= he.length)
                            throw new Error(K);
                        const ve = this.options.radius / (this.options.extent * Math.pow(2, $ - 1))
                          , ue = re.within(he[U * this.stride], he[U * this.stride + 1], ve)
                          , Se = [];
                        for (const we of ue) {
                            const fe = we * this.stride;
                            he[fe + 4] === E && Se.push(he[fe + ti] > 1 ? or(he, fe, this.clusterProps) : this.points[he[fe + Lt]])
                        }
                        if (Se.length === 0)
                            throw new Error(K);
                        return Se
                    }
                    getLeaves(E, U, $) {
                        const K = [];
                        return this._appendLeaves(K, E, U = U || 10, $ = $ || 0, 0),
                        K
                    }
                    getTile(E, U, $) {
                        const K = this.trees[this._limitZoom(E)]
                          , re = Math.pow(2, E)
                          , {extent: he, radius: ve} = this.options
                          , ue = ve / he
                          , Se = ($ - ue) / re
                          , we = ($ + 1 + ue) / re
                          , fe = {
                            features: []
                        };
                        return this._addTileFeatures(K.range((U - ue) / re, Se, (U + 1 + ue) / re, we), K.data, U, $, re, fe),
                        U === 0 && this._addTileFeatures(K.range(1 - ue / re, Se, 1, we), K.data, re, $, re, fe),
                        U === re - 1 && this._addTileFeatures(K.range(0, Se, ue / re, we), K.data, -1, $, re, fe),
                        fe.features.length ? fe : null
                    }
                    getClusterExpansionZoom(E) {
                        let U = this._getOriginZoom(E) - 1;
                        for (; U <= this.options.maxZoom; ) {
                            const $ = this.getChildren(E);
                            if (U++,
                            $.length !== 1)
                                break;
                            E = $[0].properties.cluster_id
                        }
                        return U
                    }
                    _appendLeaves(E, U, $, K, re) {
                        const he = this.getChildren(U);
                        for (const ve of he) {
                            const ue = ve.properties;
                            if (ue && ue.cluster ? re + ue.point_count <= K ? re += ue.point_count : re = this._appendLeaves(E, ue.cluster_id, $, K, re) : re < K ? re++ : E.push(ve),
                            E.length === $)
                                break
                        }
                        return re
                    }
                    _createTree(E) {
                        const U = new M.aB(E.length / this.stride | 0,this.options.nodeSize,Float32Array);
                        for (let $ = 0; $ < E.length; $ += this.stride)
                            U.add(E[$], E[$ + 1]);
                        return U.finish(),
                        U.data = E,
                        U
                    }
                    _addTileFeatures(E, U, $, K, re, he) {
                        for (const ve of E) {
                            const ue = ve * this.stride
                              , Se = U[ue + ti] > 1;
                            let we, fe, ke;
                            if (Se)
                                we = ar(U, ue, this.clusterProps),
                                fe = U[ue],
                                ke = U[ue + 1];
                            else {
                                const We = this.points[U[ue + Lt]];
                                we = We.properties;
                                const [st,tt] = We.geometry.coordinates;
                                fe = mi(st),
                                ke = wr(tt)
                            }
                            const me = {
                                type: 1,
                                geometry: [[Math.round(this.options.extent * (fe * re - $)), Math.round(this.options.extent * (ke * re - K))]],
                                tags: we
                            };
                            let je;
                            je = Se || this.options.generateId ? U[ue + Lt] : this.points[U[ue + Lt]].id,
                            je !== void 0 && (me.id = je),
                            he.features.push(me)
                        }
                    }
                    _limitZoom(E) {
                        return Math.max(this.options.minZoom, Math.min(Math.floor(+E), this.options.maxZoom + 1))
                    }
                    _cluster(E, U) {
                        const {radius: $, extent: K, reduce: re, minPoints: he} = this.options
                          , ve = $ / (K * Math.pow(2, U))
                          , ue = E.data
                          , Se = []
                          , we = this.stride;
                        for (let fe = 0; fe < ue.length; fe += we) {
                            if (ue[fe + 2] <= U)
                                continue;
                            ue[fe + 2] = U;
                            const ke = ue[fe]
                              , me = ue[fe + 1]
                              , je = E.within(ue[fe], ue[fe + 1], ve)
                              , We = ue[fe + ti];
                            let st = We;
                            for (const tt of je) {
                                const Ae = tt * we;
                                ue[Ae + 2] > U && (st += ue[Ae + ti])
                            }
                            if (st > We && st >= he) {
                                let tt, Ae = ke * We, Ge = me * We, Ze = -1;
                                const at = ((fe / we | 0) << 5) + (U + 1) + this.points.length;
                                for (const it of je) {
                                    const lt = it * we;
                                    if (ue[lt + 2] <= U)
                                        continue;
                                    ue[lt + 2] = U;
                                    const Je = ue[lt + ti];
                                    Ae += ue[lt] * Je,
                                    Ge += ue[lt + 1] * Je,
                                    ue[lt + 4] = at,
                                    re && (tt || (tt = this._map(ue, fe, !0),
                                    Ze = this.clusterProps.length,
                                    this.clusterProps.push(tt)),
                                    re(tt, this._map(ue, lt)))
                                }
                                ue[fe + 4] = at,
                                Se.push(Ae / st, Ge / st, 1 / 0, at, -1, st),
                                re && Se.push(Ze)
                            } else {
                                for (let tt = 0; tt < we; tt++)
                                    Se.push(ue[fe + tt]);
                                if (st > 1)
                                    for (const tt of je) {
                                        const Ae = tt * we;
                                        if (!(ue[Ae + 2] <= U)) {
                                            ue[Ae + 2] = U;
                                            for (let Ge = 0; Ge < we; Ge++)
                                                Se.push(ue[Ae + Ge])
                                        }
                                    }
                            }
                        }
                        return Se
                    }
                    _getOriginId(E) {
                        return E - this.points.length >> 5
                    }
                    _getOriginZoom(E) {
                        return (E - this.points.length) % 32
                    }
                    _map(E, U, $) {
                        if (E[U + ti] > 1) {
                            const he = this.clusterProps[E[U + fi]];
                            return $ ? Object.assign({}, he) : he
                        }
                        const K = this.points[E[U + Lt]].properties
                          , re = this.options.map(K);
                        return $ && re === K ? Object.assign({}, re) : re
                    }
                }
                function or(pe, E, U) {
                    return {
                        type: "Feature",
                        id: pe[E + Lt],
                        properties: ar(pe, E, U),
                        geometry: {
                            type: "Point",
                            coordinates: [($ = pe[E],
                            360 * ($ - .5)), Br(pe[E + 1])]
                        }
                    };
                    var $
                }
                function ar(pe, E, U) {
                    const $ = pe[E + ti]
                      , K = $ >= 1e4 ? `${Math.round($ / 1e3)}k` : $ >= 1e3 ? Math.round($ / 100) / 10 + "k" : $
                      , re = pe[E + fi]
                      , he = re === -1 ? {} : Object.assign({}, U[re]);
                    return Object.assign(he, {
                        cluster: !0,
                        cluster_id: pe[E + Lt],
                        point_count: $,
                        point_count_abbreviated: K
                    })
                }
                function mi(pe) {
                    return pe / 360 + .5
                }
                function wr(pe) {
                    const E = Math.sin(pe * Math.PI / 180)
                      , U = .5 - .25 * Math.log((1 + E) / (1 - E)) / Math.PI;
                    return U < 0 ? 0 : U > 1 ? 1 : U
                }
                function Br(pe) {
                    const E = (180 - 360 * pe) * Math.PI / 180;
                    return 360 * Math.atan(Math.exp(E)) / Math.PI - 90
                }
                function gi(pe, E, U, $) {
                    let K = $;
                    const re = E + (U - E >> 1);
                    let he, ve = U - E;
                    const ue = pe[E]
                      , Se = pe[E + 1]
                      , we = pe[U]
                      , fe = pe[U + 1];
                    for (let ke = E + 3; ke < U; ke += 3) {
                        const me = si(pe[ke], pe[ke + 1], ue, Se, we, fe);
                        if (me > K)
                            he = ke,
                            K = me;
                        else if (me === K) {
                            const je = Math.abs(ke - re);
                            je < ve && (he = ke,
                            ve = je)
                        }
                    }
                    K > $ && (he - E > 3 && gi(pe, E, he, $),
                    pe[he + 2] = K,
                    U - he > 3 && gi(pe, he, U, $))
                }
                function si(pe, E, U, $, K, re) {
                    let he = K - U
                      , ve = re - $;
                    if (he !== 0 || ve !== 0) {
                        const ue = ((pe - U) * he + (E - $) * ve) / (he * he + ve * ve);
                        ue > 1 ? (U = K,
                        $ = re) : ue > 0 && (U += he * ue,
                        $ += ve * ue)
                    }
                    return he = pe - U,
                    ve = E - $,
                    he * he + ve * ve
                }
                function _i(pe, E, U, $) {
                    const K = {
                        id: pe ?? null,
                        type: E,
                        geometry: U,
                        tags: $,
                        minX: 1 / 0,
                        minY: 1 / 0,
                        maxX: -1 / 0,
                        maxY: -1 / 0
                    };
                    if (E === "Point" || E === "MultiPoint" || E === "LineString")
                        Ft(K, U);
                    else if (E === "Polygon")
                        Ft(K, U[0]);
                    else if (E === "MultiLineString")
                        for (const re of U)
                            Ft(K, re);
                    else if (E === "MultiPolygon")
                        for (const re of U)
                            Ft(K, re[0]);
                    return K
                }
                function Ft(pe, E) {
                    for (let U = 0; U < E.length; U += 3)
                        pe.minX = Math.min(pe.minX, E[U]),
                        pe.minY = Math.min(pe.minY, E[U + 1]),
                        pe.maxX = Math.max(pe.maxX, E[U]),
                        pe.maxY = Math.max(pe.maxY, E[U + 1])
                }
                function Yi(pe, E, U, $) {
                    if (!E.geometry)
                        return;
                    const K = E.geometry.coordinates;
                    if (K && K.length === 0)
                        return;
                    const re = E.geometry.type
                      , he = Math.pow(U.tolerance / ((1 << U.maxZoom) * U.extent), 2);
                    let ve = []
                      , ue = E.id;
                    if (U.promoteId ? ue = E.properties[U.promoteId] : U.generateId && (ue = $ || 0),
                    re === "Point")
                        Xi(K, ve);
                    else if (re === "MultiPoint")
                        for (const Se of K)
                            Xi(Se, ve);
                    else if (re === "LineString")
                        en(K, ve, he, !1);
                    else if (re === "MultiLineString") {
                        if (U.lineMetrics) {
                            for (const Se of K)
                                ve = [],
                                en(Se, ve, he, !1),
                                pe.push(_i(ue, "LineString", ve, E.properties));
                            return
                        }
                        Vi(K, ve, he, !1)
                    } else if (re === "Polygon")
                        Vi(K, ve, he, !0);
                    else {
                        if (re !== "MultiPolygon") {
                            if (re === "GeometryCollection") {
                                for (const Se of E.geometry.geometries)
                                    Yi(pe, {
                                        id: ue,
                                        geometry: Se,
                                        properties: E.properties
                                    }, U, $);
                                return
                            }
                            throw new Error("Input data is not a valid GeoJSON object.")
                        }
                        for (const Se of K) {
                            const we = [];
                            Vi(Se, we, he, !0),
                            ve.push(we)
                        }
                    }
                    pe.push(_i(ue, re, ve, E.properties))
                }
                function Xi(pe, E) {
                    E.push(Hn(pe[0]), yi(pe[1]), 0)
                }
                function en(pe, E, U, $) {
                    let K, re, he = 0;
                    for (let ue = 0; ue < pe.length; ue++) {
                        const Se = Hn(pe[ue][0])
                          , we = yi(pe[ue][1]);
                        E.push(Se, we, 0),
                        ue > 0 && (he += $ ? (K * we - Se * re) / 2 : Math.sqrt(Math.pow(Se - K, 2) + Math.pow(we - re, 2))),
                        K = Se,
                        re = we
                    }
                    const ve = E.length - 3;
                    E[2] = 1,
                    gi(E, 0, ve, U),
                    E[ve + 2] = 1,
                    E.size = Math.abs(he),
                    E.start = 0,
                    E.end = E.size
                }
                function Vi(pe, E, U, $) {
                    for (let K = 0; K < pe.length; K++) {
                        const re = [];
                        en(pe[K], re, U, $),
                        E.push(re)
                    }
                }
                function Hn(pe) {
                    return pe / 360 + .5
                }
                function yi(pe) {
                    const E = Math.sin(pe * Math.PI / 180)
                      , U = .5 - .25 * Math.log((1 + E) / (1 - E)) / Math.PI;
                    return U < 0 ? 0 : U > 1 ? 1 : U
                }
                function ii(pe, E, U, $, K, re, he, ve) {
                    if ($ /= E,
                    re >= (U /= E) && he < $)
                        return pe;
                    if (he < U || re >= $)
                        return null;
                    const ue = [];
                    for (const Se of pe) {
                        const we = Se.geometry;
                        let fe = Se.type;
                        const ke = K === 0 ? Se.minX : Se.minY
                          , me = K === 0 ? Se.maxX : Se.maxY;
                        if (ke >= U && me < $) {
                            ue.push(Se);
                            continue
                        }
                        if (me < U || ke >= $)
                            continue;
                        let je = [];
                        if (fe === "Point" || fe === "MultiPoint")
                            Tr(we, je, U, $, K);
                        else if (fe === "LineString")
                            oi(we, je, U, $, K, !1, ve.lineMetrics);
                        else if (fe === "MultiLineString")
                            Xn(we, je, U, $, K, !1);
                        else if (fe === "Polygon")
                            Xn(we, je, U, $, K, !0);
                        else if (fe === "MultiPolygon")
                            for (const We of we) {
                                const st = [];
                                Xn(We, st, U, $, K, !0),
                                st.length && je.push(st)
                            }
                        if (je.length) {
                            if (ve.lineMetrics && fe === "LineString") {
                                for (const We of je)
                                    ue.push(_i(Se.id, fe, We, Se.tags));
                                continue
                            }
                            fe !== "LineString" && fe !== "MultiLineString" || (je.length === 1 ? (fe = "LineString",
                            je = je[0]) : fe = "MultiLineString"),
                            fe !== "Point" && fe !== "MultiPoint" || (fe = je.length === 3 ? "Point" : "MultiPoint"),
                            ue.push(_i(Se.id, fe, je, Se.tags))
                        }
                    }
                    return ue.length ? ue : null
                }
                function Tr(pe, E, U, $, K) {
                    for (let re = 0; re < pe.length; re += 3) {
                        const he = pe[re + K];
                        he >= U && he <= $ && Or(E, pe[re], pe[re + 1], pe[re + 2])
                    }
                }
                function oi(pe, E, U, $, K, re, he) {
                    let ve = Wn(pe);
                    const ue = K === 0 ? zn : kn;
                    let Se, we, fe = pe.start;
                    for (let st = 0; st < pe.length - 3; st += 3) {
                        const tt = pe[st]
                          , Ae = pe[st + 1]
                          , Ge = pe[st + 2]
                          , Ze = pe[st + 3]
                          , at = pe[st + 4]
                          , it = K === 0 ? tt : Ae
                          , lt = K === 0 ? Ze : at;
                        let Je = !1;
                        he && (Se = Math.sqrt(Math.pow(tt - Ze, 2) + Math.pow(Ae - at, 2))),
                        it < U ? lt > U && (we = ue(ve, tt, Ae, Ze, at, U),
                        he && (ve.start = fe + Se * we)) : it > $ ? lt < $ && (we = ue(ve, tt, Ae, Ze, at, $),
                        he && (ve.start = fe + Se * we)) : Or(ve, tt, Ae, Ge),
                        lt < U && it >= U && (we = ue(ve, tt, Ae, Ze, at, U),
                        Je = !0),
                        lt > $ && it <= $ && (we = ue(ve, tt, Ae, Ze, at, $),
                        Je = !0),
                        !re && Je && (he && (ve.end = fe + Se * we),
                        E.push(ve),
                        ve = Wn(pe)),
                        he && (fe += Se)
                    }
                    let ke = pe.length - 3;
                    const me = pe[ke]
                      , je = pe[ke + 1]
                      , We = K === 0 ? me : je;
                    We >= U && We <= $ && Or(ve, me, je, pe[ke + 2]),
                    ke = ve.length - 3,
                    re && ke >= 3 && (ve[ke] !== ve[0] || ve[ke + 1] !== ve[1]) && Or(ve, ve[0], ve[1], ve[2]),
                    ve.length && E.push(ve)
                }
                function Wn(pe) {
                    const E = [];
                    return E.size = pe.size,
                    E.start = pe.start,
                    E.end = pe.end,
                    E
                }
                function Xn(pe, E, U, $, K, re) {
                    for (const he of pe)
                        oi(he, E, U, $, K, re, !1)
                }
                function Or(pe, E, U, $) {
                    pe.push(E, U, $)
                }
                function zn(pe, E, U, $, K, re) {
                    const he = (re - E) / ($ - E);
                    return Or(pe, re, U + (K - U) * he, 1),
                    he
                }
                function kn(pe, E, U, $, K, re) {
                    const he = (re - U) / (K - U);
                    return Or(pe, E + ($ - E) * he, re, 1),
                    he
                }
                function tn(pe, E) {
                    const U = [];
                    for (let $ = 0; $ < pe.length; $++) {
                        const K = pe[$]
                          , re = K.type;
                        let he;
                        if (re === "Point" || re === "MultiPoint" || re === "LineString")
                            he = Nr(K.geometry, E);
                        else if (re === "MultiLineString" || re === "Polygon") {
                            he = [];
                            for (const ve of K.geometry)
                                he.push(Nr(ve, E))
                        } else if (re === "MultiPolygon") {
                            he = [];
                            for (const ve of K.geometry) {
                                const ue = [];
                                for (const Se of ve)
                                    ue.push(Nr(Se, E));
                                he.push(ue)
                            }
                        }
                        U.push(_i(K.id, re, he, K.tags))
                    }
                    return U
                }
                function Nr(pe, E) {
                    const U = [];
                    U.size = pe.size,
                    pe.start !== void 0 && (U.start = pe.start,
                    U.end = pe.end);
                    for (let $ = 0; $ < pe.length; $ += 3)
                        U.push(pe[$] + E, pe[$ + 1], pe[$ + 2]);
                    return U
                }
                function ws(pe, E) {
                    if (pe.transformed)
                        return pe;
                    const U = 1 << pe.z
                      , $ = pe.x
                      , K = pe.y;
                    for (const re of pe.features) {
                        const he = re.geometry
                          , ve = re.type;
                        if (re.geometry = [],
                        ve === 1)
                            for (let ue = 0; ue < he.length; ue += 2)
                                re.geometry.push(Kn(he[ue], he[ue + 1], E, U, $, K));
                        else
                            for (let ue = 0; ue < he.length; ue++) {
                                const Se = [];
                                for (let we = 0; we < he[ue].length; we += 2)
                                    Se.push(Kn(he[ue][we], he[ue][we + 1], E, U, $, K));
                                re.geometry.push(Se)
                            }
                    }
                    return pe.transformed = !0,
                    pe
                }
                function Kn(pe, E, U, $, K, re) {
                    return [Math.round(U * (pe * $ - K)), Math.round(U * (E * $ - re))]
                }
                function Jn(pe, E, U, $, K) {
                    const re = E === K.maxZoom ? 0 : K.tolerance / ((1 << E) * K.extent)
                      , he = {
                        features: [],
                        numPoints: 0,
                        numSimplified: 0,
                        numFeatures: pe.length,
                        source: null,
                        x: U,
                        y: $,
                        z: E,
                        transformed: !1,
                        minX: 2,
                        minY: 1,
                        maxX: -1,
                        maxY: 0
                    };
                    for (const ve of pe)
                        Ts(he, ve, re, K);
                    return he
                }
                function Ts(pe, E, U, $) {
                    const K = E.geometry
                      , re = E.type
                      , he = [];
                    if (pe.minX = Math.min(pe.minX, E.minX),
                    pe.minY = Math.min(pe.minY, E.minY),
                    pe.maxX = Math.max(pe.maxX, E.maxX),
                    pe.maxY = Math.max(pe.maxY, E.maxY),
                    re === "Point" || re === "MultiPoint")
                        for (let ve = 0; ve < K.length; ve += 3)
                            he.push(K[ve], K[ve + 1]),
                            pe.numPoints++,
                            pe.numSimplified++;
                    else if (re === "LineString")
                        Yn(he, K, pe, U, !1, !1);
                    else if (re === "MultiLineString" || re === "Polygon")
                        for (let ve = 0; ve < K.length; ve++)
                            Yn(he, K[ve], pe, U, re === "Polygon", ve === 0);
                    else if (re === "MultiPolygon")
                        for (let ve = 0; ve < K.length; ve++) {
                            const ue = K[ve];
                            for (let Se = 0; Se < ue.length; Se++)
                                Yn(he, ue[Se], pe, U, !0, Se === 0)
                        }
                    if (he.length) {
                        let ve = E.tags || null;
                        if (re === "LineString" && $.lineMetrics) {
                            ve = {};
                            for (const Se in E.tags)
                                ve[Se] = E.tags[Se];
                            ve.mapbox_clip_start = K.start / K.size,
                            ve.mapbox_clip_end = K.end / K.size
                        }
                        const ue = {
                            geometry: he,
                            type: re === "Polygon" || re === "MultiPolygon" ? 3 : re === "LineString" || re === "MultiLineString" ? 2 : 1,
                            tags: ve
                        };
                        E.id !== null && (ue.id = E.id),
                        pe.features.push(ue)
                    }
                }
                function Yn(pe, E, U, $, K, re) {
                    const he = $ * $;
                    if ($ > 0 && E.size < (K ? he : $))
                        return void (U.numPoints += E.length / 3);
                    const ve = [];
                    for (let ue = 0; ue < E.length; ue += 3)
                        ($ === 0 || E[ue + 2] > he) && (U.numSimplified++,
                        ve.push(E[ue], E[ue + 1])),
                        U.numPoints++;
                    K && function(ue, Se) {
                        let we = 0;
                        for (let fe = 0, ke = ue.length, me = ke - 2; fe < ke; me = fe,
                        fe += 2)
                            we += (ue[fe] - ue[me]) * (ue[fe + 1] + ue[me + 1]);
                        if (we > 0 === Se)
                            for (let fe = 0, ke = ue.length; fe < ke / 2; fe += 2) {
                                const me = ue[fe]
                                  , je = ue[fe + 1];
                                ue[fe] = ue[ke - 2 - fe],
                                ue[fe + 1] = ue[ke - 1 - fe],
                                ue[ke - 2 - fe] = me,
                                ue[ke - 1 - fe] = je
                            }
                    }(ve, re),
                    pe.push(ve)
                }
                const mn = {
                    maxZoom: 14,
                    indexMaxZoom: 5,
                    indexMaxPoints: 1e5,
                    tolerance: 3,
                    extent: 4096,
                    buffer: 64,
                    lineMetrics: !1,
                    promoteId: null,
                    generateId: !1,
                    debug: 0
                };
                class gn {
                    constructor(E, U) {
                        const $ = (U = this.options = function(re, he) {
                            for (const ve in he)
                                re[ve] = he[ve];
                            return re
                        }(Object.create(mn), U)).debug;
                        if ($ && console.time("preprocess data"),
                        U.maxZoom < 0 || U.maxZoom > 24)
                            throw new Error("maxZoom should be in the 0-24 range");
                        if (U.promoteId && U.generateId)
                            throw new Error("promoteId and generateId cannot be used together.");
                        let K = function(re, he) {
                            const ve = [];
                            if (re.type === "FeatureCollection")
                                for (let ue = 0; ue < re.features.length; ue++)
                                    Yi(ve, re.features[ue], he, ue);
                            else
                                Yi(ve, re.type === "Feature" ? re : {
                                    geometry: re
                                }, he);
                            return ve
                        }(E, U);
                        this.tiles = {},
                        this.tileCoords = [],
                        $ && (console.timeEnd("preprocess data"),
                        console.log("index: maxZoom: %d, maxPoints: %d", U.indexMaxZoom, U.indexMaxPoints),
                        console.time("generate tiles"),
                        this.stats = {},
                        this.total = 0),
                        K = function(re, he) {
                            const ve = he.buffer / he.extent;
                            let ue = re;
                            const Se = ii(re, 1, -1 - ve, ve, 0, -1, 2, he)
                              , we = ii(re, 1, 1 - ve, 2 + ve, 0, -1, 2, he);
                            return (Se || we) && (ue = ii(re, 1, -ve, 1 + ve, 0, -1, 2, he) || [],
                            Se && (ue = tn(Se, 1).concat(ue)),
                            we && (ue = ue.concat(tn(we, -1)))),
                            ue
                        }(K, U),
                        K.length && this.splitTile(K, 0, 0, 0),
                        $ && (K.length && console.log("features: %d, points: %d", this.tiles[0].numFeatures, this.tiles[0].numPoints),
                        console.timeEnd("generate tiles"),
                        console.log("tiles generated:", this.total, JSON.stringify(this.stats)))
                    }
                    splitTile(E, U, $, K, re, he, ve) {
                        const ue = [E, U, $, K]
                          , Se = this.options
                          , we = Se.debug;
                        for (; ue.length; ) {
                            K = ue.pop(),
                            $ = ue.pop(),
                            U = ue.pop(),
                            E = ue.pop();
                            const fe = 1 << U
                              , ke = Ln(U, $, K);
                            let me = this.tiles[ke];
                            if (!me && (we > 1 && console.time("creation"),
                            me = this.tiles[ke] = Jn(E, U, $, K, Se),
                            this.tileCoords.push({
                                z: U,
                                x: $,
                                y: K
                            }),
                            we)) {
                                we > 1 && (console.log("tile z%d-%d-%d (features: %d, points: %d, simplified: %d)", U, $, K, me.numFeatures, me.numPoints, me.numSimplified),
                                console.timeEnd("creation"));
                                const Je = `z${U}`;
                                this.stats[Je] = (this.stats[Je] || 0) + 1,
                                this.total++
                            }
                            if (me.source = E,
                            re == null) {
                                if (U === Se.indexMaxZoom || me.numPoints <= Se.indexMaxPoints)
                                    continue
                            } else {
                                if (U === Se.maxZoom || U === re)
                                    continue;
                                if (re != null) {
                                    const Je = re - U;
                                    if ($ !== he >> Je || K !== ve >> Je)
                                        continue
                                }
                            }
                            if (me.source = null,
                            E.length === 0)
                                continue;
                            we > 1 && console.time("clipping");
                            const je = .5 * Se.buffer / Se.extent
                              , We = .5 - je
                              , st = .5 + je
                              , tt = 1 + je;
                            let Ae = null
                              , Ge = null
                              , Ze = null
                              , at = null
                              , it = ii(E, fe, $ - je, $ + st, 0, me.minX, me.maxX, Se)
                              , lt = ii(E, fe, $ + We, $ + tt, 0, me.minX, me.maxX, Se);
                            E = null,
                            it && (Ae = ii(it, fe, K - je, K + st, 1, me.minY, me.maxY, Se),
                            Ge = ii(it, fe, K + We, K + tt, 1, me.minY, me.maxY, Se),
                            it = null),
                            lt && (Ze = ii(lt, fe, K - je, K + st, 1, me.minY, me.maxY, Se),
                            at = ii(lt, fe, K + We, K + tt, 1, me.minY, me.maxY, Se),
                            lt = null),
                            we > 1 && console.timeEnd("clipping"),
                            ue.push(Ae || [], U + 1, 2 * $, 2 * K),
                            ue.push(Ge || [], U + 1, 2 * $, 2 * K + 1),
                            ue.push(Ze || [], U + 1, 2 * $ + 1, 2 * K),
                            ue.push(at || [], U + 1, 2 * $ + 1, 2 * K + 1)
                        }
                    }
                    getTile(E, U, $) {
                        E = +E,
                        U = +U,
                        $ = +$;
                        const K = this.options
                          , {extent: re, debug: he} = K;
                        if (E < 0 || E > 24)
                            return null;
                        const ve = 1 << E
                          , ue = Ln(E, U = U + ve & ve - 1, $);
                        if (this.tiles[ue])
                            return ws(this.tiles[ue], re);
                        he > 1 && console.log("drilling down to z%d-%d-%d", E, U, $);
                        let Se, we = E, fe = U, ke = $;
                        for (; !Se && we > 0; )
                            we--,
                            fe >>= 1,
                            ke >>= 1,
                            Se = this.tiles[Ln(we, fe, ke)];
                        return Se && Se.source ? (he > 1 && (console.log("found parent tile z%d-%d-%d", we, fe, ke),
                        console.time("drilling down")),
                        this.splitTile(Se.source, we, fe, ke, E, U, $),
                        he > 1 && console.timeEnd("drilling down"),
                        this.tiles[ue] ? ws(this.tiles[ue], re) : null) : null
                    }
                }
                function Ln(pe, E, U) {
                    return 32 * ((1 << pe) * U + E) + pe
                }
                function Dn(pe, E) {
                    return E ? pe.properties[E] : pe.id
                }
                function eo(pe, E) {
                    if (pe == null)
                        return !0;
                    if (pe.type === "Feature")
                        return Dn(pe, E) != null;
                    if (pe.type === "FeatureCollection") {
                        const U = new Set;
                        for (const $ of pe.features) {
                            const K = Dn($, E);
                            if (K == null || U.has(K))
                                return !1;
                            U.add(K)
                        }
                        return !0
                    }
                    return !1
                }
                function Ms(pe, E) {
                    const U = new Map;
                    if (pe != null)
                        if (pe.type === "Feature")
                            U.set(Dn(pe, E), pe);
                        else
                            for (const $ of pe.features)
                                U.set(Dn($, E), $);
                    return U
                }
                class to extends ze {
                    constructor() {
                        super(...arguments),
                        this._dataUpdateable = new Map
                    }
                    loadVectorTile(E, U) {
                        return M._(this, void 0, void 0, function*() {
                            const $ = E.tileID.canonical;
                            if (!this._geoJSONIndex)
                                throw new Error("Unable to parse the data into a cluster or geojson");
                            const K = this._geoJSONIndex.getTile($.z, $.x, $.y);
                            if (!K)
                                return null;
                            const re = new St(K.features);
                            let he = Pi(re);
                            return he.byteOffset === 0 && he.byteLength === he.buffer.byteLength || (he = new Uint8Array(he)),
                            {
                                vectorTile: re,
                                rawData: he.buffer
                            }
                        })
                    }
                    loadData(E) {
                        return M._(this, void 0, void 0, function*() {
                            var U;
                            (U = this._pendingRequest) === null || U === void 0 || U.abort();
                            const $ = !!(E && E.request && E.request.collectResourceTiming) && new M.cw(E.request);
                            this._pendingRequest = new AbortController;
                            try {
                                this._pendingData = this.loadAndProcessGeoJSON(E, this._pendingRequest),
                                this._geoJSONIndex = E.cluster ? new ut(function({superclusterOptions: he, clusterProperties: ve}) {
                                    if (!ve || !he)
                                        return he;
                                    const ue = {}
                                      , Se = {}
                                      , we = {
                                        accumulated: null,
                                        zoom: 0
                                    }
                                      , fe = {
                                        properties: null
                                    }
                                      , ke = Object.keys(ve);
                                    for (const me of ke) {
                                        const [je,We] = ve[me]
                                          , st = M.cD(We)
                                          , tt = M.cD(typeof je == "string" ? [je, ["accumulated"], ["get", me]] : je);
                                        ue[me] = st.value,
                                        Se[me] = tt.value
                                    }
                                    return he.map = me => {
                                        fe.properties = me;
                                        const je = {};
                                        for (const We of ke)
                                            je[We] = ue[We].evaluate(we, fe);
                                        return je
                                    }
                                    ,
                                    he.reduce = (me, je) => {
                                        fe.properties = je;
                                        for (const We of ke)
                                            we.accumulated = me[We],
                                            me[We] = Se[We].evaluate(we, fe)
                                    }
                                    ,
                                    he
                                }(E)).load((yield this._pendingData).features) : (K = yield this._pendingData,
                                new gn(K,E.geojsonVtOptions)),
                                this.loaded = {};
                                const re = {};
                                if ($) {
                                    const he = $.finish();
                                    he && (re.resourceTiming = {},
                                    re.resourceTiming[E.source] = JSON.parse(JSON.stringify(he)))
                                }
                                return re
                            } catch (re) {
                                if (delete this._pendingRequest,
                                M.ch(re))
                                    return {
                                        abandoned: !0
                                    };
                                throw re
                            }
                            var K
                        })
                    }
                    getData() {
                        return M._(this, void 0, void 0, function*() {
                            return this._pendingData
                        })
                    }
                    reloadTile(E) {
                        const U = this.loaded;
                        return U && U[E.uid] ? super.reloadTile(E) : this.loadTile(E)
                    }
                    loadAndProcessGeoJSON(E, U) {
                        return M._(this, void 0, void 0, function*() {
                            let $ = yield this.loadGeoJSON(E, U);
                            if (delete this._pendingRequest,
                            typeof $ != "object")
                                throw new Error(`Input data given to '${E.source}' is not a valid GeoJSON object.`);
                            if (ft($, !0),
                            E.filter) {
                                const K = M.cD(E.filter, {
                                    type: "boolean",
                                    "property-type": "data-driven",
                                    overridable: !1,
                                    transition: !1
                                });
                                if (K.result === "error")
                                    throw new Error(K.value.map(he => `${he.key}: ${he.message}`).join(", "));
                                $ = {
                                    type: "FeatureCollection",
                                    features: $.features.filter(he => K.value.evaluate({
                                        zoom: 0
                                    }, he))
                                }
                            }
                            return $
                        })
                    }
                    loadGeoJSON(E, U) {
                        return M._(this, void 0, void 0, function*() {
                            const {promoteId: $} = E;
                            if (E.request) {
                                const K = yield M.j(E.request, U);
                                return this._dataUpdateable = eo(K.data, $) ? Ms(K.data, $) : void 0,
                                K.data
                            }
                            if (typeof E.data == "string")
                                try {
                                    const K = JSON.parse(E.data);
                                    return this._dataUpdateable = eo(K, $) ? Ms(K, $) : void 0,
                                    K
                                } catch {
                                    throw new Error(`Input data given to '${E.source}' is not a valid GeoJSON object.`)
                                }
                            if (!E.dataDiff)
                                throw new Error(`Input data given to '${E.source}' is not a valid GeoJSON object.`);
                            if (!this._dataUpdateable)
                                throw new Error(`Cannot update existing geojson data in ${E.source}`);
                            return function(K, re, he) {
                                var ve, ue, Se, we;
                                if (re.removeAll && K.clear(),
                                re.remove)
                                    for (const fe of re.remove)
                                        K.delete(fe);
                                if (re.add)
                                    for (const fe of re.add) {
                                        const ke = Dn(fe, he);
                                        ke != null && K.set(ke, fe)
                                    }
                                if (re.update)
                                    for (const fe of re.update) {
                                        let ke = K.get(fe.id);
                                        if (ke == null)
                                            continue;
                                        const me = !fe.removeAllProperties && (((ve = fe.removeProperties) === null || ve === void 0 ? void 0 : ve.length) > 0 || ((ue = fe.addOrUpdateProperties) === null || ue === void 0 ? void 0 : ue.length) > 0);
                                        if ((fe.newGeometry || fe.removeAllProperties || me) && (ke = Object.assign({}, ke),
                                        K.set(fe.id, ke),
                                        me && (ke.properties = Object.assign({}, ke.properties))),
                                        fe.newGeometry && (ke.geometry = fe.newGeometry),
                                        fe.removeAllProperties)
                                            ke.properties = {};
                                        else if (((Se = fe.removeProperties) === null || Se === void 0 ? void 0 : Se.length) > 0)
                                            for (const je of fe.removeProperties)
                                                Object.prototype.hasOwnProperty.call(ke.properties, je) && delete ke.properties[je];
                                        if (((we = fe.addOrUpdateProperties) === null || we === void 0 ? void 0 : we.length) > 0)
                                            for (const {key: je, value: We} of fe.addOrUpdateProperties)
                                                ke.properties[je] = We
                                    }
                            }(this._dataUpdateable, E.dataDiff, $),
                            {
                                type: "FeatureCollection",
                                features: Array.from(this._dataUpdateable.values())
                            }
                        })
                    }
                    removeSource(E) {
                        return M._(this, void 0, void 0, function*() {
                            this._pendingRequest && this._pendingRequest.abort()
                        })
                    }
                    getClusterExpansionZoom(E) {
                        return this._geoJSONIndex.getClusterExpansionZoom(E.clusterId)
                    }
                    getClusterChildren(E) {
                        return this._geoJSONIndex.getChildren(E.clusterId)
                    }
                    getClusterLeaves(E) {
                        return this._geoJSONIndex.getLeaves(E.clusterId, E.limit, E.offset)
                    }
                }
                class _n {
                    constructor(E) {
                        this.self = E,
                        this.actor = new M.H(E),
                        this.layerIndexes = {},
                        this.availableImages = {},
                        this.workerSources = {},
                        this.demWorkerSources = {},
                        this.externalWorkerSourceTypes = {},
                        this.self.registerWorkerSource = (U, $) => {
                            if (this.externalWorkerSourceTypes[U])
                                throw new Error(`Worker source with name "${U}" already registered.`);
                            this.externalWorkerSourceTypes[U] = $
                        }
                        ,
                        this.self.addProtocol = M.cj,
                        this.self.removeProtocol = M.ck,
                        this.self.registerRTLTextPlugin = U => {
                            M.cE.setMethods(U)
                        }
                        ,
                        this.actor.registerMessageHandler("LDT", (U, $) => this._getDEMWorkerSource(U, $.source).loadTile($)),
                        this.actor.registerMessageHandler("RDT", (U, $) => M._(this, void 0, void 0, function*() {
                            this._getDEMWorkerSource(U, $.source).removeTile($)
                        })),
                        this.actor.registerMessageHandler("GCEZ", (U, $) => M._(this, void 0, void 0, function*() {
                            return this._getWorkerSource(U, $.type, $.source).getClusterExpansionZoom($)
                        })),
                        this.actor.registerMessageHandler("GCC", (U, $) => M._(this, void 0, void 0, function*() {
                            return this._getWorkerSource(U, $.type, $.source).getClusterChildren($)
                        })),
                        this.actor.registerMessageHandler("GCL", (U, $) => M._(this, void 0, void 0, function*() {
                            return this._getWorkerSource(U, $.type, $.source).getClusterLeaves($)
                        })),
                        this.actor.registerMessageHandler("LD", (U, $) => this._getWorkerSource(U, $.type, $.source).loadData($)),
                        this.actor.registerMessageHandler("GD", (U, $) => this._getWorkerSource(U, $.type, $.source).getData()),
                        this.actor.registerMessageHandler("LT", (U, $) => this._getWorkerSource(U, $.type, $.source).loadTile($)),
                        this.actor.registerMessageHandler("RT", (U, $) => this._getWorkerSource(U, $.type, $.source).reloadTile($)),
                        this.actor.registerMessageHandler("AT", (U, $) => this._getWorkerSource(U, $.type, $.source).abortTile($)),
                        this.actor.registerMessageHandler("RMT", (U, $) => this._getWorkerSource(U, $.type, $.source).removeTile($)),
                        this.actor.registerMessageHandler("RS", (U, $) => M._(this, void 0, void 0, function*() {
                            if (!this.workerSources[U] || !this.workerSources[U][$.type] || !this.workerSources[U][$.type][$.source])
                                return;
                            const K = this.workerSources[U][$.type][$.source];
                            delete this.workerSources[U][$.type][$.source],
                            K.removeSource !== void 0 && K.removeSource($)
                        })),
                        this.actor.registerMessageHandler("RM", U => M._(this, void 0, void 0, function*() {
                            delete this.layerIndexes[U],
                            delete this.availableImages[U],
                            delete this.workerSources[U],
                            delete this.demWorkerSources[U]
                        })),
                        this.actor.registerMessageHandler("SR", (U, $) => M._(this, void 0, void 0, function*() {
                            this.referrer = $
                        })),
                        this.actor.registerMessageHandler("SRPS", (U, $) => this._syncRTLPluginState(U, $)),
                        this.actor.registerMessageHandler("IS", (U, $) => M._(this, void 0, void 0, function*() {
                            this.self.importScripts($)
                        })),
                        this.actor.registerMessageHandler("SI", (U, $) => this._setImages(U, $)),
                        this.actor.registerMessageHandler("UL", (U, $) => M._(this, void 0, void 0, function*() {
                            this._getLayerIndex(U).update($.layers, $.removedIds)
                        })),
                        this.actor.registerMessageHandler("SL", (U, $) => M._(this, void 0, void 0, function*() {
                            this._getLayerIndex(U).replace($)
                        }))
                    }
                    _setImages(E, U) {
                        return M._(this, void 0, void 0, function*() {
                            this.availableImages[E] = U;
                            for (const $ in this.workerSources[E]) {
                                const K = this.workerSources[E][$];
                                for (const re in K)
                                    K[re].availableImages = U
                            }
                        })
                    }
                    _syncRTLPluginState(E, U) {
                        return M._(this, void 0, void 0, function*() {
                            return yield M.cE.syncState(U, this.self.importScripts)
                        })
                    }
                    _getAvailableImages(E) {
                        let U = this.availableImages[E];
                        return U || (U = []),
                        U
                    }
                    _getLayerIndex(E) {
                        let U = this.layerIndexes[E];
                        return U || (U = this.layerIndexes[E] = new l),
                        U
                    }
                    _getWorkerSource(E, U, $) {
                        if (this.workerSources[E] || (this.workerSources[E] = {}),
                        this.workerSources[E][U] || (this.workerSources[E][U] = {}),
                        !this.workerSources[E][U][$]) {
                            const K = {
                                sendAsync: (re, he) => (re.targetMapId = E,
                                this.actor.sendAsync(re, he))
                            };
                            switch (U) {
                            case "vector":
                                this.workerSources[E][U][$] = new ze(K,this._getLayerIndex(E),this._getAvailableImages(E));
                                break;
                            case "geojson":
                                this.workerSources[E][U][$] = new to(K,this._getLayerIndex(E),this._getAvailableImages(E));
                                break;
                            default:
                                this.workerSources[E][U][$] = new this.externalWorkerSourceTypes[U](K,this._getLayerIndex(E),this._getAvailableImages(E))
                            }
                        }
                        return this.workerSources[E][U][$]
                    }
                    _getDEMWorkerSource(E, U) {
                        return this.demWorkerSources[E] || (this.demWorkerSources[E] = {}),
                        this.demWorkerSources[E][U] || (this.demWorkerSources[E][U] = new oe),
                        this.demWorkerSources[E][U]
                    }
                }
                return M.i(self) && (self.worker = new _n(self)),
                _n
            }),
            z("index", ["exports", "./shared"], function(M, l) {
                var ce = "5.2.0";
                function de() {
                    var u = new l.A(4);
                    return l.A != Float32Array && (u[1] = 0,
                    u[2] = 0),
                    u[0] = 1,
                    u[3] = 1,
                    u
                }
                let ge, ze;
                const oe = {
                    now: typeof performance < "u" && performance && performance.now ? performance.now.bind(performance) : Date.now.bind(Date),
                    frame(u, e, i) {
                        const o = requestAnimationFrame(h => {
                            a(),
                            e(h)
                        }
                        )
                          , {unsubscribe: a} = l.s(u.signal, "abort", () => {
                            a(),
                            cancelAnimationFrame(o),
                            i(l.c())
                        }
                        , !1)
                    },
                    frameAsync(u) {
                        return new Promise( (e, i) => {
                            this.frame(u, e, i)
                        }
                        )
                    },
                    getImageData(u, e=0) {
                        return this.getImageCanvasContext(u).getImageData(-e, -e, u.width + 2 * e, u.height + 2 * e)
                    },
                    getImageCanvasContext(u) {
                        const e = window.document.createElement("canvas")
                          , i = e.getContext("2d", {
                            willReadFrequently: !0
                        });
                        if (!i)
                            throw new Error("failed to create canvas 2d context");
                        return e.width = u.width,
                        e.height = u.height,
                        i.drawImage(u, 0, 0, u.width, u.height),
                        i
                    },
                    resolveURL: u => (ge || (ge = document.createElement("a")),
                    ge.href = u,
                    ge.href),
                    hardwareConcurrency: typeof navigator < "u" && navigator.hardwareConcurrency || 4,
                    get prefersReducedMotion() {
                        return !!matchMedia && (ze == null && (ze = matchMedia("(prefers-reduced-motion: reduce)")),
                        ze.matches)
                    }
                };
                class Y {
                    static testProp(e) {
                        if (!Y.docStyle)
                            return e[0];
                        for (let i = 0; i < e.length; i++)
                            if (e[i]in Y.docStyle)
                                return e[i];
                        return e[0]
                    }
                    static create(e, i, o) {
                        const a = window.document.createElement(e);
                        return i !== void 0 && (a.className = i),
                        o && o.appendChild(a),
                        a
                    }
                    static createNS(e, i) {
                        return window.document.createElementNS(e, i)
                    }
                    static disableDrag() {
                        Y.docStyle && Y.selectProp && (Y.userSelect = Y.docStyle[Y.selectProp],
                        Y.docStyle[Y.selectProp] = "none")
                    }
                    static enableDrag() {
                        Y.docStyle && Y.selectProp && (Y.docStyle[Y.selectProp] = Y.userSelect)
                    }
                    static setTransform(e, i) {
                        e.style[Y.transformProp] = i
                    }
                    static addEventListener(e, i, o, a={}) {
                        e.addEventListener(i, o, "passive"in a ? a : a.capture)
                    }
                    static removeEventListener(e, i, o, a={}) {
                        e.removeEventListener(i, o, "passive"in a ? a : a.capture)
                    }
                    static suppressClickInternal(e) {
                        e.preventDefault(),
                        e.stopPropagation(),
                        window.removeEventListener("click", Y.suppressClickInternal, !0)
                    }
                    static suppressClick() {
                        window.addEventListener("click", Y.suppressClickInternal, !0),
                        window.setTimeout( () => {
                            window.removeEventListener("click", Y.suppressClickInternal, !0)
                        }
                        , 0)
                    }
                    static getScale(e) {
                        const i = e.getBoundingClientRect();
                        return {
                            x: i.width / e.offsetWidth || 1,
                            y: i.height / e.offsetHeight || 1,
                            boundingClientRect: i
                        }
                    }
                    static getPoint(e, i, o) {
                        const a = i.boundingClientRect;
                        return new l.P((o.clientX - a.left) / i.x - e.clientLeft,(o.clientY - a.top) / i.y - e.clientTop)
                    }
                    static mousePos(e, i) {
                        const o = Y.getScale(e);
                        return Y.getPoint(e, o, i)
                    }
                    static touchPos(e, i) {
                        const o = []
                          , a = Y.getScale(e);
                        for (let h = 0; h < i.length; h++)
                            o.push(Y.getPoint(e, a, i[h]));
                        return o
                    }
                    static mouseButton(e) {
                        return e.button
                    }
                    static remove(e) {
                        e.parentNode && e.parentNode.removeChild(e)
                    }
                    static sanitize(e) {
                        const i = new DOMParser().parseFromString(e, "text/html").body || document.createElement("body")
                          , o = i.querySelectorAll("script");
                        for (const a of o)
                            a.remove();
                        return Y.clean(i),
                        i.innerHTML
                    }
                    static isPossiblyDangerous(e, i) {
                        const o = i.replace(/\s+/g, "").toLowerCase();
                        return !(!["src", "href", "xlink:href"].includes(e) || !o.includes("javascript:") && !o.includes("data:")) || !!e.startsWith("on") || void 0
                    }
                    static clean(e) {
                        const i = e.children;
                        for (const o of i)
                            Y.removeAttributes(o),
                            Y.clean(o)
                    }
                    static removeAttributes(e) {
                        for (const {name: i, value: o} of e.attributes)
                            Y.isPossiblyDangerous(i, o) && e.removeAttribute(i)
                    }
                }
                Y.docStyle = typeof window < "u" && window.document && window.document.documentElement.style,
                Y.selectProp = Y.testProp(["userSelect", "MozUserSelect", "WebkitUserSelect", "msUserSelect"]),
                Y.transformProp = Y.testProp(["transform", "WebkitTransform"]);
                const Te = {
                    supported: !1,
                    testSupport: function(u) {
                        !Pt && ft && (vt ? St(u) : He = u)
                    }
                };
                let He, ft, Pt = !1, vt = !1;
                function St(u) {
                    const e = u.createTexture();
                    u.bindTexture(u.TEXTURE_2D, e);
                    try {
                        if (u.texImage2D(u.TEXTURE_2D, 0, u.RGBA, u.RGBA, u.UNSIGNED_BYTE, ft),
                        u.isContextLost())
                            return;
                        Te.supported = !0
                    } catch {}
                    u.deleteTexture(e),
                    Pt = !0
                }
                var Wt;
                typeof document < "u" && (ft = document.createElement("img"),
                ft.onload = () => {
                    He && St(He),
                    He = null,
                    vt = !0
                }
                ,
                ft.onerror = () => {
                    Pt = !0,
                    He = null
                }
                ,
                ft.src = "data:image/webp;base64,UklGRh4AAABXRUJQVlA4TBEAAAAvAQAAAAfQ//73v/+BiOh/AAA="),
                function(u) {
                    let e, i, o, a;
                    u.resetRequestQueue = () => {
                        e = [],
                        i = 0,
                        o = 0,
                        a = {}
                    }
                    ,
                    u.addThrottleControl = v => {
                        const T = o++;
                        return a[T] = v,
                        T
                    }
                    ,
                    u.removeThrottleControl = v => {
                        delete a[v],
                        m()
                    }
                    ,
                    u.getImage = (v, T, S=!0) => new Promise( (A, k) => {
                        Te.supported && (v.headers || (v.headers = {}),
                        v.headers.accept = "image/webp,*/*"),
                        l.e(v, {
                            type: "image"
                        }),
                        e.push({
                            abortController: T,
                            requestParameters: v,
                            supportImageRefresh: S,
                            state: "queued",
                            onError: O => {
                                k(O)
                            }
                            ,
                            onSuccess: O => {
                                A(O)
                            }
                        }),
                        m()
                    }
                    );
                    const h = v => l._(this, void 0, void 0, function*() {
                        v.state = "running";
                        const {requestParameters: T, supportImageRefresh: S, onError: A, onSuccess: k, abortController: O} = v
                          , V = S === !1 && !l.i(self) && !l.g(T.url) && (!T.headers || Object.keys(T.headers).reduce( (W, J) => W && J === "accept", !0));
                        i++;
                        const H = V ? y(T, O) : l.m(T, O);
                        try {
                            const W = yield H;
                            delete v.abortController,
                            v.state = "completed",
                            W.data instanceof HTMLImageElement || l.b(W.data) ? k(W) : W.data && k({
                                data: yield(q = W.data,
                                typeof createImageBitmap == "function" ? l.f(q) : l.h(q)),
                                cacheControl: W.cacheControl,
                                expires: W.expires
                            })
                        } catch (W) {
                            delete v.abortController,
                            A(W)
                        } finally {
                            i--,
                            m()
                        }
                        var q
                    })
                      , m = () => {
                        const v = ( () => {
                            for (const T of Object.keys(a))
                                if (a[T]())
                                    return !0;
                            return !1
                        }
                        )() ? l.a.MAX_PARALLEL_IMAGE_REQUESTS_PER_FRAME : l.a.MAX_PARALLEL_IMAGE_REQUESTS;
                        for (let T = i; T < v && e.length > 0; T++) {
                            const S = e.shift();
                            S.abortController.signal.aborted ? T-- : h(S)
                        }
                    }
                      , y = (v, T) => new Promise( (S, A) => {
                        const k = new Image
                          , O = v.url
                          , V = v.credentials;
                        V && V === "include" ? k.crossOrigin = "use-credentials" : (V && V === "same-origin" || !l.d(O)) && (k.crossOrigin = "anonymous"),
                        T.signal.addEventListener("abort", () => {
                            k.src = "",
                            A(l.c())
                        }
                        ),
                        k.fetchPriority = "high",
                        k.onload = () => {
                            k.onerror = k.onload = null,
                            S({
                                data: k
                            })
                        }
                        ,
                        k.onerror = () => {
                            k.onerror = k.onload = null,
                            T.signal.aborted || A(new Error("Could not load image. Please make sure to use a supported image type such as PNG or JPEG. Note that SVGs are not supported."))
                        }
                        ,
                        k.src = O
                    }
                    )
                }(Wt || (Wt = {})),
                Wt.resetRequestQueue();
                class pi {
                    constructor(e) {
                        this._transformRequestFn = e
                    }
                    transformRequest(e, i) {
                        return this._transformRequestFn && this._transformRequestFn(e, i) || {
                            url: e
                        }
                    }
                    setTransformRequest(e) {
                        this._transformRequestFn = e
                    }
                }
                function Mt(u) {
                    const e = [];
                    if (typeof u == "string")
                        e.push({
                            id: "default",
                            url: u
                        });
                    else if (u && u.length > 0) {
                        const i = [];
                        for (const {id: o, url: a} of u) {
                            const h = `${o}${a}`;
                            i.indexOf(h) === -1 && (i.push(h),
                            e.push({
                                id: o,
                                url: a
                            }))
                        }
                    }
                    return e
                }
                function gt(u, e, i) {
                    try {
                        const o = new URL(u);
                        return o.pathname += `${e}${i}`,
                        o.toString()
                    } catch {
                        throw new Error(`Invalid sprite URL "${u}", must be absolute. Modify style specification directly or use TransformStyleFunction to correct the issue dynamically`)
                    }
                }
                class It {
                    constructor(e, i, o, a) {
                        this.context = e,
                        this.format = o,
                        this.texture = e.gl.createTexture(),
                        this.update(i, a)
                    }
                    update(e, i, o) {
                        const {width: a, height: h} = e
                          , m = !(this.size && this.size[0] === a && this.size[1] === h || o)
                          , {context: y} = this
                          , {gl: v} = y;
                        if (this.useMipmap = !!(i && i.useMipmap),
                        v.bindTexture(v.TEXTURE_2D, this.texture),
                        y.pixelStoreUnpackFlipY.set(!1),
                        y.pixelStoreUnpack.set(1),
                        y.pixelStoreUnpackPremultiplyAlpha.set(this.format === v.RGBA && (!i || i.premultiply !== !1)),
                        m)
                            this.size = [a, h],
                            e instanceof HTMLImageElement || e instanceof HTMLCanvasElement || e instanceof HTMLVideoElement || e instanceof ImageData || l.b(e) ? v.texImage2D(v.TEXTURE_2D, 0, this.format, this.format, v.UNSIGNED_BYTE, e) : v.texImage2D(v.TEXTURE_2D, 0, this.format, a, h, 0, this.format, v.UNSIGNED_BYTE, e.data);
                        else {
                            const {x: T, y: S} = o || {
                                x: 0,
                                y: 0
                            };
                            e instanceof HTMLImageElement || e instanceof HTMLCanvasElement || e instanceof HTMLVideoElement || e instanceof ImageData || l.b(e) ? v.texSubImage2D(v.TEXTURE_2D, 0, T, S, v.RGBA, v.UNSIGNED_BYTE, e) : v.texSubImage2D(v.TEXTURE_2D, 0, T, S, a, h, v.RGBA, v.UNSIGNED_BYTE, e.data)
                        }
                        this.useMipmap && this.isSizePowerOfTwo() && v.generateMipmap(v.TEXTURE_2D)
                    }
                    bind(e, i, o) {
                        const {context: a} = this
                          , {gl: h} = a;
                        h.bindTexture(h.TEXTURE_2D, this.texture),
                        o !== h.LINEAR_MIPMAP_NEAREST || this.isSizePowerOfTwo() || (o = h.LINEAR),
                        e !== this.filter && (h.texParameteri(h.TEXTURE_2D, h.TEXTURE_MAG_FILTER, e),
                        h.texParameteri(h.TEXTURE_2D, h.TEXTURE_MIN_FILTER, o || e),
                        this.filter = e),
                        i !== this.wrap && (h.texParameteri(h.TEXTURE_2D, h.TEXTURE_WRAP_S, i),
                        h.texParameteri(h.TEXTURE_2D, h.TEXTURE_WRAP_T, i),
                        this.wrap = i)
                    }
                    isSizePowerOfTwo() {
                        return this.size[0] === this.size[1] && Math.log(this.size[0]) / Math.LN2 % 1 == 0
                    }
                    destroy() {
                        const {gl: e} = this.context;
                        e.deleteTexture(this.texture),
                        this.texture = null
                    }
                }
                function Pi(u) {
                    const {userImage: e} = u;
                    return !!(e && e.render && e.render()) && (u.data.replace(new Uint8Array(e.data.buffer)),
                    !0)
                }
                class ei extends l.E {
                    constructor() {
                        super(),
                        this.images = {},
                        this.updatedImages = {},
                        this.callbackDispatchedThisFrame = {},
                        this.loaded = !1,
                        this.requestors = [],
                        this.patterns = {},
                        this.atlasImage = new l.R({
                            width: 1,
                            height: 1
                        }),
                        this.dirty = !0
                    }
                    isLoaded() {
                        return this.loaded
                    }
                    setLoaded(e) {
                        if (this.loaded !== e && (this.loaded = e,
                        e)) {
                            for (const {ids: i, promiseResolve: o} of this.requestors)
                                o(this._getImagesForIds(i));
                            this.requestors = []
                        }
                    }
                    getImage(e) {
                        const i = this.images[e];
                        if (i && !i.data && i.spriteData) {
                            const o = i.spriteData;
                            i.data = new l.R({
                                width: o.width,
                                height: o.height
                            },o.context.getImageData(o.x, o.y, o.width, o.height).data),
                            i.spriteData = null
                        }
                        return i
                    }
                    addImage(e, i) {
                        if (this.images[e])
                            throw new Error(`Image id ${e} already exist, use updateImage instead`);
                        this._validate(e, i) && (this.images[e] = i)
                    }
                    _validate(e, i) {
                        let o = !0;
                        const a = i.data || i.spriteData;
                        return this._validateStretch(i.stretchX, a && a.width) || (this.fire(new l.k(new Error(`Image "${e}" has invalid "stretchX" value`))),
                        o = !1),
                        this._validateStretch(i.stretchY, a && a.height) || (this.fire(new l.k(new Error(`Image "${e}" has invalid "stretchY" value`))),
                        o = !1),
                        this._validateContent(i.content, i) || (this.fire(new l.k(new Error(`Image "${e}" has invalid "content" value`))),
                        o = !1),
                        o
                    }
                    _validateStretch(e, i) {
                        if (!e)
                            return !0;
                        let o = 0;
                        for (const a of e) {
                            if (a[0] < o || a[1] < a[0] || i < a[1])
                                return !1;
                            o = a[1]
                        }
                        return !0
                    }
                    _validateContent(e, i) {
                        if (!e)
                            return !0;
                        if (e.length !== 4)
                            return !1;
                        const o = i.spriteData
                          , a = o && o.width || i.data.width
                          , h = o && o.height || i.data.height;
                        return !(e[0] < 0 || a < e[0] || e[1] < 0 || h < e[1] || e[2] < 0 || a < e[2] || e[3] < 0 || h < e[3] || e[2] < e[0] || e[3] < e[1])
                    }
                    updateImage(e, i, o=!0) {
                        const a = this.getImage(e);
                        if (o && (a.data.width !== i.data.width || a.data.height !== i.data.height))
                            throw new Error(`size mismatch between old image (${a.data.width}x${a.data.height}) and new image (${i.data.width}x${i.data.height}).`);
                        i.version = a.version + 1,
                        this.images[e] = i,
                        this.updatedImages[e] = !0
                    }
                    removeImage(e) {
                        const i = this.images[e];
                        delete this.images[e],
                        delete this.patterns[e],
                        i.userImage && i.userImage.onRemove && i.userImage.onRemove()
                    }
                    listImages() {
                        return Object.keys(this.images)
                    }
                    getImages(e) {
                        return new Promise( (i, o) => {
                            let a = !0;
                            if (!this.isLoaded())
                                for (const h of e)
                                    this.images[h] || (a = !1);
                            this.isLoaded() || a ? i(this._getImagesForIds(e)) : this.requestors.push({
                                ids: e,
                                promiseResolve: i
                            })
                        }
                        )
                    }
                    _getImagesForIds(e) {
                        const i = {};
                        for (const o of e) {
                            let a = this.getImage(o);
                            a || (this.fire(new l.l("styleimagemissing",{
                                id: o
                            })),
                            a = this.getImage(o)),
                            a ? i[o] = {
                                data: a.data.clone(),
                                pixelRatio: a.pixelRatio,
                                sdf: a.sdf,
                                version: a.version,
                                stretchX: a.stretchX,
                                stretchY: a.stretchY,
                                content: a.content,
                                textFitWidth: a.textFitWidth,
                                textFitHeight: a.textFitHeight,
                                hasRenderCallback: !!(a.userImage && a.userImage.render)
                            } : l.w(`Image "${o}" could not be loaded. Please make sure you have added the image with map.addImage() or a "sprite" property in your style. You can provide missing images by listening for the "styleimagemissing" map event.`)
                        }
                        return i
                    }
                    getPixelSize() {
                        const {width: e, height: i} = this.atlasImage;
                        return {
                            width: e,
                            height: i
                        }
                    }
                    getPattern(e) {
                        const i = this.patterns[e]
                          , o = this.getImage(e);
                        if (!o)
                            return null;
                        if (i && i.position.version === o.version)
                            return i.position;
                        if (i)
                            i.position.version = o.version;
                        else {
                            const a = {
                                w: o.data.width + 2,
                                h: o.data.height + 2,
                                x: 0,
                                y: 0
                            }
                              , h = new l.I(a,o);
                            this.patterns[e] = {
                                bin: a,
                                position: h
                            }
                        }
                        return this._updatePatternAtlas(),
                        this.patterns[e].position
                    }
                    bind(e) {
                        const i = e.gl;
                        this.atlasTexture ? this.dirty && (this.atlasTexture.update(this.atlasImage),
                        this.dirty = !1) : this.atlasTexture = new It(e,this.atlasImage,i.RGBA),
                        this.atlasTexture.bind(i.LINEAR, i.CLAMP_TO_EDGE)
                    }
                    _updatePatternAtlas() {
                        const e = [];
                        for (const h in this.patterns)
                            e.push(this.patterns[h].bin);
                        const {w: i, h: o} = l.p(e)
                          , a = this.atlasImage;
                        a.resize({
                            width: i || 1,
                            height: o || 1
                        });
                        for (const h in this.patterns) {
                            const {bin: m} = this.patterns[h]
                              , y = m.x + 1
                              , v = m.y + 1
                              , T = this.getImage(h).data
                              , S = T.width
                              , A = T.height;
                            l.R.copy(T, a, {
                                x: 0,
                                y: 0
                            }, {
                                x: y,
                                y: v
                            }, {
                                width: S,
                                height: A
                            }),
                            l.R.copy(T, a, {
                                x: 0,
                                y: A - 1
                            }, {
                                x: y,
                                y: v - 1
                            }, {
                                width: S,
                                height: 1
                            }),
                            l.R.copy(T, a, {
                                x: 0,
                                y: 0
                            }, {
                                x: y,
                                y: v + A
                            }, {
                                width: S,
                                height: 1
                            }),
                            l.R.copy(T, a, {
                                x: S - 1,
                                y: 0
                            }, {
                                x: y - 1,
                                y: v
                            }, {
                                width: 1,
                                height: A
                            }),
                            l.R.copy(T, a, {
                                x: 0,
                                y: 0
                            }, {
                                x: y + S,
                                y: v
                            }, {
                                width: 1,
                                height: A
                            })
                        }
                        this.dirty = !0
                    }
                    beginFrame() {
                        this.callbackDispatchedThisFrame = {}
                    }
                    dispatchRenderCallbacks(e) {
                        for (const i of e) {
                            if (this.callbackDispatchedThisFrame[i])
                                continue;
                            this.callbackDispatchedThisFrame[i] = !0;
                            const o = this.getImage(i);
                            o || l.w(`Image with ID: "${i}" was not found`),
                            Pi(o) && this.updateImage(i, o)
                        }
                    }
                }
                const nt = 1e20;
                function Wi(u, e, i, o, a, h, m, y, v) {
                    for (let T = e; T < e + o; T++)
                        Lt(u, i * h + T, h, a, m, y, v);
                    for (let T = i; T < i + a; T++)
                        Lt(u, T * h + e, 1, o, m, y, v)
                }
                function Lt(u, e, i, o, a, h, m) {
                    h[0] = 0,
                    m[0] = -1e20,
                    m[1] = nt,
                    a[0] = u[e];
                    for (let y = 1, v = 0, T = 0; y < o; y++) {
                        a[y] = u[e + y * i];
                        const S = y * y;
                        do {
                            const A = h[v];
                            T = (a[y] - a[A] + S - A * A) / (y - A) / 2
                        } while (T <= m[v] && --v > -1);
                        v++,
                        h[v] = y,
                        m[v] = T,
                        m[v + 1] = nt
                    }
                    for (let y = 0, v = 0; y < o; y++) {
                        for (; m[v + 1] < y; )
                            v++;
                        const T = h[v]
                          , S = y - T;
                        u[e + y * i] = a[T] + S * S
                    }
                }
                class ti {
                    constructor(e, i) {
                        this.requestManager = e,
                        this.localIdeographFontFamily = i,
                        this.entries = {}
                    }
                    setURL(e) {
                        this.url = e
                    }
                    getGlyphs(e) {
                        return l._(this, void 0, void 0, function*() {
                            const i = [];
                            for (const h in e)
                                for (const m of e[h])
                                    i.push(this._getAndCacheGlyphsPromise(h, m));
                            const o = yield Promise.all(i)
                              , a = {};
                            for (const {stack: h, id: m, glyph: y} of o)
                                a[h] || (a[h] = {}),
                                a[h][m] = y && {
                                    id: y.id,
                                    bitmap: y.bitmap.clone(),
                                    metrics: y.metrics
                                };
                            return a
                        })
                    }
                    _getAndCacheGlyphsPromise(e, i) {
                        return l._(this, void 0, void 0, function*() {
                            let o = this.entries[e];
                            o || (o = this.entries[e] = {
                                glyphs: {},
                                requests: {},
                                ranges: {}
                            });
                            let a = o.glyphs[i];
                            if (a !== void 0)
                                return {
                                    stack: e,
                                    id: i,
                                    glyph: a
                                };
                            if (a = this._tinySDF(o, e, i),
                            a)
                                return o.glyphs[i] = a,
                                {
                                    stack: e,
                                    id: i,
                                    glyph: a
                                };
                            const h = Math.floor(i / 256);
                            if (256 * h > 65535)
                                throw new Error("glyphs > 65535 not supported");
                            if (o.ranges[h])
                                return {
                                    stack: e,
                                    id: i,
                                    glyph: a
                                };
                            if (!this.url)
                                throw new Error("glyphsUrl is not set");
                            if (!o.requests[h]) {
                                const y = ti.loadGlyphRange(e, h, this.url, this.requestManager);
                                o.requests[h] = y
                            }
                            const m = yield o.requests[h];
                            for (const y in m)
                                this._doesCharSupportLocalGlyph(+y) || (o.glyphs[+y] = m[+y]);
                            return o.ranges[h] = !0,
                            {
                                stack: e,
                                id: i,
                                glyph: m[i] || null
                            }
                        })
                    }
                    _doesCharSupportLocalGlyph(e) {
                        return !!this.localIdeographFontFamily && (/\p{Ideo}|\p{sc=Hang}|\p{sc=Hira}|\p{sc=Kana}/u.test(String.fromCodePoint(e)) || l.u["CJK Unified Ideographs"](e) || l.u["Hangul Syllables"](e) || l.u.Hiragana(e) || l.u.Katakana(e) || l.u["CJK Symbols and Punctuation"](e) || l.u["Halfwidth and Fullwidth Forms"](e))
                    }
                    _tinySDF(e, i, o) {
                        const a = this.localIdeographFontFamily;
                        if (!a || !this._doesCharSupportLocalGlyph(o))
                            return;
                        let h = e.tinySDF;
                        if (!h) {
                            let y = "400";
                            /bold/i.test(i) ? y = "900" : /medium/i.test(i) ? y = "500" : /light/i.test(i) && (y = "200"),
                            h = e.tinySDF = new ti.TinySDF({
                                fontSize: 48,
                                buffer: 6,
                                radius: 16,
                                cutoff: .25,
                                fontFamily: a,
                                fontWeight: y
                            })
                        }
                        const m = h.draw(String.fromCharCode(o));
                        return {
                            id: o,
                            bitmap: new l.q({
                                width: m.width || 60,
                                height: m.height || 60
                            },m.data),
                            metrics: {
                                width: m.glyphWidth / 2 || 24,
                                height: m.glyphHeight / 2 || 24,
                                left: m.glyphLeft / 2 + .5 || 0,
                                top: m.glyphTop / 2 - 27.5 || -8,
                                advance: m.glyphAdvance / 2 || 24,
                                isDoubleResolution: !0
                            }
                        }
                    }
                }
                ti.loadGlyphRange = function(u, e, i, o) {
                    return l._(this, void 0, void 0, function*() {
                        const a = 256 * e
                          , h = a + 255
                          , m = o.transformRequest(i.replace("{fontstack}", u).replace("{range}", `${a}-${h}`), "Glyphs")
                          , y = yield l.n(m, new AbortController);
                        if (!y || !y.data)
                            throw new Error(`Could not load glyph range. range: ${e}, ${a}-${h}`);
                        const v = {};
                        for (const T of l.o(y.data))
                            v[T.id] = T;
                        return v
                    })
                }
                ,
                ti.TinySDF = class {
                    constructor({fontSize: u=24, buffer: e=3, radius: i=8, cutoff: o=.25, fontFamily: a="sans-serif", fontWeight: h="normal", fontStyle: m="normal"}={}) {
                        this.buffer = e,
                        this.cutoff = o,
                        this.radius = i;
                        const y = this.size = u + 4 * e
                          , v = this._createCanvas(y)
                          , T = this.ctx = v.getContext("2d", {
                            willReadFrequently: !0
                        });
                        T.font = `${m} ${h} ${u}px ${a}`,
                        T.textBaseline = "alphabetic",
                        T.textAlign = "left",
                        T.fillStyle = "black",
                        this.gridOuter = new Float64Array(y * y),
                        this.gridInner = new Float64Array(y * y),
                        this.f = new Float64Array(y),
                        this.z = new Float64Array(y + 1),
                        this.v = new Uint16Array(y)
                    }
                    _createCanvas(u) {
                        const e = document.createElement("canvas");
                        return e.width = e.height = u,
                        e
                    }
                    draw(u) {
                        const {width: e, actualBoundingBoxAscent: i, actualBoundingBoxDescent: o, actualBoundingBoxLeft: a, actualBoundingBoxRight: h} = this.ctx.measureText(u)
                          , m = Math.ceil(i)
                          , y = Math.max(0, Math.min(this.size - this.buffer, Math.ceil(h - a)))
                          , v = Math.min(this.size - this.buffer, m + Math.ceil(o))
                          , T = y + 2 * this.buffer
                          , S = v + 2 * this.buffer
                          , A = Math.max(T * S, 0)
                          , k = new Uint8ClampedArray(A)
                          , O = {
                            data: k,
                            width: T,
                            height: S,
                            glyphWidth: y,
                            glyphHeight: v,
                            glyphTop: m,
                            glyphLeft: 0,
                            glyphAdvance: e
                        };
                        if (y === 0 || v === 0)
                            return O;
                        const {ctx: V, buffer: H, gridInner: q, gridOuter: W} = this;
                        V.clearRect(H, H, y, v),
                        V.fillText(u, H, H + m);
                        const J = V.getImageData(H, H, y, v);
                        W.fill(nt, 0, A),
                        q.fill(0, 0, A);
                        for (let te = 0; te < v; te++)
                            for (let ie = 0; ie < y; ie++) {
                                const ne = J.data[4 * (te * y + ie) + 3] / 255;
                                if (ne === 0)
                                    continue;
                                const le = (te + H) * T + ie + H;
                                if (ne === 1)
                                    W[le] = 0,
                                    q[le] = nt;
                                else {
                                    const se = .5 - ne;
                                    W[le] = se > 0 ? se * se : 0,
                                    q[le] = se < 0 ? se * se : 0
                                }
                            }
                        Wi(W, 0, 0, T, S, T, this.f, this.v, this.z),
                        Wi(q, H, H, y, v, T, this.f, this.v, this.z);
                        for (let te = 0; te < A; te++) {
                            const ie = Math.sqrt(W[te]) - Math.sqrt(q[te]);
                            k[te] = Math.round(255 - 255 * (ie / this.radius + this.cutoff))
                        }
                        return O
                    }
                }
                ;
                class fi {
                    constructor() {
                        this.specification = l.v.light.position
                    }
                    possiblyEvaluate(e, i) {
                        return l.z(e.expression.evaluate(i))
                    }
                    interpolate(e, i, o) {
                        return {
                            x: l.B.number(e.x, i.x, o),
                            y: l.B.number(e.y, i.y, o),
                            z: l.B.number(e.z, i.z, o)
                        }
                    }
                }
                let ut;
                class or extends l.E {
                    constructor(e) {
                        super(),
                        ut = ut || new l.r({
                            anchor: new l.D(l.v.light.anchor),
                            position: new fi,
                            color: new l.D(l.v.light.color),
                            intensity: new l.D(l.v.light.intensity)
                        }),
                        this._transitionable = new l.T(ut),
                        this.setLight(e),
                        this._transitioning = this._transitionable.untransitioned()
                    }
                    getLight() {
                        return this._transitionable.serialize()
                    }
                    setLight(e, i={}) {
                        if (!this._validate(l.t, e, i))
                            for (const o in e) {
                                const a = e[o];
                                o.endsWith("-transition") ? this._transitionable.setTransition(o.slice(0, -11), a) : this._transitionable.setValue(o, a)
                            }
                    }
                    updateTransitions(e) {
                        this._transitioning = this._transitionable.transitioned(e, this._transitioning)
                    }
                    hasTransition() {
                        return this._transitioning.hasTransition()
                    }
                    recalculate(e) {
                        this.properties = this._transitioning.possiblyEvaluate(e)
                    }
                    _validate(e, i, o) {
                        return (!o || o.validate !== !1) && l.x(this, e.call(l.y, {
                            value: i,
                            style: {
                                glyphs: !0,
                                sprite: !0
                            },
                            styleSpec: l.v
                        }))
                    }
                }
                const ar = new l.r({
                    "sky-color": new l.D(l.v.sky["sky-color"]),
                    "horizon-color": new l.D(l.v.sky["horizon-color"]),
                    "fog-color": new l.D(l.v.sky["fog-color"]),
                    "fog-ground-blend": new l.D(l.v.sky["fog-ground-blend"]),
                    "horizon-fog-blend": new l.D(l.v.sky["horizon-fog-blend"]),
                    "sky-horizon-blend": new l.D(l.v.sky["sky-horizon-blend"]),
                    "atmosphere-blend": new l.D(l.v.sky["atmosphere-blend"])
                });
                class mi extends l.E {
                    constructor(e) {
                        super(),
                        this._transitionable = new l.T(ar),
                        this.setSky(e),
                        this._transitioning = this._transitionable.untransitioned(),
                        this.recalculate(new l.C(0))
                    }
                    setSky(e, i={}) {
                        if (!this._validate(l.F, e, i)) {
                            e || (e = {
                                "sky-color": "transparent",
                                "horizon-color": "transparent",
                                "fog-color": "transparent",
                                "fog-ground-blend": 1,
                                "atmosphere-blend": 0
                            });
                            for (const o in e) {
                                const a = e[o];
                                o.endsWith("-transition") ? this._transitionable.setTransition(o.slice(0, -11), a) : this._transitionable.setValue(o, a)
                            }
                        }
                    }
                    getSky() {
                        return this._transitionable.serialize()
                    }
                    updateTransitions(e) {
                        this._transitioning = this._transitionable.transitioned(e, this._transitioning)
                    }
                    hasTransition() {
                        return this._transitioning.hasTransition()
                    }
                    recalculate(e) {
                        this.properties = this._transitioning.possiblyEvaluate(e)
                    }
                    _validate(e, i, o={}) {
                        return o?.validate !== !1 && l.x(this, e.call(l.y, l.e({
                            value: i,
                            style: {
                                glyphs: !0,
                                sprite: !0
                            },
                            styleSpec: l.v
                        })))
                    }
                    calculateFogBlendOpacity(e) {
                        return e < 60 ? 0 : e < 70 ? (e - 60) / 10 : 1
                    }
                }
                class wr {
                    constructor(e, i) {
                        this.width = e,
                        this.height = i,
                        this.nextRow = 0,
                        this.data = new Uint8Array(this.width * this.height),
                        this.dashEntry = {}
                    }
                    getDash(e, i) {
                        const o = e.join(",") + String(i);
                        return this.dashEntry[o] || (this.dashEntry[o] = this.addDash(e, i)),
                        this.dashEntry[o]
                    }
                    getDashRanges(e, i, o) {
                        const a = [];
                        let h = e.length % 2 == 1 ? -e[e.length - 1] * o : 0
                          , m = e[0] * o
                          , y = !0;
                        a.push({
                            left: h,
                            right: m,
                            isDash: y,
                            zeroLength: e[0] === 0
                        });
                        let v = e[0];
                        for (let T = 1; T < e.length; T++) {
                            y = !y;
                            const S = e[T];
                            h = v * o,
                            v += S,
                            m = v * o,
                            a.push({
                                left: h,
                                right: m,
                                isDash: y,
                                zeroLength: S === 0
                            })
                        }
                        return a
                    }
                    addRoundDash(e, i, o) {
                        const a = i / 2;
                        for (let h = -o; h <= o; h++) {
                            const m = this.width * (this.nextRow + o + h);
                            let y = 0
                              , v = e[y];
                            for (let T = 0; T < this.width; T++) {
                                T / v.right > 1 && (v = e[++y]);
                                const S = Math.abs(T - v.left)
                                  , A = Math.abs(T - v.right)
                                  , k = Math.min(S, A);
                                let O;
                                const V = h / o * (a + 1);
                                if (v.isDash) {
                                    const H = a - Math.abs(V);
                                    O = Math.sqrt(k * k + H * H)
                                } else
                                    O = a - Math.sqrt(k * k + V * V);
                                this.data[m + T] = Math.max(0, Math.min(255, O + 128))
                            }
                        }
                    }
                    addRegularDash(e) {
                        for (let y = e.length - 1; y >= 0; --y) {
                            const v = e[y]
                              , T = e[y + 1];
                            v.zeroLength ? e.splice(y, 1) : T && T.isDash === v.isDash && (T.left = v.left,
                            e.splice(y, 1))
                        }
                        const i = e[0]
                          , o = e[e.length - 1];
                        i.isDash === o.isDash && (i.left = o.left - this.width,
                        o.right = i.right + this.width);
                        const a = this.width * this.nextRow;
                        let h = 0
                          , m = e[h];
                        for (let y = 0; y < this.width; y++) {
                            y / m.right > 1 && (m = e[++h]);
                            const v = Math.abs(y - m.left)
                              , T = Math.abs(y - m.right)
                              , S = Math.min(v, T);
                            this.data[a + y] = Math.max(0, Math.min(255, (m.isDash ? S : -S) + 128))
                        }
                    }
                    addDash(e, i) {
                        const o = i ? 7 : 0
                          , a = 2 * o + 1;
                        if (this.nextRow + a > this.height)
                            return l.w("LineAtlas out of space"),
                            null;
                        let h = 0;
                        for (let y = 0; y < e.length; y++)
                            h += e[y];
                        if (h !== 0) {
                            const y = this.width / h
                              , v = this.getDashRanges(e, this.width, y);
                            i ? this.addRoundDash(v, y, o) : this.addRegularDash(v)
                        }
                        const m = {
                            y: (this.nextRow + o + .5) / this.height,
                            height: 2 * o / this.height,
                            width: h
                        };
                        return this.nextRow += a,
                        this.dirty = !0,
                        m
                    }
                    bind(e) {
                        const i = e.gl;
                        this.texture ? (i.bindTexture(i.TEXTURE_2D, this.texture),
                        this.dirty && (this.dirty = !1,
                        i.texSubImage2D(i.TEXTURE_2D, 0, 0, 0, this.width, this.height, i.ALPHA, i.UNSIGNED_BYTE, this.data))) : (this.texture = i.createTexture(),
                        i.bindTexture(i.TEXTURE_2D, this.texture),
                        i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_S, i.REPEAT),
                        i.texParameteri(i.TEXTURE_2D, i.TEXTURE_WRAP_T, i.REPEAT),
                        i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MIN_FILTER, i.LINEAR),
                        i.texParameteri(i.TEXTURE_2D, i.TEXTURE_MAG_FILTER, i.LINEAR),
                        i.texImage2D(i.TEXTURE_2D, 0, i.ALPHA, this.width, this.height, 0, i.ALPHA, i.UNSIGNED_BYTE, this.data))
                    }
                }
                const Br = "maplibre_preloaded_worker_pool";
                class gi {
                    constructor() {
                        this.active = {}
                    }
                    acquire(e) {
                        if (!this.workers)
                            for (this.workers = []; this.workers.length < gi.workerCount; )
                                this.workers.push(new Worker(l.a.WORKER_URL));
                        return this.active[e] = !0,
                        this.workers.slice()
                    }
                    release(e) {
                        delete this.active[e],
                        this.numActive() === 0 && (this.workers.forEach(i => {
                            i.terminate()
                        }
                        ),
                        this.workers = null)
                    }
                    isPreloaded() {
                        return !!this.active[Br]
                    }
                    numActive() {
                        return Object.keys(this.active).length
                    }
                }
                const si = Math.floor(oe.hardwareConcurrency / 2);
                let _i, Ft;
                function Yi() {
                    return _i || (_i = new gi),
                    _i
                }
                gi.workerCount = l.G(globalThis) ? Math.max(Math.min(si, 3), 1) : 1;
                class Xi {
                    constructor(e, i) {
                        this.workerPool = e,
                        this.actors = [],
                        this.currentActor = 0,
                        this.id = i;
                        const o = this.workerPool.acquire(i);
                        for (let a = 0; a < o.length; a++) {
                            const h = new l.H(o[a],i);
                            h.name = `Worker ${a}`,
                            this.actors.push(h)
                        }
                        if (!this.actors.length)
                            throw new Error("No actors found")
                    }
                    broadcast(e, i) {
                        const o = [];
                        for (const a of this.actors)
                            o.push(a.sendAsync({
                                type: e,
                                data: i
                            }));
                        return Promise.all(o)
                    }
                    getActor() {
                        return this.currentActor = (this.currentActor + 1) % this.actors.length,
                        this.actors[this.currentActor]
                    }
                    remove(e=!0) {
                        this.actors.forEach(i => {
                            i.remove()
                        }
                        ),
                        this.actors = [],
                        e && this.workerPool.release(this.id)
                    }
                    registerMessageHandler(e, i) {
                        for (const o of this.actors)
                            o.registerMessageHandler(e, i)
                    }
                }
                function en() {
                    return Ft || (Ft = new Xi(Yi(),l.J),
                    Ft.registerMessageHandler("GR", (u, e, i) => l.m(e, i))),
                    Ft
                }
                function Vi(u, e) {
                    const i = l.K();
                    return l.L(i, i, [1, 1, 0]),
                    l.M(i, i, [.5 * u.width, .5 * u.height, 1]),
                    u.calculatePosMatrix ? l.N(i, i, u.calculatePosMatrix(e.toUnwrapped())) : i
                }
                function Hn(u, e, i, o, a, h) {
                    var m;
                    const y = function(A, k, O) {
                        if (A)
                            for (const V of A) {
                                const H = k[V];
                                if (H && H.source === O && H.type === "fill-extrusion")
                                    return !0
                            }
                        else
                            for (const V in k) {
                                const H = k[V];
                                if (H.source === O && H.type === "fill-extrusion")
                                    return !0
                            }
                        return !1
                    }((m = a?.layers) !== null && m !== void 0 ? m : null, e, u.id)
                      , v = h.maxPitchScaleFactor()
                      , T = u.tilesIn(o, v, y);
                    T.sort(yi);
                    const S = [];
                    for (const A of T)
                        S.push({
                            wrappedTileID: A.tileID.wrapped().key,
                            queryResults: A.tile.queryRenderedFeatures(e, i, u._state, A.queryGeometry, A.cameraQueryGeometry, A.scale, a, h, v, Vi(u.transform, A.tileID))
                        });
                    return function(A, k) {
                        for (const O in A)
                            for (const V of A[O])
                                ii(V, k);
                        return A
                    }(function(A) {
                        const k = {}
                          , O = {};
                        for (const V of A) {
                            const H = V.queryResults
                              , q = V.wrappedTileID
                              , W = O[q] = O[q] || {};
                            for (const J in H) {
                                const te = H[J]
                                  , ie = W[J] = W[J] || {}
                                  , ne = k[J] = k[J] || [];
                                for (const le of te)
                                    ie[le.featureIndex] || (ie[le.featureIndex] = !0,
                                    ne.push(le))
                            }
                        }
                        return k
                    }(S), u)
                }
                function yi(u, e) {
                    const i = u.tileID
                      , o = e.tileID;
                    return i.overscaledZ - o.overscaledZ || i.canonical.y - o.canonical.y || i.wrap - o.wrap || i.canonical.x - o.canonical.x
                }
                function ii(u, e) {
                    const i = u.feature
                      , o = e.getFeatureState(i.layer["source-layer"], i.id);
                    i.source = i.layer.source,
                    i.layer["source-layer"] && (i.sourceLayer = i.layer["source-layer"]),
                    i.state = o
                }
                function Tr(u, e, i) {
                    return l._(this, void 0, void 0, function*() {
                        let o = u;
                        if (u.url ? o = (yield l.j(e.transformRequest(u.url, "Source"), i)).data : yield oe.frameAsync(i),
                        !o)
                            return null;
                        const a = l.O(l.e(o, u), ["tiles", "minzoom", "maxzoom", "attribution", "bounds", "scheme", "tileSize", "encoding"]);
                        return "vector_layers"in o && o.vector_layers && (a.vectorLayerIds = o.vector_layers.map(h => h.id)),
                        a
                    })
                }
                class oi {
                    constructor(e, i) {
                        e && (i ? this.setSouthWest(e).setNorthEast(i) : Array.isArray(e) && (e.length === 4 ? this.setSouthWest([e[0], e[1]]).setNorthEast([e[2], e[3]]) : this.setSouthWest(e[0]).setNorthEast(e[1])))
                    }
                    setNorthEast(e) {
                        return this._ne = e instanceof l.Q ? new l.Q(e.lng,e.lat) : l.Q.convert(e),
                        this
                    }
                    setSouthWest(e) {
                        return this._sw = e instanceof l.Q ? new l.Q(e.lng,e.lat) : l.Q.convert(e),
                        this
                    }
                    extend(e) {
                        const i = this._sw
                          , o = this._ne;
                        let a, h;
                        if (e instanceof l.Q)
                            a = e,
                            h = e;
                        else {
                            if (!(e instanceof oi))
                                return Array.isArray(e) ? e.length === 4 || e.every(Array.isArray) ? this.extend(oi.convert(e)) : this.extend(l.Q.convert(e)) : e && ("lng"in e || "lon"in e) && "lat"in e ? this.extend(l.Q.convert(e)) : this;
                            if (a = e._sw,
                            h = e._ne,
                            !a || !h)
                                return this
                        }
                        return i || o ? (i.lng = Math.min(a.lng, i.lng),
                        i.lat = Math.min(a.lat, i.lat),
                        o.lng = Math.max(h.lng, o.lng),
                        o.lat = Math.max(h.lat, o.lat)) : (this._sw = new l.Q(a.lng,a.lat),
                        this._ne = new l.Q(h.lng,h.lat)),
                        this
                    }
                    getCenter() {
                        return new l.Q((this._sw.lng + this._ne.lng) / 2,(this._sw.lat + this._ne.lat) / 2)
                    }
                    getSouthWest() {
                        return this._sw
                    }
                    getNorthEast() {
                        return this._ne
                    }
                    getNorthWest() {
                        return new l.Q(this.getWest(),this.getNorth())
                    }
                    getSouthEast() {
                        return new l.Q(this.getEast(),this.getSouth())
                    }
                    getWest() {
                        return this._sw.lng
                    }
                    getSouth() {
                        return this._sw.lat
                    }
                    getEast() {
                        return this._ne.lng
                    }
                    getNorth() {
                        return this._ne.lat
                    }
                    toArray() {
                        return [this._sw.toArray(), this._ne.toArray()]
                    }
                    toString() {
                        return `LngLatBounds(${this._sw.toString()}, ${this._ne.toString()})`
                    }
                    isEmpty() {
                        return !(this._sw && this._ne)
                    }
                    contains(e) {
                        const {lng: i, lat: o} = l.Q.convert(e);
                        let a = this._sw.lng <= i && i <= this._ne.lng;
                        return this._sw.lng > this._ne.lng && (a = this._sw.lng >= i && i >= this._ne.lng),
                        this._sw.lat <= o && o <= this._ne.lat && a
                    }
                    static convert(e) {
                        return e instanceof oi ? e : e && new oi(e)
                    }
                    static fromLngLat(e, i=0) {
                        const o = 360 * i / 40075017
                          , a = o / Math.cos(Math.PI / 180 * e.lat);
                        return new oi(new l.Q(e.lng - a,e.lat - o),new l.Q(e.lng + a,e.lat + o))
                    }
                    adjustAntiMeridian() {
                        const e = new l.Q(this._sw.lng,this._sw.lat)
                          , i = new l.Q(this._ne.lng,this._ne.lat);
                        return new oi(e,e.lng > i.lng ? new l.Q(i.lng + 360,i.lat) : i)
                    }
                }
                class Wn {
                    constructor(e, i, o) {
                        this.bounds = oi.convert(this.validateBounds(e)),
                        this.minzoom = i || 0,
                        this.maxzoom = o || 24
                    }
                    validateBounds(e) {
                        return Array.isArray(e) && e.length === 4 ? [Math.max(-180, e[0]), Math.max(-90, e[1]), Math.min(180, e[2]), Math.min(90, e[3])] : [-180, -90, 180, 90]
                    }
                    contains(e) {
                        const i = Math.pow(2, e.z)
                          , o = Math.floor(l.U(this.bounds.getWest()) * i)
                          , a = Math.floor(l.S(this.bounds.getNorth()) * i)
                          , h = Math.ceil(l.U(this.bounds.getEast()) * i)
                          , m = Math.ceil(l.S(this.bounds.getSouth()) * i);
                        return e.x >= o && e.x < h && e.y >= a && e.y < m
                    }
                }
                class Xn extends l.E {
                    constructor(e, i, o, a) {
                        if (super(),
                        this.id = e,
                        this.dispatcher = o,
                        this.type = "vector",
                        this.minzoom = 0,
                        this.maxzoom = 22,
                        this.scheme = "xyz",
                        this.tileSize = 512,
                        this.reparseOverscaled = !0,
                        this.isTileClipped = !0,
                        this._loaded = !1,
                        l.e(this, l.O(i, ["url", "scheme", "tileSize", "promoteId"])),
                        this._options = l.e({
                            type: "vector"
                        }, i),
                        this._collectResourceTiming = i.collectResourceTiming,
                        this.tileSize !== 512)
                            throw new Error("vector tile sources must have a tileSize of 512");
                        this.setEventedParent(a)
                    }
                    load() {
                        return l._(this, void 0, void 0, function*() {
                            this._loaded = !1,
                            this.fire(new l.l("dataloading",{
                                dataType: "source"
                            })),
                            this._tileJSONRequest = new AbortController;
                            try {
                                const e = yield Tr(this._options, this.map._requestManager, this._tileJSONRequest);
                                this._tileJSONRequest = null,
                                this._loaded = !0,
                                this.map.style.sourceCaches[this.id].clearTiles(),
                                e && (l.e(this, e),
                                e.bounds && (this.tileBounds = new Wn(e.bounds,this.minzoom,this.maxzoom)),
                                this.fire(new l.l("data",{
                                    dataType: "source",
                                    sourceDataType: "metadata"
                                })),
                                this.fire(new l.l("data",{
                                    dataType: "source",
                                    sourceDataType: "content"
                                })))
                            } catch (e) {
                                this._tileJSONRequest = null,
                                this.fire(new l.k(e))
                            }
                        })
                    }
                    loaded() {
                        return this._loaded
                    }
                    hasTile(e) {
                        return !this.tileBounds || this.tileBounds.contains(e.canonical)
                    }
                    onAdd(e) {
                        this.map = e,
                        this.load()
                    }
                    setSourceProperty(e) {
                        this._tileJSONRequest && this._tileJSONRequest.abort(),
                        e(),
                        this.load()
                    }
                    setTiles(e) {
                        return this.setSourceProperty( () => {
                            this._options.tiles = e
                        }
                        ),
                        this
                    }
                    setUrl(e) {
                        return this.setSourceProperty( () => {
                            this.url = e,
                            this._options.url = e
                        }
                        ),
                        this
                    }
                    onRemove() {
                        this._tileJSONRequest && (this._tileJSONRequest.abort(),
                        this._tileJSONRequest = null)
                    }
                    serialize() {
                        return l.e({}, this._options)
                    }
                    loadTile(e) {
                        return l._(this, void 0, void 0, function*() {
                            const i = e.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme)
                              , o = {
                                request: this.map._requestManager.transformRequest(i, "Tile"),
                                uid: e.uid,
                                tileID: e.tileID,
                                zoom: e.tileID.overscaledZ,
                                tileSize: this.tileSize * e.tileID.overscaleFactor(),
                                type: this.type,
                                source: this.id,
                                pixelRatio: this.map.getPixelRatio(),
                                showCollisionBoxes: this.map.showCollisionBoxes,
                                promoteId: this.promoteId,
                                subdivisionGranularity: this.map.style.projection.subdivisionGranularity
                            };
                            o.request.collectResourceTiming = this._collectResourceTiming;
                            let a = "RT";
                            if (e.actor && e.state !== "expired") {
                                if (e.state === "loading")
                                    return new Promise( (h, m) => {
                                        e.reloadPromise = {
                                            resolve: h,
                                            reject: m
                                        }
                                    }
                                    )
                            } else
                                e.actor = this.dispatcher.getActor(),
                                a = "LT";
                            e.abortController = new AbortController;
                            try {
                                const h = yield e.actor.sendAsync({
                                    type: a,
                                    data: o
                                }, e.abortController);
                                if (delete e.abortController,
                                e.aborted)
                                    return;
                                this._afterTileLoadWorkerResponse(e, h)
                            } catch (h) {
                                if (delete e.abortController,
                                e.aborted)
                                    return;
                                if (h && h.status !== 404)
                                    throw h;
                                this._afterTileLoadWorkerResponse(e, null)
                            }
                        })
                    }
                    _afterTileLoadWorkerResponse(e, i) {
                        if (i && i.resourceTiming && (e.resourceTiming = i.resourceTiming),
                        i && this.map._refreshExpiredTiles && e.setExpiryData(i),
                        e.loadVectorData(i, this.map.painter),
                        e.reloadPromise) {
                            const o = e.reloadPromise;
                            e.reloadPromise = null,
                            this.loadTile(e).then(o.resolve).catch(o.reject)
                        }
                    }
                    abortTile(e) {
                        return l._(this, void 0, void 0, function*() {
                            e.abortController && (e.abortController.abort(),
                            delete e.abortController),
                            e.actor && (yield e.actor.sendAsync({
                                type: "AT",
                                data: {
                                    uid: e.uid,
                                    type: this.type,
                                    source: this.id
                                }
                            }))
                        })
                    }
                    unloadTile(e) {
                        return l._(this, void 0, void 0, function*() {
                            e.unloadVectorData(),
                            e.actor && (yield e.actor.sendAsync({
                                type: "RMT",
                                data: {
                                    uid: e.uid,
                                    type: this.type,
                                    source: this.id
                                }
                            }))
                        })
                    }
                    hasTransition() {
                        return !1
                    }
                }
                class Or extends l.E {
                    constructor(e, i, o, a) {
                        super(),
                        this.id = e,
                        this.dispatcher = o,
                        this.setEventedParent(a),
                        this.type = "raster",
                        this.minzoom = 0,
                        this.maxzoom = 22,
                        this.roundZoom = !0,
                        this.scheme = "xyz",
                        this.tileSize = 512,
                        this._loaded = !1,
                        this._options = l.e({
                            type: "raster"
                        }, i),
                        l.e(this, l.O(i, ["url", "scheme", "tileSize"]))
                    }
                    load() {
                        return l._(this, arguments, void 0, function*(e=!1) {
                            this._loaded = !1,
                            this.fire(new l.l("dataloading",{
                                dataType: "source"
                            })),
                            this._tileJSONRequest = new AbortController;
                            try {
                                const i = yield Tr(this._options, this.map._requestManager, this._tileJSONRequest);
                                this._tileJSONRequest = null,
                                this._loaded = !0,
                                i && (l.e(this, i),
                                i.bounds && (this.tileBounds = new Wn(i.bounds,this.minzoom,this.maxzoom)),
                                this.fire(new l.l("data",{
                                    dataType: "source",
                                    sourceDataType: "metadata"
                                })),
                                this.fire(new l.l("data",{
                                    dataType: "source",
                                    sourceDataType: "content",
                                    sourceDataChanged: e
                                })))
                            } catch (i) {
                                this._tileJSONRequest = null,
                                this.fire(new l.k(i))
                            }
                        })
                    }
                    loaded() {
                        return this._loaded
                    }
                    onAdd(e) {
                        this.map = e,
                        this.load()
                    }
                    onRemove() {
                        this._tileJSONRequest && (this._tileJSONRequest.abort(),
                        this._tileJSONRequest = null)
                    }
                    setSourceProperty(e) {
                        this._tileJSONRequest && (this._tileJSONRequest.abort(),
                        this._tileJSONRequest = null),
                        e(),
                        this.load(!0)
                    }
                    setTiles(e) {
                        return this.setSourceProperty( () => {
                            this._options.tiles = e
                        }
                        ),
                        this
                    }
                    setUrl(e) {
                        return this.setSourceProperty( () => {
                            this.url = e,
                            this._options.url = e
                        }
                        ),
                        this
                    }
                    serialize() {
                        return l.e({}, this._options)
                    }
                    hasTile(e) {
                        return !this.tileBounds || this.tileBounds.contains(e.canonical)
                    }
                    loadTile(e) {
                        return l._(this, void 0, void 0, function*() {
                            const i = e.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme);
                            e.abortController = new AbortController;
                            try {
                                const o = yield Wt.getImage(this.map._requestManager.transformRequest(i, "Tile"), e.abortController, this.map._refreshExpiredTiles);
                                if (delete e.abortController,
                                e.aborted)
                                    return void (e.state = "unloaded");
                                if (o && o.data) {
                                    this.map._refreshExpiredTiles && o.cacheControl && o.expires && e.setExpiryData({
                                        cacheControl: o.cacheControl,
                                        expires: o.expires
                                    });
                                    const a = this.map.painter.context
                                      , h = a.gl
                                      , m = o.data;
                                    e.texture = this.map.painter.getTileTexture(m.width),
                                    e.texture ? e.texture.update(m, {
                                        useMipmap: !0
                                    }) : (e.texture = new It(a,m,h.RGBA,{
                                        useMipmap: !0
                                    }),
                                    e.texture.bind(h.LINEAR, h.CLAMP_TO_EDGE, h.LINEAR_MIPMAP_NEAREST)),
                                    e.state = "loaded"
                                }
                            } catch (o) {
                                if (delete e.abortController,
                                e.aborted)
                                    e.state = "unloaded";
                                else if (o)
                                    throw e.state = "errored",
                                    o
                            }
                        })
                    }
                    abortTile(e) {
                        return l._(this, void 0, void 0, function*() {
                            e.abortController && (e.abortController.abort(),
                            delete e.abortController)
                        })
                    }
                    unloadTile(e) {
                        return l._(this, void 0, void 0, function*() {
                            e.texture && this.map.painter.saveTileTexture(e.texture)
                        })
                    }
                    hasTransition() {
                        return !1
                    }
                }
                class zn extends Or {
                    constructor(e, i, o, a) {
                        super(e, i, o, a),
                        this.type = "raster-dem",
                        this.maxzoom = 22,
                        this._options = l.e({
                            type: "raster-dem"
                        }, i),
                        this.encoding = i.encoding || "mapbox",
                        this.redFactor = i.redFactor,
                        this.greenFactor = i.greenFactor,
                        this.blueFactor = i.blueFactor,
                        this.baseShift = i.baseShift
                    }
                    loadTile(e) {
                        return l._(this, void 0, void 0, function*() {
                            const i = e.tileID.canonical.url(this.tiles, this.map.getPixelRatio(), this.scheme)
                              , o = this.map._requestManager.transformRequest(i, "Tile");
                            e.neighboringTiles = this._getNeighboringTiles(e.tileID),
                            e.abortController = new AbortController;
                            try {
                                const a = yield Wt.getImage(o, e.abortController, this.map._refreshExpiredTiles);
                                if (delete e.abortController,
                                e.aborted)
                                    return void (e.state = "unloaded");
                                if (a && a.data) {
                                    const h = a.data;
                                    this.map._refreshExpiredTiles && a.cacheControl && a.expires && e.setExpiryData({
                                        cacheControl: a.cacheControl,
                                        expires: a.expires
                                    });
                                    const m = l.b(h) && l.V() ? h : yield this.readImageNow(h)
                                      , y = {
                                        type: this.type,
                                        uid: e.uid,
                                        source: this.id,
                                        rawImageData: m,
                                        encoding: this.encoding,
                                        redFactor: this.redFactor,
                                        greenFactor: this.greenFactor,
                                        blueFactor: this.blueFactor,
                                        baseShift: this.baseShift
                                    };
                                    if (!e.actor || e.state === "expired") {
                                        e.actor = this.dispatcher.getActor();
                                        const v = yield e.actor.sendAsync({
                                            type: "LDT",
                                            data: y
                                        });
                                        e.dem = v,
                                        e.needsHillshadePrepare = !0,
                                        e.needsTerrainPrepare = !0,
                                        e.state = "loaded"
                                    }
                                }
                            } catch (a) {
                                if (delete e.abortController,
                                e.aborted)
                                    e.state = "unloaded";
                                else if (a)
                                    throw e.state = "errored",
                                    a
                            }
                        })
                    }
                    readImageNow(e) {
                        return l._(this, void 0, void 0, function*() {
                            if (typeof VideoFrame < "u" && l.W()) {
                                const i = e.width + 2
                                  , o = e.height + 2;
                                try {
                                    return new l.R({
                                        width: i,
                                        height: o
                                    },yield l.X(e, -1, -1, i, o))
                                } catch {}
                            }
                            return oe.getImageData(e, 1)
                        })
                    }
                    _getNeighboringTiles(e) {
                        const i = e.canonical
                          , o = Math.pow(2, i.z)
                          , a = (i.x - 1 + o) % o
                          , h = i.x === 0 ? e.wrap - 1 : e.wrap
                          , m = (i.x + 1 + o) % o
                          , y = i.x + 1 === o ? e.wrap + 1 : e.wrap
                          , v = {};
                        return v[new l.Y(e.overscaledZ,h,i.z,a,i.y).key] = {
                            backfilled: !1
                        },
                        v[new l.Y(e.overscaledZ,y,i.z,m,i.y).key] = {
                            backfilled: !1
                        },
                        i.y > 0 && (v[new l.Y(e.overscaledZ,h,i.z,a,i.y - 1).key] = {
                            backfilled: !1
                        },
                        v[new l.Y(e.overscaledZ,e.wrap,i.z,i.x,i.y - 1).key] = {
                            backfilled: !1
                        },
                        v[new l.Y(e.overscaledZ,y,i.z,m,i.y - 1).key] = {
                            backfilled: !1
                        }),
                        i.y + 1 < o && (v[new l.Y(e.overscaledZ,h,i.z,a,i.y + 1).key] = {
                            backfilled: !1
                        },
                        v[new l.Y(e.overscaledZ,e.wrap,i.z,i.x,i.y + 1).key] = {
                            backfilled: !1
                        },
                        v[new l.Y(e.overscaledZ,y,i.z,m,i.y + 1).key] = {
                            backfilled: !1
                        }),
                        v
                    }
                    unloadTile(e) {
                        return l._(this, void 0, void 0, function*() {
                            e.demTexture && this.map.painter.saveTileTexture(e.demTexture),
                            e.fbo && (e.fbo.destroy(),
                            delete e.fbo),
                            e.dem && delete e.dem,
                            delete e.neighboringTiles,
                            e.state = "unloaded",
                            e.actor && (yield e.actor.sendAsync({
                                type: "RDT",
                                data: {
                                    type: this.type,
                                    uid: e.uid,
                                    source: this.id
                                }
                            }))
                        })
                    }
                }
                class kn extends l.E {
                    constructor(e, i, o, a) {
                        super(),
                        this.id = e,
                        this.type = "geojson",
                        this.minzoom = 0,
                        this.maxzoom = 18,
                        this.tileSize = 512,
                        this.isTileClipped = !0,
                        this.reparseOverscaled = !0,
                        this._removed = !1,
                        this._pendingLoads = 0,
                        this.actor = o.getActor(),
                        this.setEventedParent(a),
                        this._data = i.data,
                        this._options = l.e({}, i),
                        this._collectResourceTiming = i.collectResourceTiming,
                        i.maxzoom !== void 0 && (this.maxzoom = i.maxzoom),
                        i.type && (this.type = i.type),
                        i.attribution && (this.attribution = i.attribution),
                        this.promoteId = i.promoteId,
                        i.clusterMaxZoom !== void 0 && this.maxzoom <= i.clusterMaxZoom && l.w(`The maxzoom value "${this.maxzoom}" is expected to be greater than the clusterMaxZoom value "${i.clusterMaxZoom}".`),
                        this.workerOptions = l.e({
                            source: this.id,
                            cluster: i.cluster || !1,
                            geojsonVtOptions: {
                                buffer: this._pixelsToTileUnits(i.buffer !== void 0 ? i.buffer : 128),
                                tolerance: this._pixelsToTileUnits(i.tolerance !== void 0 ? i.tolerance : .375),
                                extent: l.Z,
                                maxZoom: this.maxzoom,
                                lineMetrics: i.lineMetrics || !1,
                                generateId: i.generateId || !1
                            },
                            superclusterOptions: {
                                maxZoom: i.clusterMaxZoom !== void 0 ? i.clusterMaxZoom : this.maxzoom - 1,
                                minPoints: Math.max(2, i.clusterMinPoints || 2),
                                extent: l.Z,
                                radius: this._pixelsToTileUnits(i.clusterRadius || 50),
                                log: !1,
                                generateId: i.generateId || !1
                            },
                            clusterProperties: i.clusterProperties,
                            filter: i.filter
                        }, i.workerOptions),
                        typeof this.promoteId == "string" && (this.workerOptions.promoteId = this.promoteId)
                    }
                    _pixelsToTileUnits(e) {
                        return e * (l.Z / this.tileSize)
                    }
                    load() {
                        return l._(this, void 0, void 0, function*() {
                            yield this._updateWorkerData()
                        })
                    }
                    onAdd(e) {
                        this.map = e,
                        this.load()
                    }
                    setData(e) {
                        return this._data = e,
                        this._updateWorkerData(),
                        this
                    }
                    updateData(e) {
                        return this._updateWorkerData(e),
                        this
                    }
                    getData() {
                        return l._(this, void 0, void 0, function*() {
                            const e = l.e({
                                type: this.type
                            }, this.workerOptions);
                            return this.actor.sendAsync({
                                type: "GD",
                                data: e
                            })
                        })
                    }
                    setClusterOptions(e) {
                        return this.workerOptions.cluster = e.cluster,
                        e && (e.clusterRadius !== void 0 && (this.workerOptions.superclusterOptions.radius = this._pixelsToTileUnits(e.clusterRadius)),
                        e.clusterMaxZoom !== void 0 && (this.workerOptions.superclusterOptions.maxZoom = e.clusterMaxZoom)),
                        this._updateWorkerData(),
                        this
                    }
                    getClusterExpansionZoom(e) {
                        return this.actor.sendAsync({
                            type: "GCEZ",
                            data: {
                                type: this.type,
                                clusterId: e,
                                source: this.id
                            }
                        })
                    }
                    getClusterChildren(e) {
                        return this.actor.sendAsync({
                            type: "GCC",
                            data: {
                                type: this.type,
                                clusterId: e,
                                source: this.id
                            }
                        })
                    }
                    getClusterLeaves(e, i, o) {
                        return this.actor.sendAsync({
                            type: "GCL",
                            data: {
                                type: this.type,
                                source: this.id,
                                clusterId: e,
                                limit: i,
                                offset: o
                            }
                        })
                    }
                    _updateWorkerData(e) {
                        return l._(this, void 0, void 0, function*() {
                            const i = l.e({
                                type: this.type
                            }, this.workerOptions);
                            e ? i.dataDiff = e : typeof this._data == "string" ? (i.request = this.map._requestManager.transformRequest(oe.resolveURL(this._data), "Source"),
                            i.request.collectResourceTiming = this._collectResourceTiming) : i.data = JSON.stringify(this._data),
                            this._pendingLoads++,
                            this.fire(new l.l("dataloading",{
                                dataType: "source"
                            }));
                            try {
                                const o = yield this.actor.sendAsync({
                                    type: "LD",
                                    data: i
                                });
                                if (this._pendingLoads--,
                                this._removed || o.abandoned)
                                    return void this.fire(new l.l("dataabort",{
                                        dataType: "source"
                                    }));
                                let a = null;
                                o.resourceTiming && o.resourceTiming[this.id] && (a = o.resourceTiming[this.id].slice(0));
                                const h = {
                                    dataType: "source"
                                };
                                this._collectResourceTiming && a && a.length > 0 && l.e(h, {
                                    resourceTiming: a
                                }),
                                this.fire(new l.l("data",Object.assign(Object.assign({}, h), {
                                    sourceDataType: "metadata"
                                }))),
                                this.fire(new l.l("data",Object.assign(Object.assign({}, h), {
                                    sourceDataType: "content"
                                })))
                            } catch (o) {
                                if (this._pendingLoads--,
                                this._removed)
                                    return void this.fire(new l.l("dataabort",{
                                        dataType: "source"
                                    }));
                                this.fire(new l.k(o))
                            }
                        })
                    }
                    loaded() {
                        return this._pendingLoads === 0
                    }
                    loadTile(e) {
                        return l._(this, void 0, void 0, function*() {
                            const i = e.actor ? "RT" : "LT";
                            e.actor = this.actor;
                            const o = {
                                type: this.type,
                                uid: e.uid,
                                tileID: e.tileID,
                                zoom: e.tileID.overscaledZ,
                                maxZoom: this.maxzoom,
                                tileSize: this.tileSize,
                                source: this.id,
                                pixelRatio: this.map.getPixelRatio(),
                                showCollisionBoxes: this.map.showCollisionBoxes,
                                promoteId: this.promoteId,
                                subdivisionGranularity: this.map.style.projection.subdivisionGranularity
                            };
                            e.abortController = new AbortController;
                            const a = yield this.actor.sendAsync({
                                type: i,
                                data: o
                            }, e.abortController);
                            delete e.abortController,
                            e.unloadVectorData(),
                            e.aborted || e.loadVectorData(a, this.map.painter, i === "RT")
                        })
                    }
                    abortTile(e) {
                        return l._(this, void 0, void 0, function*() {
                            e.abortController && (e.abortController.abort(),
                            delete e.abortController),
                            e.aborted = !0
                        })
                    }
                    unloadTile(e) {
                        return l._(this, void 0, void 0, function*() {
                            e.unloadVectorData(),
                            yield this.actor.sendAsync({
                                type: "RMT",
                                data: {
                                    uid: e.uid,
                                    type: this.type,
                                    source: this.id
                                }
                            })
                        })
                    }
                    onRemove() {
                        this._removed = !0,
                        this.actor.sendAsync({
                            type: "RS",
                            data: {
                                type: this.type,
                                source: this.id
                            }
                        })
                    }
                    serialize() {
                        return l.e({}, this._options, {
                            type: this.type,
                            data: this._data
                        })
                    }
                    hasTransition() {
                        return !1
                    }
                }
                class tn extends l.E {
                    constructor(e, i, o, a) {
                        super(),
                        this.flippedWindingOrder = !1,
                        this.id = e,
                        this.dispatcher = o,
                        this.coordinates = i.coordinates,
                        this.type = "image",
                        this.minzoom = 0,
                        this.maxzoom = 22,
                        this.tileSize = 512,
                        this.tiles = {},
                        this._loaded = !1,
                        this.setEventedParent(a),
                        this.options = i
                    }
                    load(e) {
                        return l._(this, void 0, void 0, function*() {
                            this._loaded = !1,
                            this.fire(new l.l("dataloading",{
                                dataType: "source"
                            })),
                            this.url = this.options.url,
                            this._request = new AbortController;
                            try {
                                const i = yield Wt.getImage(this.map._requestManager.transformRequest(this.url, "Image"), this._request);
                                this._request = null,
                                this._loaded = !0,
                                i && i.data && (this.image = i.data,
                                e && (this.coordinates = e),
                                this._finishLoading())
                            } catch (i) {
                                this._request = null,
                                this._loaded = !0,
                                this.fire(new l.k(i))
                            }
                        })
                    }
                    loaded() {
                        return this._loaded
                    }
                    updateImage(e) {
                        return e.url ? (this._request && (this._request.abort(),
                        this._request = null),
                        this.options.url = e.url,
                        this.load(e.coordinates).finally( () => {
                            this.texture = null
                        }
                        ),
                        this) : this
                    }
                    _finishLoading() {
                        this.map && (this.setCoordinates(this.coordinates),
                        this.fire(new l.l("data",{
                            dataType: "source",
                            sourceDataType: "metadata"
                        })))
                    }
                    onAdd(e) {
                        this.map = e,
                        this.load()
                    }
                    onRemove() {
                        this._request && (this._request.abort(),
                        this._request = null)
                    }
                    setCoordinates(e) {
                        this.coordinates = e;
                        const i = e.map(l.$.fromLngLat);
                        var o;
                        return this.tileID = function(a) {
                            let h = 1 / 0
                              , m = 1 / 0
                              , y = -1 / 0
                              , v = -1 / 0;
                            for (const k of a)
                                h = Math.min(h, k.x),
                                m = Math.min(m, k.y),
                                y = Math.max(y, k.x),
                                v = Math.max(v, k.y);
                            const T = Math.max(y - h, v - m)
                              , S = Math.max(0, Math.floor(-Math.log(T) / Math.LN2))
                              , A = Math.pow(2, S);
                            return new l.a0(S,Math.floor((h + y) / 2 * A),Math.floor((m + v) / 2 * A))
                        }(i),
                        this.minzoom = this.maxzoom = this.tileID.z,
                        this.tileCoords = i.map(a => this.tileID.getTilePoint(a)._round()),
                        this.flippedWindingOrder = ((o = this.tileCoords)[1].x - o[0].x) * (o[2].y - o[0].y) - (o[1].y - o[0].y) * (o[2].x - o[0].x) < 0,
                        this.fire(new l.l("data",{
                            dataType: "source",
                            sourceDataType: "content"
                        })),
                        this
                    }
                    prepare() {
                        if (Object.keys(this.tiles).length === 0 || !this.image)
                            return;
                        const e = this.map.painter.context
                          , i = e.gl;
                        this.texture || (this.texture = new It(e,this.image,i.RGBA),
                        this.texture.bind(i.LINEAR, i.CLAMP_TO_EDGE));
                        let o = !1;
                        for (const a in this.tiles) {
                            const h = this.tiles[a];
                            h.state !== "loaded" && (h.state = "loaded",
                            h.texture = this.texture,
                            o = !0)
                        }
                        o && this.fire(new l.l("data",{
                            dataType: "source",
                            sourceDataType: "idle",
                            sourceId: this.id
                        }))
                    }
                    loadTile(e) {
                        return l._(this, void 0, void 0, function*() {
                            this.tileID && this.tileID.equals(e.tileID.canonical) ? (this.tiles[String(e.tileID.wrap)] = e,
                            e.buckets = {}) : e.state = "errored"
                        })
                    }
                    serialize() {
                        return {
                            type: "image",
                            url: this.options.url,
                            coordinates: this.coordinates
                        }
                    }
                    hasTransition() {
                        return !1
                    }
                }
                class Nr extends tn {
                    constructor(e, i, o, a) {
                        super(e, i, o, a),
                        this.roundZoom = !0,
                        this.type = "video",
                        this.options = i
                    }
                    load() {
                        return l._(this, void 0, void 0, function*() {
                            this._loaded = !1;
                            const e = this.options;
                            this.urls = [];
                            for (const i of e.urls)
                                this.urls.push(this.map._requestManager.transformRequest(i, "Source").url);
                            try {
                                const i = yield l.a1(this.urls);
                                if (this._loaded = !0,
                                !i)
                                    return;
                                this.video = i,
                                this.video.loop = !0,
                                this.video.addEventListener("playing", () => {
                                    this.map.triggerRepaint()
                                }
                                ),
                                this.map && this.video.play(),
                                this._finishLoading()
                            } catch (i) {
                                this.fire(new l.k(i))
                            }
                        })
                    }
                    pause() {
                        this.video && this.video.pause()
                    }
                    play() {
                        this.video && this.video.play()
                    }
                    seek(e) {
                        if (this.video) {
                            const i = this.video.seekable;
                            e < i.start(0) || e > i.end(0) ? this.fire(new l.k(new l.a2(`sources.${this.id}`,null,`Playback for this video can be set only between the ${i.start(0)} and ${i.end(0)}-second mark.`))) : this.video.currentTime = e
                        }
                    }
                    getVideo() {
                        return this.video
                    }
                    onAdd(e) {
                        this.map || (this.map = e,
                        this.load(),
                        this.video && (this.video.play(),
                        this.setCoordinates(this.coordinates)))
                    }
                    prepare() {
                        if (Object.keys(this.tiles).length === 0 || this.video.readyState < 2)
                            return;
                        const e = this.map.painter.context
                          , i = e.gl;
                        this.texture ? this.video.paused || (this.texture.bind(i.LINEAR, i.CLAMP_TO_EDGE),
                        i.texSubImage2D(i.TEXTURE_2D, 0, 0, 0, i.RGBA, i.UNSIGNED_BYTE, this.video)) : (this.texture = new It(e,this.video,i.RGBA),
                        this.texture.bind(i.LINEAR, i.CLAMP_TO_EDGE));
                        let o = !1;
                        for (const a in this.tiles) {
                            const h = this.tiles[a];
                            h.state !== "loaded" && (h.state = "loaded",
                            h.texture = this.texture,
                            o = !0)
                        }
                        o && this.fire(new l.l("data",{
                            dataType: "source",
                            sourceDataType: "idle",
                            sourceId: this.id
                        }))
                    }
                    serialize() {
                        return {
                            type: "video",
                            urls: this.urls,
                            coordinates: this.coordinates
                        }
                    }
                    hasTransition() {
                        return this.video && !this.video.paused
                    }
                }
                class ws extends tn {
                    constructor(e, i, o, a) {
                        super(e, i, o, a),
                        i.coordinates ? Array.isArray(i.coordinates) && i.coordinates.length === 4 && !i.coordinates.some(h => !Array.isArray(h) || h.length !== 2 || h.some(m => typeof m != "number")) || this.fire(new l.k(new l.a2(`sources.${e}`,null,'"coordinates" property must be an array of 4 longitude/latitude array pairs'))) : this.fire(new l.k(new l.a2(`sources.${e}`,null,'missing required property "coordinates"'))),
                        i.animate && typeof i.animate != "boolean" && this.fire(new l.k(new l.a2(`sources.${e}`,null,'optional "animate" property must be a boolean value'))),
                        i.canvas ? typeof i.canvas == "string" || i.canvas instanceof HTMLCanvasElement || this.fire(new l.k(new l.a2(`sources.${e}`,null,'"canvas" must be either a string representing the ID of the canvas element from which to read, or an HTMLCanvasElement instance'))) : this.fire(new l.k(new l.a2(`sources.${e}`,null,'missing required property "canvas"'))),
                        this.options = i,
                        this.animate = i.animate === void 0 || i.animate
                    }
                    load() {
                        return l._(this, void 0, void 0, function*() {
                            this._loaded = !0,
                            this.canvas || (this.canvas = this.options.canvas instanceof HTMLCanvasElement ? this.options.canvas : document.getElementById(this.options.canvas)),
                            this.width = this.canvas.width,
                            this.height = this.canvas.height,
                            this._hasInvalidDimensions() ? this.fire(new l.k(new Error("Canvas dimensions cannot be less than or equal to zero."))) : (this.play = function() {
                                this._playing = !0,
                                this.map.triggerRepaint()
                            }
                            ,
                            this.pause = function() {
                                this._playing && (this.prepare(),
                                this._playing = !1)
                            }
                            ,
                            this._finishLoading())
                        })
                    }
                    getCanvas() {
                        return this.canvas
                    }
                    onAdd(e) {
                        this.map = e,
                        this.load(),
                        this.canvas && this.animate && this.play()
                    }
                    onRemove() {
                        this.pause()
                    }
                    prepare() {
                        let e = !1;
                        if (this.canvas.width !== this.width && (this.width = this.canvas.width,
                        e = !0),
                        this.canvas.height !== this.height && (this.height = this.canvas.height,
                        e = !0),
                        this._hasInvalidDimensions() || Object.keys(this.tiles).length === 0)
                            return;
                        const i = this.map.painter.context
                          , o = i.gl;
                        this.texture ? (e || this._playing) && this.texture.update(this.canvas, {
                            premultiply: !0
                        }) : this.texture = new It(i,this.canvas,o.RGBA,{
                            premultiply: !0
                        });
                        let a = !1;
                        for (const h in this.tiles) {
                            const m = this.tiles[h];
                            m.state !== "loaded" && (m.state = "loaded",
                            m.texture = this.texture,
                            a = !0)
                        }
                        a && this.fire(new l.l("data",{
                            dataType: "source",
                            sourceDataType: "idle",
                            sourceId: this.id
                        }))
                    }
                    serialize() {
                        return {
                            type: "canvas",
                            coordinates: this.coordinates
                        }
                    }
                    hasTransition() {
                        return this._playing
                    }
                    _hasInvalidDimensions() {
                        for (const e of [this.canvas.width, this.canvas.height])
                            if (isNaN(e) || e <= 0)
                                return !0;
                        return !1
                    }
                }
                const Kn = {}
                  , Jn = u => {
                    switch (u) {
                    case "geojson":
                        return kn;
                    case "image":
                        return tn;
                    case "raster":
                        return Or;
                    case "raster-dem":
                        return zn;
                    case "vector":
                        return Xn;
                    case "video":
                        return Nr;
                    case "canvas":
                        return ws
                    }
                    return Kn[u]
                }
                  , Ts = "RTLPluginLoaded";
                class Yn extends l.E {
                    constructor() {
                        super(...arguments),
                        this.status = "unavailable",
                        this.url = null,
                        this.dispatcher = en()
                    }
                    _syncState(e) {
                        return this.status = e,
                        this.dispatcher.broadcast("SRPS", {
                            pluginStatus: e,
                            pluginURL: this.url
                        }).catch(i => {
                            throw this.status = "error",
                            i
                        }
                        )
                    }
                    getRTLTextPluginStatus() {
                        return this.status
                    }
                    clearRTLTextPlugin() {
                        this.status = "unavailable",
                        this.url = null
                    }
                    setRTLTextPlugin(e) {
                        return l._(this, arguments, void 0, function*(i, o=!1) {
                            if (this.url)
                                throw new Error("setRTLTextPlugin cannot be called multiple times.");
                            if (this.url = oe.resolveURL(i),
                            !this.url)
                                throw new Error(`requested url ${i} is invalid`);
                            if (this.status === "unavailable") {
                                if (!o)
                                    return this._requestImport();
                                this.status = "deferred",
                                this._syncState(this.status)
                            } else if (this.status === "requested")
                                return this._requestImport()
                        })
                    }
                    _requestImport() {
                        return l._(this, void 0, void 0, function*() {
                            yield this._syncState("loading"),
                            this.status = "loaded",
                            this.fire(new l.l(Ts))
                        })
                    }
                    lazyLoad() {
                        this.status === "unavailable" ? this.status = "requested" : this.status === "deferred" && this._requestImport()
                    }
                }
                let mn = null;
                function gn() {
                    return mn || (mn = new Yn),
                    mn
                }
                class Ln {
                    constructor(e, i) {
                        this.timeAdded = 0,
                        this.fadeEndTime = 0,
                        this.tileID = e,
                        this.uid = l.a3(),
                        this.uses = 0,
                        this.tileSize = i,
                        this.buckets = {},
                        this.expirationTime = null,
                        this.queryPadding = 0,
                        this.hasSymbolBuckets = !1,
                        this.hasRTLText = !1,
                        this.dependencies = {},
                        this.rtt = [],
                        this.rttCoords = {},
                        this.expiredRequestCount = 0,
                        this.state = "loading"
                    }
                    registerFadeDuration(e) {
                        const i = e + this.timeAdded;
                        i < this.fadeEndTime || (this.fadeEndTime = i)
                    }
                    wasRequested() {
                        return this.state === "errored" || this.state === "loaded" || this.state === "reloading"
                    }
                    clearTextures(e) {
                        this.demTexture && e.saveTileTexture(this.demTexture),
                        this.demTexture = null
                    }
                    loadVectorData(e, i, o) {
                        if (this.hasData() && this.unloadVectorData(),
                        this.state = "loaded",
                        e) {
                            e.featureIndex && (this.latestFeatureIndex = e.featureIndex,
                            e.rawTileData ? (this.latestRawTileData = e.rawTileData,
                            this.latestFeatureIndex.rawTileData = e.rawTileData) : this.latestRawTileData && (this.latestFeatureIndex.rawTileData = this.latestRawTileData)),
                            this.collisionBoxArray = e.collisionBoxArray,
                            this.buckets = function(a, h) {
                                const m = {};
                                if (!h)
                                    return m;
                                for (const y of a) {
                                    const v = y.layerIds.map(T => h.getLayer(T)).filter(Boolean);
                                    if (v.length !== 0) {
                                        y.layers = v,
                                        y.stateDependentLayerIds && (y.stateDependentLayers = y.stateDependentLayerIds.map(T => v.filter(S => S.id === T)[0]));
                                        for (const T of v)
                                            m[T.id] = y
                                    }
                                }
                                return m
                            }(e.buckets, i?.style),
                            this.hasSymbolBuckets = !1;
                            for (const a in this.buckets) {
                                const h = this.buckets[a];
                                if (h instanceof l.a5) {
                                    if (this.hasSymbolBuckets = !0,
                                    !o)
                                        break;
                                    h.justReloaded = !0
                                }
                            }
                            if (this.hasRTLText = !1,
                            this.hasSymbolBuckets)
                                for (const a in this.buckets) {
                                    const h = this.buckets[a];
                                    if (h instanceof l.a5 && h.hasRTLText) {
                                        this.hasRTLText = !0,
                                        gn().lazyLoad();
                                        break
                                    }
                                }
                            this.queryPadding = 0;
                            for (const a in this.buckets) {
                                const h = this.buckets[a];
                                this.queryPadding = Math.max(this.queryPadding, i.style.getLayer(a).queryRadius(h))
                            }
                            e.imageAtlas && (this.imageAtlas = e.imageAtlas),
                            e.glyphAtlasImage && (this.glyphAtlasImage = e.glyphAtlasImage)
                        } else
                            this.collisionBoxArray = new l.a4
                    }
                    unloadVectorData() {
                        for (const e in this.buckets)
                            this.buckets[e].destroy();
                        this.buckets = {},
                        this.imageAtlasTexture && this.imageAtlasTexture.destroy(),
                        this.imageAtlas && (this.imageAtlas = null),
                        this.glyphAtlasTexture && this.glyphAtlasTexture.destroy(),
                        this.latestFeatureIndex = null,
                        this.state = "unloaded"
                    }
                    getBucket(e) {
                        return this.buckets[e.id]
                    }
                    upload(e) {
                        for (const o in this.buckets) {
                            const a = this.buckets[o];
                            a.uploadPending() && a.upload(e)
                        }
                        const i = e.gl;
                        this.imageAtlas && !this.imageAtlas.uploaded && (this.imageAtlasTexture = new It(e,this.imageAtlas.image,i.RGBA),
                        this.imageAtlas.uploaded = !0),
                        this.glyphAtlasImage && (this.glyphAtlasTexture = new It(e,this.glyphAtlasImage,i.ALPHA),
                        this.glyphAtlasImage = null)
                    }
                    prepare(e) {
                        this.imageAtlas && this.imageAtlas.patchUpdatedImages(e, this.imageAtlasTexture)
                    }
                    queryRenderedFeatures(e, i, o, a, h, m, y, v, T, S) {
                        return this.latestFeatureIndex && this.latestFeatureIndex.rawTileData ? this.latestFeatureIndex.query({
                            queryGeometry: a,
                            cameraQueryGeometry: h,
                            scale: m,
                            tileSize: this.tileSize,
                            pixelPosMatrix: S,
                            transform: v,
                            params: y,
                            queryPadding: this.queryPadding * T
                        }, e, i, o) : {}
                    }
                    querySourceFeatures(e, i) {
                        const o = this.latestFeatureIndex;
                        if (!o || !o.rawTileData)
                            return;
                        const a = o.loadVTLayers()
                          , h = i && i.sourceLayer ? i.sourceLayer : ""
                          , m = a._geojsonTileLayer || a[h];
                        if (!m)
                            return;
                        const y = l.a6(i && i.filter)
                          , {z: v, x: T, y: S} = this.tileID.canonical
                          , A = {
                            z: v,
                            x: T,
                            y: S
                        };
                        for (let k = 0; k < m.length; k++) {
                            const O = m.feature(k);
                            if (y.needGeometry) {
                                const q = l.a7(O, !0);
                                if (!y.filter(new l.C(this.tileID.overscaledZ), q, this.tileID.canonical))
                                    continue
                            } else if (!y.filter(new l.C(this.tileID.overscaledZ), O))
                                continue;
                            const V = o.getId(O, h)
                              , H = new l.a8(O,v,T,S,V);
                            H.tile = A,
                            e.push(H)
                        }
                    }
                    hasData() {
                        return this.state === "loaded" || this.state === "reloading" || this.state === "expired"
                    }
                    patternsLoaded() {
                        return this.imageAtlas && !!Object.keys(this.imageAtlas.patternPositions).length
                    }
                    setExpiryData(e) {
                        const i = this.expirationTime;
                        if (e.cacheControl) {
                            const o = l.a9(e.cacheControl);
                            o["max-age"] && (this.expirationTime = Date.now() + 1e3 * o["max-age"])
                        } else
                            e.expires && (this.expirationTime = new Date(e.expires).getTime());
                        if (this.expirationTime) {
                            const o = Date.now();
                            let a = !1;
                            if (this.expirationTime > o)
                                a = !1;
                            else if (i)
                                if (this.expirationTime < i)
                                    a = !0;
                                else {
                                    const h = this.expirationTime - i;
                                    h ? this.expirationTime = o + Math.max(h, 3e4) : a = !0
                                }
                            else
                                a = !0;
                            a ? (this.expiredRequestCount++,
                            this.state = "expired") : this.expiredRequestCount = 0
                        }
                    }
                    getExpiryTimeout() {
                        if (this.expirationTime)
                            return this.expiredRequestCount ? 1e3 * (1 << Math.min(this.expiredRequestCount - 1, 31)) : Math.min(this.expirationTime - new Date().getTime(), Math.pow(2, 31) - 1)
                    }
                    setFeatureState(e, i) {
                        if (!this.latestFeatureIndex || !this.latestFeatureIndex.rawTileData || Object.keys(e).length === 0)
                            return;
                        const o = this.latestFeatureIndex.loadVTLayers();
                        for (const a in this.buckets) {
                            if (!i.style.hasLayer(a))
                                continue;
                            const h = this.buckets[a]
                              , m = h.layers[0].sourceLayer || "_geojsonTileLayer"
                              , y = o[m]
                              , v = e[m];
                            if (!y || !v || Object.keys(v).length === 0)
                                continue;
                            h.update(v, y, this.imageAtlas && this.imageAtlas.patternPositions || {});
                            const T = i && i.style && i.style.getLayer(a);
                            T && (this.queryPadding = Math.max(this.queryPadding, T.queryRadius(h)))
                        }
                    }
                    holdingForFade() {
                        return this.symbolFadeHoldUntil !== void 0
                    }
                    symbolFadeFinished() {
                        return !this.symbolFadeHoldUntil || this.symbolFadeHoldUntil < oe.now()
                    }
                    clearFadeHold() {
                        this.symbolFadeHoldUntil = void 0
                    }
                    setHoldDuration(e) {
                        this.symbolFadeHoldUntil = oe.now() + e
                    }
                    setDependencies(e, i) {
                        const o = {};
                        for (const a of i)
                            o[a] = !0;
                        this.dependencies[e] = o
                    }
                    hasDependency(e, i) {
                        for (const o of e) {
                            const a = this.dependencies[o];
                            if (a) {
                                for (const h of i)
                                    if (a[h])
                                        return !0
                            }
                        }
                        return !1
                    }
                }
                class Dn {
                    constructor(e, i) {
                        this.max = e,
                        this.onRemove = i,
                        this.reset()
                    }
                    reset() {
                        for (const e in this.data)
                            for (const i of this.data[e])
                                i.timeout && clearTimeout(i.timeout),
                                this.onRemove(i.value);
                        return this.data = {},
                        this.order = [],
                        this
                    }
                    add(e, i, o) {
                        const a = e.wrapped().key;
                        this.data[a] === void 0 && (this.data[a] = []);
                        const h = {
                            value: i,
                            timeout: void 0
                        };
                        if (o !== void 0 && (h.timeout = setTimeout( () => {
                            this.remove(e, h)
                        }
                        , o)),
                        this.data[a].push(h),
                        this.order.push(a),
                        this.order.length > this.max) {
                            const m = this._getAndRemoveByKey(this.order[0]);
                            m && this.onRemove(m)
                        }
                        return this
                    }
                    has(e) {
                        return e.wrapped().key in this.data
                    }
                    getAndRemove(e) {
                        return this.has(e) ? this._getAndRemoveByKey(e.wrapped().key) : null
                    }
                    _getAndRemoveByKey(e) {
                        const i = this.data[e].shift();
                        return i.timeout && clearTimeout(i.timeout),
                        this.data[e].length === 0 && delete this.data[e],
                        this.order.splice(this.order.indexOf(e), 1),
                        i.value
                    }
                    getByKey(e) {
                        const i = this.data[e];
                        return i ? i[0].value : null
                    }
                    get(e) {
                        return this.has(e) ? this.data[e.wrapped().key][0].value : null
                    }
                    remove(e, i) {
                        if (!this.has(e))
                            return this;
                        const o = e.wrapped().key
                          , a = i === void 0 ? 0 : this.data[o].indexOf(i)
                          , h = this.data[o][a];
                        return this.data[o].splice(a, 1),
                        h.timeout && clearTimeout(h.timeout),
                        this.data[o].length === 0 && delete this.data[o],
                        this.onRemove(h.value),
                        this.order.splice(this.order.indexOf(o), 1),
                        this
                    }
                    setMaxSize(e) {
                        for (this.max = e; this.order.length > this.max; ) {
                            const i = this._getAndRemoveByKey(this.order[0]);
                            i && this.onRemove(i)
                        }
                        return this
                    }
                    filter(e) {
                        const i = [];
                        for (const o in this.data)
                            for (const a of this.data[o])
                                e(a.value) || i.push(a);
                        for (const o of i)
                            this.remove(o.value.tileID, o)
                    }
                }
                class eo {
                    constructor() {
                        this.state = {},
                        this.stateChanges = {},
                        this.deletedStates = {}
                    }
                    updateState(e, i, o) {
                        const a = String(i);
                        if (this.stateChanges[e] = this.stateChanges[e] || {},
                        this.stateChanges[e][a] = this.stateChanges[e][a] || {},
                        l.e(this.stateChanges[e][a], o),
                        this.deletedStates[e] === null) {
                            this.deletedStates[e] = {};
                            for (const h in this.state[e])
                                h !== a && (this.deletedStates[e][h] = null)
                        } else if (this.deletedStates[e] && this.deletedStates[e][a] === null) {
                            this.deletedStates[e][a] = {};
                            for (const h in this.state[e][a])
                                o[h] || (this.deletedStates[e][a][h] = null)
                        } else
                            for (const h in o)
                                this.deletedStates[e] && this.deletedStates[e][a] && this.deletedStates[e][a][h] === null && delete this.deletedStates[e][a][h]
                    }
                    removeFeatureState(e, i, o) {
                        if (this.deletedStates[e] === null)
                            return;
                        const a = String(i);
                        if (this.deletedStates[e] = this.deletedStates[e] || {},
                        o && i !== void 0)
                            this.deletedStates[e][a] !== null && (this.deletedStates[e][a] = this.deletedStates[e][a] || {},
                            this.deletedStates[e][a][o] = null);
                        else if (i !== void 0)
                            if (this.stateChanges[e] && this.stateChanges[e][a])
                                for (o in this.deletedStates[e][a] = {},
                                this.stateChanges[e][a])
                                    this.deletedStates[e][a][o] = null;
                            else
                                this.deletedStates[e][a] = null;
                        else
                            this.deletedStates[e] = null
                    }
                    getState(e, i) {
                        const o = String(i)
                          , a = l.e({}, (this.state[e] || {})[o], (this.stateChanges[e] || {})[o]);
                        if (this.deletedStates[e] === null)
                            return {};
                        if (this.deletedStates[e]) {
                            const h = this.deletedStates[e][i];
                            if (h === null)
                                return {};
                            for (const m in h)
                                delete a[m]
                        }
                        return a
                    }
                    initializeTileState(e, i) {
                        e.setFeatureState(this.state, i)
                    }
                    coalesceChanges(e, i) {
                        const o = {};
                        for (const a in this.stateChanges) {
                            this.state[a] = this.state[a] || {};
                            const h = {};
                            for (const m in this.stateChanges[a])
                                this.state[a][m] || (this.state[a][m] = {}),
                                l.e(this.state[a][m], this.stateChanges[a][m]),
                                h[m] = this.state[a][m];
                            o[a] = h
                        }
                        for (const a in this.deletedStates) {
                            this.state[a] = this.state[a] || {};
                            const h = {};
                            if (this.deletedStates[a] === null)
                                for (const m in this.state[a])
                                    h[m] = {},
                                    this.state[a][m] = {};
                            else
                                for (const m in this.deletedStates[a]) {
                                    if (this.deletedStates[a][m] === null)
                                        this.state[a][m] = {};
                                    else
                                        for (const y of Object.keys(this.deletedStates[a][m]))
                                            delete this.state[a][m][y];
                                    h[m] = this.state[a][m]
                                }
                            o[a] = o[a] || {},
                            l.e(o[a], h)
                        }
                        if (this.stateChanges = {},
                        this.deletedStates = {},
                        Object.keys(o).length !== 0)
                            for (const a in e)
                                e[a].setFeatureState(o, i)
                    }
                }
                function Ms(u, e, i) {
                    const o = e.intersectsFrustum(u);
                    if (!i)
                        return o;
                    const a = e.intersectsPlane(i);
                    return o === 0 || a === 0 ? 0 : o === 2 && a === 2 ? 2 : 1
                }
                function to(u, e, i, o, a) {
                    let h = u;
                    const m = Math.atan(e / i)
                      , y = Math.hypot(e, i);
                    return h = u + l.aa(o / y / Math.max(.5, Math.cos(l.ac(a / 2)))),
                    h += 1 * l.aa(Math.cos(m)) / 2,
                    h += l.ad(u - h, -0, 0),
                    h
                }
                function _n(u, e) {
                    const i = (e.roundZoom ? Math.round : Math.floor)(u.zoom + l.aa(u.tileSize / e.tileSize));
                    return Math.max(0, i)
                }
                function pe(u, e) {
                    const i = u.getCameraFrustum()
                      , o = u.getClippingPlane()
                      , a = u.screenPointToMercatorCoordinate(u.getCameraPoint())
                      , h = l.$.fromLngLat(u.center, u.elevation);
                    a.z = h.z + Math.cos(u.pitchInRadians) * u.cameraToCenterDistance / u.worldSize;
                    const m = u.getCoveringTilesDetailsProvider()
                      , y = m.allowVariableZoom(u, e)
                      , v = _n(u, e)
                      , T = e.minzoom || 0
                      , S = e.maxzoom !== void 0 ? e.maxzoom : u.maxZoom
                      , A = Math.min(Math.max(0, v), S)
                      , k = Math.pow(2, A)
                      , O = [k * a.x, k * a.y, 0]
                      , V = [k * h.x, k * h.y, 0]
                      , H = Math.hypot(h.x - a.x, h.y - a.y)
                      , q = Math.abs(h.z - a.z)
                      , W = Math.hypot(H, q)
                      , J = ne => ({
                        zoom: 0,
                        x: 0,
                        y: 0,
                        wrap: ne,
                        fullyVisible: !1
                    })
                      , te = []
                      , ie = [];
                    if (u.renderWorldCopies && m.allowWorldCopies())
                        for (let ne = 1; ne <= 3; ne++)
                            te.push(J(-ne)),
                            te.push(J(ne));
                    for (te.push(J(0)); te.length > 0; ) {
                        const ne = te.pop()
                          , le = ne.x
                          , se = ne.y;
                        let _e = ne.fullyVisible;
                        const xe = {
                            x: le,
                            y: se,
                            z: ne.zoom
                        }
                          , Pe = m.getTileAABB(xe, ne.wrap, u.elevation, e);
                        if (!_e) {
                            const Oe = Ms(i, Pe, o);
                            if (Oe === 0)
                                continue;
                            _e = Oe === 2
                        }
                        const Ie = m.distanceToTile2d(a.x, a.y, xe, Pe);
                        let Ce = v;
                        y && (Ce = (e.calculateTileZoom || to)(u.zoom + l.aa(u.tileSize / e.tileSize), Ie, q, W, u.fov)),
                        Ce = (e.roundZoom ? Math.round : Math.floor)(Ce),
                        Ce = Math.max(0, Ce);
                        const Ne = Math.min(Ce, S);
                        if (ne.wrap = m.getWrap(h, xe, ne.wrap),
                        ne.zoom >= Ne) {
                            if (ne.zoom < T)
                                continue;
                            const Oe = A - ne.zoom
                              , De = O[0] - .5 - (le << Oe)
                              , $e = O[1] - .5 - (se << Oe)
                              , Ke = e.reparseOverscaled ? Math.max(ne.zoom, Ce) : ne.zoom;
                            ie.push({
                                tileID: new l.Y(ne.zoom === S ? Ke : ne.zoom,ne.wrap,ne.zoom,le,se),
                                distanceSq: l.ab([V[0] - .5 - le, V[1] - .5 - se]),
                                tileDistanceToCamera: Math.sqrt(De * De + $e * $e)
                            })
                        } else
                            for (let Oe = 0; Oe < 4; Oe++)
                                te.push({
                                    zoom: ne.zoom + 1,
                                    x: (le << 1) + Oe % 2,
                                    y: (se << 1) + (Oe >> 1),
                                    wrap: ne.wrap,
                                    fullyVisible: _e
                                })
                    }
                    return ie.sort( (ne, le) => ne.distanceSq - le.distanceSq).map(ne => ne.tileID)
                }
                class E extends l.E {
                    constructor(e, i, o) {
                        super(),
                        this.id = e,
                        this.dispatcher = o,
                        this.on("data", a => this._dataHandler(a)),
                        this.on("dataloading", () => {
                            this._sourceErrored = !1
                        }
                        ),
                        this.on("error", () => {
                            this._sourceErrored = this._source.loaded()
                        }
                        ),
                        this._source = ( (a, h, m, y) => {
                            const v = new (Jn(h.type))(a,h,m,y);
                            if (v.id !== a)
                                throw new Error(`Expected Source id to be ${a} instead of ${v.id}`);
                            return v
                        }
                        )(e, i, o, this),
                        this._tiles = {},
                        this._cache = new Dn(0,a => this._unloadTile(a)),
                        this._timers = {},
                        this._cacheTimers = {},
                        this._maxTileCacheSize = null,
                        this._maxTileCacheZoomLevels = null,
                        this._loadedParentTiles = {},
                        this._coveredTiles = {},
                        this._state = new eo,
                        this._didEmitContent = !1,
                        this._updated = !1
                    }
                    onAdd(e) {
                        this.map = e,
                        this._maxTileCacheSize = e ? e._maxTileCacheSize : null,
                        this._maxTileCacheZoomLevels = e ? e._maxTileCacheZoomLevels : null,
                        this._source && this._source.onAdd && this._source.onAdd(e)
                    }
                    onRemove(e) {
                        this.clearTiles(),
                        this._source && this._source.onRemove && this._source.onRemove(e)
                    }
                    loaded() {
                        if (this._sourceErrored)
                            return !0;
                        if (!this._sourceLoaded || !this._source.loaded())
                            return !1;
                        if (!(this.used === void 0 && this.usedForTerrain === void 0 || this.used || this.usedForTerrain))
                            return !0;
                        if (!this._updated)
                            return !1;
                        for (const e in this._tiles) {
                            const i = this._tiles[e];
                            if (i.state !== "loaded" && i.state !== "errored")
                                return !1
                        }
                        return !0
                    }
                    getSource() {
                        return this._source
                    }
                    pause() {
                        this._paused = !0
                    }
                    resume() {
                        if (!this._paused)
                            return;
                        const e = this._shouldReloadOnResume;
                        this._paused = !1,
                        this._shouldReloadOnResume = !1,
                        e && this.reload(),
                        this.transform && this.update(this.transform, this.terrain)
                    }
                    _loadTile(e, i, o) {
                        return l._(this, void 0, void 0, function*() {
                            try {
                                yield this._source.loadTile(e),
                                this._tileLoaded(e, i, o)
                            } catch (a) {
                                e.state = "errored",
                                a.status !== 404 ? this._source.fire(new l.k(a,{
                                    tile: e
                                })) : this.update(this.transform, this.terrain)
                            }
                        })
                    }
                    _unloadTile(e) {
                        this._source.unloadTile && this._source.unloadTile(e)
                    }
                    _abortTile(e) {
                        this._source.abortTile && this._source.abortTile(e),
                        this._source.fire(new l.l("dataabort",{
                            tile: e,
                            coord: e.tileID,
                            dataType: "source"
                        }))
                    }
                    serialize() {
                        return this._source.serialize()
                    }
                    prepare(e) {
                        this._source.prepare && this._source.prepare(),
                        this._state.coalesceChanges(this._tiles, this.map ? this.map.painter : null);
                        for (const i in this._tiles) {
                            const o = this._tiles[i];
                            o.upload(e),
                            o.prepare(this.map.style.imageManager)
                        }
                    }
                    getIds() {
                        return Object.values(this._tiles).map(e => e.tileID).sort(U).map(e => e.key)
                    }
                    getRenderableIds(e) {
                        const i = [];
                        for (const o in this._tiles)
                            this._isIdRenderable(o, e) && i.push(this._tiles[o]);
                        return e ? i.sort( (o, a) => {
                            const h = o.tileID
                              , m = a.tileID
                              , y = new l.P(h.canonical.x,h.canonical.y)._rotate(-this.transform.bearingInRadians)
                              , v = new l.P(m.canonical.x,m.canonical.y)._rotate(-this.transform.bearingInRadians);
                            return h.overscaledZ - m.overscaledZ || v.y - y.y || v.x - y.x
                        }
                        ).map(o => o.tileID.key) : i.map(o => o.tileID).sort(U).map(o => o.key)
                    }
                    hasRenderableParent(e) {
                        const i = this.findLoadedParent(e, 0);
                        return !!i && this._isIdRenderable(i.tileID.key)
                    }
                    _isIdRenderable(e, i) {
                        return this._tiles[e] && this._tiles[e].hasData() && !this._coveredTiles[e] && (i || !this._tiles[e].holdingForFade())
                    }
                    reload(e) {
                        if (this._paused)
                            this._shouldReloadOnResume = !0;
                        else {
                            this._cache.reset();
                            for (const i in this._tiles)
                                (e || this._tiles[i].state !== "errored") && this._reloadTile(i, "reloading")
                        }
                    }
                    _reloadTile(e, i) {
                        return l._(this, void 0, void 0, function*() {
                            const o = this._tiles[e];
                            o && (o.state !== "loading" && (o.state = i),
                            yield this._loadTile(o, e, i))
                        })
                    }
                    _tileLoaded(e, i, o) {
                        e.timeAdded = oe.now(),
                        o === "expired" && (e.refreshedUponExpiration = !0),
                        this._setTileReloadTimer(i, e),
                        this.getSource().type === "raster-dem" && e.dem && this._backfillDEM(e),
                        this._state.initializeTileState(e, this.map ? this.map.painter : null),
                        e.aborted || this._source.fire(new l.l("data",{
                            dataType: "source",
                            tile: e,
                            coord: e.tileID
                        }))
                    }
                    _backfillDEM(e) {
                        const i = this.getRenderableIds();
                        for (let a = 0; a < i.length; a++) {
                            const h = i[a];
                            if (e.neighboringTiles && e.neighboringTiles[h]) {
                                const m = this.getTileByID(h);
                                o(e, m),
                                o(m, e)
                            }
                        }
                        function o(a, h) {
                            a.needsHillshadePrepare = !0,
                            a.needsTerrainPrepare = !0;
                            let m = h.tileID.canonical.x - a.tileID.canonical.x;
                            const y = h.tileID.canonical.y - a.tileID.canonical.y
                              , v = Math.pow(2, a.tileID.canonical.z)
                              , T = h.tileID.key;
                            m === 0 && y === 0 || Math.abs(y) > 1 || (Math.abs(m) > 1 && (Math.abs(m + v) === 1 ? m += v : Math.abs(m - v) === 1 && (m -= v)),
                            h.dem && a.dem && (a.dem.backfillBorder(h.dem, m, y),
                            a.neighboringTiles && a.neighboringTiles[T] && (a.neighboringTiles[T].backfilled = !0)))
                        }
                    }
                    getTile(e) {
                        return this.getTileByID(e.key)
                    }
                    getTileByID(e) {
                        return this._tiles[e]
                    }
                    _retainLoadedChildren(e, i, o, a) {
                        for (const h in this._tiles) {
                            let m = this._tiles[h];
                            if (a[h] || !m.hasData() || m.tileID.overscaledZ <= i || m.tileID.overscaledZ > o)
                                continue;
                            let y = m.tileID;
                            for (; m && m.tileID.overscaledZ > i + 1; ) {
                                const T = m.tileID.scaledTo(m.tileID.overscaledZ - 1);
                                m = this._tiles[T.key],
                                m && m.hasData() && (y = T)
                            }
                            let v = y;
                            for (; v.overscaledZ > i; )
                                if (v = v.scaledTo(v.overscaledZ - 1),
                                e[v.key] || e[v.canonical.key]) {
                                    a[y.key] = y;
                                    break
                                }
                        }
                    }
                    findLoadedParent(e, i) {
                        if (e.key in this._loadedParentTiles) {
                            const o = this._loadedParentTiles[e.key];
                            return o && o.tileID.overscaledZ >= i ? o : null
                        }
                        for (let o = e.overscaledZ - 1; o >= i; o--) {
                            const a = e.scaledTo(o)
                              , h = this._getLoadedTile(a);
                            if (h)
                                return h
                        }
                    }
                    findLoadedSibling(e) {
                        return this._getLoadedTile(e)
                    }
                    _getLoadedTile(e) {
                        const i = this._tiles[e.key];
                        return i && i.hasData() ? i : this._cache.getByKey(e.wrapped().key)
                    }
                    updateCacheSize(e) {
                        const i = Math.ceil(e.width / this._source.tileSize) + 1
                          , o = Math.ceil(e.height / this._source.tileSize) + 1
                          , a = Math.floor(i * o * (this._maxTileCacheZoomLevels === null ? l.a.MAX_TILE_CACHE_ZOOM_LEVELS : this._maxTileCacheZoomLevels))
                          , h = typeof this._maxTileCacheSize == "number" ? Math.min(this._maxTileCacheSize, a) : a;
                        this._cache.setMaxSize(h)
                    }
                    handleWrapJump(e) {
                        const i = Math.round((e - (this._prevLng === void 0 ? e : this._prevLng)) / 360);
                        if (this._prevLng = e,
                        i) {
                            const o = {};
                            for (const a in this._tiles) {
                                const h = this._tiles[a];
                                h.tileID = h.tileID.unwrapTo(h.tileID.wrap + i),
                                o[h.tileID.key] = h
                            }
                            this._tiles = o;
                            for (const a in this._timers)
                                clearTimeout(this._timers[a]),
                                delete this._timers[a];
                            for (const a in this._tiles)
                                this._setTileReloadTimer(a, this._tiles[a])
                        }
                    }
                    _updateCoveredAndRetainedTiles(e, i, o, a, h, m) {
                        const y = {}
                          , v = {}
                          , T = Object.keys(e)
                          , S = oe.now();
                        for (const A of T) {
                            const k = e[A]
                              , O = this._tiles[A];
                            if (!O || O.fadeEndTime !== 0 && O.fadeEndTime <= S)
                                continue;
                            const V = this.findLoadedParent(k, i)
                              , H = this.findLoadedSibling(k)
                              , q = V || H || null;
                            q && (this._addTile(q.tileID),
                            y[q.tileID.key] = q.tileID),
                            v[A] = k
                        }
                        this._retainLoadedChildren(v, a, o, e);
                        for (const A in y)
                            e[A] || (this._coveredTiles[A] = !0,
                            e[A] = y[A]);
                        if (m) {
                            const A = {}
                              , k = {};
                            for (const O of h)
                                this._tiles[O.key].hasData() ? A[O.key] = O : k[O.key] = O;
                            for (const O in k) {
                                const V = k[O].children(this._source.maxzoom);
                                this._tiles[V[0].key] && this._tiles[V[1].key] && this._tiles[V[2].key] && this._tiles[V[3].key] && (A[V[0].key] = e[V[0].key] = V[0],
                                A[V[1].key] = e[V[1].key] = V[1],
                                A[V[2].key] = e[V[2].key] = V[2],
                                A[V[3].key] = e[V[3].key] = V[3],
                                delete k[O])
                            }
                            for (const O in k) {
                                const V = k[O]
                                  , H = this.findLoadedParent(V, this._source.minzoom)
                                  , q = this.findLoadedSibling(V)
                                  , W = H || q || null;
                                if (W) {
                                    A[W.tileID.key] = e[W.tileID.key] = W.tileID;
                                    for (const J in A)
                                        A[J].isChildOf(W.tileID) && delete A[J]
                                }
                            }
                            for (const O in this._tiles)
                                A[O] || (this._coveredTiles[O] = !0)
                        }
                    }
                    update(e, i) {
                        if (!this._sourceLoaded || this._paused)
                            return;
                        let o;
                        this.transform = e,
                        this.terrain = i,
                        this.updateCacheSize(e),
                        this.handleWrapJump(this.transform.center.lng),
                        this._coveredTiles = {},
                        this.used || this.usedForTerrain ? this._source.tileID ? o = e.getVisibleUnwrappedCoordinates(this._source.tileID).map(S => new l.Y(S.canonical.z,S.wrap,S.canonical.z,S.canonical.x,S.canonical.y)) : (o = pe(e, {
                            tileSize: this.usedForTerrain ? this.tileSize : this._source.tileSize,
                            minzoom: this._source.minzoom,
                            maxzoom: this._source.maxzoom,
                            roundZoom: !this.usedForTerrain && this._source.roundZoom,
                            reparseOverscaled: this._source.reparseOverscaled,
                            terrain: i,
                            calculateTileZoom: this._source.calculateTileZoom
                        }),
                        this._source.hasTile && (o = o.filter(S => this._source.hasTile(S)))) : o = [];
                        const a = _n(e, this._source)
                          , h = Math.max(a - E.maxOverzooming, this._source.minzoom)
                          , m = Math.max(a + E.maxUnderzooming, this._source.minzoom);
                        if (this.usedForTerrain) {
                            const S = {};
                            for (const A of o)
                                if (A.canonical.z > this._source.minzoom) {
                                    const k = A.scaledTo(A.canonical.z - 1);
                                    S[k.key] = k;
                                    const O = A.scaledTo(Math.max(this._source.minzoom, Math.min(A.canonical.z, 5)));
                                    S[O.key] = O
                                }
                            o = o.concat(Object.values(S))
                        }
                        const y = o.length === 0 && !this._updated && this._didEmitContent;
                        this._updated = !0,
                        y && this.fire(new l.l("data",{
                            sourceDataType: "idle",
                            dataType: "source",
                            sourceId: this.id
                        }));
                        const v = this._updateRetainedTiles(o, a);
                        $(this._source.type) && this._updateCoveredAndRetainedTiles(v, h, m, a, o, i);
                        for (const S in v)
                            this._tiles[S].clearFadeHold();
                        const T = l.ae(this._tiles, v);
                        for (const S of T) {
                            const A = this._tiles[S];
                            A.hasSymbolBuckets && !A.holdingForFade() ? A.setHoldDuration(this.map._fadeDuration) : A.hasSymbolBuckets && !A.symbolFadeFinished() || this._removeTile(S)
                        }
                        this._updateLoadedParentTileCache(),
                        this._updateLoadedSiblingTileCache()
                    }
                    releaseSymbolFadeTiles() {
                        for (const e in this._tiles)
                            this._tiles[e].holdingForFade() && this._removeTile(e)
                    }
                    _updateRetainedTiles(e, i) {
                        var o;
                        const a = {}
                          , h = {}
                          , m = Math.max(i - E.maxOverzooming, this._source.minzoom)
                          , y = Math.max(i + E.maxUnderzooming, this._source.minzoom)
                          , v = {};
                        for (const T of e) {
                            const S = this._addTile(T);
                            a[T.key] = T,
                            S.hasData() || i < this._source.maxzoom && (v[T.key] = T)
                        }
                        this._retainLoadedChildren(v, i, y, a);
                        for (const T of e) {
                            let S = this._tiles[T.key];
                            if (S.hasData())
                                continue;
                            if (i + 1 > this._source.maxzoom) {
                                const k = T.children(this._source.maxzoom)[0]
                                  , O = this.getTile(k);
                                if (O && O.hasData()) {
                                    a[k.key] = k;
                                    continue
                                }
                            } else {
                                const k = T.children(this._source.maxzoom);
                                if (a[k[0].key] && a[k[1].key] && a[k[2].key] && a[k[3].key])
                                    continue
                            }
                            let A = S.wasRequested();
                            for (let k = T.overscaledZ - 1; k >= m; --k) {
                                const O = T.scaledTo(k);
                                if (h[O.key])
                                    break;
                                if (h[O.key] = !0,
                                S = this.getTile(O),
                                !S && A && (S = this._addTile(O)),
                                S) {
                                    const V = S.hasData();
                                    if ((V || !(!((o = this.map) === null || o === void 0) && o.cancelPendingTileRequestsWhileZooming) || A) && (a[O.key] = O),
                                    A = S.wasRequested(),
                                    V)
                                        break
                                }
                            }
                        }
                        return a
                    }
                    _updateLoadedParentTileCache() {
                        this._loadedParentTiles = {};
                        for (const e in this._tiles) {
                            const i = [];
                            let o, a = this._tiles[e].tileID;
                            for (; a.overscaledZ > 0; ) {
                                if (a.key in this._loadedParentTiles) {
                                    o = this._loadedParentTiles[a.key];
                                    break
                                }
                                i.push(a.key);
                                const h = a.scaledTo(a.overscaledZ - 1);
                                if (o = this._getLoadedTile(h),
                                o)
                                    break;
                                a = h
                            }
                            for (const h of i)
                                this._loadedParentTiles[h] = o
                        }
                    }
                    _updateLoadedSiblingTileCache() {
                        this._loadedSiblingTiles = {};
                        for (const e in this._tiles) {
                            const i = this._tiles[e].tileID
                              , o = this._getLoadedTile(i);
                            this._loadedSiblingTiles[i.key] = o
                        }
                    }
                    _addTile(e) {
                        let i = this._tiles[e.key];
                        if (i)
                            return i;
                        i = this._cache.getAndRemove(e),
                        i && (this._setTileReloadTimer(e.key, i),
                        i.tileID = e,
                        this._state.initializeTileState(i, this.map ? this.map.painter : null),
                        this._cacheTimers[e.key] && (clearTimeout(this._cacheTimers[e.key]),
                        delete this._cacheTimers[e.key],
                        this._setTileReloadTimer(e.key, i)));
                        const o = i;
                        return i || (i = new Ln(e,this._source.tileSize * e.overscaleFactor()),
                        this._loadTile(i, e.key, i.state)),
                        i.uses++,
                        this._tiles[e.key] = i,
                        o || this._source.fire(new l.l("dataloading",{
                            tile: i,
                            coord: i.tileID,
                            dataType: "source"
                        })),
                        i
                    }
                    _setTileReloadTimer(e, i) {
                        e in this._timers && (clearTimeout(this._timers[e]),
                        delete this._timers[e]);
                        const o = i.getExpiryTimeout();
                        o && (this._timers[e] = setTimeout( () => {
                            this._reloadTile(e, "expired"),
                            delete this._timers[e]
                        }
                        , o))
                    }
                    _removeTile(e) {
                        const i = this._tiles[e];
                        i && (i.uses--,
                        delete this._tiles[e],
                        this._timers[e] && (clearTimeout(this._timers[e]),
                        delete this._timers[e]),
                        i.uses > 0 || (i.hasData() && i.state !== "reloading" ? this._cache.add(i.tileID, i, i.getExpiryTimeout()) : (i.aborted = !0,
                        this._abortTile(i),
                        this._unloadTile(i))))
                    }
                    _dataHandler(e) {
                        const i = e.sourceDataType;
                        e.dataType === "source" && i === "metadata" && (this._sourceLoaded = !0),
                        this._sourceLoaded && !this._paused && e.dataType === "source" && i === "content" && (this.reload(e.sourceDataChanged),
                        this.transform && this.update(this.transform, this.terrain),
                        this._didEmitContent = !0)
                    }
                    clearTiles() {
                        this._shouldReloadOnResume = !1,
                        this._paused = !1;
                        for (const e in this._tiles)
                            this._removeTile(e);
                        this._cache.reset()
                    }
                    tilesIn(e, i, o) {
                        const a = []
                          , h = this.transform;
                        if (!h)
                            return a;
                        const m = o ? h.getCameraQueryGeometry(e) : e
                          , y = e.map(V => h.screenPointToMercatorCoordinate(V, this.terrain))
                          , v = m.map(V => h.screenPointToMercatorCoordinate(V, this.terrain))
                          , T = this.getIds();
                        let S = 1 / 0
                          , A = 1 / 0
                          , k = -1 / 0
                          , O = -1 / 0;
                        for (const V of v)
                            S = Math.min(S, V.x),
                            A = Math.min(A, V.y),
                            k = Math.max(k, V.x),
                            O = Math.max(O, V.y);
                        for (let V = 0; V < T.length; V++) {
                            const H = this._tiles[T[V]];
                            if (H.holdingForFade())
                                continue;
                            const q = H.tileID
                              , W = Math.pow(2, h.zoom - H.tileID.overscaledZ)
                              , J = i * H.queryPadding * l.Z / H.tileSize / W
                              , te = [q.getTilePoint(new l.$(S,A)), q.getTilePoint(new l.$(k,O))];
                            if (te[0].x - J < l.Z && te[0].y - J < l.Z && te[1].x + J >= 0 && te[1].y + J >= 0) {
                                const ie = y.map(le => q.getTilePoint(le))
                                  , ne = v.map(le => q.getTilePoint(le));
                                a.push({
                                    tile: H,
                                    tileID: q,
                                    queryGeometry: ie,
                                    cameraQueryGeometry: ne,
                                    scale: W
                                })
                            }
                        }
                        return a
                    }
                    getVisibleCoordinates(e) {
                        const i = this.getRenderableIds(e).map(o => this._tiles[o].tileID);
                        return this.transform && this.transform.populateCache(i),
                        i
                    }
                    hasTransition() {
                        if (this._source.hasTransition())
                            return !0;
                        if ($(this._source.type)) {
                            const e = oe.now();
                            for (const i in this._tiles)
                                if (this._tiles[i].fadeEndTime >= e)
                                    return !0
                        }
                        return !1
                    }
                    setFeatureState(e, i, o) {
                        this._state.updateState(e = e || "_geojsonTileLayer", i, o)
                    }
                    removeFeatureState(e, i, o) {
                        this._state.removeFeatureState(e = e || "_geojsonTileLayer", i, o)
                    }
                    getFeatureState(e, i) {
                        return this._state.getState(e = e || "_geojsonTileLayer", i)
                    }
                    setDependencies(e, i, o) {
                        const a = this._tiles[e];
                        a && a.setDependencies(i, o)
                    }
                    reloadTilesForDependencies(e, i) {
                        for (const o in this._tiles)
                            this._tiles[o].hasDependency(e, i) && this._reloadTile(o, "reloading");
                        this._cache.filter(o => !o.hasDependency(e, i))
                    }
                }
                function U(u, e) {
                    const i = Math.abs(2 * u.wrap) - +(u.wrap < 0)
                      , o = Math.abs(2 * e.wrap) - +(e.wrap < 0);
                    return u.overscaledZ - e.overscaledZ || o - i || e.canonical.y - u.canonical.y || e.canonical.x - u.canonical.x
                }
                function $(u) {
                    return u === "raster" || u === "image" || u === "video"
                }
                E.maxOverzooming = 10,
                E.maxUnderzooming = 3;
                class K {
                    constructor(e, i) {
                        this.reset(e, i)
                    }
                    reset(e, i) {
                        this.points = e || [],
                        this._distances = [0];
                        for (let o = 1; o < this.points.length; o++)
                            this._distances[o] = this._distances[o - 1] + this.points[o].dist(this.points[o - 1]);
                        this.length = this._distances[this._distances.length - 1],
                        this.padding = Math.min(i || 0, .5 * this.length),
                        this.paddedLength = this.length - 2 * this.padding
                    }
                    lerp(e) {
                        if (this.points.length === 1)
                            return this.points[0];
                        e = l.ad(e, 0, 1);
                        let i = 1
                          , o = this._distances[i];
                        const a = e * this.paddedLength + this.padding;
                        for (; o < a && i < this._distances.length; )
                            o = this._distances[++i];
                        const h = i - 1
                          , m = this._distances[h]
                          , y = o - m
                          , v = y > 0 ? (a - m) / y : 0;
                        return this.points[h].mult(1 - v).add(this.points[i].mult(v))
                    }
                }
                function re(u, e) {
                    let i = !0;
                    return u === "always" || u !== "never" && e !== "never" || (i = !1),
                    i
                }
                class he {
                    constructor(e, i, o) {
                        const a = this.boxCells = []
                          , h = this.circleCells = [];
                        this.xCellCount = Math.ceil(e / o),
                        this.yCellCount = Math.ceil(i / o);
                        for (let m = 0; m < this.xCellCount * this.yCellCount; m++)
                            a.push([]),
                            h.push([]);
                        this.circleKeys = [],
                        this.boxKeys = [],
                        this.bboxes = [],
                        this.circles = [],
                        this.width = e,
                        this.height = i,
                        this.xScale = this.xCellCount / e,
                        this.yScale = this.yCellCount / i,
                        this.boxUid = 0,
                        this.circleUid = 0
                    }
                    keysLength() {
                        return this.boxKeys.length + this.circleKeys.length
                    }
                    insert(e, i, o, a, h) {
                        this._forEachCell(i, o, a, h, this._insertBoxCell, this.boxUid++),
                        this.boxKeys.push(e),
                        this.bboxes.push(i),
                        this.bboxes.push(o),
                        this.bboxes.push(a),
                        this.bboxes.push(h)
                    }
                    insertCircle(e, i, o, a) {
                        this._forEachCell(i - a, o - a, i + a, o + a, this._insertCircleCell, this.circleUid++),
                        this.circleKeys.push(e),
                        this.circles.push(i),
                        this.circles.push(o),
                        this.circles.push(a)
                    }
                    _insertBoxCell(e, i, o, a, h, m) {
                        this.boxCells[h].push(m)
                    }
                    _insertCircleCell(e, i, o, a, h, m) {
                        this.circleCells[h].push(m)
                    }
                    _query(e, i, o, a, h, m, y) {
                        if (o < 0 || e > this.width || a < 0 || i > this.height)
                            return [];
                        const v = [];
                        if (e <= 0 && i <= 0 && this.width <= o && this.height <= a) {
                            if (h)
                                return [{
                                    key: null,
                                    x1: e,
                                    y1: i,
                                    x2: o,
                                    y2: a
                                }];
                            for (let T = 0; T < this.boxKeys.length; T++)
                                v.push({
                                    key: this.boxKeys[T],
                                    x1: this.bboxes[4 * T],
                                    y1: this.bboxes[4 * T + 1],
                                    x2: this.bboxes[4 * T + 2],
                                    y2: this.bboxes[4 * T + 3]
                                });
                            for (let T = 0; T < this.circleKeys.length; T++) {
                                const S = this.circles[3 * T]
                                  , A = this.circles[3 * T + 1]
                                  , k = this.circles[3 * T + 2];
                                v.push({
                                    key: this.circleKeys[T],
                                    x1: S - k,
                                    y1: A - k,
                                    x2: S + k,
                                    y2: A + k
                                })
                            }
                        } else
                            this._forEachCell(e, i, o, a, this._queryCell, v, {
                                hitTest: h,
                                overlapMode: m,
                                seenUids: {
                                    box: {},
                                    circle: {}
                                }
                            }, y);
                        return v
                    }
                    query(e, i, o, a) {
                        return this._query(e, i, o, a, !1, null)
                    }
                    hitTest(e, i, o, a, h, m) {
                        return this._query(e, i, o, a, !0, h, m).length > 0
                    }
                    hitTestCircle(e, i, o, a, h) {
                        const m = e - o
                          , y = e + o
                          , v = i - o
                          , T = i + o;
                        if (y < 0 || m > this.width || T < 0 || v > this.height)
                            return !1;
                        const S = [];
                        return this._forEachCell(m, v, y, T, this._queryCellCircle, S, {
                            hitTest: !0,
                            overlapMode: a,
                            circle: {
                                x: e,
                                y: i,
                                radius: o
                            },
                            seenUids: {
                                box: {},
                                circle: {}
                            }
                        }, h),
                        S.length > 0
                    }
                    _queryCell(e, i, o, a, h, m, y, v) {
                        const {seenUids: T, hitTest: S, overlapMode: A} = y
                          , k = this.boxCells[h];
                        if (k !== null) {
                            const V = this.bboxes;
                            for (const H of k)
                                if (!T.box[H]) {
                                    T.box[H] = !0;
                                    const q = 4 * H
                                      , W = this.boxKeys[H];
                                    if (e <= V[q + 2] && i <= V[q + 3] && o >= V[q + 0] && a >= V[q + 1] && (!v || v(W)) && (!S || !re(A, W.overlapMode)) && (m.push({
                                        key: W,
                                        x1: V[q],
                                        y1: V[q + 1],
                                        x2: V[q + 2],
                                        y2: V[q + 3]
                                    }),
                                    S))
                                        return !0
                                }
                        }
                        const O = this.circleCells[h];
                        if (O !== null) {
                            const V = this.circles;
                            for (const H of O)
                                if (!T.circle[H]) {
                                    T.circle[H] = !0;
                                    const q = 3 * H
                                      , W = this.circleKeys[H];
                                    if (this._circleAndRectCollide(V[q], V[q + 1], V[q + 2], e, i, o, a) && (!v || v(W)) && (!S || !re(A, W.overlapMode))) {
                                        const J = V[q]
                                          , te = V[q + 1]
                                          , ie = V[q + 2];
                                        if (m.push({
                                            key: W,
                                            x1: J - ie,
                                            y1: te - ie,
                                            x2: J + ie,
                                            y2: te + ie
                                        }),
                                        S)
                                            return !0
                                    }
                                }
                        }
                        return !1
                    }
                    _queryCellCircle(e, i, o, a, h, m, y, v) {
                        const {circle: T, seenUids: S, overlapMode: A} = y
                          , k = this.boxCells[h];
                        if (k !== null) {
                            const V = this.bboxes;
                            for (const H of k)
                                if (!S.box[H]) {
                                    S.box[H] = !0;
                                    const q = 4 * H
                                      , W = this.boxKeys[H];
                                    if (this._circleAndRectCollide(T.x, T.y, T.radius, V[q + 0], V[q + 1], V[q + 2], V[q + 3]) && (!v || v(W)) && !re(A, W.overlapMode))
                                        return m.push(!0),
                                        !0
                                }
                        }
                        const O = this.circleCells[h];
                        if (O !== null) {
                            const V = this.circles;
                            for (const H of O)
                                if (!S.circle[H]) {
                                    S.circle[H] = !0;
                                    const q = 3 * H
                                      , W = this.circleKeys[H];
                                    if (this._circlesCollide(V[q], V[q + 1], V[q + 2], T.x, T.y, T.radius) && (!v || v(W)) && !re(A, W.overlapMode))
                                        return m.push(!0),
                                        !0
                                }
                        }
                    }
                    _forEachCell(e, i, o, a, h, m, y, v) {
                        const T = this._convertToXCellCoord(e)
                          , S = this._convertToYCellCoord(i)
                          , A = this._convertToXCellCoord(o)
                          , k = this._convertToYCellCoord(a);
                        for (let O = T; O <= A; O++)
                            for (let V = S; V <= k; V++)
                                if (h.call(this, e, i, o, a, this.xCellCount * V + O, m, y, v))
                                    return
                    }
                    _convertToXCellCoord(e) {
                        return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(e * this.xScale)))
                    }
                    _convertToYCellCoord(e) {
                        return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(e * this.yScale)))
                    }
                    _circlesCollide(e, i, o, a, h, m) {
                        const y = a - e
                          , v = h - i
                          , T = o + m;
                        return T * T > y * y + v * v
                    }
                    _circleAndRectCollide(e, i, o, a, h, m, y) {
                        const v = (m - a) / 2
                          , T = Math.abs(e - (a + v));
                        if (T > v + o)
                            return !1;
                        const S = (y - h) / 2
                          , A = Math.abs(i - (h + S));
                        if (A > S + o)
                            return !1;
                        if (T <= v || A <= S)
                            return !0;
                        const k = T - v
                          , O = A - S;
                        return k * k + O * O <= o * o
                    }
                }
                function ve(u, e, i) {
                    const o = l.K();
                    if (!u) {
                        const {vecSouth: A, vecEast: k} = Se(e)
                          , O = de();
                        O[0] = k[0],
                        O[1] = k[1],
                        O[2] = A[0],
                        O[3] = A[1],
                        a = O,
                        (S = (m = (h = O)[0]) * (T = h[3]) - (v = h[2]) * (y = h[1])) && (a[0] = T * (S = 1 / S),
                        a[1] = -y * S,
                        a[2] = -v * S,
                        a[3] = m * S),
                        o[0] = O[0],
                        o[1] = O[1],
                        o[4] = O[2],
                        o[5] = O[3]
                    }
                    var a, h, m, y, v, T, S;
                    return l.M(o, o, [1 / i, 1 / i, 1]),
                    o
                }
                function ue(u, e, i, o) {
                    if (u) {
                        const a = l.K();
                        if (!e) {
                            const {vecSouth: h, vecEast: m} = Se(i);
                            a[0] = m[0],
                            a[1] = m[1],
                            a[4] = h[0],
                            a[5] = h[1]
                        }
                        return l.M(a, a, [o, o, 1]),
                        a
                    }
                    return i.pixelsToClipSpaceMatrix
                }
                function Se(u) {
                    const e = Math.cos(u.rollInRadians)
                      , i = Math.sin(u.rollInRadians)
                      , o = Math.cos(u.pitchInRadians)
                      , a = Math.cos(u.bearingInRadians)
                      , h = Math.sin(u.bearingInRadians)
                      , m = l.aj();
                    m[0] = -a * o * i - h * e,
                    m[1] = -h * o * i + a * e;
                    const y = l.ak(m);
                    y < 1e-9 ? l.al(m) : l.am(m, m, 1 / y);
                    const v = l.aj();
                    v[0] = a * o * e - h * i,
                    v[1] = h * o * e + a * i;
                    const T = l.ak(v);
                    return T < 1e-9 ? l.al(v) : l.am(v, v, 1 / T),
                    {
                        vecEast: v,
                        vecSouth: m
                    }
                }
                function we(u, e, i, o) {
                    let a;
                    o ? (a = [u, e, o(u, e), 1],
                    l.ao(a, a, i)) : (a = [u, e, 0, 1],
                    xi(a, a, i));
                    const h = a[3];
                    return {
                        point: new l.P(a[0] / h,a[1] / h),
                        signedDistanceFromCamera: h,
                        isOccluded: !1
                    }
                }
                function fe(u, e) {
                    return .5 + u / e * .5
                }
                function ke(u, e) {
                    return u.x >= -e[0] && u.x <= e[0] && u.y >= -e[1] && u.y <= e[1]
                }
                function me(u, e, i, o, a, h, m, y, v, T, S, A, k) {
                    const O = i ? u.textSizeData : u.iconSizeData
                      , V = l.af(O, e.transform.zoom)
                      , H = [256 / e.width * 2 + 1, 256 / e.height * 2 + 1]
                      , q = i ? u.text.dynamicLayoutVertexArray : u.icon.dynamicLayoutVertexArray;
                    q.clear();
                    const W = u.lineVertexArray
                      , J = i ? u.text.placedSymbolArray : u.icon.placedSymbolArray
                      , te = e.transform.width / e.transform.height;
                    let ie = !1;
                    for (let ne = 0; ne < J.length; ne++) {
                        const le = J.get(ne);
                        if (le.hidden || le.writingMode === l.ag.vertical && !ie) {
                            ui(le.numGlyphs, q);
                            continue
                        }
                        ie = !1;
                        const se = new l.P(le.anchorX,le.anchorY)
                          , _e = {
                            getElevation: k,
                            pitchedLabelPlaneMatrix: o,
                            lineVertexArray: W,
                            pitchWithMap: h,
                            projectionCache: {
                                projections: {},
                                offsets: {},
                                cachedAnchorPoint: void 0,
                                anyProjectionOccluded: !1
                            },
                            transform: e.transform,
                            tileAnchorPoint: se,
                            unwrappedTileID: v,
                            width: T,
                            height: S,
                            translation: A
                        }
                          , xe = at(le.anchorX, le.anchorY, _e);
                        if (!ke(xe.point, H)) {
                            ui(le.numGlyphs, q);
                            continue
                        }
                        const Pe = fe(e.transform.cameraToCenterDistance, xe.signedDistanceFromCamera)
                          , Ie = l.ah(O, V, le)
                          , Ce = h ? Ie * e.transform.getPitchedTextCorrection(le.anchorX, le.anchorY, v) / Pe : Ie * Pe
                          , Ne = st({
                            projectionContext: _e,
                            pitchedLabelPlaneMatrixInverse: a,
                            symbol: le,
                            fontSize: Ce,
                            flip: !1,
                            keepUpright: m,
                            glyphOffsetArray: u.glyphOffsetArray,
                            dynamicLayoutVertexArray: q,
                            aspectRatio: te,
                            rotateToLine: y
                        });
                        ie = Ne.useVertical,
                        (Ne.notEnoughRoom || ie || Ne.needsFlipping && st({
                            projectionContext: _e,
                            pitchedLabelPlaneMatrixInverse: a,
                            symbol: le,
                            fontSize: Ce,
                            flip: !0,
                            keepUpright: m,
                            glyphOffsetArray: u.glyphOffsetArray,
                            dynamicLayoutVertexArray: q,
                            aspectRatio: te,
                            rotateToLine: y
                        }).notEnoughRoom) && ui(le.numGlyphs, q)
                    }
                    i ? u.text.dynamicLayoutVertexBuffer.updateData(q) : u.icon.dynamicLayoutVertexBuffer.updateData(q)
                }
                function je(u, e, i, o, a, h, m, y) {
                    const v = h.glyphStartIndex + h.numGlyphs
                      , T = h.lineStartIndex
                      , S = h.lineStartIndex + h.lineLength
                      , A = e.getoffsetX(h.glyphStartIndex)
                      , k = e.getoffsetX(v - 1)
                      , O = Je(u * A, i, o, a, h.segment, T, S, y, m);
                    if (!O)
                        return null;
                    const V = Je(u * k, i, o, a, h.segment, T, S, y, m);
                    return V ? y.projectionCache.anyProjectionOccluded ? null : {
                        first: O,
                        last: V
                    } : null
                }
                function We(u, e, i, o) {
                    return u === l.ag.horizontal && Math.abs(i.y - e.y) > Math.abs(i.x - e.x) * o ? {
                        useVertical: !0
                    } : (u === l.ag.vertical ? e.y < i.y : e.x > i.x) ? {
                        needsFlipping: !0
                    } : null
                }
                function st(u) {
                    const {projectionContext: e, pitchedLabelPlaneMatrixInverse: i, symbol: o, fontSize: a, flip: h, keepUpright: m, glyphOffsetArray: y, dynamicLayoutVertexArray: v, aspectRatio: T, rotateToLine: S} = u
                      , A = a / 24
                      , k = o.lineOffsetX * A
                      , O = o.lineOffsetY * A;
                    let V;
                    if (o.numGlyphs > 1) {
                        const H = o.glyphStartIndex + o.numGlyphs
                          , q = o.lineStartIndex
                          , W = o.lineStartIndex + o.lineLength
                          , J = je(A, y, k, O, h, o, S, e);
                        if (!J)
                            return {
                                notEnoughRoom: !0
                            };
                        const te = Ze(J.first.point.x, J.first.point.y, e, i)
                          , ie = Ze(J.last.point.x, J.last.point.y, e, i);
                        if (m && !h) {
                            const ne = We(o.writingMode, te, ie, T);
                            if (ne)
                                return ne
                        }
                        V = [J.first];
                        for (let ne = o.glyphStartIndex + 1; ne < H - 1; ne++)
                            V.push(Je(A * y.getoffsetX(ne), k, O, h, o.segment, q, W, e, S));
                        V.push(J.last)
                    } else {
                        if (m && !h) {
                            const q = Ge(e.tileAnchorPoint.x, e.tileAnchorPoint.y, e).point
                              , W = o.lineStartIndex + o.segment + 1
                              , J = new l.P(e.lineVertexArray.getx(W),e.lineVertexArray.gety(W))
                              , te = Ge(J.x, J.y, e)
                              , ie = te.signedDistanceFromCamera > 0 ? te.point : tt(e.tileAnchorPoint, J, q, 1, e)
                              , ne = Ze(q.x, q.y, e, i)
                              , le = Ze(ie.x, ie.y, e, i)
                              , se = We(o.writingMode, ne, le, T);
                            if (se)
                                return se
                        }
                        const H = Je(A * y.getoffsetX(o.glyphStartIndex), k, O, h, o.segment, o.lineStartIndex, o.lineStartIndex + o.lineLength, e, S);
                        if (!H || e.projectionCache.anyProjectionOccluded)
                            return {
                                notEnoughRoom: !0
                            };
                        V = [H]
                    }
                    for (const H of V)
                        l.an(v, H.point, H.angle);
                    return {}
                }
                function tt(u, e, i, o, a) {
                    const h = u.add(u.sub(e)._unit())
                      , m = Ge(h.x, h.y, a).point
                      , y = i.sub(m);
                    return i.add(y._mult(o / y.mag()))
                }
                function Ae(u, e, i) {
                    const o = e.projectionCache;
                    if (o.projections[u])
                        return o.projections[u];
                    const a = new l.P(e.lineVertexArray.getx(u),e.lineVertexArray.gety(u))
                      , h = Ge(a.x, a.y, e);
                    if (h.signedDistanceFromCamera > 0)
                        return o.projections[u] = h.point,
                        o.anyProjectionOccluded = o.anyProjectionOccluded || h.isOccluded,
                        h.point;
                    const m = u - i.direction;
                    return tt(i.distanceFromAnchor === 0 ? e.tileAnchorPoint : new l.P(e.lineVertexArray.getx(m),e.lineVertexArray.gety(m)), a, i.previousVertex, i.absOffsetX - i.distanceFromAnchor + 1, e)
                }
                function Ge(u, e, i) {
                    const o = u + i.translation[0]
                      , a = e + i.translation[1];
                    let h;
                    return i.pitchWithMap ? (h = we(o, a, i.pitchedLabelPlaneMatrix, i.getElevation),
                    h.isOccluded = !1) : (h = i.transform.projectTileCoordinates(o, a, i.unwrappedTileID, i.getElevation),
                    h.point.x = (.5 * h.point.x + .5) * i.width,
                    h.point.y = (.5 * -h.point.y + .5) * i.height),
                    h
                }
                function Ze(u, e, i, o) {
                    if (i.pitchWithMap) {
                        const a = [u, e, 0, 1];
                        return l.ao(a, a, o),
                        i.transform.projectTileCoordinates(a[0] / a[3], a[1] / a[3], i.unwrappedTileID, i.getElevation).point
                    }
                    return {
                        x: u / i.width * 2 - 1,
                        y: e / i.height * 2 - 1
                    }
                }
                function at(u, e, i) {
                    return i.transform.projectTileCoordinates(u, e, i.unwrappedTileID, i.getElevation)
                }
                function it(u, e, i) {
                    return u._unit()._perp()._mult(e * i)
                }
                function lt(u, e, i, o, a, h, m, y, v) {
                    if (y.projectionCache.offsets[u])
                        return y.projectionCache.offsets[u];
                    const T = i.add(e);
                    if (u + v.direction < o || u + v.direction >= a)
                        return y.projectionCache.offsets[u] = T,
                        T;
                    const S = Ae(u + v.direction, y, v)
                      , A = it(S.sub(i), m, v.direction)
                      , k = i.add(A)
                      , O = S.add(A);
                    return y.projectionCache.offsets[u] = l.ap(h, T, k, O) || T,
                    y.projectionCache.offsets[u]
                }
                function Je(u, e, i, o, a, h, m, y, v) {
                    const T = o ? u - e : u + e;
                    let S = T > 0 ? 1 : -1
                      , A = 0;
                    o && (S *= -1,
                    A = Math.PI),
                    S < 0 && (A += Math.PI);
                    let k, O = S > 0 ? h + a : h + a + 1;
                    y.projectionCache.cachedAnchorPoint ? k = y.projectionCache.cachedAnchorPoint : (k = Ge(y.tileAnchorPoint.x, y.tileAnchorPoint.y, y).point,
                    y.projectionCache.cachedAnchorPoint = k);
                    let V, H, q = k, W = k, J = 0, te = 0;
                    const ie = Math.abs(T)
                      , ne = [];
                    let le;
                    for (; J + te <= ie; ) {
                        if (O += S,
                        O < h || O >= m)
                            return null;
                        J += te,
                        W = q,
                        H = V;
                        const xe = {
                            absOffsetX: ie,
                            direction: S,
                            distanceFromAnchor: J,
                            previousVertex: W
                        };
                        if (q = Ae(O, y, xe),
                        i === 0)
                            ne.push(W),
                            le = q.sub(W);
                        else {
                            let Pe;
                            const Ie = q.sub(W);
                            Pe = Ie.mag() === 0 ? it(Ae(O + S, y, xe).sub(q), i, S) : it(Ie, i, S),
                            H || (H = W.add(Pe)),
                            V = lt(O, Pe, q, h, m, H, i, y, xe),
                            ne.push(H),
                            le = V.sub(H)
                        }
                        te = le.mag()
                    }
                    const se = le._mult((ie - J) / te)._add(H || W)
                      , _e = A + Math.atan2(q.y - W.y, q.x - W.x);
                    return ne.push(se),
                    {
                        point: se,
                        angle: v ? _e : 0,
                        path: ne
                    }
                }
                const Qn = new Float32Array([-1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0, -1 / 0, -1 / 0, 0]);
                function ui(u, e) {
                    for (let i = 0; i < u; i++) {
                        const o = e.length;
                        e.resize(o + 4),
                        e.float32.set(Qn, 3 * o)
                    }
                }
                function xi(u, e, i) {
                    const o = e[0]
                      , a = e[1];
                    return u[0] = i[0] * o + i[4] * a + i[12],
                    u[1] = i[1] * o + i[5] * a + i[13],
                    u[3] = i[3] * o + i[7] * a + i[15],
                    u
                }
                const Bt = 100;
                class zo {
                    constructor(e, i=new he(e.width + 200,e.height + 200,25), o=new he(e.width + 200,e.height + 200,25)) {
                        this.transform = e,
                        this.grid = i,
                        this.ignoredGrid = o,
                        this.pitchFactor = Math.cos(e.pitch * Math.PI / 180) * e.cameraToCenterDistance,
                        this.screenRightBoundary = e.width + Bt,
                        this.screenBottomBoundary = e.height + Bt,
                        this.gridRightBoundary = e.width + 200,
                        this.gridBottomBoundary = e.height + 200,
                        this.perspectiveRatioCutoff = .6
                    }
                    placeCollisionBox(e, i, o, a, h, m, y, v, T, S, A, k) {
                        const O = this.projectAndGetPerspectiveRatio(e.anchorPointX + v[0], e.anchorPointY + v[1], h, S, k)
                          , V = o * O.perspectiveRatio;
                        let H;
                        if (m || y)
                            H = this._projectCollisionBox(e, V, a, h, m, y, v, O, S, A, k);
                        else {
                            const le = O.x + (A ? A.x * V : 0)
                              , se = O.y + (A ? A.y * V : 0);
                            H = {
                                allPointsOccluded: !1,
                                box: [le + e.x1 * V, se + e.y1 * V, le + e.x2 * V, se + e.y2 * V]
                            }
                        }
                        const [q,W,J,te] = H.box
                          , ie = m ? H.allPointsOccluded : O.isOccluded;
                        let ne = ie;
                        return ne || (ne = O.perspectiveRatio < this.perspectiveRatioCutoff),
                        ne || (ne = !this.isInsideGrid(q, W, J, te)),
                        ne || i !== "always" && this.grid.hitTest(q, W, J, te, i, T) ? {
                            box: [q, W, J, te],
                            placeable: !1,
                            offscreen: !1,
                            occluded: ie
                        } : {
                            box: [q, W, J, te],
                            placeable: !0,
                            offscreen: this.isOffscreen(q, W, J, te),
                            occluded: ie
                        }
                    }
                    placeCollisionCircles(e, i, o, a, h, m, y, v, T, S, A, k, O, V) {
                        const H = []
                          , q = new l.P(i.anchorX,i.anchorY)
                          , W = this.getPerspectiveRatio(q.x, q.y, m, V)
                          , J = (T ? h * this.transform.getPitchedTextCorrection(i.anchorX, i.anchorY, m) / W : h * W) / l.au
                          , te = {
                            getElevation: V,
                            pitchedLabelPlaneMatrix: y,
                            lineVertexArray: o,
                            pitchWithMap: T,
                            projectionCache: {
                                projections: {},
                                offsets: {},
                                cachedAnchorPoint: void 0,
                                anyProjectionOccluded: !1
                            },
                            transform: this.transform,
                            tileAnchorPoint: q,
                            unwrappedTileID: m,
                            width: this.transform.width,
                            height: this.transform.height,
                            translation: O
                        }
                          , ie = je(J, a, i.lineOffsetX * J, i.lineOffsetY * J, !1, i, !1, te);
                        let ne = !1
                          , le = !1
                          , se = !0;
                        if (ie) {
                            const _e = .5 * A * W + k
                              , xe = new l.P(-100,-100)
                              , Pe = new l.P(this.screenRightBoundary,this.screenBottomBoundary)
                              , Ie = new K
                              , Ce = ie.first
                              , Ne = ie.last;
                            let Oe = [];
                            for (let Ke = Ce.path.length - 1; Ke >= 1; Ke--)
                                Oe.push(Ce.path[Ke]);
                            for (let Ke = 1; Ke < Ne.path.length; Ke++)
                                Oe.push(Ne.path[Ke]);
                            const De = 2.5 * _e;
                            if (T) {
                                const Ke = this.projectPathToScreenSpace(Oe, te);
                                Oe = Ke.some(wt => wt.signedDistanceFromCamera <= 0) ? [] : Ke.map(wt => wt.point)
                            }
                            let $e = [];
                            if (Oe.length > 0) {
                                const Ke = Oe[0].clone()
                                  , wt = Oe[0].clone();
                                for (let Dt = 1; Dt < Oe.length; Dt++)
                                    Ke.x = Math.min(Ke.x, Oe[Dt].x),
                                    Ke.y = Math.min(Ke.y, Oe[Dt].y),
                                    wt.x = Math.max(wt.x, Oe[Dt].x),
                                    wt.y = Math.max(wt.y, Oe[Dt].y);
                                $e = Ke.x >= xe.x && wt.x <= Pe.x && Ke.y >= xe.y && wt.y <= Pe.y ? [Oe] : wt.x < xe.x || Ke.x > Pe.x || wt.y < xe.y || Ke.y > Pe.y ? [] : l.aq([Oe], xe.x, xe.y, Pe.x, Pe.y)
                            }
                            for (const Ke of $e) {
                                Ie.reset(Ke, .25 * _e);
                                let wt = 0;
                                wt = Ie.length <= .5 * _e ? 1 : Math.ceil(Ie.paddedLength / De) + 1;
                                for (let Dt = 0; Dt < wt; Dt++) {
                                    const Et = Dt / Math.max(wt - 1, 1)
                                      , Zt = Ie.lerp(Et)
                                      , Ot = Zt.x + Bt
                                      , Ct = Zt.y + Bt;
                                    H.push(Ot, Ct, _e, 0);
                                    const At = Ot - _e
                                      , Ei = Ct - _e
                                      , Ai = Ot + _e
                                      , vi = Ct + _e;
                                    if (se = se && this.isOffscreen(At, Ei, Ai, vi),
                                    le = le || this.isInsideGrid(At, Ei, Ai, vi),
                                    e !== "always" && this.grid.hitTestCircle(Ot, Ct, _e, e, S) && (ne = !0,
                                    !v))
                                        return {
                                            circles: [],
                                            offscreen: !1,
                                            collisionDetected: ne
                                        }
                                }
                            }
                        }
                        return {
                            circles: !v && ne || !le || W < this.perspectiveRatioCutoff ? [] : H,
                            offscreen: se,
                            collisionDetected: ne
                        }
                    }
                    projectPathToScreenSpace(e, i) {
                        const o = function(a, h) {
                            const m = l.K();
                            return l.ai(m, h.pitchedLabelPlaneMatrix),
                            a.map(y => {
                                const v = we(y.x, y.y, m, h.getElevation)
                                  , T = h.transform.projectTileCoordinates(v.point.x, v.point.y, h.unwrappedTileID, h.getElevation);
                                return T.point.x = (.5 * T.point.x + .5) * h.width,
                                T.point.y = (.5 * -T.point.y + .5) * h.height,
                                T
                            }
                            )
                        }(e, i);
                        return function(a) {
                            let h = 0
                              , m = 0
                              , y = 0
                              , v = 0;
                            for (let T = 0; T < a.length; T++)
                                a[T].isOccluded ? (y = T + 1,
                                v = 0) : (v++,
                                v > m && (m = v,
                                h = y));
                            return a.slice(h, h + m)
                        }(o)
                    }
                    queryRenderedSymbols(e) {
                        if (e.length === 0 || this.grid.keysLength() === 0 && this.ignoredGrid.keysLength() === 0)
                            return {};
                        const i = [];
                        let o = 1 / 0
                          , a = 1 / 0
                          , h = -1 / 0
                          , m = -1 / 0;
                        for (const S of e) {
                            const A = new l.P(S.x + Bt,S.y + Bt);
                            o = Math.min(o, A.x),
                            a = Math.min(a, A.y),
                            h = Math.max(h, A.x),
                            m = Math.max(m, A.y),
                            i.push(A)
                        }
                        const y = this.grid.query(o, a, h, m).concat(this.ignoredGrid.query(o, a, h, m))
                          , v = {}
                          , T = {};
                        for (const S of y) {
                            const A = S.key;
                            if (v[A.bucketInstanceId] === void 0 && (v[A.bucketInstanceId] = {}),
                            v[A.bucketInstanceId][A.featureIndex])
                                continue;
                            const k = [new l.P(S.x1,S.y1), new l.P(S.x2,S.y1), new l.P(S.x2,S.y2), new l.P(S.x1,S.y2)];
                            l.ar(i, k) && (v[A.bucketInstanceId][A.featureIndex] = !0,
                            T[A.bucketInstanceId] === void 0 && (T[A.bucketInstanceId] = []),
                            T[A.bucketInstanceId].push(A.featureIndex))
                        }
                        return T
                    }
                    insertCollisionBox(e, i, o, a, h, m) {
                        (o ? this.ignoredGrid : this.grid).insert({
                            bucketInstanceId: a,
                            featureIndex: h,
                            collisionGroupID: m,
                            overlapMode: i
                        }, e[0], e[1], e[2], e[3])
                    }
                    insertCollisionCircles(e, i, o, a, h, m) {
                        const y = o ? this.ignoredGrid : this.grid
                          , v = {
                            bucketInstanceId: a,
                            featureIndex: h,
                            collisionGroupID: m,
                            overlapMode: i
                        };
                        for (let T = 0; T < e.length; T += 4)
                            y.insertCircle(v, e[T], e[T + 1], e[T + 2])
                    }
                    projectAndGetPerspectiveRatio(e, i, o, a, h) {
                        if (h) {
                            let m;
                            a ? (m = [e, i, a(e, i), 1],
                            l.ao(m, m, h)) : (m = [e, i, 0, 1],
                            xi(m, m, h));
                            const y = m[3];
                            return {
                                x: (m[0] / y + 1) / 2 * this.transform.width + Bt,
                                y: (-m[1] / y + 1) / 2 * this.transform.height + Bt,
                                perspectiveRatio: .5 + this.transform.cameraToCenterDistance / y * .5,
                                isOccluded: !1,
                                signedDistanceFromCamera: y
                            }
                        }
                        {
                            const m = this.transform.projectTileCoordinates(e, i, o, a);
                            return {
                                x: (m.point.x + 1) / 2 * this.transform.width + Bt,
                                y: (1 - m.point.y) / 2 * this.transform.height + Bt,
                                perspectiveRatio: .5 + this.transform.cameraToCenterDistance / m.signedDistanceFromCamera * .5,
                                isOccluded: m.isOccluded,
                                signedDistanceFromCamera: m.signedDistanceFromCamera
                            }
                        }
                    }
                    getPerspectiveRatio(e, i, o, a) {
                        const h = this.transform.projectTileCoordinates(e, i, o, a);
                        return .5 + this.transform.cameraToCenterDistance / h.signedDistanceFromCamera * .5
                    }
                    isOffscreen(e, i, o, a) {
                        return o < Bt || e >= this.screenRightBoundary || a < Bt || i > this.screenBottomBoundary
                    }
                    isInsideGrid(e, i, o, a) {
                        return o >= 0 && e < this.gridRightBoundary && a >= 0 && i < this.gridBottomBoundary
                    }
                    getViewportMatrix() {
                        const e = l.as([]);
                        return l.L(e, e, [-100, -100, 0]),
                        e
                    }
                    _projectCollisionBox(e, i, o, a, h, m, y, v, T, S, A) {
                        let k = 1
                          , O = 0
                          , V = 0
                          , H = 1;
                        const q = e.anchorPointX + y[0]
                          , W = e.anchorPointY + y[1];
                        if (m && !h) {
                            const Oe = this.projectAndGetPerspectiveRatio(q + 1, W, a, T, A)
                              , De = Oe.x - v.x
                              , $e = Math.atan((Oe.y - v.y) / De) + (De < 0 ? Math.PI : 0)
                              , Ke = Math.sin($e)
                              , wt = Math.cos($e);
                            k = wt,
                            O = Ke,
                            V = -Ke,
                            H = wt
                        } else if (!m && h) {
                            const Oe = Se(this.transform);
                            k = Oe.vecEast[0],
                            O = Oe.vecEast[1],
                            V = Oe.vecSouth[0],
                            H = Oe.vecSouth[1]
                        }
                        let J = v.x
                          , te = v.y
                          , ie = i;
                        h && (J = q,
                        te = W,
                        ie = Math.pow(2, -(this.transform.zoom - o.overscaledZ)),
                        ie *= this.transform.getPitchedTextCorrection(q, W, a),
                        S || (ie *= l.ad(.5 + v.signedDistanceFromCamera / this.transform.cameraToCenterDistance * .5, 0, 4))),
                        S && (J += k * S.x * ie + V * S.y * ie,
                        te += O * S.x * ie + H * S.y * ie);
                        const ne = e.x1 * ie
                          , le = e.x2 * ie
                          , se = (ne + le) / 2
                          , _e = e.y1 * ie
                          , xe = e.y2 * ie
                          , Pe = (_e + xe) / 2
                          , Ie = [{
                            offsetX: ne,
                            offsetY: _e
                        }, {
                            offsetX: se,
                            offsetY: _e
                        }, {
                            offsetX: le,
                            offsetY: _e
                        }, {
                            offsetX: le,
                            offsetY: Pe
                        }, {
                            offsetX: le,
                            offsetY: xe
                        }, {
                            offsetX: se,
                            offsetY: xe
                        }, {
                            offsetX: ne,
                            offsetY: xe
                        }, {
                            offsetX: ne,
                            offsetY: Pe
                        }];
                        let Ce = [];
                        for (const {offsetX: Oe, offsetY: De} of Ie)
                            Ce.push(new l.P(J + k * Oe + V * De,te + O * Oe + H * De));
                        let Ne = !1;
                        if (h) {
                            const Oe = Ce.map(De => this.projectAndGetPerspectiveRatio(De.x, De.y, a, T, A));
                            Ne = Oe.some(De => !De.isOccluded),
                            Ce = Oe.map(De => new l.P(De.x,De.y))
                        } else
                            Ne = !0;
                        return {
                            box: l.at(Ce),
                            allPointsOccluded: !Ne
                        }
                    }
                }
                class Qi {
                    constructor(e, i, o, a) {
                        this.opacity = e ? Math.max(0, Math.min(1, e.opacity + (e.placed ? i : -i))) : a && o ? 1 : 0,
                        this.placed = o
                    }
                    isHidden() {
                        return this.opacity === 0 && !this.placed
                    }
                }
                class zt {
                    constructor(e, i, o, a, h) {
                        this.text = new Qi(e ? e.text : null,i,o,h),
                        this.icon = new Qi(e ? e.icon : null,i,a,h)
                    }
                    isHidden() {
                        return this.text.isHidden() && this.icon.isHidden()
                    }
                }
                class xc {
                    constructor(e, i, o) {
                        this.text = e,
                        this.icon = i,
                        this.skipFade = o
                    }
                }
                class io {
                    constructor(e, i, o, a, h) {
                        this.bucketInstanceId = e,
                        this.featureIndex = i,
                        this.sourceLayerIndex = o,
                        this.bucketIndex = a,
                        this.tileID = h
                    }
                }
                class Ua {
                    constructor(e) {
                        this.crossSourceCollisions = e,
                        this.maxGroupID = 0,
                        this.collisionGroups = {}
                    }
                    get(e) {
                        if (this.crossSourceCollisions)
                            return {
                                ID: 0,
                                predicate: null
                            };
                        if (!this.collisionGroups[e]) {
                            const i = ++this.maxGroupID;
                            this.collisionGroups[e] = {
                                ID: i,
                                predicate: o => o.collisionGroupID === i
                            }
                        }
                        return this.collisionGroups[e]
                    }
                }
                function Rn(u, e, i, o, a) {
                    const {horizontalAlign: h, verticalAlign: m} = l.aA(u);
                    return new l.P(-(h - .5) * e + o[0] * a,-(m - .5) * i + o[1] * a)
                }
                class Cs {
                    constructor(e, i, o, a, h) {
                        this.transform = e.clone(),
                        this.terrain = i,
                        this.collisionIndex = new zo(this.transform),
                        this.placements = {},
                        this.opacities = {},
                        this.variableOffsets = {},
                        this.stale = !1,
                        this.commitTime = 0,
                        this.fadeDuration = o,
                        this.retainedQueryData = {},
                        this.collisionGroups = new Ua(a),
                        this.collisionCircleArrays = {},
                        this.collisionBoxArrays = new Map,
                        this.prevPlacement = h,
                        h && (h.prevPlacement = void 0),
                        this.placedOrientations = {}
                    }
                    _getTerrainElevationFunc(e) {
                        const i = this.terrain;
                        return i ? (o, a) => i.getElevation(e, o, a) : null
                    }
                    getBucketParts(e, i, o, a) {
                        const h = o.getBucket(i)
                          , m = o.latestFeatureIndex;
                        if (!h || !m || i.id !== h.layerIds[0])
                            return;
                        const y = o.collisionBoxArray
                          , v = h.layers[0].layout
                          , T = h.layers[0].paint
                          , S = Math.pow(2, this.transform.zoom - o.tileID.overscaledZ)
                          , A = o.tileSize / l.Z
                          , k = o.tileID.toUnwrapped()
                          , O = v.get("text-rotation-alignment") === "map"
                          , V = l.av(o, 1, this.transform.zoom)
                          , H = l.aw(this.collisionIndex.transform, o, T.get("text-translate"), T.get("text-translate-anchor"))
                          , q = l.aw(this.collisionIndex.transform, o, T.get("icon-translate"), T.get("icon-translate-anchor"))
                          , W = ve(O, this.transform, V);
                        this.retainedQueryData[h.bucketInstanceId] = new io(h.bucketInstanceId,m,h.sourceLayerIndex,h.index,o.tileID);
                        const J = {
                            bucket: h,
                            layout: v,
                            translationText: H,
                            translationIcon: q,
                            unwrappedTileID: k,
                            pitchedLabelPlaneMatrix: W,
                            scale: S,
                            textPixelRatio: A,
                            holdingForFade: o.holdingForFade(),
                            collisionBoxArray: y,
                            partiallyEvaluatedTextSize: l.af(h.textSizeData, this.transform.zoom),
                            collisionGroup: this.collisionGroups.get(h.sourceID)
                        };
                        if (a)
                            for (const te of h.sortKeyRanges) {
                                const {sortKey: ie, symbolInstanceStart: ne, symbolInstanceEnd: le} = te;
                                e.push({
                                    sortKey: ie,
                                    symbolInstanceStart: ne,
                                    symbolInstanceEnd: le,
                                    parameters: J
                                })
                            }
                        else
                            e.push({
                                symbolInstanceStart: 0,
                                symbolInstanceEnd: h.symbolInstances.length,
                                parameters: J
                            })
                    }
                    attemptAnchorPlacement(e, i, o, a, h, m, y, v, T, S, A, k, O, V, H, q, W, J, te, ie) {
                        const ne = l.ax[e.textAnchor]
                          , le = [e.textOffset0, e.textOffset1]
                          , se = Rn(ne, o, a, le, h)
                          , _e = this.collisionIndex.placeCollisionBox(i, k, v, T, S, y, m, q, A.predicate, te, se, ie);
                        if ((!J || this.collisionIndex.placeCollisionBox(J, k, v, T, S, y, m, W, A.predicate, te, se, ie).placeable) && _e.placeable) {
                            let xe;
                            if (this.prevPlacement && this.prevPlacement.variableOffsets[O.crossTileID] && this.prevPlacement.placements[O.crossTileID] && this.prevPlacement.placements[O.crossTileID].text && (xe = this.prevPlacement.variableOffsets[O.crossTileID].anchor),
                            O.crossTileID === 0)
                                throw new Error("symbolInstance.crossTileID can't be 0");
                            return this.variableOffsets[O.crossTileID] = {
                                textOffset: le,
                                width: o,
                                height: a,
                                anchor: ne,
                                textBoxScale: h,
                                prevAnchor: xe
                            },
                            this.markUsedJustification(V, ne, O, H),
                            V.allowVerticalPlacement && (this.markUsedOrientation(V, H, O),
                            this.placedOrientations[O.crossTileID] = H),
                            {
                                shift: se,
                                placedGlyphBoxes: _e
                            }
                        }
                    }
                    placeLayerBucketPart(e, i, o) {
                        const {bucket: a, layout: h, translationText: m, translationIcon: y, unwrappedTileID: v, pitchedLabelPlaneMatrix: T, textPixelRatio: S, holdingForFade: A, collisionBoxArray: k, partiallyEvaluatedTextSize: O, collisionGroup: V} = e.parameters
                          , H = h.get("text-optional")
                          , q = h.get("icon-optional")
                          , W = l.ay(h, "text-overlap", "text-allow-overlap")
                          , J = W === "always"
                          , te = l.ay(h, "icon-overlap", "icon-allow-overlap")
                          , ie = te === "always"
                          , ne = h.get("text-rotation-alignment") === "map"
                          , le = h.get("text-pitch-alignment") === "map"
                          , se = h.get("icon-text-fit") !== "none"
                          , _e = h.get("symbol-z-order") === "viewport-y"
                          , xe = J && (ie || !a.hasIconData() || q)
                          , Pe = ie && (J || !a.hasTextData() || H);
                        !a.collisionArrays && k && a.deserializeCollisionBoxes(k);
                        const Ie = this.retainedQueryData[a.bucketInstanceId].tileID
                          , Ce = this._getTerrainElevationFunc(Ie)
                          , Ne = this.transform.getFastPathSimpleProjectionMatrix(Ie)
                          , Oe = (De, $e, Ke) => {
                            var wt, Dt;
                            if (i[De.crossTileID])
                                return;
                            if (A)
                                return void (this.placements[De.crossTileID] = new xc(!1,!1,!1));
                            let Et = !1
                              , Zt = !1
                              , Ot = !0
                              , Ct = null
                              , At = {
                                box: null,
                                placeable: !1,
                                offscreen: null,
                                occluded: !1
                            }
                              , Ei = {
                                placeable: !1
                            }
                              , Ai = null
                              , vi = null
                              , Bi = null
                              , Un = 0
                              , vn = 0
                              , an = 0;
                            $e.textFeatureIndex ? Un = $e.textFeatureIndex : De.useRuntimeCollisionCircles && (Un = De.featureIndex),
                            $e.verticalTextFeatureIndex && (vn = $e.verticalTextFeatureIndex);
                            const kr = $e.textBox;
                            if (kr) {
                                const Lr = Rt => {
                                    let kt = l.ag.horizontal;
                                    if (a.allowVerticalPlacement && !Rt && this.prevPlacement) {
                                        const bi = this.prevPlacement.placedOrientations[De.crossTileID];
                                        bi && (this.placedOrientations[De.crossTileID] = bi,
                                        kt = bi,
                                        this.markUsedOrientation(a, kt, De))
                                    }
                                    return kt
                                }
                                  , ln = (Rt, kt) => {
                                    if (a.allowVerticalPlacement && De.numVerticalGlyphVertices > 0 && $e.verticalTextBox) {
                                        for (const bi of a.writingModes)
                                            if (bi === l.ag.vertical ? (At = kt(),
                                            Ei = At) : At = Rt(),
                                            At && At.placeable)
                                                break
                                    } else
                                        At = Rt()
                                }
                                  , Zr = De.textAnchorOffsetStartIndex
                                  , cn = De.textAnchorOffsetEndIndex;
                                if (cn === Zr) {
                                    const Rt = (kt, bi) => {
                                        const wi = this.collisionIndex.placeCollisionBox(kt, W, S, Ie, v, le, ne, m, V.predicate, Ce, void 0, Ne);
                                        return wi && wi.placeable && (this.markUsedOrientation(a, bi, De),
                                        this.placedOrientations[De.crossTileID] = bi),
                                        wi
                                    }
                                    ;
                                    ln( () => Rt(kr, l.ag.horizontal), () => {
                                        const kt = $e.verticalTextBox;
                                        return a.allowVerticalPlacement && De.numVerticalGlyphVertices > 0 && kt ? Rt(kt, l.ag.vertical) : {
                                            box: null,
                                            offscreen: null
                                        }
                                    }
                                    ),
                                    Lr(At && At.placeable)
                                } else {
                                    let Rt = l.ax[(Dt = (wt = this.prevPlacement) === null || wt === void 0 ? void 0 : wt.variableOffsets[De.crossTileID]) === null || Dt === void 0 ? void 0 : Dt.anchor];
                                    const kt = (wi, _s, vh) => {
                                        const cu = wi.x2 - wi.x1
                                          , Ul = wi.y2 - wi.y1
                                          , uu = De.textBoxScale
                                          , ys = se && te === "never" ? _s : null;
                                        let hr = null
                                          , Zl = W === "never" ? 1 : 2
                                          , hu = "never";
                                        Rt && Zl++;
                                        for (let ba = 0; ba < Zl; ba++) {
                                            for (let wa = Zr; wa < cn; wa++) {
                                                const du = a.textAnchorOffsets.get(wa);
                                                if (Rt && du.textAnchor !== Rt)
                                                    continue;
                                                const Ta = this.attemptAnchorPlacement(du, wi, cu, Ul, uu, ne, le, S, Ie, v, V, hu, De, a, vh, m, y, ys, Ce);
                                                if (Ta && (hr = Ta.placedGlyphBoxes,
                                                hr && hr.placeable))
                                                    return Et = !0,
                                                    Ct = Ta.shift,
                                                    hr
                                            }
                                            Rt ? Rt = null : hu = W
                                        }
                                        return o && !hr && (hr = {
                                            box: this.collisionIndex.placeCollisionBox(kr, "always", S, Ie, v, le, ne, m, V.predicate, Ce, void 0, Ne).box,
                                            offscreen: !1,
                                            placeable: !1,
                                            occluded: !1
                                        }),
                                        hr
                                    }
                                    ;
                                    ln( () => kt(kr, $e.iconBox, l.ag.horizontal), () => {
                                        const wi = $e.verticalTextBox;
                                        return a.allowVerticalPlacement && (!At || !At.placeable) && De.numVerticalGlyphVertices > 0 && wi ? kt(wi, $e.verticalIconBox, l.ag.vertical) : {
                                            box: null,
                                            occluded: !0,
                                            offscreen: null
                                        }
                                    }
                                    ),
                                    At && (Et = At.placeable,
                                    Ot = At.offscreen);
                                    const bi = Lr(At && At.placeable);
                                    if (!Et && this.prevPlacement) {
                                        const wi = this.prevPlacement.variableOffsets[De.crossTileID];
                                        wi && (this.variableOffsets[De.crossTileID] = wi,
                                        this.markUsedJustification(a, wi.anchor, De, bi))
                                    }
                                }
                            }
                            if (Ai = At,
                            Et = Ai && Ai.placeable,
                            Ot = Ai && Ai.offscreen,
                            De.useRuntimeCollisionCircles) {
                                const Lr = a.text.placedSymbolArray.get(De.centerJustifiedTextSymbolIndex)
                                  , ln = l.ah(a.textSizeData, O, Lr)
                                  , Zr = h.get("text-padding");
                                vi = this.collisionIndex.placeCollisionCircles(W, Lr, a.lineVertexArray, a.glyphOffsetArray, ln, v, T, o, le, V.predicate, De.collisionCircleDiameter, Zr, m, Ce),
                                vi.circles.length && vi.collisionDetected && !o && l.w("Collisions detected, but collision boxes are not shown"),
                                Et = J || vi.circles.length > 0 && !vi.collisionDetected,
                                Ot = Ot && vi.offscreen
                            }
                            if ($e.iconFeatureIndex && (an = $e.iconFeatureIndex),
                            $e.iconBox) {
                                const Lr = ln => this.collisionIndex.placeCollisionBox(ln, te, S, Ie, v, le, ne, y, V.predicate, Ce, se && Ct ? Ct : void 0, Ne);
                                Ei && Ei.placeable && $e.verticalIconBox ? (Bi = Lr($e.verticalIconBox),
                                Zt = Bi.placeable) : (Bi = Lr($e.iconBox),
                                Zt = Bi.placeable),
                                Ot = Ot && Bi.offscreen
                            }
                            const ms = H || De.numHorizontalGlyphVertices === 0 && De.numVerticalGlyphVertices === 0
                              , To = q || De.numIconVertices === 0;
                            ms || To ? To ? ms || (Zt = Zt && Et) : Et = Zt && Et : Zt = Et = Zt && Et;
                            const gs = Zt && Bi.placeable;
                            if (Et && Ai.placeable && this.collisionIndex.insertCollisionBox(Ai.box, W, h.get("text-ignore-placement"), a.bucketInstanceId, Ei && Ei.placeable && vn ? vn : Un, V.ID),
                            gs && this.collisionIndex.insertCollisionBox(Bi.box, te, h.get("icon-ignore-placement"), a.bucketInstanceId, an, V.ID),
                            vi && Et && this.collisionIndex.insertCollisionCircles(vi.circles, W, h.get("text-ignore-placement"), a.bucketInstanceId, Un, V.ID),
                            o && this.storeCollisionData(a.bucketInstanceId, Ke, $e, Ai, Bi, vi),
                            De.crossTileID === 0)
                                throw new Error("symbolInstance.crossTileID can't be 0");
                            if (a.bucketInstanceId === 0)
                                throw new Error("bucket.bucketInstanceId can't be 0");
                            this.placements[De.crossTileID] = new xc((Et || xe) && !Ai?.occluded,(Zt || Pe) && !Bi?.occluded,Ot || a.justReloaded),
                            i[De.crossTileID] = !0
                        }
                        ;
                        if (_e) {
                            if (e.symbolInstanceStart !== 0)
                                throw new Error("bucket.bucketInstanceId should be 0");
                            const De = a.getSortedSymbolIndexes(-this.transform.bearingInRadians);
                            for (let $e = De.length - 1; $e >= 0; --$e) {
                                const Ke = De[$e];
                                Oe(a.symbolInstances.get(Ke), a.collisionArrays[Ke], Ke)
                            }
                        } else
                            for (let De = e.symbolInstanceStart; De < e.symbolInstanceEnd; De++)
                                Oe(a.symbolInstances.get(De), a.collisionArrays[De], De);
                        a.justReloaded = !1
                    }
                    storeCollisionData(e, i, o, a, h, m) {
                        if (o.textBox || o.iconBox) {
                            let y, v;
                            this.collisionBoxArrays.has(e) ? y = this.collisionBoxArrays.get(e) : (y = new Map,
                            this.collisionBoxArrays.set(e, y)),
                            y.has(i) ? v = y.get(i) : (v = {
                                text: null,
                                icon: null
                            },
                            y.set(i, v)),
                            o.textBox && (v.text = a.box),
                            o.iconBox && (v.icon = h.box)
                        }
                        if (m) {
                            let y = this.collisionCircleArrays[e];
                            y === void 0 && (y = this.collisionCircleArrays[e] = []);
                            for (let v = 0; v < m.circles.length; v += 4)
                                y.push(m.circles[v + 0] - Bt),
                                y.push(m.circles[v + 1] - Bt),
                                y.push(m.circles[v + 2]),
                                y.push(m.collisionDetected ? 1 : 0)
                        }
                    }
                    markUsedJustification(e, i, o, a) {
                        let h;
                        h = a === l.ag.vertical ? o.verticalPlacedTextSymbolIndex : {
                            left: o.leftJustifiedTextSymbolIndex,
                            center: o.centerJustifiedTextSymbolIndex,
                            right: o.rightJustifiedTextSymbolIndex
                        }[l.az(i)];
                        const m = [o.leftJustifiedTextSymbolIndex, o.centerJustifiedTextSymbolIndex, o.rightJustifiedTextSymbolIndex, o.verticalPlacedTextSymbolIndex];
                        for (const y of m)
                            y >= 0 && (e.text.placedSymbolArray.get(y).crossTileID = h >= 0 && y !== h ? 0 : o.crossTileID)
                    }
                    markUsedOrientation(e, i, o) {
                        const a = i === l.ag.horizontal || i === l.ag.horizontalOnly ? i : 0
                          , h = i === l.ag.vertical ? i : 0
                          , m = [o.leftJustifiedTextSymbolIndex, o.centerJustifiedTextSymbolIndex, o.rightJustifiedTextSymbolIndex];
                        for (const y of m)
                            e.text.placedSymbolArray.get(y).placedOrientation = a;
                        o.verticalPlacedTextSymbolIndex && (e.text.placedSymbolArray.get(o.verticalPlacedTextSymbolIndex).placedOrientation = h)
                    }
                    commit(e) {
                        this.commitTime = e,
                        this.zoomAtLastRecencyCheck = this.transform.zoom;
                        const i = this.prevPlacement;
                        let o = !1;
                        this.prevZoomAdjustment = i ? i.zoomAdjustment(this.transform.zoom) : 0;
                        const a = i ? i.symbolFadeChange(e) : 1
                          , h = i ? i.opacities : {}
                          , m = i ? i.variableOffsets : {}
                          , y = i ? i.placedOrientations : {};
                        for (const v in this.placements) {
                            const T = this.placements[v]
                              , S = h[v];
                            S ? (this.opacities[v] = new zt(S,a,T.text,T.icon),
                            o = o || T.text !== S.text.placed || T.icon !== S.icon.placed) : (this.opacities[v] = new zt(null,a,T.text,T.icon,T.skipFade),
                            o = o || T.text || T.icon)
                        }
                        for (const v in h) {
                            const T = h[v];
                            if (!this.opacities[v]) {
                                const S = new zt(T,a,!1,!1);
                                S.isHidden() || (this.opacities[v] = S,
                                o = o || T.text.placed || T.icon.placed)
                            }
                        }
                        for (const v in m)
                            this.variableOffsets[v] || !this.opacities[v] || this.opacities[v].isHidden() || (this.variableOffsets[v] = m[v]);
                        for (const v in y)
                            this.placedOrientations[v] || !this.opacities[v] || this.opacities[v].isHidden() || (this.placedOrientations[v] = y[v]);
                        if (i && i.lastPlacementChangeTime === void 0)
                            throw new Error("Last placement time for previous placement is not defined");
                        o ? this.lastPlacementChangeTime = e : typeof this.lastPlacementChangeTime != "number" && (this.lastPlacementChangeTime = i ? i.lastPlacementChangeTime : e)
                    }
                    updateLayerOpacities(e, i) {
                        const o = {};
                        for (const a of i) {
                            const h = a.getBucket(e);
                            h && a.latestFeatureIndex && e.id === h.layerIds[0] && this.updateBucketOpacities(h, a.tileID, o, a.collisionBoxArray)
                        }
                    }
                    updateBucketOpacities(e, i, o, a) {
                        e.hasTextData() && (e.text.opacityVertexArray.clear(),
                        e.text.hasVisibleVertices = !1),
                        e.hasIconData() && (e.icon.opacityVertexArray.clear(),
                        e.icon.hasVisibleVertices = !1),
                        e.hasIconCollisionBoxData() && e.iconCollisionBox.collisionVertexArray.clear(),
                        e.hasTextCollisionBoxData() && e.textCollisionBox.collisionVertexArray.clear();
                        const h = e.layers[0]
                          , m = h.layout
                          , y = new zt(null,0,!1,!1,!0)
                          , v = m.get("text-allow-overlap")
                          , T = m.get("icon-allow-overlap")
                          , S = h._unevaluatedLayout.hasValue("text-variable-anchor") || h._unevaluatedLayout.hasValue("text-variable-anchor-offset")
                          , A = m.get("text-rotation-alignment") === "map"
                          , k = m.get("text-pitch-alignment") === "map"
                          , O = m.get("icon-text-fit") !== "none"
                          , V = new zt(null,0,v && (T || !e.hasIconData() || m.get("icon-optional")),T && (v || !e.hasTextData() || m.get("text-optional")),!0);
                        !e.collisionArrays && a && (e.hasIconCollisionBoxData() || e.hasTextCollisionBoxData()) && e.deserializeCollisionBoxes(a);
                        const H = (W, J, te) => {
                            for (let ie = 0; ie < J / 4; ie++)
                                W.opacityVertexArray.emplaceBack(te);
                            W.hasVisibleVertices = W.hasVisibleVertices || te !== Ss
                        }
                          , q = this.collisionBoxArrays.get(e.bucketInstanceId);
                        for (let W = 0; W < e.symbolInstances.length; W++) {
                            const J = e.symbolInstances.get(W)
                              , {numHorizontalGlyphVertices: te, numVerticalGlyphVertices: ie, crossTileID: ne} = J;
                            let le = this.opacities[ne];
                            o[ne] ? le = y : le || (le = V,
                            this.opacities[ne] = le),
                            o[ne] = !0;
                            const se = J.numIconVertices > 0
                              , _e = this.placedOrientations[J.crossTileID]
                              , xe = _e === l.ag.vertical
                              , Pe = _e === l.ag.horizontal || _e === l.ag.horizontalOnly;
                            if (te > 0 || ie > 0) {
                                const Ce = Ga(le.text);
                                H(e.text, te, xe ? Ss : Ce),
                                H(e.text, ie, Pe ? Ss : Ce);
                                const Ne = le.text.isHidden();
                                [J.rightJustifiedTextSymbolIndex, J.centerJustifiedTextSymbolIndex, J.leftJustifiedTextSymbolIndex].forEach($e => {
                                    $e >= 0 && (e.text.placedSymbolArray.get($e).hidden = Ne || xe ? 1 : 0)
                                }
                                ),
                                J.verticalPlacedTextSymbolIndex >= 0 && (e.text.placedSymbolArray.get(J.verticalPlacedTextSymbolIndex).hidden = Ne || Pe ? 1 : 0);
                                const Oe = this.variableOffsets[J.crossTileID];
                                Oe && this.markUsedJustification(e, Oe.anchor, J, _e);
                                const De = this.placedOrientations[J.crossTileID];
                                De && (this.markUsedJustification(e, "left", J, De),
                                this.markUsedOrientation(e, De, J))
                            }
                            if (se) {
                                const Ce = Ga(le.icon)
                                  , Ne = !(O && J.verticalPlacedIconSymbolIndex && xe);
                                J.placedIconSymbolIndex >= 0 && (H(e.icon, J.numIconVertices, Ne ? Ce : Ss),
                                e.icon.placedSymbolArray.get(J.placedIconSymbolIndex).hidden = le.icon.isHidden()),
                                J.verticalPlacedIconSymbolIndex >= 0 && (H(e.icon, J.numVerticalIconVertices, Ne ? Ss : Ce),
                                e.icon.placedSymbolArray.get(J.verticalPlacedIconSymbolIndex).hidden = le.icon.isHidden())
                            }
                            const Ie = q && q.has(W) ? q.get(W) : {
                                text: null,
                                icon: null
                            };
                            if (e.hasIconCollisionBoxData() || e.hasTextCollisionBoxData()) {
                                const Ce = e.collisionArrays[W];
                                if (Ce) {
                                    let Ne = new l.P(0,0);
                                    if (Ce.textBox || Ce.verticalTextBox) {
                                        let Oe = !0;
                                        if (S) {
                                            const De = this.variableOffsets[ne];
                                            De ? (Ne = Rn(De.anchor, De.width, De.height, De.textOffset, De.textBoxScale),
                                            A && Ne._rotate(k ? -this.transform.bearingInRadians : this.transform.bearingInRadians)) : Oe = !1
                                        }
                                        if (Ce.textBox || Ce.verticalTextBox) {
                                            let De;
                                            Ce.textBox && (De = xe),
                                            Ce.verticalTextBox && (De = Pe),
                                            Za(e.textCollisionBox.collisionVertexArray, le.text.placed, !Oe || De, Ie.text, Ne.x, Ne.y)
                                        }
                                    }
                                    if (Ce.iconBox || Ce.verticalIconBox) {
                                        const Oe = !!(!Pe && Ce.verticalIconBox);
                                        let De;
                                        Ce.iconBox && (De = Oe),
                                        Ce.verticalIconBox && (De = !Oe),
                                        Za(e.iconCollisionBox.collisionVertexArray, le.icon.placed, De, Ie.icon, O ? Ne.x : 0, O ? Ne.y : 0)
                                    }
                                }
                            }
                        }
                        if (e.sortFeatures(-this.transform.bearingInRadians),
                        this.retainedQueryData[e.bucketInstanceId] && (this.retainedQueryData[e.bucketInstanceId].featureSortOrder = e.featureSortOrder),
                        e.hasTextData() && e.text.opacityVertexBuffer && e.text.opacityVertexBuffer.updateData(e.text.opacityVertexArray),
                        e.hasIconData() && e.icon.opacityVertexBuffer && e.icon.opacityVertexBuffer.updateData(e.icon.opacityVertexArray),
                        e.hasIconCollisionBoxData() && e.iconCollisionBox.collisionVertexBuffer && e.iconCollisionBox.collisionVertexBuffer.updateData(e.iconCollisionBox.collisionVertexArray),
                        e.hasTextCollisionBoxData() && e.textCollisionBox.collisionVertexBuffer && e.textCollisionBox.collisionVertexBuffer.updateData(e.textCollisionBox.collisionVertexArray),
                        e.text.opacityVertexArray.length !== e.text.layoutVertexArray.length / 4)
                            throw new Error(`bucket.text.opacityVertexArray.length (= ${e.text.opacityVertexArray.length}) !== bucket.text.layoutVertexArray.length (= ${e.text.layoutVertexArray.length}) / 4`);
                        if (e.icon.opacityVertexArray.length !== e.icon.layoutVertexArray.length / 4)
                            throw new Error(`bucket.icon.opacityVertexArray.length (= ${e.icon.opacityVertexArray.length}) !== bucket.icon.layoutVertexArray.length (= ${e.icon.layoutVertexArray.length}) / 4`);
                        e.bucketInstanceId in this.collisionCircleArrays && (e.collisionCircleArray = this.collisionCircleArrays[e.bucketInstanceId],
                        delete this.collisionCircleArrays[e.bucketInstanceId])
                    }
                    symbolFadeChange(e) {
                        return this.fadeDuration === 0 ? 1 : (e - this.commitTime) / this.fadeDuration + this.prevZoomAdjustment
                    }
                    zoomAdjustment(e) {
                        return Math.max(0, (this.transform.zoom - e) / 1.5)
                    }
                    hasTransitions(e) {
                        return this.stale || e - this.lastPlacementChangeTime < this.fadeDuration
                    }
                    stillRecent(e, i) {
                        const o = this.zoomAtLastRecencyCheck === i ? 1 - this.zoomAdjustment(i) : 1;
                        return this.zoomAtLastRecencyCheck = i,
                        this.commitTime + this.fadeDuration * o > e
                    }
                    setStale() {
                        this.stale = !0
                    }
                }
                function Za(u, e, i, o, a, h) {
                    o && o.length !== 0 || (o = [0, 0, 0, 0]);
                    const m = o[0] - Bt
                      , y = o[1] - Bt
                      , v = o[2] - Bt
                      , T = o[3] - Bt;
                    u.emplaceBack(e ? 1 : 0, i ? 1 : 0, a || 0, h || 0, m, y),
                    u.emplaceBack(e ? 1 : 0, i ? 1 : 0, a || 0, h || 0, v, y),
                    u.emplaceBack(e ? 1 : 0, i ? 1 : 0, a || 0, h || 0, v, T),
                    u.emplaceBack(e ? 1 : 0, i ? 1 : 0, a || 0, h || 0, m, T)
                }
                const vc = Math.pow(2, 25)
                  , bc = Math.pow(2, 24)
                  , Ps = Math.pow(2, 17)
                  , wc = Math.pow(2, 16)
                  , Ku = Math.pow(2, 9)
                  , Ju = Math.pow(2, 8)
                  , Yu = Math.pow(2, 1);
                function Ga(u) {
                    if (u.opacity === 0 && !u.placed)
                        return 0;
                    if (u.opacity === 1 && u.placed)
                        return 4294967295;
                    const e = u.placed ? 1 : 0
                      , i = Math.floor(127 * u.opacity);
                    return i * vc + e * bc + i * Ps + e * wc + i * Ku + e * Ju + i * Yu + e
                }
                const Ss = 0;
                class $a {
                    constructor(e) {
                        this._sortAcrossTiles = e.layout.get("symbol-z-order") !== "viewport-y" && !e.layout.get("symbol-sort-key").isConstant(),
                        this._currentTileIndex = 0,
                        this._currentPartIndex = 0,
                        this._seenCrossTileIDs = {},
                        this._bucketParts = []
                    }
                    continuePlacement(e, i, o, a, h) {
                        const m = this._bucketParts;
                        for (; this._currentTileIndex < e.length; )
                            if (i.getBucketParts(m, a, e[this._currentTileIndex], this._sortAcrossTiles),
                            this._currentTileIndex++,
                            h())
                                return !0;
                        for (this._sortAcrossTiles && (this._sortAcrossTiles = !1,
                        m.sort( (y, v) => y.sortKey - v.sortKey)); this._currentPartIndex < m.length; )
                            if (i.placeLayerBucketPart(m[this._currentPartIndex], this._seenCrossTileIDs, o),
                            this._currentPartIndex++,
                            h())
                                return !0;
                        return !1
                    }
                }
                class qa {
                    constructor(e, i, o, a, h, m, y, v) {
                        this.placement = new Cs(e,i,m,y,v),
                        this._currentPlacementIndex = o.length - 1,
                        this._forceFullPlacement = a,
                        this._showCollisionBoxes = h,
                        this._done = !1
                    }
                    isDone() {
                        return this._done
                    }
                    continuePlacement(e, i, o) {
                        const a = oe.now()
                          , h = () => !this._forceFullPlacement && oe.now() - a > 2;
                        for (; this._currentPlacementIndex >= 0; ) {
                            const m = i[e[this._currentPlacementIndex]]
                              , y = this.placement.collisionIndex.transform.zoom;
                            if (m.type === "symbol" && (!m.minzoom || m.minzoom <= y) && (!m.maxzoom || m.maxzoom > y)) {
                                if (this._inProgressLayer || (this._inProgressLayer = new $a(m)),
                                this._inProgressLayer.continuePlacement(o[m.source], this.placement, this._showCollisionBoxes, m, h))
                                    return;
                                delete this._inProgressLayer
                            }
                            this._currentPlacementIndex--
                        }
                        this._done = !0
                    }
                    commit(e) {
                        return this.placement.commit(e),
                        this.placement
                    }
                }
                const Is = 512 / l.Z / 2;
                class Ha {
                    constructor(e, i, o) {
                        this.tileID = e,
                        this.bucketInstanceId = o,
                        this._symbolsByKey = {};
                        const a = new Map;
                        for (let h = 0; h < i.length; h++) {
                            const m = i.get(h)
                              , y = m.key
                              , v = a.get(y);
                            v ? v.push(m) : a.set(y, [m])
                        }
                        for (const [h,m] of a) {
                            const y = {
                                positions: m.map(v => ({
                                    x: Math.floor(v.anchorX * Is),
                                    y: Math.floor(v.anchorY * Is)
                                })),
                                crossTileIDs: m.map(v => v.crossTileID)
                            };
                            if (y.positions.length > 128) {
                                const v = new l.aB(y.positions.length,16,Uint16Array);
                                for (const {x: T, y: S} of y.positions)
                                    v.add(T, S);
                                v.finish(),
                                delete y.positions,
                                y.index = v
                            }
                            this._symbolsByKey[h] = y
                        }
                    }
                    getScaledCoordinates(e, i) {
                        const {x: o, y: a, z: h} = this.tileID.canonical
                          , {x: m, y, z: v} = i.canonical
                          , T = Is / Math.pow(2, v - h)
                          , S = (y * l.Z + e.anchorY) * T
                          , A = a * l.Z * Is;
                        return {
                            x: Math.floor((m * l.Z + e.anchorX) * T - o * l.Z * Is),
                            y: Math.floor(S - A)
                        }
                    }
                    findMatches(e, i, o) {
                        const a = this.tileID.canonical.z < i.canonical.z ? 1 : Math.pow(2, this.tileID.canonical.z - i.canonical.z);
                        for (let h = 0; h < e.length; h++) {
                            const m = e.get(h);
                            if (m.crossTileID)
                                continue;
                            const y = this._symbolsByKey[m.key];
                            if (!y)
                                continue;
                            const v = this.getScaledCoordinates(m, i);
                            if (y.index) {
                                const T = y.index.range(v.x - a, v.y - a, v.x + a, v.y + a).sort();
                                for (const S of T) {
                                    const A = y.crossTileIDs[S];
                                    if (!o[A]) {
                                        o[A] = !0,
                                        m.crossTileID = A;
                                        break
                                    }
                                }
                            } else if (y.positions)
                                for (let T = 0; T < y.positions.length; T++) {
                                    const S = y.positions[T]
                                      , A = y.crossTileIDs[T];
                                    if (Math.abs(S.x - v.x) <= a && Math.abs(S.y - v.y) <= a && !o[A]) {
                                        o[A] = !0,
                                        m.crossTileID = A;
                                        break
                                    }
                                }
                        }
                    }
                    getCrossTileIDsLists() {
                        return Object.values(this._symbolsByKey).map( ({crossTileIDs: e}) => e)
                    }
                }
                class Wa {
                    constructor() {
                        this.maxCrossTileID = 0
                    }
                    generate() {
                        return ++this.maxCrossTileID
                    }
                }
                class ko {
                    constructor() {
                        this.indexes = {},
                        this.usedCrossTileIDs = {},
                        this.lng = 0
                    }
                    handleWrapJump(e) {
                        const i = Math.round((e - this.lng) / 360);
                        if (i !== 0)
                            for (const o in this.indexes) {
                                const a = this.indexes[o]
                                  , h = {};
                                for (const m in a) {
                                    const y = a[m];
                                    y.tileID = y.tileID.unwrapTo(y.tileID.wrap + i),
                                    h[y.tileID.key] = y
                                }
                                this.indexes[o] = h
                            }
                        this.lng = e
                    }
                    addBucket(e, i, o) {
                        if (this.indexes[e.overscaledZ] && this.indexes[e.overscaledZ][e.key]) {
                            if (this.indexes[e.overscaledZ][e.key].bucketInstanceId === i.bucketInstanceId)
                                return !1;
                            this.removeBucketCrossTileIDs(e.overscaledZ, this.indexes[e.overscaledZ][e.key])
                        }
                        for (let h = 0; h < i.symbolInstances.length; h++)
                            i.symbolInstances.get(h).crossTileID = 0;
                        this.usedCrossTileIDs[e.overscaledZ] || (this.usedCrossTileIDs[e.overscaledZ] = {});
                        const a = this.usedCrossTileIDs[e.overscaledZ];
                        for (const h in this.indexes) {
                            const m = this.indexes[h];
                            if (Number(h) > e.overscaledZ)
                                for (const y in m) {
                                    const v = m[y];
                                    v.tileID.isChildOf(e) && v.findMatches(i.symbolInstances, e, a)
                                }
                            else {
                                const y = m[e.scaledTo(Number(h)).key];
                                y && y.findMatches(i.symbolInstances, e, a)
                            }
                        }
                        for (let h = 0; h < i.symbolInstances.length; h++) {
                            const m = i.symbolInstances.get(h);
                            m.crossTileID || (m.crossTileID = o.generate(),
                            a[m.crossTileID] = !0)
                        }
                        return this.indexes[e.overscaledZ] === void 0 && (this.indexes[e.overscaledZ] = {}),
                        this.indexes[e.overscaledZ][e.key] = new Ha(e,i.symbolInstances,i.bucketInstanceId),
                        !0
                    }
                    removeBucketCrossTileIDs(e, i) {
                        for (const o of i.getCrossTileIDsLists())
                            for (const a of o)
                                delete this.usedCrossTileIDs[e][a]
                    }
                    removeStaleBuckets(e) {
                        let i = !1;
                        for (const o in this.indexes) {
                            const a = this.indexes[o];
                            for (const h in a)
                                e[a[h].bucketInstanceId] || (this.removeBucketCrossTileIDs(o, a[h]),
                                delete a[h],
                                i = !0)
                        }
                        return i
                    }
                }
                class Xa {
                    constructor() {
                        this.layerIndexes = {},
                        this.crossTileIDs = new Wa,
                        this.maxBucketInstanceId = 0,
                        this.bucketsInCurrentPlacement = {}
                    }
                    addLayer(e, i, o) {
                        let a = this.layerIndexes[e.id];
                        a === void 0 && (a = this.layerIndexes[e.id] = new ko);
                        let h = !1;
                        const m = {};
                        a.handleWrapJump(o);
                        for (const y of i) {
                            const v = y.getBucket(e);
                            v && e.id === v.layerIds[0] && (v.bucketInstanceId || (v.bucketInstanceId = ++this.maxBucketInstanceId),
                            a.addBucket(y.tileID, v, this.crossTileIDs) && (h = !0),
                            m[v.bucketInstanceId] = !0)
                        }
                        return a.removeStaleBuckets(m) && (h = !0),
                        h
                    }
                    pruneUnusedLayers(e) {
                        const i = {};
                        e.forEach(o => {
                            i[o] = !0
                        }
                        );
                        for (const o in this.layerIndexes)
                            i[o] || delete this.layerIndexes[o]
                    }
                }
                var es = "void main() {fragColor=vec4(1.0);}";
                const jr = {
                    prelude: _t(`#ifdef GL_ES
precision mediump float;
#else
#if !defined(lowp)
#define lowp
#endif
#if !defined(mediump)
#define mediump
#endif
#if !defined(highp)
#define highp
#endif
#endif
out highp vec4 fragColor;`, `#ifdef GL_ES
precision highp float;
#else
#if !defined(lowp)
#define lowp
#endif
#if !defined(mediump)
#define mediump
#endif
#if !defined(highp)
#define highp
#endif
#endif
vec2 unpack_float(const float packedValue) {int packedIntValue=int(packedValue);int v0=packedIntValue/256;return vec2(v0,packedIntValue-v0*256);}vec2 unpack_opacity(const float packedOpacity) {int intOpacity=int(packedOpacity)/2;return vec2(float(intOpacity)/127.0,mod(packedOpacity,2.0));}vec4 decode_color(const vec2 encodedColor) {return vec4(unpack_float(encodedColor[0])/255.0,unpack_float(encodedColor[1])/255.0
);}float unpack_mix_vec2(const vec2 packedValue,const float t) {return mix(packedValue[0],packedValue[1],t);}vec4 unpack_mix_color(const vec4 packedColors,const float t) {vec4 minColor=decode_color(vec2(packedColors[0],packedColors[1]));vec4 maxColor=decode_color(vec2(packedColors[2],packedColors[3]));return mix(minColor,maxColor,t);}vec2 get_pattern_pos(const vec2 pixel_coord_upper,const vec2 pixel_coord_lower,const vec2 pattern_size,const float tile_units_to_pixels,const vec2 pos) {vec2 offset=mod(mod(mod(pixel_coord_upper,pattern_size)*256.0,pattern_size)*256.0+pixel_coord_lower,pattern_size);return (tile_units_to_pixels*pos+offset)/pattern_size;}mat3 rotationMatrixFromAxisAngle(vec3 u,float angle) {float c=cos(angle);float s=sin(angle);float c2=1.0-c;return mat3(u.x*u.x*c2+      c,u.x*u.y*c2-u.z*s,u.x*u.z*c2+u.y*s,u.y*u.x*c2+u.z*s,u.y*u.y*c2+    c,u.y*u.z*c2-u.x*s,u.z*u.x*c2-u.y*s,u.z*u.y*c2+u.x*s,u.z*u.z*c2+    c
);}
#ifdef TERRAIN3D
uniform sampler2D u_terrain;uniform float u_terrain_dim;uniform mat4 u_terrain_matrix;uniform vec4 u_terrain_unpack;uniform float u_terrain_exaggeration;uniform highp sampler2D u_depth;
#endif
const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitShifts=vec4(1.)/bitSh;highp float unpack(highp vec4 color) {return dot(color,bitShifts);}highp float depthOpacity(vec3 frag) {
#ifdef TERRAIN3D
highp float d=unpack(texture(u_depth,frag.xy*0.5+0.5))+0.0001-frag.z;return 1.0-max(0.0,min(1.0,-d*500.0));
#else
return 1.0;
#endif
}float calculate_visibility(vec4 pos) {
#ifdef TERRAIN3D
vec3 frag=pos.xyz/pos.w;highp float d=depthOpacity(frag);if (d > 0.95) return 1.0;return (d+depthOpacity(frag+vec3(0.0,0.01,0.0)))/2.0;
#else
return 1.0;
#endif
}float ele(vec2 pos) {
#ifdef TERRAIN3D
vec4 rgb=(texture(u_terrain,pos)*255.0)*u_terrain_unpack;return rgb.r+rgb.g+rgb.b-u_terrain_unpack.a;
#else
return 0.0;
#endif
}float get_elevation(vec2 pos) {
#ifdef TERRAIN3D
#ifdef GLOBE
if ((pos.y <-32767.5) || (pos.y > 32766.5)) {return 0.0;}
#endif
vec2 coord=(u_terrain_matrix*vec4(pos,0.0,1.0)).xy*u_terrain_dim+1.0;vec2 f=fract(coord);vec2 c=(floor(coord)+0.5)/(u_terrain_dim+2.0);float d=1.0/(u_terrain_dim+2.0);float tl=ele(c);float tr=ele(c+vec2(d,0.0));float bl=ele(c+vec2(0.0,d));float br=ele(c+vec2(d,d));float elevation=mix(mix(tl,tr,f.x),mix(bl,br,f.x),f.y);return elevation*u_terrain_exaggeration;
#else
return 0.0;
#endif
}const float PI=3.141592653589793;uniform mat4 u_projection_matrix;`),
                    projectionMercator: _t("", "float projectLineThickness(float tileY) {return 1.0;}float projectCircleRadius(float tileY) {return 1.0;}vec4 projectTile(vec2 p) {vec4 result=u_projection_matrix*vec4(p,0.0,1.0);return result;}vec4 projectTile(vec2 p,vec2 rawPos) {vec4 result=u_projection_matrix*vec4(p,0.0,1.0);if (rawPos.y <-32767.5 || rawPos.y > 32766.5) {result.z=-10000000.0;}return result;}vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return u_projection_matrix*vec4(posInTile,elevation,1.0);}vec4 projectTileFor3D(vec2 posInTile,float elevation) {return projectTileWithElevation(posInTile,elevation);}"),
                    projectionGlobe: _t("", `#define GLOBE_RADIUS 6371008.8
uniform highp vec4 u_projection_tile_mercator_coords;uniform highp vec4 u_projection_clipping_plane;uniform highp float u_projection_transition;uniform mat4 u_projection_fallback_matrix;vec3 globeRotateVector(vec3 vec,vec2 angles) {vec3 axisRight=vec3(vec.z,0.0,-vec.x);vec3 axisUp=cross(axisRight,vec);axisRight=normalize(axisRight);axisUp=normalize(axisUp);vec2 t=tan(angles);return normalize(vec+axisRight*t.x+axisUp*t.y);}mat3 globeGetRotationMatrix(vec3 spherePos) {vec3 axisRight=vec3(spherePos.z,0.0,-spherePos.x);vec3 axisDown=cross(axisRight,spherePos);axisRight=normalize(axisRight);axisDown=normalize(axisDown);return mat3(axisRight,axisDown,spherePos
);}float circumferenceRatioAtTileY(float tileY) {float mercator_pos_y=u_projection_tile_mercator_coords.y+u_projection_tile_mercator_coords.w*tileY;float spherical_y=2.0*atan(exp(PI-(mercator_pos_y*PI*2.0)))-PI*0.5;return cos(spherical_y);}float projectLineThickness(float tileY) {float thickness=1.0/circumferenceRatioAtTileY(tileY); 
if (u_projection_transition < 0.999) {return mix(1.0,thickness,u_projection_transition);} else {return thickness;}}vec3 projectToSphere(vec2 translatedPos,vec2 rawPos) {vec2 mercator_pos=u_projection_tile_mercator_coords.xy+u_projection_tile_mercator_coords.zw*translatedPos;vec2 spherical;spherical.x=mercator_pos.x*PI*2.0+PI;spherical.y=2.0*atan(exp(PI-(mercator_pos.y*PI*2.0)))-PI*0.5;float len=cos(spherical.y);vec3 pos=vec3(sin(spherical.x)*len,sin(spherical.y),cos(spherical.x)*len
);if (rawPos.y <-32767.5) {pos=vec3(0.0,1.0,0.0);}if (rawPos.y > 32766.5) {pos=vec3(0.0,-1.0,0.0);}return pos;}vec3 projectToSphere(vec2 posInTile) {return projectToSphere(posInTile,vec2(0.0,0.0));}float globeComputeClippingZ(vec3 spherePos) {return (1.0-(dot(spherePos,u_projection_clipping_plane.xyz)+u_projection_clipping_plane.w));}vec4 interpolateProjection(vec2 posInTile,vec3 spherePos,float elevation) {vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);vec4 globePosition=u_projection_matrix*vec4(elevatedPos,1.0);globePosition.z=globeComputeClippingZ(elevatedPos)*globePosition.w;if (u_projection_transition > 0.999) {return globePosition;}vec4 flatPosition=u_projection_fallback_matrix*vec4(posInTile,elevation,1.0);const float z_globeness_threshold=0.2;vec4 result=globePosition;result.z=mix(0.0,globePosition.z,clamp((u_projection_transition-z_globeness_threshold)/(1.0-z_globeness_threshold),0.0,1.0));result.xyw=mix(flatPosition.xyw,globePosition.xyw,u_projection_transition);if ((posInTile.y <-32767.5) || (posInTile.y > 32766.5)) {result=globePosition;const float poles_hidden_anim_percentage=0.02;result.z=mix(globePosition.z,100.0,pow(max((1.0-u_projection_transition)/poles_hidden_anim_percentage,0.0),8.0));}return result;}vec4 interpolateProjectionFor3D(vec2 posInTile,vec3 spherePos,float elevation) {vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);vec4 globePosition=u_projection_matrix*vec4(elevatedPos,1.0);if (u_projection_transition > 0.999) {return globePosition;}vec4 fallbackPosition=u_projection_fallback_matrix*vec4(posInTile,elevation,1.0);return mix(fallbackPosition,globePosition,u_projection_transition);}vec4 projectTile(vec2 posInTile) {return interpolateProjection(posInTile,projectToSphere(posInTile),0.0);}vec4 projectTile(vec2 posInTile,vec2 rawPos) {return interpolateProjection(posInTile,projectToSphere(posInTile,rawPos),0.0);}vec4 projectTileWithElevation(vec2 posInTile,float elevation) {return interpolateProjection(posInTile,projectToSphere(posInTile),elevation);}vec4 projectTileFor3D(vec2 posInTile,float elevation) {vec3 spherePos=projectToSphere(posInTile,posInTile);return interpolateProjectionFor3D(posInTile,spherePos,elevation);}`),
                    background: _t(`uniform vec4 u_color;uniform float u_opacity;void main() {fragColor=u_color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "in vec2 a_pos;void main() {gl_Position=projectTile(a_pos);}"),
                    backgroundPattern: _t(`uniform vec2 u_pattern_tl_a;uniform vec2 u_pattern_br_a;uniform vec2 u_pattern_tl_b;uniform vec2 u_pattern_br_b;uniform vec2 u_texsize;uniform float u_mix;uniform float u_opacity;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;void main() {vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(u_pattern_tl_a/u_texsize,u_pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(u_pattern_tl_b/u_texsize,u_pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);fragColor=mix(color1,color2,u_mix)*u_opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "uniform vec2 u_pattern_size_a;uniform vec2 u_pattern_size_b;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_scale_a;uniform float u_scale_b;uniform float u_tile_units_to_pixels;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;void main() {gl_Position=projectTile(a_pos);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_a*u_pattern_size_a,u_tile_units_to_pixels,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,u_scale_b*u_pattern_size_b,u_tile_units_to_pixels,a_pos);}"),
                    circle: _t(`in vec3 v_data;in float v_visibility;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 extrude=v_data.xy;float extrude_length=length(extrude);float antialiased_blur=v_data.z;float opacity_t=smoothstep(0.0,antialiased_blur,extrude_length-1.0);float color_t=stroke_width < 0.01 ? 0.0 : smoothstep(antialiased_blur,0.0,extrude_length-radius/(radius+stroke_width));fragColor=v_visibility*opacity_t*mix(color*opacity,stroke_color*stroke_opacity,color_t);const float epsilon=0.5/255.0;if (fragColor.r < epsilon && fragColor.g < epsilon && fragColor.b < epsilon && fragColor.a < epsilon) {discard;}
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform bool u_scale_with_map;uniform bool u_pitch_with_map;uniform vec2 u_extrude_scale;uniform highp float u_globe_extrude_scale;uniform lowp float u_device_pixel_ratio;uniform highp float u_camera_to_center_distance;uniform vec2 u_translate;in vec2 a_pos;out vec3 v_data;out float v_visibility;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define mediump float radius
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define highp vec4 stroke_color
#pragma mapbox: define mediump float stroke_width
#pragma mapbox: define lowp float stroke_opacity
void main(void) {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize mediump float radius
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize highp vec4 stroke_color
#pragma mapbox: initialize mediump float stroke_width
#pragma mapbox: initialize lowp float stroke_opacity
vec2 pos_raw=a_pos+32768.0;vec2 extrude=vec2(mod(pos_raw,8.0)/7.0*2.0-1.0);vec2 circle_center=floor(pos_raw/8.0)+u_translate;float ele=get_elevation(circle_center);v_visibility=calculate_visibility(projectTileWithElevation(circle_center,ele));if (u_pitch_with_map) {
#ifdef GLOBE
vec3 center_vector=projectToSphere(circle_center);
#endif
float angle_scale=u_globe_extrude_scale;vec2 corner_position=circle_center;if (u_scale_with_map) {angle_scale*=(radius+stroke_width);corner_position+=extrude*u_extrude_scale*(radius+stroke_width);} else {
#ifdef GLOBE
vec4 projected_center=interpolateProjection(circle_center,center_vector,ele);
#else
vec4 projected_center=projectTileWithElevation(circle_center,ele);
#endif
corner_position+=extrude*u_extrude_scale*(radius+stroke_width)*(projected_center.w/u_camera_to_center_distance);angle_scale*=(radius+stroke_width)*(projected_center.w/u_camera_to_center_distance);}
#ifdef GLOBE
vec2 angles=extrude*angle_scale;vec3 corner_vector=globeRotateVector(center_vector,angles);gl_Position=interpolateProjection(corner_position,corner_vector,ele);
#else
gl_Position=projectTileWithElevation(corner_position,ele);
#endif
} else {gl_Position=projectTileWithElevation(circle_center,ele);if (gl_Position.z/gl_Position.w > 1.0) {gl_Position.xy=vec2(10000.0);}if (u_scale_with_map) {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*u_camera_to_center_distance;} else {gl_Position.xy+=extrude*(radius+stroke_width)*u_extrude_scale*gl_Position.w;}}float antialiasblur=-max(1.0/u_device_pixel_ratio/(radius+stroke_width),blur);v_data=vec3(extrude.x,extrude.y,antialiasblur);}`),
                    clippingMask: _t(es, "in vec2 a_pos;void main() {gl_Position=projectTile(a_pos);}"),
                    heatmap: _t(`uniform highp float u_intensity;in vec2 v_extrude;
#pragma mapbox: define highp float weight
#define GAUSS_COEF 0.3989422804014327
void main() {
#pragma mapbox: initialize highp float weight
float d=-0.5*3.0*3.0*dot(v_extrude,v_extrude);float val=weight*u_intensity*GAUSS_COEF*exp(d);fragColor=vec4(val,1.0,1.0,1.0);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform float u_extrude_scale;uniform float u_opacity;uniform float u_intensity;uniform highp float u_globe_extrude_scale;in vec2 a_pos;out vec2 v_extrude;
#pragma mapbox: define highp float weight
#pragma mapbox: define mediump float radius
const highp float ZERO=1.0/255.0/16.0;
#define GAUSS_COEF 0.3989422804014327
void main(void) {
#pragma mapbox: initialize highp float weight
#pragma mapbox: initialize mediump float radius
vec2 pos_raw=a_pos+32768.0;vec2 unscaled_extrude=vec2(mod(pos_raw,8.0)/7.0*2.0-1.0);float S=sqrt(-2.0*log(ZERO/weight/u_intensity/GAUSS_COEF))/3.0;v_extrude=S*unscaled_extrude;vec2 extrude=v_extrude*radius*u_extrude_scale;vec2 circle_center=floor(pos_raw/8.0);
#ifdef GLOBE
vec2 angles=v_extrude*radius*u_globe_extrude_scale;vec3 center_vector=projectToSphere(circle_center);vec3 corner_vector=globeRotateVector(center_vector,angles);gl_Position=interpolateProjection(circle_center+extrude,corner_vector,0.0);
#else
gl_Position=projectTileFor3D(circle_center+extrude,get_elevation(circle_center));
#endif
}`),
                    heatmapTexture: _t(`uniform sampler2D u_image;uniform sampler2D u_color_ramp;uniform float u_opacity;in vec2 v_pos;void main() {float t=texture(u_image,v_pos).r;vec4 color=texture(u_color_ramp,vec2(t,0.5));fragColor=color*u_opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(0.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_world;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos*u_world,0,1);v_pos.x=a_pos.x;v_pos.y=1.0-a_pos.y;}"),
                    collisionBox: _t("in float v_placed;in float v_notUsed;void main() {float alpha=0.5;fragColor=vec4(1.0,0.0,0.0,1.0)*alpha;if (v_placed > 0.5) {fragColor=vec4(0.0,0.0,1.0,0.5)*alpha;}if (v_notUsed > 0.5) {fragColor*=.1;}}", "in vec2 a_anchor_pos;in vec2 a_placed;in vec2 a_box_real;uniform vec2 u_pixel_extrude_scale;out float v_placed;out float v_notUsed;void main() {gl_Position=projectTileWithElevation(a_anchor_pos,get_elevation(a_anchor_pos));gl_Position.xy=((a_box_real+0.5)*u_pixel_extrude_scale*2.0-1.0)*vec2(1.0,-1.0)*gl_Position.w;if (gl_Position.z/gl_Position.w < 1.1) {gl_Position.z=0.5;}v_placed=a_placed.x;v_notUsed=a_placed.y;}"),
                    collisionCircle: _t("in float v_radius;in vec2 v_extrude;in float v_collision;void main() {float alpha=0.5;float stroke_radius=0.9;float distance_to_center=length(v_extrude);float distance_to_edge=abs(distance_to_center-v_radius);float opacity_t=smoothstep(-stroke_radius,0.0,-distance_to_edge);vec4 color=mix(vec4(0.0,0.0,1.0,0.5),vec4(1.0,0.0,0.0,1.0),v_collision);fragColor=color*alpha*opacity_t;}", "in vec2 a_pos;in float a_radius;in vec2 a_flags;uniform vec2 u_viewport_size;out float v_radius;out vec2 v_extrude;out float v_collision;void main() {float radius=a_radius;float collision=a_flags.x;float vertexIdx=a_flags.y;vec2 quadVertexOffset=vec2(mix(-1.0,1.0,float(vertexIdx >=2.0)),mix(-1.0,1.0,float(vertexIdx >=1.0 && vertexIdx <=2.0)));vec2 quadVertexExtent=quadVertexOffset*radius;float padding_factor=1.2;v_radius=radius;v_extrude=quadVertexExtent*padding_factor;v_collision=collision;gl_Position=vec4((a_pos/u_viewport_size*2.0-1.0)*vec2(1.0,-1.0),0.0,1.0)+vec4(quadVertexExtent*padding_factor/u_viewport_size*2.0,0.0,0.0);}"),
                    debug: _t("uniform highp vec4 u_color;uniform sampler2D u_overlay;in vec2 v_uv;void main() {vec4 overlay_color=texture(u_overlay,v_uv);fragColor=mix(u_color,overlay_color,overlay_color.a);}", "in vec2 a_pos;out vec2 v_uv;uniform float u_overlay_scale;void main() {v_uv=a_pos/8192.0;gl_Position=projectTileWithElevation(a_pos*u_overlay_scale,get_elevation(a_pos));}"),
                    depth: _t(es, `in vec2 a_pos;void main() {
#ifdef GLOBE
gl_Position=projectTileFor3D(a_pos,0.0);
#else
gl_Position=u_projection_matrix*vec4(a_pos,0.0,1.0);
#endif
}`),
                    fill: _t(`#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
fragColor=color*opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_fill_translate;in vec2 a_pos;
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float opacity
gl_Position=projectTile(a_pos+u_fill_translate,a_pos);}`),
                    fillOutline: _t(`in vec2 v_pos;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);fragColor=outline_color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_world;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define highp vec4 outline_color
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 outline_color
#pragma mapbox: initialize lowp float opacity
gl_Position=projectTile(a_pos+u_fill_translate,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
}`),
                    fillOutlinePattern: _t(`uniform vec2 u_texsize;uniform sampler2D u_image;uniform float u_fade;in vec2 v_pos_a;in vec2 v_pos_b;in vec2 v_pos;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);float dist=length(v_pos-gl_FragCoord.xy);float alpha=1.0-smoothstep(0.0,1.0,dist);fragColor=mix(color1,color2,u_fade)*alpha*opacity;
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_world;uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;out vec2 v_pos;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;gl_Position=projectTile(a_pos+u_fill_translate,a_pos);vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,a_pos);v_pos=(gl_Position.xy/gl_Position.w+1.0)/2.0*u_world;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
}`),
                    fillPattern: _t(`#ifdef GL_ES
precision highp float;
#endif
uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);fragColor=mix(color1,color2,u_fade)*opacity;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform vec3 u_scale;uniform vec2 u_fill_translate;in vec2 a_pos;out vec2 v_pos_a;out vec2 v_pos_b;
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;gl_Position=projectTile(a_pos+u_fill_translate,a_pos);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileZoomRatio,a_pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileZoomRatio,a_pos);}`),
                    fillExtrusion: _t(`in vec4 v_color;void main() {fragColor=v_color;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp vec3 u_lightpos_globe;uniform lowp float u_lightintensity;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec2 u_fill_translate;in vec2 a_pos;in vec4 a_normal_ed;
#ifdef TERRAIN3D
in vec2 a_centroid;
#endif
out vec4 v_color;
#pragma mapbox: define highp float base
#pragma mapbox: define highp float height
#pragma mapbox: define highp vec4 color
void main() {
#pragma mapbox: initialize highp float base
#pragma mapbox: initialize highp float height
#pragma mapbox: initialize highp vec4 color
vec3 normal=a_normal_ed.xyz;
#ifdef TERRAIN3D
float height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);
#else
float height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;
#endif
base=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);float elevation=t > 0.0 ? height : base;vec2 posInTile=a_pos+u_fill_translate;
#ifdef GLOBE
vec3 spherePos=projectToSphere(posInTile,a_pos);gl_Position=interpolateProjectionFor3D(posInTile,spherePos,elevation);
#else
gl_Position=u_projection_matrix*vec4(posInTile,elevation,1.0);
#endif
float colorvalue=color.r*0.2126+color.g*0.7152+color.b*0.0722;v_color=vec4(0.0,0.0,0.0,1.0);vec4 ambientlight=vec4(0.03,0.03,0.03,1.0);color+=ambientlight;vec3 normalForLighting=normal/16384.0;float directional=clamp(dot(normalForLighting,u_lightpos),0.0,1.0);
#ifdef GLOBE
mat3 rotMatrix=globeGetRotationMatrix(spherePos);normalForLighting=rotMatrix*normalForLighting;directional=mix(directional,clamp(dot(normalForLighting,u_lightpos_globe),0.0,1.0),u_projection_transition);
#endif
directional=mix((1.0-u_lightintensity),max((1.0-colorvalue+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_color.r+=clamp(color.r*directional*u_lightcolor.r,mix(0.0,0.3,1.0-u_lightcolor.r),1.0);v_color.g+=clamp(color.g*directional*u_lightcolor.g,mix(0.0,0.3,1.0-u_lightcolor.g),1.0);v_color.b+=clamp(color.b*directional*u_lightcolor.b,mix(0.0,0.3,1.0-u_lightcolor.b),1.0);v_color*=u_opacity;}`),
                    fillExtrusionPattern: _t(`uniform vec2 u_texsize;uniform float u_fade;uniform sampler2D u_image;in vec2 v_pos_a;in vec2 v_pos_b;in vec4 v_lighting;
#pragma mapbox: define lowp float base
#pragma mapbox: define lowp float height
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float base
#pragma mapbox: initialize lowp float height
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;vec2 imagecoord=mod(v_pos_a,1.0);vec2 pos=mix(pattern_tl_a/u_texsize,pattern_br_a/u_texsize,imagecoord);vec4 color1=texture(u_image,pos);vec2 imagecoord_b=mod(v_pos_b,1.0);vec2 pos2=mix(pattern_tl_b/u_texsize,pattern_br_b/u_texsize,imagecoord_b);vec4 color2=texture(u_image,pos2);vec4 mixedColor=mix(color1,color2,u_fade);fragColor=mixedColor*v_lighting;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_pixel_coord_upper;uniform vec2 u_pixel_coord_lower;uniform float u_height_factor;uniform vec3 u_scale;uniform float u_vertical_gradient;uniform lowp float u_opacity;uniform vec2 u_fill_translate;uniform vec3 u_lightcolor;uniform lowp vec3 u_lightpos;uniform lowp vec3 u_lightpos_globe;uniform lowp float u_lightintensity;in vec2 a_pos;in vec4 a_normal_ed;
#ifdef TERRAIN3D
in vec2 a_centroid;
#endif
#ifdef GLOBE
out vec3 v_sphere_pos;
#endif
out vec2 v_pos_a;out vec2 v_pos_b;out vec4 v_lighting;
#pragma mapbox: define lowp float base
#pragma mapbox: define lowp float height
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float base
#pragma mapbox: initialize lowp float height
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec3 normal=a_normal_ed.xyz;float edgedistance=a_normal_ed.w;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;
#ifdef TERRAIN3D
float height_terrain3d_offset=get_elevation(a_centroid);float base_terrain3d_offset=height_terrain3d_offset-(base > 0.0 ? 0.0 : 10.0);
#else
float height_terrain3d_offset=0.0;float base_terrain3d_offset=0.0;
#endif
base=max(0.0,base)+base_terrain3d_offset;height=max(0.0,height)+height_terrain3d_offset;float t=mod(normal.x,2.0);float elevation=t > 0.0 ? height : base;vec2 posInTile=a_pos+u_fill_translate;
#ifdef GLOBE
vec3 spherePos=projectToSphere(posInTile,a_pos);vec3 elevatedPos=spherePos*(1.0+elevation/GLOBE_RADIUS);v_sphere_pos=elevatedPos;gl_Position=interpolateProjectionFor3D(posInTile,spherePos,elevation);
#else
gl_Position=u_projection_matrix*vec4(posInTile,elevation,1.0);
#endif
vec2 pos=normal.x==1.0 && normal.y==0.0 && normal.z==16384.0
? a_pos
: vec2(edgedistance,elevation*u_height_factor);v_pos_a=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,fromScale*display_size_a,tileRatio,pos);v_pos_b=get_pattern_pos(u_pixel_coord_upper,u_pixel_coord_lower,toScale*display_size_b,tileRatio,pos);v_lighting=vec4(0.0,0.0,0.0,1.0);float directional=clamp(dot(normal/16383.0,u_lightpos),0.0,1.0);directional=mix((1.0-u_lightintensity),max((0.5+u_lightintensity),1.0),directional);if (normal.y !=0.0) {directional*=((1.0-u_vertical_gradient)+(u_vertical_gradient*clamp((t+base)*pow(height/150.0,0.5),mix(0.7,0.98,1.0-u_lightintensity),1.0)));}v_lighting.rgb+=clamp(directional*u_lightcolor,mix(vec3(0.0),vec3(0.3),1.0-u_lightcolor),vec3(1.0));v_lighting*=u_opacity;}`),
                    hillshadePrepare: _t(`#ifdef GL_ES
precision highp float;
#endif
uniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_dimension;uniform float u_zoom;uniform vec4 u_unpack;float getElevation(vec2 coord,float bias) {vec4 data=texture(u_image,coord)*255.0;data.a=-1.0;return dot(data,u_unpack)/4.0;}void main() {vec2 epsilon=1.0/u_dimension;float a=getElevation(v_pos+vec2(-epsilon.x,-epsilon.y),0.0);float b=getElevation(v_pos+vec2(0,-epsilon.y),0.0);float c=getElevation(v_pos+vec2(epsilon.x,-epsilon.y),0.0);float d=getElevation(v_pos+vec2(-epsilon.x,0),0.0);float e=getElevation(v_pos,0.0);float f=getElevation(v_pos+vec2(epsilon.x,0),0.0);float g=getElevation(v_pos+vec2(-epsilon.x,epsilon.y),0.0);float h=getElevation(v_pos+vec2(0,epsilon.y),0.0);float i=getElevation(v_pos+vec2(epsilon.x,epsilon.y),0.0);float exaggerationFactor=u_zoom < 2.0 ? 0.4 : u_zoom < 4.5 ? 0.35 : 0.3;float exaggeration=u_zoom < 15.0 ? (u_zoom-15.0)*exaggerationFactor : 0.0;vec2 deriv=vec2((c+f+f+i)-(a+d+d+g),(g+h+h+i)-(a+b+b+c))/pow(2.0,exaggeration+(19.2562-u_zoom));fragColor=clamp(vec4(deriv.x/2.0+0.5,deriv.y/2.0+0.5,1.0,1.0),0.0,1.0);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;uniform vec2 u_dimension;in vec2 a_pos;in vec2 a_texture_pos;out vec2 v_pos;void main() {gl_Position=u_matrix*vec4(a_pos,0,1);highp vec2 epsilon=1.0/u_dimension;float scale=(u_dimension.x-2.0)/u_dimension.x;v_pos=(a_texture_pos/8192.0)*scale+epsilon;}"),
                    hillshade: _t(`uniform sampler2D u_image;in vec2 v_pos;uniform vec2 u_latrange;uniform vec2 u_light;uniform vec4 u_shadow;uniform vec4 u_highlight;uniform vec4 u_accent;
#define PI 3.141592653589793
void main() {vec4 pixel=texture(u_image,v_pos);vec2 deriv=((pixel.rg*2.0)-1.0);float scaleFactor=cos(radians((u_latrange[0]-u_latrange[1])*(1.0-v_pos.y)+u_latrange[1]));float slope=atan(1.25*length(deriv)/scaleFactor);float aspect=deriv.x !=0.0 ? atan(deriv.y,-deriv.x) : PI/2.0*(deriv.y > 0.0 ? 1.0 :-1.0);float intensity=u_light.x;float azimuth=u_light.y+PI;float base=1.875-intensity*1.75;float maxValue=0.5*PI;float scaledSlope=intensity !=0.5 ? ((pow(base,slope)-1.0)/(pow(base,maxValue)-1.0))*maxValue : slope;float accent=cos(scaledSlope);vec4 accent_color=(1.0-accent)*u_accent*clamp(intensity*2.0,0.0,1.0);float shade=abs(mod((aspect+azimuth)/PI+0.5,2.0)-1.0);vec4 shade_color=mix(u_shadow,u_highlight,shade)*sin(scaledSlope)*clamp(intensity*2.0,0.0,1.0);fragColor=accent_color*(1.0-shade_color.a)+shade_color;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, "uniform mat4 u_matrix;in vec2 a_pos;out vec2 v_pos;void main() {gl_Position=projectTile(a_pos,a_pos);v_pos=a_pos/8192.0;if (a_pos.y <-32767.5) {v_pos.y=0.0;}if (a_pos.y > 32766.5) {v_pos.y=1.0;}}"),
                    line: _t(`uniform lowp float u_device_pixel_ratio;in vec2 v_width2;in vec2 v_normal;in float v_gamma_scale;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);fragColor=color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
in vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform mediump float u_ratio;uniform vec2 u_units_to_pixels;uniform lowp float u_device_pixel_ratio;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp float v_linesofar;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;v_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*2.0;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_width2=vec2(outset,inset);}`),
                    lineGradient: _t(`uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;in vec2 v_width2;in vec2 v_normal;in float v_gamma_scale;in highp vec2 v_uv;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);vec4 color=texture(u_image,v_uv);fragColor=color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
in vec2 a_pos_normal;in vec4 a_data;in float a_uv_x;in float a_split_index;uniform vec2 u_translation;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_units_to_pixels;uniform float u_image_height;out vec2 v_normal;out vec2 v_width2;out float v_gamma_scale;out highp vec2 v_uv;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;highp float texel_height=1.0/u_image_height;highp float half_texel_height=0.5*texel_height;v_uv=vec2(a_uv_x,a_split_index*texel_height-half_texel_height);vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_width2=vec2(outset,inset);}`),
                    linePattern: _t(`#ifdef GL_ES
precision highp float;
#endif
uniform lowp float u_device_pixel_ratio;uniform vec2 u_texsize;uniform float u_fade;uniform mediump vec3 u_scale;uniform sampler2D u_image;in vec2 v_normal;in vec2 v_width2;in float v_linesofar;in float v_gamma_scale;in float v_width;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
vec2 pattern_tl_a=pattern_from.xy;vec2 pattern_br_a=pattern_from.zw;vec2 pattern_tl_b=pattern_to.xy;vec2 pattern_br_b=pattern_to.zw;float tileZoomRatio=u_scale.x;float fromScale=u_scale.y;float toScale=u_scale.z;vec2 display_size_a=(pattern_br_a-pattern_tl_a)/pixel_ratio_from;vec2 display_size_b=(pattern_br_b-pattern_tl_b)/pixel_ratio_to;vec2 pattern_size_a=vec2(display_size_a.x*fromScale/tileZoomRatio,display_size_a.y);vec2 pattern_size_b=vec2(display_size_b.x*toScale/tileZoomRatio,display_size_b.y);float aspect_a=display_size_a.y/v_width;float aspect_b=display_size_b.y/v_width;float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float x_a=mod(v_linesofar/pattern_size_a.x*aspect_a,1.0);float x_b=mod(v_linesofar/pattern_size_b.x*aspect_b,1.0);float y=0.5*v_normal.y+0.5;vec2 texel_size=1.0/u_texsize;vec2 pos_a=mix(pattern_tl_a*texel_size-texel_size,pattern_br_a*texel_size+texel_size,vec2(x_a,y));vec2 pos_b=mix(pattern_tl_b*texel_size-texel_size,pattern_br_b*texel_size+texel_size,vec2(x_b,y));vec4 color=mix(texture(u_image,pos_a),texture(u_image,pos_b),u_fade);fragColor=color*alpha*opacity;
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
#define LINE_DISTANCE_SCALE 2.0
in vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform vec2 u_units_to_pixels;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;out vec2 v_normal;out vec2 v_width2;out float v_linesofar;out float v_gamma_scale;out float v_width;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
#pragma mapbox: define lowp vec4 pattern_from
#pragma mapbox: define lowp vec4 pattern_to
#pragma mapbox: define lowp float pixel_ratio_from
#pragma mapbox: define lowp float pixel_ratio_to
void main() {
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
#pragma mapbox: initialize mediump vec4 pattern_from
#pragma mapbox: initialize mediump vec4 pattern_to
#pragma mapbox: initialize lowp float pixel_ratio_from
#pragma mapbox: initialize lowp float pixel_ratio_to
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_linesofar=a_linesofar;v_width2=vec2(outset,inset);v_width=floorwidth;}`),
                    lineSDF: _t(`uniform lowp float u_device_pixel_ratio;uniform sampler2D u_image;uniform float u_sdfgamma;uniform float u_mix;in vec2 v_normal;in vec2 v_width2;in vec2 v_tex_a;in vec2 v_tex_b;in float v_gamma_scale;
#ifdef GLOBE
in float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
float dist=length(v_normal)*v_width2.s;float blur2=(blur+1.0/u_device_pixel_ratio)*v_gamma_scale;float alpha=clamp(min(dist-(v_width2.t-blur2),v_width2.s-dist)/blur2,0.0,1.0);float sdfdist_a=texture(u_image,v_tex_a).a;float sdfdist_b=texture(u_image,v_tex_b).a;float sdfdist=mix(sdfdist_a,sdfdist_b,u_mix);alpha*=smoothstep(0.5-u_sdfgamma/floorwidth,0.5+u_sdfgamma/floorwidth,sdfdist);fragColor=color*(alpha*opacity);
#ifdef GLOBE
if (v_depth > 1.0) {discard;}
#endif
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `
#define scale 0.015873016
#define LINE_DISTANCE_SCALE 2.0
in vec2 a_pos_normal;in vec4 a_data;uniform vec2 u_translation;uniform mediump float u_ratio;uniform lowp float u_device_pixel_ratio;uniform vec2 u_patternscale_a;uniform float u_tex_y_a;uniform vec2 u_patternscale_b;uniform float u_tex_y_b;uniform vec2 u_units_to_pixels;out vec2 v_normal;out vec2 v_width2;out vec2 v_tex_a;out vec2 v_tex_b;out float v_gamma_scale;
#ifdef GLOBE
out float v_depth;
#endif
#pragma mapbox: define highp vec4 color
#pragma mapbox: define lowp float blur
#pragma mapbox: define lowp float opacity
#pragma mapbox: define mediump float gapwidth
#pragma mapbox: define lowp float offset
#pragma mapbox: define mediump float width
#pragma mapbox: define lowp float floorwidth
void main() {
#pragma mapbox: initialize highp vec4 color
#pragma mapbox: initialize lowp float blur
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize mediump float gapwidth
#pragma mapbox: initialize lowp float offset
#pragma mapbox: initialize mediump float width
#pragma mapbox: initialize lowp float floorwidth
float ANTIALIASING=1.0/u_device_pixel_ratio/2.0;vec2 a_extrude=a_data.xy-128.0;float a_direction=mod(a_data.z,4.0)-1.0;float a_linesofar=(floor(a_data.z/4.0)+a_data.w*64.0)*LINE_DISTANCE_SCALE;vec2 pos=floor(a_pos_normal*0.5);mediump vec2 normal=a_pos_normal-2.0*pos;normal.y=normal.y*2.0-1.0;v_normal=normal;gapwidth=gapwidth/2.0;float halfwidth=width/2.0;offset=-1.0*offset;float inset=gapwidth+(gapwidth > 0.0 ? ANTIALIASING : 0.0);float outset=gapwidth+halfwidth*(gapwidth > 0.0 ? 2.0 : 1.0)+(halfwidth==0.0 ? 0.0 : ANTIALIASING);mediump vec2 dist=outset*a_extrude*scale;mediump float u=0.5*a_direction;mediump float t=1.0-abs(u);mediump vec2 offset2=offset*a_extrude*scale*normal.y*mat2(t,-u,u,t);float adjustedThickness=projectLineThickness(pos.y);vec4 projected_no_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation);vec4 projected_with_extrude=projectTile(pos+offset2/u_ratio*adjustedThickness+u_translation+dist/u_ratio*adjustedThickness);gl_Position=projected_with_extrude;
#ifdef GLOBE
v_depth=gl_Position.z/gl_Position.w;
#endif
#ifdef TERRAIN3D
v_gamma_scale=1.0;
#else
float extrude_length_without_perspective=length(dist);float extrude_length_with_perspective=length((projected_with_extrude.xy-projected_no_extrude.xy)/projected_with_extrude.w*u_units_to_pixels);v_gamma_scale=extrude_length_without_perspective/extrude_length_with_perspective;
#endif
v_tex_a=vec2(a_linesofar*u_patternscale_a.x/floorwidth,normal.y*u_patternscale_a.y+u_tex_y_a);v_tex_b=vec2(a_linesofar*u_patternscale_b.x/floorwidth,normal.y*u_patternscale_b.y+u_tex_y_b);v_width2=vec2(outset,inset);}`),
                    raster: _t(`uniform float u_fade_t;uniform float u_opacity;uniform sampler2D u_image0;uniform sampler2D u_image1;in vec2 v_pos0;in vec2 v_pos1;uniform float u_brightness_low;uniform float u_brightness_high;uniform float u_saturation_factor;uniform float u_contrast_factor;uniform vec3 u_spin_weights;void main() {vec4 color0=texture(u_image0,v_pos0);vec4 color1=texture(u_image1,v_pos1);if (color0.a > 0.0) {color0.rgb=color0.rgb/color0.a;}if (color1.a > 0.0) {color1.rgb=color1.rgb/color1.a;}vec4 color=mix(color0,color1,u_fade_t);color.a*=u_opacity;vec3 rgb=color.rgb;rgb=vec3(dot(rgb,u_spin_weights.xyz),dot(rgb,u_spin_weights.zxy),dot(rgb,u_spin_weights.yzx));float average=(color.r+color.g+color.b)/3.0;rgb+=(average-rgb)*u_saturation_factor;rgb=(rgb-0.5)*u_contrast_factor+0.5;vec3 u_high_vec=vec3(u_brightness_low,u_brightness_low,u_brightness_low);vec3 u_low_vec=vec3(u_brightness_high,u_brightness_high,u_brightness_high);fragColor=vec4(mix(u_high_vec,u_low_vec,rgb)*color.a,color.a);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `uniform vec2 u_tl_parent;uniform float u_scale_parent;uniform float u_buffer_scale;uniform vec4 u_coords_top;uniform vec4 u_coords_bottom;in vec2 a_pos;out vec2 v_pos0;out vec2 v_pos1;void main() {vec2 fractionalPos=a_pos/8192.0;vec2 position=mix(mix(u_coords_top.xy,u_coords_top.zw,fractionalPos.x),mix(u_coords_bottom.xy,u_coords_bottom.zw,fractionalPos.x),fractionalPos.y);gl_Position=projectTile(position,position);v_pos0=((fractionalPos-0.5)/u_buffer_scale)+0.5;
#ifdef GLOBE
if (a_pos.y <-32767.5) {v_pos0.y=0.0;}if (a_pos.y > 32766.5) {v_pos0.y=1.0;}
#endif
v_pos1=(v_pos0*u_scale_parent)+u_tl_parent;}`),
                    symbolIcon: _t(`uniform sampler2D u_texture;in vec2 v_tex;in float v_fade_opacity;
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float opacity
lowp float alpha=opacity*v_fade_opacity;fragColor=texture(u_texture,v_tex)*alpha;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `in vec4 a_pos_offset;in vec4 a_data;in vec4 a_pixeloffset;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform highp float u_camera_to_center_distance;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform float u_fade_change;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform vec2 u_texsize;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform vec2 u_translation;uniform float u_pitched_scale;out vec2 v_tex;out float v_fade_opacity;
#pragma mapbox: define lowp float opacity
void main() {
#pragma mapbox: initialize lowp float opacity
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;vec2 a_minFontScale=a_pixeloffset.zw/256.0;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;
#ifdef GLOBE
if(u_pitch_with_map) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}
#endif
vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*max(a_minFontScale,fontScale)+a_pxoffset/16.0)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}gl_Position=finalPos;v_tex=a_tex/u_texsize;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float visibility=calculate_visibility(projectedPoint);v_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));}`),
                    symbolSDF: _t(`#define SDF_PX 8.0
uniform bool u_is_halo;uniform sampler2D u_texture;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;uniform bool u_is_text;in vec2 v_data0;in vec3 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
float EDGE_GAMMA=0.105/u_device_pixel_ratio;vec2 tex=v_data0.xy;float gamma_scale=v_data1.x;float size=v_data1.y;float fade_opacity=v_data1[2];float fontScale=u_is_text ? size/24.0 : size;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float inner_edge=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);inner_edge=inner_edge+gamma*gamma_scale;}lowp float dist=texture(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(inner_edge-gamma_scaled,inner_edge+gamma_scaled,dist);if (u_is_halo) {lowp float halo_edge=(6.0-halo_width/fontScale)/SDF_PX;alpha=min(smoothstep(halo_edge-gamma_scaled,halo_edge+gamma_scaled,dist),1.0-alpha);}fragColor=color*(alpha*opacity*fade_opacity);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `in vec4 a_pos_offset;in vec4 a_data;in vec4 a_pixeloffset;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_translation;uniform float u_pitched_scale;out vec2 v_data0;out vec3 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);vec2 a_pxoffset=a_pixeloffset.xy;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=u_is_text ? size/24.0 : size;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;
#ifdef GLOBE
if(u_pitch_with_map) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}
#endif
vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale+a_pxoffset)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}float gamma_scale=finalPos.w;gl_Position=finalPos;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0=a_tex/u_texsize;v_data1=vec3(gamma_scale,size,interpolated_fade_opacity);}`),
                    symbolTextAndIcon: _t(`#define SDF_PX 8.0
#define SDF 1.0
#define ICON 0.0
uniform bool u_is_halo;uniform sampler2D u_texture;uniform sampler2D u_texture_icon;uniform highp float u_gamma_scale;uniform lowp float u_device_pixel_ratio;in vec4 v_data0;in vec4 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
float fade_opacity=v_data1[2];if (v_data1.w==ICON) {vec2 tex_icon=v_data0.zw;lowp float alpha=opacity*fade_opacity;fragColor=texture(u_texture_icon,tex_icon)*alpha;
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
return;}vec2 tex=v_data0.xy;float EDGE_GAMMA=0.105/u_device_pixel_ratio;float gamma_scale=v_data1.x;float size=v_data1.y;float fontScale=size/24.0;lowp vec4 color=fill_color;highp float gamma=EDGE_GAMMA/(fontScale*u_gamma_scale);lowp float buff=(256.0-64.0)/256.0;if (u_is_halo) {color=halo_color;gamma=(halo_blur*1.19/SDF_PX+EDGE_GAMMA)/(fontScale*u_gamma_scale);buff=(6.0-halo_width/fontScale)/SDF_PX;}lowp float dist=texture(u_texture,tex).a;highp float gamma_scaled=gamma*gamma_scale;highp float alpha=smoothstep(buff-gamma_scaled,buff+gamma_scaled,dist);fragColor=color*(alpha*opacity*fade_opacity);
#ifdef OVERDRAW_INSPECTOR
fragColor=vec4(1.0);
#endif
}`, `in vec4 a_pos_offset;in vec4 a_data;in vec3 a_projected_pos;in float a_fade_opacity;uniform bool u_is_size_zoom_constant;uniform bool u_is_size_feature_constant;uniform highp float u_size_t;uniform highp float u_size;uniform mat4 u_label_plane_matrix;uniform mat4 u_coord_matrix;uniform bool u_is_text;uniform bool u_pitch_with_map;uniform highp float u_pitch;uniform bool u_rotate_symbol;uniform highp float u_aspect_ratio;uniform highp float u_camera_to_center_distance;uniform float u_fade_change;uniform vec2 u_texsize;uniform vec2 u_texsize_icon;uniform bool u_is_along_line;uniform bool u_is_variable_anchor;uniform vec2 u_translation;uniform float u_pitched_scale;out vec4 v_data0;out vec4 v_data1;
#pragma mapbox: define highp vec4 fill_color
#pragma mapbox: define highp vec4 halo_color
#pragma mapbox: define lowp float opacity
#pragma mapbox: define lowp float halo_width
#pragma mapbox: define lowp float halo_blur
void main() {
#pragma mapbox: initialize highp vec4 fill_color
#pragma mapbox: initialize highp vec4 halo_color
#pragma mapbox: initialize lowp float opacity
#pragma mapbox: initialize lowp float halo_width
#pragma mapbox: initialize lowp float halo_blur
vec2 a_pos=a_pos_offset.xy;vec2 a_offset=a_pos_offset.zw;vec2 a_tex=a_data.xy;vec2 a_size=a_data.zw;float a_size_min=floor(a_size[0]*0.5);float is_sdf=a_size[0]-2.0*a_size_min;float ele=get_elevation(a_pos);highp float segment_angle=-a_projected_pos[2];float size;if (!u_is_size_zoom_constant && !u_is_size_feature_constant) {size=mix(a_size_min,a_size[1],u_size_t)/128.0;} else if (u_is_size_zoom_constant && !u_is_size_feature_constant) {size=a_size_min/128.0;} else {size=u_size;}vec2 translated_a_pos=a_pos+u_translation;vec4 projectedPoint=projectTileWithElevation(translated_a_pos,ele);highp float camera_to_anchor_distance=projectedPoint.w;highp float distance_ratio=u_pitch_with_map ?
camera_to_anchor_distance/u_camera_to_center_distance :
u_camera_to_center_distance/camera_to_anchor_distance;highp float perspective_ratio=clamp(0.5+0.5*distance_ratio,0.0,4.0);size*=perspective_ratio;float fontScale=size/24.0;highp float symbol_rotation=0.0;if (u_rotate_symbol) {vec4 offsetProjectedPoint=projectTileWithElevation(translated_a_pos+vec2(1,0),ele);vec2 a=projectedPoint.xy/projectedPoint.w;vec2 b=offsetProjectedPoint.xy/offsetProjectedPoint.w;symbol_rotation=atan((b.y-a.y)/u_aspect_ratio,b.x-a.x);}highp float angle_sin=sin(segment_angle+symbol_rotation);highp float angle_cos=cos(segment_angle+symbol_rotation);mat2 rotation_matrix=mat2(angle_cos,-1.0*angle_sin,angle_sin,angle_cos);vec4 projected_pos;if (u_is_along_line || u_is_variable_anchor) {projected_pos=vec4(a_projected_pos.xy,ele,1.0);} else if (u_pitch_with_map) {projected_pos=u_label_plane_matrix*vec4(a_projected_pos.xy+u_translation,ele,1.0);} else {projected_pos=u_label_plane_matrix*projectTileWithElevation(a_projected_pos.xy+u_translation,ele);}float z=float(u_pitch_with_map)*projected_pos.z/projected_pos.w;float projectionScaling=1.0;
#ifdef GLOBE
if(u_pitch_with_map && !u_is_along_line) {float anchor_pos_tile_y=(u_coord_matrix*vec4(projected_pos.xy/projected_pos.w,z,1.0)).y;projectionScaling=mix(projectionScaling,1.0/circumferenceRatioAtTileY(anchor_pos_tile_y)*u_pitched_scale,u_projection_transition);}
#endif
vec4 finalPos=u_coord_matrix*vec4(projected_pos.xy/projected_pos.w+rotation_matrix*(a_offset/32.0*fontScale)*projectionScaling,z,1.0);if(u_pitch_with_map) {finalPos=projectTileWithElevation(finalPos.xy,finalPos.z);}float gamma_scale=finalPos.w;gl_Position=finalPos;vec2 fade_opacity=unpack_opacity(a_fade_opacity);float visibility=calculate_visibility(projectedPoint);float fade_change=fade_opacity[1] > 0.5 ? u_fade_change :-u_fade_change;float interpolated_fade_opacity=max(0.0,min(visibility,fade_opacity[0]+fade_change));v_data0.xy=a_tex/u_texsize;v_data0.zw=a_tex/u_texsize_icon;v_data1=vec4(gamma_scale,size,interpolated_fade_opacity,is_sdf);}`),
                    terrain: _t("uniform sampler2D u_texture;uniform vec4 u_fog_color;uniform vec4 u_horizon_color;uniform float u_fog_ground_blend;uniform float u_fog_ground_blend_opacity;uniform float u_horizon_fog_blend;uniform bool u_is_globe_mode;in vec2 v_texture_pos;in float v_fog_depth;const float gamma=2.2;vec4 gammaToLinear(vec4 color) {return pow(color,vec4(gamma));}vec4 linearToGamma(vec4 color) {return pow(color,vec4(1.0/gamma));}void main() {vec4 surface_color=texture(u_texture,vec2(v_texture_pos.x,1.0-v_texture_pos.y));if (!u_is_globe_mode && v_fog_depth > u_fog_ground_blend) {vec4 surface_color_linear=gammaToLinear(surface_color);float blend_color=smoothstep(0.0,1.0,max((v_fog_depth-u_horizon_fog_blend)/(1.0-u_horizon_fog_blend),0.0));vec4 fog_horizon_color_linear=mix(gammaToLinear(u_fog_color),gammaToLinear(u_horizon_color),blend_color);float factor_fog=max(v_fog_depth-u_fog_ground_blend,0.0)/(1.0-u_fog_ground_blend);fragColor=linearToGamma(mix(surface_color_linear,fog_horizon_color_linear,pow(factor_fog,2.0)*u_fog_ground_blend_opacity));} else {fragColor=surface_color;}}", "in vec3 a_pos3d;uniform mat4 u_fog_matrix;uniform float u_ele_delta;out vec2 v_texture_pos;out float v_fog_depth;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/8192.0;gl_Position=projectTileFor3D(a_pos3d.xy,get_elevation(a_pos3d.xy)-ele_delta);vec4 pos=u_fog_matrix*vec4(a_pos3d.xy,ele,1.0);v_fog_depth=pos.z/pos.w*0.5+0.5;}"),
                    terrainDepth: _t("in float v_depth;const highp vec4 bitSh=vec4(256.*256.*256.,256.*256.,256.,1.);const highp vec4 bitMsk=vec4(0.,vec3(1./256.0));highp vec4 pack(highp float value) {highp vec4 comp=fract(value*bitSh);comp-=comp.xxyz*bitMsk;return comp;}void main() {fragColor=pack(v_depth);}", "in vec3 a_pos3d;uniform float u_ele_delta;out float v_depth;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;gl_Position=projectTileFor3D(a_pos3d.xy,ele-ele_delta);v_depth=gl_Position.z/gl_Position.w;}"),
                    terrainCoords: _t("precision mediump float;uniform sampler2D u_texture;uniform float u_terrain_coords_id;in vec2 v_texture_pos;void main() {vec4 rgba=texture(u_texture,v_texture_pos);fragColor=vec4(rgba.r,rgba.g,rgba.b,u_terrain_coords_id);}", "in vec3 a_pos3d;uniform float u_ele_delta;out vec2 v_texture_pos;void main() {float ele=get_elevation(a_pos3d.xy);float ele_delta=a_pos3d.z==1.0 ? u_ele_delta : 0.0;v_texture_pos=a_pos3d.xy/8192.0;gl_Position=projectTileFor3D(a_pos3d.xy,ele-ele_delta);}"),
                    projectionErrorMeasurement: _t("in vec4 v_output_error_encoded;void main() {fragColor=v_output_error_encoded;}", "in vec2 a_pos;uniform highp float u_input;uniform highp float u_output_expected;out vec4 v_output_error_encoded;void main() {float real_output=2.0*atan(exp(PI-(u_input*PI*2.0)))-PI*0.5;float error=real_output-u_output_expected;float abs_error=abs(error)*128.0;v_output_error_encoded.x=min(floor(abs_error*256.0),255.0)/255.0;abs_error-=v_output_error_encoded.x;v_output_error_encoded.y=min(floor(abs_error*65536.0),255.0)/255.0;abs_error-=v_output_error_encoded.x/255.0;v_output_error_encoded.z=min(floor(abs_error*16777216.0),255.0)/255.0;v_output_error_encoded.w=error >=0.0 ? 1.0 : 0.0;gl_Position=vec4(a_pos,0.0,1.0);}"),
                    atmosphere: _t(`in vec3 view_direction;uniform vec3 u_sun_pos;uniform vec3 u_globe_position;uniform float u_globe_radius;uniform float u_atmosphere_blend;/**Shader use from https:*Made some change to adapt to MapLibre Globe geometry*/const float PI=3.141592653589793;const int iSteps=5;const int jSteps=3;/*radius of the planet*/const float EARTH_RADIUS=6371e3;/*radius of the atmosphere*/const float ATMOS_RADIUS=6471e3;vec2 rsi(vec3 r0,vec3 rd,float sr) {float a=dot(rd,rd);float b=2.0*dot(rd,r0);float c=dot(r0,r0)-(sr*sr);float d=(b*b)-4.0*a*c;if (d < 0.0) return vec2(1e5,-1e5);return vec2((-b-sqrt(d))/(2.0*a),(-b+sqrt(d))/(2.0*a));}vec4 atmosphere(vec3 r,vec3 r0,vec3 pSun,float iSun,float rPlanet,float rAtmos,vec3 kRlh,float kMie,float shRlh,float shMie,float g) {pSun=normalize(pSun);r=normalize(r);vec2 p=rsi(r0,r,rAtmos);if (p.x > p.y) {return vec4(0.0,0.0,0.0,1.0);}if (p.x < 0.0) {p.x=0.0;}vec3 pos=r0+r*p.x;vec2 p2=rsi(r0,r,rPlanet);if (p2.x <=p2.y && p2.x > 0.0) {p.y=min(p.y,p2.x);}float iStepSize=(p.y-p.x)/float(iSteps);float iTime=p.x+iStepSize*0.5;vec3 totalRlh=vec3(0,0,0);vec3 totalMie=vec3(0,0,0);float iOdRlh=0.0;float iOdMie=0.0;float mu=dot(r,pSun);float mumu=mu*mu;float gg=g*g;float pRlh=3.0/(16.0*PI)*(1.0+mumu);float pMie=3.0/(8.0*PI)*((1.0-gg)*(mumu+1.0))/(pow(1.0+gg-2.0*mu*g,1.5)*(2.0+gg));for (int i=0; i < iSteps; i++) {vec3 iPos=r0+r*iTime;float iHeight=length(iPos)-rPlanet;float odStepRlh=exp(-iHeight/shRlh)*iStepSize;float odStepMie=exp(-iHeight/shMie)*iStepSize;iOdRlh+=odStepRlh;iOdMie+=odStepMie;float jStepSize=rsi(iPos,pSun,rAtmos).y/float(jSteps);float jTime=jStepSize*0.5;float jOdRlh=0.0;float jOdMie=0.0;for (int j=0; j < jSteps; j++) {vec3 jPos=iPos+pSun*jTime;float jHeight=length(jPos)-rPlanet;jOdRlh+=exp(-jHeight/shRlh)*jStepSize;jOdMie+=exp(-jHeight/shMie)*jStepSize;jTime+=jStepSize;}vec3 attn=exp(-(kMie*(iOdMie+jOdMie)+kRlh*(iOdRlh+jOdRlh)));totalRlh+=odStepRlh*attn;totalMie+=odStepMie*attn;iTime+=iStepSize;}float opacity=exp(-(length(kRlh)*length(totalRlh)+kMie*length(totalMie)));vec3 color=iSun*(pRlh*kRlh*totalRlh+pMie*kMie*totalMie);return vec4(color,opacity);}void main() {vec3 scale_camera_pos=-u_globe_position*EARTH_RADIUS/u_globe_radius;vec4 color=atmosphere(normalize(view_direction),scale_camera_pos,u_sun_pos,22.0,EARTH_RADIUS,ATMOS_RADIUS,vec3(5.5e-6,13.0e-6,22.4e-6),21e-6,8e3,1.2e3,0.758
);color.rgb=1.0-exp(-1.0*color.rgb);color=pow(color,vec4(1.0/2.2));fragColor=vec4(color.rgb,1.0-color.a)*u_atmosphere_blend;}`, "in vec2 a_pos;uniform mat4 u_inv_proj_matrix;out vec3 view_direction;void main() {view_direction=(u_inv_proj_matrix*vec4(a_pos,0.0,1.0)).xyz;gl_Position=vec4(a_pos,0.0,1.0);}"),
                    sky: _t("uniform vec4 u_sky_color;uniform vec4 u_horizon_color;uniform vec2 u_horizon;uniform vec2 u_horizon_normal;uniform float u_sky_horizon_blend;uniform float u_sky_blend;void main() {float x=gl_FragCoord.x;float y=gl_FragCoord.y;float blend=(y-u_horizon.y)*u_horizon_normal.y+(x-u_horizon.x)*u_horizon_normal.x;if (blend > 0.0) {if (blend < u_sky_horizon_blend) {fragColor=mix(u_sky_color,u_horizon_color,pow(1.0-blend/u_sky_horizon_blend,2.0));} else {fragColor=u_sky_color;}}fragColor=mix(fragColor,vec4(vec3(0.0),0.0),u_sky_blend);}", "in vec2 a_pos;void main() {gl_Position=vec4(a_pos,1.0,1.0);}")
                };
                function _t(u, e) {
                    const i = /#pragma mapbox: ([\w]+) ([\w]+) ([\w]+) ([\w]+)/g
                      , o = e.match(/in ([\w]+) ([\w]+)/g)
                      , a = u.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g)
                      , h = e.match(/uniform ([\w]+) ([\w]+)([\s]*)([\w]*)/g)
                      , m = h ? h.concat(a) : a
                      , y = {};
                    return {
                        fragmentSource: u = u.replace(i, (v, T, S, A, k) => (y[k] = !0,
                        T === "define" ? `
#ifndef HAS_UNIFORM_u_${k}
in ${S} ${A} ${k};
#else
uniform ${S} ${A} u_${k};
#endif
` : `
#ifdef HAS_UNIFORM_u_${k}
    ${S} ${A} ${k} = u_${k};
#endif
`)),
                        vertexSource: e = e.replace(i, (v, T, S, A, k) => {
                            const O = A === "float" ? "vec2" : "vec4"
                              , V = k.match(/color/) ? "color" : O;
                            return y[k] ? T === "define" ? `
#ifndef HAS_UNIFORM_u_${k}
uniform lowp float u_${k}_t;
in ${S} ${O} a_${k};
out ${S} ${A} ${k};
#else
uniform ${S} ${A} u_${k};
#endif
` : V === "vec4" ? `
#ifndef HAS_UNIFORM_u_${k}
    ${k} = a_${k};
#else
    ${S} ${A} ${k} = u_${k};
#endif
` : `
#ifndef HAS_UNIFORM_u_${k}
    ${k} = unpack_mix_${V}(a_${k}, u_${k}_t);
#else
    ${S} ${A} ${k} = u_${k};
#endif
` : T === "define" ? `
#ifndef HAS_UNIFORM_u_${k}
uniform lowp float u_${k}_t;
in ${S} ${O} a_${k};
#else
uniform ${S} ${A} u_${k};
#endif
` : V === "vec4" ? `
#ifndef HAS_UNIFORM_u_${k}
    ${S} ${A} ${k} = a_${k};
#else
    ${S} ${A} ${k} = u_${k};
#endif
` : `
#ifndef HAS_UNIFORM_u_${k}
    ${S} ${A} ${k} = unpack_mix_${V}(a_${k}, u_${k}_t);
#else
    ${S} ${A} ${k} = u_${k};
#endif
`
                        }
                        ),
                        staticAttributes: o,
                        staticUniforms: m
                    }
                }
                class lr {
                    constructor(e, i, o) {
                        this.vertexBuffer = e,
                        this.indexBuffer = i,
                        this.segments = o
                    }
                    destroy() {
                        this.vertexBuffer.destroy(),
                        this.indexBuffer.destroy(),
                        this.segments.destroy(),
                        this.vertexBuffer = null,
                        this.indexBuffer = null,
                        this.segments = null
                    }
                }
                var Mr = l.aC([{
                    name: "a_pos",
                    type: "Int16",
                    components: 2
                }]);
                const yt = "#define PROJECTION_MERCATOR"
                  , Lo = "mercator";
                class Ka {
                    constructor() {
                        this._cachedMesh = null
                    }
                    get name() {
                        return "mercator"
                    }
                    get useSubdivision() {
                        return !1
                    }
                    get shaderVariantName() {
                        return Lo
                    }
                    get shaderDefine() {
                        return yt
                    }
                    get shaderPreludeCode() {
                        return jr.projectionMercator
                    }
                    get vertexShaderPreludeCode() {
                        return jr.projectionMercator.vertexSource
                    }
                    get subdivisionGranularity() {
                        return l.aD.noSubdivision
                    }
                    get useGlobeControls() {
                        return !1
                    }
                    get transitionState() {
                        return 0
                    }
                    get latitudeErrorCorrectionRadians() {
                        return 0
                    }
                    destroy() {}
                    updateGPUdependent(e) {}
                    getMeshFromTileID(e, i, o, a, h) {
                        if (this._cachedMesh)
                            return this._cachedMesh;
                        const m = new l.aE;
                        m.emplaceBack(0, 0),
                        m.emplaceBack(l.Z, 0),
                        m.emplaceBack(0, l.Z),
                        m.emplaceBack(l.Z, l.Z);
                        const y = e.createVertexBuffer(m, Mr.members)
                          , v = l.aF.simpleSegment(0, 0, 4, 2)
                          , T = new l.aG;
                        T.emplaceBack(1, 0, 2),
                        T.emplaceBack(1, 2, 3);
                        const S = e.createIndexBuffer(T);
                        return this._cachedMesh = new lr(y,S,v),
                        this._cachedMesh
                    }
                    recalculate() {}
                    hasTransition() {
                        return !1
                    }
                    setErrorQueryLatitudeDegrees(e) {}
                }
                function Cr(u, e) {
                    const i = l.ad(e.lat, -85.051129, l.aI);
                    return new l.P(l.U(e.lng) * u,l.S(i) * u)
                }
                function Fi(u, e) {
                    return new l.$(e.x / u,e.y / u).toLngLat()
                }
                function Si(u) {
                    return u.cameraToCenterDistance * Math.min(.85 * Math.tan(l.ac(90 - u.pitch)), Math.tan(l.ac(89.25 - u.pitch)))
                }
                function Xt(u, e) {
                    const i = u.canonical
                      , o = e / l.aH(i.z)
                      , a = i.x + Math.pow(2, i.z) * u.wrap
                      , h = l.as(new Float64Array(16));
                    return l.L(h, h, [a * o, i.y * o, 0]),
                    l.M(h, h, [o / l.Z, o / l.Z, 1]),
                    h
                }
                function Ja(u, e, i, o, a) {
                    const h = l.$.fromLngLat(u, e)
                      , m = a * l.aJ(1, u.lat)
                      , y = m * Math.cos(l.ac(i))
                      , v = Math.sqrt(m * m - y * y)
                      , T = v * Math.sin(l.ac(-o))
                      , S = v * Math.cos(l.ac(-o));
                    return new l.$(h.x + T,h.y + S,h.z + y)
                }
                class Ii {
                    constructor(e=0, i=0, o=0, a=0) {
                        if (isNaN(e) || e < 0 || isNaN(i) || i < 0 || isNaN(o) || o < 0 || isNaN(a) || a < 0)
                            throw new Error("Invalid value for edge-insets, top, bottom, left and right must all be numbers");
                        this.top = e,
                        this.bottom = i,
                        this.left = o,
                        this.right = a
                    }
                    interpolate(e, i, o) {
                        return i.top != null && e.top != null && (this.top = l.B.number(e.top, i.top, o)),
                        i.bottom != null && e.bottom != null && (this.bottom = l.B.number(e.bottom, i.bottom, o)),
                        i.left != null && e.left != null && (this.left = l.B.number(e.left, i.left, o)),
                        i.right != null && e.right != null && (this.right = l.B.number(e.right, i.right, o)),
                        this
                    }
                    getCenter(e, i) {
                        const o = l.ad((this.left + e - this.right) / 2, 0, e)
                          , a = l.ad((this.top + i - this.bottom) / 2, 0, i);
                        return new l.P(o,a)
                    }
                    equals(e) {
                        return this.top === e.top && this.bottom === e.bottom && this.left === e.left && this.right === e.right
                    }
                    clone() {
                        return new Ii(this.top,this.bottom,this.left,this.right)
                    }
                    toJSON() {
                        return {
                            top: this.top,
                            bottom: this.bottom,
                            left: this.left,
                            right: this.right
                        }
                    }
                }
                function Ki(u, e) {
                    if (!u.renderWorldCopies || u.lngRange)
                        return;
                    const i = e.lng - u.center.lng;
                    e.lng += i > 180 ? -360 : i < -180 ? 360 : 0
                }
                function er(u) {
                    return Math.max(0, Math.floor(u))
                }
                class Do {
                    constructor(e, i, o, a, h, m) {
                        this._callbacks = e,
                        this._tileSize = 512,
                        this._renderWorldCopies = m === void 0 || !!m,
                        this._minZoom = i || 0,
                        this._maxZoom = o || 22,
                        this._minPitch = a ?? 0,
                        this._maxPitch = h ?? 60,
                        this.setMaxBounds(),
                        this._width = 0,
                        this._height = 0,
                        this._center = new l.Q(0,0),
                        this._elevation = 0,
                        this._zoom = 0,
                        this._tileZoom = er(this._zoom),
                        this._scale = l.aH(this._zoom),
                        this._bearingInRadians = 0,
                        this._fovInRadians = .6435011087932844,
                        this._pitchInRadians = 0,
                        this._rollInRadians = 0,
                        this._unmodified = !0,
                        this._edgeInsets = new Ii,
                        this._minElevationForCurrentTile = 0,
                        this._autoCalculateNearFarZ = !0
                    }
                    apply(e, i, o) {
                        this._latRange = e.latRange,
                        this._lngRange = e.lngRange,
                        this._width = e.width,
                        this._height = e.height,
                        this._center = e.center,
                        this._elevation = e.elevation,
                        this._minElevationForCurrentTile = e.minElevationForCurrentTile,
                        this._zoom = e.zoom,
                        this._tileZoom = er(this._zoom),
                        this._scale = l.aH(this._zoom),
                        this._bearingInRadians = e.bearingInRadians,
                        this._fovInRadians = e.fovInRadians,
                        this._pitchInRadians = e.pitchInRadians,
                        this._rollInRadians = e.rollInRadians,
                        this._unmodified = e.unmodified,
                        this._edgeInsets = new Ii(e.padding.top,e.padding.bottom,e.padding.left,e.padding.right),
                        this._minZoom = e.minZoom,
                        this._maxZoom = e.maxZoom,
                        this._minPitch = e.minPitch,
                        this._maxPitch = e.maxPitch,
                        this._renderWorldCopies = e.renderWorldCopies,
                        this._cameraToCenterDistance = e.cameraToCenterDistance,
                        this._nearZ = e.nearZ,
                        this._farZ = e.farZ,
                        this._autoCalculateNearFarZ = !o && e.autoCalculateNearFarZ,
                        i && this._constrain(),
                        this._calcMatrices()
                    }
                    get pixelsToClipSpaceMatrix() {
                        return this._pixelsToClipSpaceMatrix
                    }
                    get clipSpaceToPixelsMatrix() {
                        return this._clipSpaceToPixelsMatrix
                    }
                    get minElevationForCurrentTile() {
                        return this._minElevationForCurrentTile
                    }
                    setMinElevationForCurrentTile(e) {
                        this._minElevationForCurrentTile = e
                    }
                    get tileSize() {
                        return this._tileSize
                    }
                    get tileZoom() {
                        return this._tileZoom
                    }
                    get scale() {
                        return this._scale
                    }
                    get width() {
                        return this._width
                    }
                    get height() {
                        return this._height
                    }
                    get bearingInRadians() {
                        return this._bearingInRadians
                    }
                    get lngRange() {
                        return this._lngRange
                    }
                    get latRange() {
                        return this._latRange
                    }
                    get pixelsToGLUnits() {
                        return this._pixelsToGLUnits
                    }
                    get minZoom() {
                        return this._minZoom
                    }
                    setMinZoom(e) {
                        this._minZoom !== e && (this._minZoom = e,
                        this.setZoom(this.getConstrained(this._center, this.zoom).zoom))
                    }
                    get maxZoom() {
                        return this._maxZoom
                    }
                    setMaxZoom(e) {
                        this._maxZoom !== e && (this._maxZoom = e,
                        this.setZoom(this.getConstrained(this._center, this.zoom).zoom))
                    }
                    get minPitch() {
                        return this._minPitch
                    }
                    setMinPitch(e) {
                        this._minPitch !== e && (this._minPitch = e,
                        this.setPitch(Math.max(this.pitch, e)))
                    }
                    get maxPitch() {
                        return this._maxPitch
                    }
                    setMaxPitch(e) {
                        this._maxPitch !== e && (this._maxPitch = e,
                        this.setPitch(Math.min(this.pitch, e)))
                    }
                    get renderWorldCopies() {
                        return this._renderWorldCopies
                    }
                    setRenderWorldCopies(e) {
                        e === void 0 ? e = !0 : e === null && (e = !1),
                        this._renderWorldCopies = e
                    }
                    get worldSize() {
                        return this._tileSize * this._scale
                    }
                    get centerOffset() {
                        return this.centerPoint._sub(this.size._div(2))
                    }
                    get size() {
                        return new l.P(this._width,this._height)
                    }
                    get bearing() {
                        return this._bearingInRadians / Math.PI * 180
                    }
                    setBearing(e) {
                        const i = l.aK(e, -180, 180) * Math.PI / 180;
                        var o, a, h, m, y, v, T, S, A;
                        this._bearingInRadians !== i && (this._unmodified = !1,
                        this._bearingInRadians = i,
                        this._calcMatrices(),
                        this._rotationMatrix = de(),
                        o = this._rotationMatrix,
                        h = -this._bearingInRadians,
                        m = (a = this._rotationMatrix)[0],
                        y = a[1],
                        v = a[2],
                        T = a[3],
                        S = Math.sin(h),
                        A = Math.cos(h),
                        o[0] = m * A + v * S,
                        o[1] = y * A + T * S,
                        o[2] = m * -S + v * A,
                        o[3] = y * -S + T * A)
                    }
                    get rotationMatrix() {
                        return this._rotationMatrix
                    }
                    get pitchInRadians() {
                        return this._pitchInRadians
                    }
                    get pitch() {
                        return this._pitchInRadians / Math.PI * 180
                    }
                    setPitch(e) {
                        const i = l.ad(e, this.minPitch, this.maxPitch) / 180 * Math.PI;
                        this._pitchInRadians !== i && (this._unmodified = !1,
                        this._pitchInRadians = i,
                        this._calcMatrices())
                    }
                    get rollInRadians() {
                        return this._rollInRadians
                    }
                    get roll() {
                        return this._rollInRadians / Math.PI * 180
                    }
                    setRoll(e) {
                        const i = e / 180 * Math.PI;
                        this._rollInRadians !== i && (this._unmodified = !1,
                        this._rollInRadians = i,
                        this._calcMatrices())
                    }
                    get fovInRadians() {
                        return this._fovInRadians
                    }
                    get fov() {
                        return l.aL(this._fovInRadians)
                    }
                    setFov(e) {
                        e = l.ad(e, .1, 150),
                        this.fov !== e && (this._unmodified = !1,
                        this._fovInRadians = l.ac(e),
                        this._calcMatrices())
                    }
                    get zoom() {
                        return this._zoom
                    }
                    setZoom(e) {
                        const i = this.getConstrained(this._center, e).zoom;
                        this._zoom !== i && (this._unmodified = !1,
                        this._zoom = i,
                        this._tileZoom = Math.max(0, Math.floor(i)),
                        this._scale = l.aH(i),
                        this._constrain(),
                        this._calcMatrices())
                    }
                    get center() {
                        return this._center
                    }
                    setCenter(e) {
                        e.lat === this._center.lat && e.lng === this._center.lng || (this._unmodified = !1,
                        this._center = e,
                        this._constrain(),
                        this._calcMatrices())
                    }
                    get elevation() {
                        return this._elevation
                    }
                    setElevation(e) {
                        e !== this._elevation && (this._elevation = e,
                        this._constrain(),
                        this._calcMatrices())
                    }
                    get padding() {
                        return this._edgeInsets.toJSON()
                    }
                    setPadding(e) {
                        this._edgeInsets.equals(e) || (this._unmodified = !1,
                        this._edgeInsets.interpolate(this._edgeInsets, e, 1),
                        this._calcMatrices())
                    }
                    get centerPoint() {
                        return this._edgeInsets.getCenter(this._width, this._height)
                    }
                    get pixelsPerMeter() {
                        return this._pixelPerMeter
                    }
                    get unmodified() {
                        return this._unmodified
                    }
                    get cameraToCenterDistance() {
                        return this._cameraToCenterDistance
                    }
                    get nearZ() {
                        return this._nearZ
                    }
                    get farZ() {
                        return this._farZ
                    }
                    get autoCalculateNearFarZ() {
                        return this._autoCalculateNearFarZ
                    }
                    overrideNearFarZ(e, i) {
                        this._autoCalculateNearFarZ = !1,
                        this._nearZ = e,
                        this._farZ = i,
                        this._calcMatrices()
                    }
                    clearNearFarZOverride() {
                        this._autoCalculateNearFarZ = !0,
                        this._calcMatrices()
                    }
                    isPaddingEqual(e) {
                        return this._edgeInsets.equals(e)
                    }
                    interpolatePadding(e, i, o) {
                        this._unmodified = !1,
                        this._edgeInsets.interpolate(e, i, o),
                        this._constrain(),
                        this._calcMatrices()
                    }
                    resize(e, i, o=!0) {
                        this._width = e,
                        this._height = i,
                        o && this._constrain(),
                        this._calcMatrices()
                    }
                    getMaxBounds() {
                        return this._latRange && this._latRange.length === 2 && this._lngRange && this._lngRange.length === 2 ? new oi([this._lngRange[0], this._latRange[0]],[this._lngRange[1], this._latRange[1]]) : null
                    }
                    setMaxBounds(e) {
                        e ? (this._lngRange = [e.getWest(), e.getEast()],
                        this._latRange = [e.getSouth(), e.getNorth()],
                        this._constrain()) : (this._lngRange = null,
                        this._latRange = [-85.051129, l.aI])
                    }
                    getConstrained(e, i) {
                        return this._callbacks.getConstrained(e, i)
                    }
                    getCameraQueryGeometry(e, i) {
                        if (i.length === 1)
                            return [i[0], e];
                        {
                            let o = e.x
                              , a = e.y
                              , h = e.x
                              , m = e.y;
                            for (const y of i)
                                o = Math.min(o, y.x),
                                a = Math.min(a, y.y),
                                h = Math.max(h, y.x),
                                m = Math.max(m, y.y);
                            return [new l.P(o,a), new l.P(h,a), new l.P(h,m), new l.P(o,m), new l.P(o,a)]
                        }
                    }
                    _constrain() {
                        if (!this.center || !this._width || !this._height || this._constraining)
                            return;
                        this._constraining = !0;
                        const e = this._unmodified
                          , {center: i, zoom: o} = this.getConstrained(this.center, this.zoom);
                        this.setCenter(i),
                        this.setZoom(o),
                        this._unmodified = e,
                        this._constraining = !1
                    }
                    _calcMatrices() {
                        if (this._width && this._height) {
                            this._pixelsToGLUnits = [2 / this._width, -2 / this._height];
                            let e = l.as(new Float64Array(16));
                            l.M(e, e, [this._width / 2, -this._height / 2, 1]),
                            l.L(e, e, [1, -1, 0]),
                            this._clipSpaceToPixelsMatrix = e,
                            e = l.as(new Float64Array(16)),
                            l.M(e, e, [1, -1, 1]),
                            l.L(e, e, [-1, -1, 0]),
                            l.M(e, e, [2 / this._width, 2 / this._height, 1]),
                            this._pixelsToClipSpaceMatrix = e,
                            this._cameraToCenterDistance = .5 / Math.tan(this.fovInRadians / 2) * this._height
                        }
                        this._callbacks.calcMatrices()
                    }
                    calculateCenterFromCameraLngLatAlt(e, i, o, a) {
                        const h = o !== void 0 ? o : this.bearing
                          , m = a = a !== void 0 ? a : this.pitch
                          , y = l.$.fromLngLat(e, i)
                          , v = -Math.cos(l.ac(m))
                          , T = Math.sin(l.ac(m))
                          , S = T * Math.sin(l.ac(h))
                          , A = -T * Math.cos(l.ac(h));
                        let k = this.elevation;
                        const O = i - k;
                        let V;
                        v * O >= 0 || Math.abs(v) < .1 ? (V = 1e4,
                        k = i + V * v) : V = -O / v;
                        let H, q, W = l.aM(1, y.y), J = 0;
                        do {
                            if (J += 1,
                            J > 10)
                                break;
                            q = V / W,
                            H = new l.$(y.x + S * q,y.y + A * q),
                            W = 1 / H.meterInMercatorCoordinateUnits()
                        } while (Math.abs(V - q * W) > 1e-12);
                        return {
                            center: H.toLngLat(),
                            elevation: k,
                            zoom: l.aa(this.height / 2 / Math.tan(this.fovInRadians / 2) / q / this.tileSize)
                        }
                    }
                    recalculateZoomAndCenter(e) {
                        if (this.elevation - e == 0)
                            return;
                        const i = l.aJ(1, this.center.lat) * this.worldSize
                          , o = this.cameraToCenterDistance / i
                          , a = l.$.fromLngLat(this.center, this.elevation)
                          , h = Ja(this.center, this.elevation, this.pitch, this.bearing, o);
                        this._elevation = e;
                        const m = this.calculateCenterFromCameraLngLatAlt(h.toLngLat(), l.aM(h.z, a.y), this.bearing, this.pitch);
                        this._elevation = m.elevation,
                        this._center = m.center,
                        this.setZoom(m.zoom)
                    }
                    getCameraPoint() {
                        const e = Math.tan(this.pitchInRadians) * (this.cameraToCenterDistance || 1);
                        return this.centerPoint.add(new l.P(e * Math.sin(this.rollInRadians),e * Math.cos(this.rollInRadians)))
                    }
                    getCameraAltitude() {
                        return Math.cos(this.pitchInRadians) * this._cameraToCenterDistance / this._pixelPerMeter + this.elevation
                    }
                    getCameraLngLat() {
                        const e = l.aJ(1, this.center.lat) * this.worldSize;
                        return Ja(this.center, this.elevation, this.pitch, this.bearing, this.cameraToCenterDistance / e).toLngLat()
                    }
                    getMercatorTileCoordinates(e) {
                        if (!e)
                            return [0, 0, 1, 1];
                        const i = e.canonical.z >= 0 ? 1 << e.canonical.z : Math.pow(2, e.canonical.z);
                        return [e.canonical.x / i, e.canonical.y / i, 1 / i / l.Z, 1 / i / l.Z]
                    }
                }
                class Vr {
                    constructor(e, i) {
                        this.min = e,
                        this.max = i,
                        this.center = l.aN([], l.aO([], this.min, this.max), .5)
                    }
                    quadrant(e) {
                        const i = [e % 2 == 0, e < 2]
                          , o = l.aP(this.min)
                          , a = l.aP(this.max);
                        for (let h = 0; h < i.length; h++)
                            o[h] = i[h] ? this.min[h] : this.center[h],
                            a[h] = i[h] ? this.center[h] : this.max[h];
                        return a[2] = this.max[2],
                        new Vr(o,a)
                    }
                    distanceX(e) {
                        return Math.max(Math.min(this.max[0], e[0]), this.min[0]) - e[0]
                    }
                    distanceY(e) {
                        return Math.max(Math.min(this.max[1], e[1]), this.min[1]) - e[1]
                    }
                    intersectsFrustum(e) {
                        let i = !0;
                        for (let o = 0; o < e.planes.length; o++) {
                            const a = this.intersectsPlane(e.planes[o]);
                            if (a === 0)
                                return 0;
                            a === 1 && (i = !1)
                        }
                        return i ? 2 : e.aabb.min[0] > this.max[0] || e.aabb.min[1] > this.max[1] || e.aabb.min[2] > this.max[2] || e.aabb.max[0] < this.min[0] || e.aabb.max[1] < this.min[1] || e.aabb.max[2] < this.min[2] ? 0 : 1
                    }
                    intersectsPlane(e) {
                        let i = e[3]
                          , o = e[3];
                        for (let a = 0; a < 3; a++)
                            e[a] > 0 ? (i += e[a] * this.min[a],
                            o += e[a] * this.max[a]) : (o += e[a] * this.min[a],
                            i += e[a] * this.max[a]);
                        return i >= 0 ? 2 : o < 0 ? 0 : 1
                    }
                }
                class hi {
                    distanceToTile2d(e, i, o, a) {
                        const h = a.distanceX([e, i])
                          , m = a.distanceY([e, i]);
                        return Math.hypot(h, m)
                    }
                    getWrap(e, i, o) {
                        return o
                    }
                    getTileAABB(e, i, o, a) {
                        var h, m;
                        let y = o
                          , v = o;
                        if (a.terrain) {
                            const S = new l.Y(e.z,i,e.z,e.x,e.y)
                              , A = a.terrain.getMinMaxElevation(S);
                            y = (h = A.minElevation) !== null && h !== void 0 ? h : o,
                            v = (m = A.maxElevation) !== null && m !== void 0 ? m : o
                        }
                        const T = 1 << e.z;
                        return new Vr([i + e.x / T, e.y / T, y],[i + (e.x + 1) / T, (e.y + 1) / T, v])
                    }
                    allowVariableZoom(e, i) {
                        const o = e.fov * (Math.abs(Math.cos(e.rollInRadians)) * e.height + Math.abs(Math.sin(e.rollInRadians)) * e.width) / e.height
                          , a = l.ad(78.5 - o / 2, 0, 60);
                        return !!i.terrain || e.pitch > a
                    }
                    allowWorldCopies() {
                        return !0
                    }
                    recalculateCache() {}
                }
                class Fn {
                    constructor(e, i, o) {
                        this.points = e,
                        this.planes = i,
                        this.aabb = o
                    }
                    static fromInvProjectionMatrix(e, i=1, o=0) {
                        const a = Math.pow(2, o)
                          , h = [[-1, 1, -1, 1], [1, 1, -1, 1], [1, -1, -1, 1], [-1, -1, -1, 1], [-1, 1, 1, 1], [1, 1, 1, 1], [1, -1, 1, 1], [-1, -1, 1, 1]].map(T => {
                            const S = 1 / (T = l.ao([], T, e))[3] / i * a;
                            return l.aQ(T, T, [S, S, 1 / T[3], S])
                        }
                        )
                          , m = [[0, 1, 2], [6, 5, 4], [0, 3, 7], [2, 1, 5], [3, 2, 6], [0, 4, 5]].map(T => {
                            const S = l.aR([], h[T[0]], h[T[1]])
                              , A = l.aR([], h[T[2]], h[T[1]])
                              , k = l.aS([], l.aT([], S, A))
                              , O = -l.aU(k, h[T[1]]);
                            return k.concat(O)
                        }
                        )
                          , y = [Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY, Number.POSITIVE_INFINITY]
                          , v = [Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY, Number.NEGATIVE_INFINITY];
                        for (const T of h)
                            for (let S = 0; S < 3; S++)
                                y[S] = Math.min(y[S], T[S]),
                                v[S] = Math.max(v[S], T[S]);
                        return new Fn(h,m,new Vr(y,v))
                    }
                }
                class Pr {
                    get pixelsToClipSpaceMatrix() {
                        return this._helper.pixelsToClipSpaceMatrix
                    }
                    get clipSpaceToPixelsMatrix() {
                        return this._helper.clipSpaceToPixelsMatrix
                    }
                    get pixelsToGLUnits() {
                        return this._helper.pixelsToGLUnits
                    }
                    get centerOffset() {
                        return this._helper.centerOffset
                    }
                    get size() {
                        return this._helper.size
                    }
                    get rotationMatrix() {
                        return this._helper.rotationMatrix
                    }
                    get centerPoint() {
                        return this._helper.centerPoint
                    }
                    get pixelsPerMeter() {
                        return this._helper.pixelsPerMeter
                    }
                    setMinZoom(e) {
                        this._helper.setMinZoom(e)
                    }
                    setMaxZoom(e) {
                        this._helper.setMaxZoom(e)
                    }
                    setMinPitch(e) {
                        this._helper.setMinPitch(e)
                    }
                    setMaxPitch(e) {
                        this._helper.setMaxPitch(e)
                    }
                    setRenderWorldCopies(e) {
                        this._helper.setRenderWorldCopies(e)
                    }
                    setBearing(e) {
                        this._helper.setBearing(e)
                    }
                    setPitch(e) {
                        this._helper.setPitch(e)
                    }
                    setRoll(e) {
                        this._helper.setRoll(e)
                    }
                    setFov(e) {
                        this._helper.setFov(e)
                    }
                    setZoom(e) {
                        this._helper.setZoom(e)
                    }
                    setCenter(e) {
                        this._helper.setCenter(e)
                    }
                    setElevation(e) {
                        this._helper.setElevation(e)
                    }
                    setMinElevationForCurrentTile(e) {
                        this._helper.setMinElevationForCurrentTile(e)
                    }
                    setPadding(e) {
                        this._helper.setPadding(e)
                    }
                    interpolatePadding(e, i, o) {
                        return this._helper.interpolatePadding(e, i, o)
                    }
                    isPaddingEqual(e) {
                        return this._helper.isPaddingEqual(e)
                    }
                    resize(e, i, o=!0) {
                        this._helper.resize(e, i, o)
                    }
                    getMaxBounds() {
                        return this._helper.getMaxBounds()
                    }
                    setMaxBounds(e) {
                        this._helper.setMaxBounds(e)
                    }
                    overrideNearFarZ(e, i) {
                        this._helper.overrideNearFarZ(e, i)
                    }
                    clearNearFarZOverride() {
                        this._helper.clearNearFarZOverride()
                    }
                    getCameraQueryGeometry(e) {
                        return this._helper.getCameraQueryGeometry(this.getCameraPoint(), e)
                    }
                    get tileSize() {
                        return this._helper.tileSize
                    }
                    get tileZoom() {
                        return this._helper.tileZoom
                    }
                    get scale() {
                        return this._helper.scale
                    }
                    get worldSize() {
                        return this._helper.worldSize
                    }
                    get width() {
                        return this._helper.width
                    }
                    get height() {
                        return this._helper.height
                    }
                    get lngRange() {
                        return this._helper.lngRange
                    }
                    get latRange() {
                        return this._helper.latRange
                    }
                    get minZoom() {
                        return this._helper.minZoom
                    }
                    get maxZoom() {
                        return this._helper.maxZoom
                    }
                    get zoom() {
                        return this._helper.zoom
                    }
                    get center() {
                        return this._helper.center
                    }
                    get minPitch() {
                        return this._helper.minPitch
                    }
                    get maxPitch() {
                        return this._helper.maxPitch
                    }
                    get pitch() {
                        return this._helper.pitch
                    }
                    get pitchInRadians() {
                        return this._helper.pitchInRadians
                    }
                    get roll() {
                        return this._helper.roll
                    }
                    get rollInRadians() {
                        return this._helper.rollInRadians
                    }
                    get bearing() {
                        return this._helper.bearing
                    }
                    get bearingInRadians() {
                        return this._helper.bearingInRadians
                    }
                    get fov() {
                        return this._helper.fov
                    }
                    get fovInRadians() {
                        return this._helper.fovInRadians
                    }
                    get elevation() {
                        return this._helper.elevation
                    }
                    get minElevationForCurrentTile() {
                        return this._helper.minElevationForCurrentTile
                    }
                    get padding() {
                        return this._helper.padding
                    }
                    get unmodified() {
                        return this._helper.unmodified
                    }
                    get renderWorldCopies() {
                        return this._helper.renderWorldCopies
                    }
                    get cameraToCenterDistance() {
                        return this._helper.cameraToCenterDistance
                    }
                    get nearZ() {
                        return this._helper.nearZ
                    }
                    get farZ() {
                        return this._helper.farZ
                    }
                    get autoCalculateNearFarZ() {
                        return this._helper.autoCalculateNearFarZ
                    }
                    setTransitionState(e, i) {}
                    constructor(e, i, o, a, h) {
                        this._posMatrixCache = new Map,
                        this._alignedPosMatrixCache = new Map,
                        this._fogMatrixCacheF32 = new Map,
                        this._helper = new Do({
                            calcMatrices: () => {
                                this._calcMatrices()
                            }
                            ,
                            getConstrained: (m, y) => this.getConstrained(m, y)
                        },e,i,o,a,h),
                        this._coveringTilesDetailsProvider = new hi
                    }
                    clone() {
                        const e = new Pr;
                        return e.apply(this),
                        e
                    }
                    apply(e, i, o) {
                        this._helper.apply(e, i, o)
                    }
                    get cameraPosition() {
                        return this._cameraPosition
                    }
                    get projectionMatrix() {
                        return this._projectionMatrix
                    }
                    get modelViewProjectionMatrix() {
                        return this._viewProjMatrix
                    }
                    get inverseProjectionMatrix() {
                        return this._invProjMatrix
                    }
                    get mercatorMatrix() {
                        return this._mercatorMatrix
                    }
                    getVisibleUnwrappedCoordinates(e) {
                        const i = [new l.aV(0,e)];
                        if (this._helper._renderWorldCopies) {
                            const o = this.screenPointToMercatorCoordinate(new l.P(0,0))
                              , a = this.screenPointToMercatorCoordinate(new l.P(this._helper._width,0))
                              , h = this.screenPointToMercatorCoordinate(new l.P(this._helper._width,this._helper._height))
                              , m = this.screenPointToMercatorCoordinate(new l.P(0,this._helper._height))
                              , y = Math.floor(Math.min(o.x, a.x, h.x, m.x))
                              , v = Math.floor(Math.max(o.x, a.x, h.x, m.x))
                              , T = 1;
                            for (let S = y - T; S <= v + T; S++)
                                S !== 0 && i.push(new l.aV(S,e))
                        }
                        return i
                    }
                    getCameraFrustum() {
                        return Fn.fromInvProjectionMatrix(this._invViewProjMatrix, this.worldSize)
                    }
                    getClippingPlane() {
                        return null
                    }
                    getCoveringTilesDetailsProvider() {
                        return this._coveringTilesDetailsProvider
                    }
                    recalculateZoomAndCenter(e) {
                        const i = this.screenPointToLocation(this.centerPoint, e)
                          , o = e ? e.getElevationForLngLatZoom(i, this._helper._tileZoom) : 0;
                        this._helper.recalculateZoomAndCenter(o)
                    }
                    setLocationAtPoint(e, i) {
                        const o = l.aJ(this.elevation, this.center.lat)
                          , a = this.screenPointToMercatorCoordinateAtZ(i, o)
                          , h = this.screenPointToMercatorCoordinateAtZ(this.centerPoint, o)
                          , m = l.$.fromLngLat(e)
                          , y = new l.$(m.x - (a.x - h.x),m.y - (a.y - h.y));
                        this.setCenter(y?.toLngLat()),
                        this._helper._renderWorldCopies && this.setCenter(this.center.wrap())
                    }
                    locationToScreenPoint(e, i) {
                        return i ? this.coordinatePoint(l.$.fromLngLat(e), i.getElevationForLngLatZoom(e, this._helper._tileZoom), this._pixelMatrix3D) : this.coordinatePoint(l.$.fromLngLat(e))
                    }
                    screenPointToLocation(e, i) {
                        var o;
                        return (o = this.screenPointToMercatorCoordinate(e, i)) === null || o === void 0 ? void 0 : o.toLngLat()
                    }
                    screenPointToMercatorCoordinate(e, i) {
                        if (i) {
                            const o = i.pointCoordinate(e);
                            if (o != null)
                                return o
                        }
                        return this.screenPointToMercatorCoordinateAtZ(e)
                    }
                    screenPointToMercatorCoordinateAtZ(e, i) {
                        const o = i || 0
                          , a = [e.x, e.y, 0, 1]
                          , h = [e.x, e.y, 1, 1];
                        l.ao(a, a, this._pixelMatrixInverse),
                        l.ao(h, h, this._pixelMatrixInverse);
                        const m = a[3]
                          , y = h[3]
                          , v = a[1] / m
                          , T = h[1] / y
                          , S = a[2] / m
                          , A = h[2] / y
                          , k = S === A ? 0 : (o - S) / (A - S);
                        return new l.$(l.B.number(a[0] / m, h[0] / y, k) / this.worldSize,l.B.number(v, T, k) / this.worldSize,o)
                    }
                    coordinatePoint(e, i=0, o=this._pixelMatrix) {
                        const a = [e.x * this.worldSize, e.y * this.worldSize, i, 1];
                        return l.ao(a, a, o),
                        new l.P(a[0] / a[3],a[1] / a[3])
                    }
                    getBounds() {
                        const e = Math.max(0, this._helper._height / 2 - Si(this));
                        return new oi().extend(this.screenPointToLocation(new l.P(0,e))).extend(this.screenPointToLocation(new l.P(this._helper._width,e))).extend(this.screenPointToLocation(new l.P(this._helper._width,this._helper._height))).extend(this.screenPointToLocation(new l.P(0,this._helper._height)))
                    }
                    isPointOnMapSurface(e, i) {
                        return i ? i.pointCoordinate(e) != null : e.y > this.height / 2 - Si(this)
                    }
                    calculatePosMatrix(e, i=!1, o) {
                        var a;
                        const h = (a = e.key) !== null && a !== void 0 ? a : l.aW(e.wrap, e.canonical.z, e.canonical.z, e.canonical.x, e.canonical.y)
                          , m = i ? this._alignedPosMatrixCache : this._posMatrixCache;
                        if (m.has(h)) {
                            const T = m.get(h);
                            return o ? T.f32 : T.f64
                        }
                        const y = Xt(e, this.worldSize);
                        l.N(y, i ? this._alignedProjMatrix : this._viewProjMatrix, y);
                        const v = {
                            f64: y,
                            f32: new Float32Array(y)
                        };
                        return m.set(h, v),
                        o ? v.f32 : v.f64
                    }
                    calculateFogMatrix(e) {
                        const i = e.key
                          , o = this._fogMatrixCacheF32;
                        if (o.has(i))
                            return o.get(i);
                        const a = Xt(e, this.worldSize);
                        return l.N(a, this._fogMatrix, a),
                        o.set(i, new Float32Array(a)),
                        o.get(i)
                    }
                    getConstrained(e, i) {
                        i = l.ad(+i, this.minZoom, this.maxZoom);
                        const o = {
                            center: new l.Q(e.lng,e.lat),
                            zoom: i
                        };
                        let a = this._helper._lngRange;
                        this._helper._renderWorldCopies || a !== null || (a = [-179.9999999999, 180 - 1e-10]);
                        const h = this.tileSize * l.aH(o.zoom);
                        let m = 0
                          , y = h
                          , v = 0
                          , T = h
                          , S = 0
                          , A = 0;
                        const {x: k, y: O} = this.size;
                        if (this._helper._latRange) {
                            const te = this._helper._latRange;
                            m = l.S(te[1]) * h,
                            y = l.S(te[0]) * h,
                            y - m < O && (S = O / (y - m))
                        }
                        a && (v = l.aK(l.U(a[0]) * h, 0, h),
                        T = l.aK(l.U(a[1]) * h, 0, h),
                        T < v && (T += h),
                        T - v < k && (A = k / (T - v)));
                        const {x: V, y: H} = Cr(h, e);
                        let q, W;
                        const J = Math.max(A || 0, S || 0);
                        if (J) {
                            const te = new l.P(A ? (T + v) / 2 : V,S ? (y + m) / 2 : H);
                            return o.center = Fi(h, te).wrap(),
                            o.zoom += l.aa(J),
                            o
                        }
                        if (this._helper._latRange) {
                            const te = O / 2;
                            H - te < m && (W = m + te),
                            H + te > y && (W = y - te)
                        }
                        if (a) {
                            const te = (v + T) / 2;
                            let ie = V;
                            this._helper._renderWorldCopies && (ie = l.aK(V, te - h / 2, te + h / 2));
                            const ne = k / 2;
                            ie - ne < v && (q = v + ne),
                            ie + ne > T && (q = T - ne)
                        }
                        if (q !== void 0 || W !== void 0) {
                            const te = new l.P(q ?? V,W ?? H);
                            o.center = Fi(h, te).wrap()
                        }
                        return o
                    }
                    calculateCenterFromCameraLngLatAlt(e, i, o, a) {
                        return this._helper.calculateCenterFromCameraLngLatAlt(e, i, o, a)
                    }
                    _calculateNearFarZIfNeeded(e, i, o) {
                        if (!this._helper.autoCalculateNearFarZ)
                            return;
                        const a = Math.min(this.elevation, this.minElevationForCurrentTile, this.getCameraAltitude() - 100)
                          , h = e - a * this._helper._pixelPerMeter / Math.cos(i)
                          , m = a < 0 ? h : e
                          , y = Math.PI / 2 + this.pitchInRadians
                          , v = l.ac(this.fov) * (Math.abs(Math.cos(l.ac(this.roll))) * this.height + Math.abs(Math.sin(l.ac(this.roll))) * this.width) / this.height * (.5 + o.y / this.height)
                          , T = Math.sin(v) * m / Math.sin(l.ad(Math.PI - y - v, .01, Math.PI - .01))
                          , S = Si(this)
                          , A = Math.atan(S / this._helper.cameraToCenterDistance)
                          , k = l.ac(.75)
                          , O = A > k ? 2 * A * (.5 + o.y / (2 * S)) : k
                          , V = Math.sin(O) * m / Math.sin(l.ad(Math.PI - y - O, .01, Math.PI - .01))
                          , H = Math.min(T, V);
                        this._helper._farZ = 1.01 * (Math.cos(Math.PI / 2 - i) * H + m),
                        this._helper._nearZ = this._helper._height / 50
                    }
                    _calcMatrices() {
                        if (!this._helper._height)
                            return;
                        const e = this.centerOffset
                          , i = Cr(this.worldSize, this.center)
                          , o = i.x
                          , a = i.y;
                        this._helper._pixelPerMeter = l.aJ(1, this.center.lat) * this.worldSize;
                        const h = l.ac(Math.min(this.pitch, 89.25))
                          , m = Math.max(this._helper.cameraToCenterDistance / 2, this._helper.cameraToCenterDistance + this._helper._elevation * this._helper._pixelPerMeter / Math.cos(h));
                        let y;
                        this._calculateNearFarZIfNeeded(m, h, e),
                        y = new Float64Array(16),
                        l.aX(y, this.fovInRadians, this._helper._width / this._helper._height, this._helper._nearZ, this._helper._farZ),
                        this._invProjMatrix = new Float64Array(16),
                        l.ai(this._invProjMatrix, y),
                        y[8] = 2 * -e.x / this._helper._width,
                        y[9] = 2 * e.y / this._helper._height,
                        this._projectionMatrix = l.aY(y),
                        l.M(y, y, [1, -1, 1]),
                        l.L(y, y, [0, 0, -this._helper.cameraToCenterDistance]),
                        l.aZ(y, y, -this.rollInRadians),
                        l.a_(y, y, this.pitchInRadians),
                        l.aZ(y, y, -this.bearingInRadians),
                        l.L(y, y, [-o, -a, 0]),
                        this._mercatorMatrix = l.M([], y, [this.worldSize, this.worldSize, this.worldSize]),
                        l.M(y, y, [1, 1, this._helper._pixelPerMeter]),
                        this._pixelMatrix = l.N(new Float64Array(16), this.clipSpaceToPixelsMatrix, y),
                        l.L(y, y, [0, 0, -this.elevation]),
                        this._viewProjMatrix = y,
                        this._invViewProjMatrix = l.ai([], y);
                        const v = [0, 0, -1, 1];
                        l.ao(v, v, this._invViewProjMatrix),
                        this._cameraPosition = [v[0] / v[3], v[1] / v[3], v[2] / v[3]],
                        this._fogMatrix = new Float64Array(16),
                        l.aX(this._fogMatrix, this.fovInRadians, this.width / this.height, m, this._helper._farZ),
                        this._fogMatrix[8] = 2 * -e.x / this.width,
                        this._fogMatrix[9] = 2 * e.y / this.height,
                        l.M(this._fogMatrix, this._fogMatrix, [1, -1, 1]),
                        l.L(this._fogMatrix, this._fogMatrix, [0, 0, -this.cameraToCenterDistance]),
                        l.aZ(this._fogMatrix, this._fogMatrix, -this.rollInRadians),
                        l.a_(this._fogMatrix, this._fogMatrix, this.pitchInRadians),
                        l.aZ(this._fogMatrix, this._fogMatrix, -this.bearingInRadians),
                        l.L(this._fogMatrix, this._fogMatrix, [-o, -a, 0]),
                        l.M(this._fogMatrix, this._fogMatrix, [1, 1, this._helper._pixelPerMeter]),
                        l.L(this._fogMatrix, this._fogMatrix, [0, 0, -this.elevation]),
                        this._pixelMatrix3D = l.N(new Float64Array(16), this.clipSpaceToPixelsMatrix, y);
                        const T = this._helper._width % 2 / 2
                          , S = this._helper._height % 2 / 2
                          , A = Math.cos(this.bearingInRadians)
                          , k = Math.sin(-this.bearingInRadians)
                          , O = o - Math.round(o) + A * T + k * S
                          , V = a - Math.round(a) + A * S + k * T
                          , H = new Float64Array(y);
                        if (l.L(H, H, [O > .5 ? O - 1 : O, V > .5 ? V - 1 : V, 0]),
                        this._alignedProjMatrix = H,
                        y = l.ai(new Float64Array(16), this._pixelMatrix),
                        !y)
                            throw new Error("failed to invert matrix");
                        this._pixelMatrixInverse = y,
                        this._clearMatrixCaches()
                    }
                    _clearMatrixCaches() {
                        this._posMatrixCache.clear(),
                        this._alignedPosMatrixCache.clear(),
                        this._fogMatrixCacheF32.clear()
                    }
                    maxPitchScaleFactor() {
                        if (!this._pixelMatrixInverse)
                            return 1;
                        const e = this.screenPointToMercatorCoordinate(new l.P(0,0))
                          , i = [e.x * this.worldSize, e.y * this.worldSize, 0, 1];
                        return l.ao(i, i, this._pixelMatrix)[3] / this._helper.cameraToCenterDistance
                    }
                    getCameraPoint() {
                        return this._helper.getCameraPoint()
                    }
                    getCameraAltitude() {
                        return this._helper.getCameraAltitude()
                    }
                    getCameraLngLat() {
                        const e = l.aJ(1, this.center.lat) * this.worldSize;
                        return Ja(this.center, this.elevation, this.pitch, this.bearing, this._helper.cameraToCenterDistance / e).toLngLat()
                    }
                    lngLatToCameraDepth(e, i) {
                        const o = l.$.fromLngLat(e)
                          , a = [o.x * this.worldSize, o.y * this.worldSize, i, 1];
                        return l.ao(a, a, this._viewProjMatrix),
                        a[2] / a[3]
                    }
                    getProjectionData(e) {
                        const {overscaledTileID: i, aligned: o, applyTerrainMatrix: a} = e
                          , h = this._helper.getMercatorTileCoordinates(i)
                          , m = i ? this.calculatePosMatrix(i, o, !0) : null;
                        let y;
                        return y = i && i.terrainRttPosMatrix32f && a ? i.terrainRttPosMatrix32f : m || l.a$(),
                        {
                            mainMatrix: y,
                            tileMercatorCoords: h,
                            clippingPlane: [0, 0, 0, 0],
                            projectionTransition: 0,
                            fallbackMatrix: y
                        }
                    }
                    isLocationOccluded(e) {
                        return !1
                    }
                    getPixelScale() {
                        return 1
                    }
                    getCircleRadiusCorrection() {
                        return 1
                    }
                    getPitchedTextCorrection(e, i, o) {
                        return 1
                    }
                    transformLightDirection(e) {
                        return l.aP(e)
                    }
                    getRayDirectionFromPixel(e) {
                        throw new Error("Not implemented.")
                    }
                    projectTileCoordinates(e, i, o, a) {
                        const h = this.calculatePosMatrix(o);
                        let m;
                        a ? (m = [e, i, a(e, i), 1],
                        l.ao(m, m, h)) : (m = [e, i, 0, 1],
                        xi(m, m, h));
                        const y = m[3];
                        return {
                            point: new l.P(m[0] / y,m[1] / y),
                            signedDistanceFromCamera: y,
                            isOccluded: !1
                        }
                    }
                    populateCache(e) {
                        for (const i of e)
                            this.calculatePosMatrix(i)
                    }
                    getMatrixForModel(e, i) {
                        const o = l.$.fromLngLat(e, i)
                          , a = o.meterInMercatorCoordinateUnits()
                          , h = l.b0();
                        return l.L(h, h, [o.x, o.y, o.z]),
                        l.aZ(h, h, Math.PI),
                        l.a_(h, h, Math.PI / 2),
                        l.M(h, h, [-a, a, a]),
                        h
                    }
                    getProjectionDataForCustomLayer(e=!0) {
                        const i = new l.Y(0,0,0,0,0)
                          , o = this.getProjectionData({
                            overscaledTileID: i,
                            applyGlobeMatrix: e
                        })
                          , a = Xt(i, this.worldSize);
                        l.N(a, this._viewProjMatrix, a),
                        o.tileMercatorCoords = [0, 0, 1, 1];
                        const h = [l.Z, l.Z, this.worldSize / this._helper.pixelsPerMeter]
                          , m = l.b1();
                        return l.M(m, a, h),
                        o.fallbackMatrix = m,
                        o.mainMatrix = m,
                        o
                    }
                    getFastPathSimpleProjectionMatrix(e) {
                        return this.calculatePosMatrix(e)
                    }
                }
                function ro() {
                    l.w("Map cannot fit within canvas with the given bounds, padding, and/or offset.")
                }
                function Sr(u) {
                    if (u.useSlerp)
                        if (u.k < 1) {
                            const e = l.b2(u.startEulerAngles.roll, u.startEulerAngles.pitch, u.startEulerAngles.bearing)
                              , i = l.b2(u.endEulerAngles.roll, u.endEulerAngles.pitch, u.endEulerAngles.bearing)
                              , o = new Float64Array(4);
                            l.b3(o, e, i, u.k);
                            const a = l.b4(o);
                            u.tr.setRoll(a.roll),
                            u.tr.setPitch(a.pitch),
                            u.tr.setBearing(a.bearing)
                        } else
                            u.tr.setRoll(u.endEulerAngles.roll),
                            u.tr.setPitch(u.endEulerAngles.pitch),
                            u.tr.setBearing(u.endEulerAngles.bearing);
                    else
                        u.tr.setRoll(l.B.number(u.startEulerAngles.roll, u.endEulerAngles.roll, u.k)),
                        u.tr.setPitch(l.B.number(u.startEulerAngles.pitch, u.endEulerAngles.pitch, u.k)),
                        u.tr.setBearing(l.B.number(u.startEulerAngles.bearing, u.endEulerAngles.bearing, u.k))
                }
                function Ya(u, e, i, o, a) {
                    const h = a.padding
                      , m = Cr(a.worldSize, i.getNorthWest())
                      , y = Cr(a.worldSize, i.getNorthEast())
                      , v = Cr(a.worldSize, i.getSouthEast())
                      , T = Cr(a.worldSize, i.getSouthWest())
                      , S = l.ac(-o)
                      , A = m.rotate(S)
                      , k = y.rotate(S)
                      , O = v.rotate(S)
                      , V = T.rotate(S)
                      , H = new l.P(Math.max(A.x, k.x, V.x, O.x),Math.max(A.y, k.y, V.y, O.y))
                      , q = new l.P(Math.min(A.x, k.x, V.x, O.x),Math.min(A.y, k.y, V.y, O.y))
                      , W = H.sub(q)
                      , J = (a.width - (h.left + h.right + e.left + e.right)) / W.x
                      , te = (a.height - (h.top + h.bottom + e.top + e.bottom)) / W.y;
                    if (te < 0 || J < 0)
                        return void ro();
                    const ie = Math.min(l.aa(a.scale * Math.min(J, te)), u.maxZoom)
                      , ne = l.P.convert(u.offset)
                      , le = new l.P((e.left - e.right) / 2,(e.top - e.bottom) / 2).rotate(l.ac(o))
                      , se = ne.add(le).mult(a.scale / l.aH(ie));
                    return {
                        center: Fi(a.worldSize, m.add(v).div(2).sub(se)),
                        zoom: ie,
                        bearing: o
                    }
                }
                class Ur {
                    get useGlobeControls() {
                        return !1
                    }
                    handlePanInertia(e, i) {
                        return {
                            easingOffset: e,
                            easingCenter: i.center
                        }
                    }
                    handleMapControlsRollPitchBearingZoom(e, i) {
                        e.bearingDelta && i.setBearing(i.bearing + e.bearingDelta),
                        e.pitchDelta && i.setPitch(i.pitch + e.pitchDelta),
                        e.rollDelta && i.setRoll(i.roll + e.rollDelta),
                        e.zoomDelta && i.setZoom(i.zoom + e.zoomDelta)
                    }
                    handleMapControlsPan(e, i, o) {
                        e.around.distSqr(i.centerPoint) < .01 || i.setLocationAtPoint(o, e.around)
                    }
                    cameraForBoxAndBearing(e, i, o, a, h) {
                        return Ya(e, i, o, a, h)
                    }
                    handleJumpToCenterZoom(e, i) {
                        e.zoom !== (i.zoom !== void 0 ? +i.zoom : e.zoom) && e.setZoom(+i.zoom),
                        i.center !== void 0 && e.setCenter(l.Q.convert(i.center))
                    }
                    handleEaseTo(e, i) {
                        const o = e.zoom
                          , a = e.padding
                          , h = {
                            roll: e.roll,
                            pitch: e.pitch,
                            bearing: e.bearing
                        }
                          , m = {
                            roll: i.roll === void 0 ? e.roll : i.roll,
                            pitch: i.pitch === void 0 ? e.pitch : i.pitch,
                            bearing: i.bearing === void 0 ? e.bearing : i.bearing
                        }
                          , y = i.zoom !== void 0
                          , v = !e.isPaddingEqual(i.padding);
                        let T = !1;
                        const S = y ? +i.zoom : e.zoom;
                        let A = e.centerPoint.add(i.offsetAsPoint);
                        const k = e.screenPointToLocation(A)
                          , {center: O, zoom: V} = e.getConstrained(l.Q.convert(i.center || k), S ?? o);
                        Ki(e, O);
                        const H = Cr(e.worldSize, k)
                          , q = Cr(e.worldSize, O).sub(H)
                          , W = l.aH(V - o);
                        return T = V !== o,
                        {
                            easeFunc: J => {
                                if (T && e.setZoom(l.B.number(o, V, J)),
                                l.b5(h, m) || Sr({
                                    startEulerAngles: h,
                                    endEulerAngles: m,
                                    tr: e,
                                    k: J,
                                    useSlerp: h.roll != m.roll
                                }),
                                v && (e.interpolatePadding(a, i.padding, J),
                                A = e.centerPoint.add(i.offsetAsPoint)),
                                i.around)
                                    e.setLocationAtPoint(i.around, i.aroundPoint);
                                else {
                                    const te = l.aH(e.zoom - o)
                                      , ie = V > o ? Math.min(2, W) : Math.max(.5, W)
                                      , ne = Math.pow(ie, 1 - J)
                                      , le = Fi(e.worldSize, H.add(q.mult(J * ne)).mult(te));
                                    e.setLocationAtPoint(e.renderWorldCopies ? le.wrap() : le, A)
                                }
                            }
                            ,
                            isZooming: T,
                            elevationCenter: O
                        }
                    }
                    handleFlyTo(e, i) {
                        const o = i.zoom !== void 0
                          , a = e.zoom
                          , h = e.getConstrained(l.Q.convert(i.center || i.locationAtOffset), o ? +i.zoom : a)
                          , m = h.center
                          , y = h.zoom;
                        Ki(e, m);
                        const v = Cr(e.worldSize, i.locationAtOffset)
                          , T = Cr(e.worldSize, m).sub(v)
                          , S = T.mag()
                          , A = l.aH(y - a);
                        let k;
                        if (i.minZoom !== void 0) {
                            const O = Math.min(+i.minZoom, a, y)
                              , V = e.getConstrained(m, O).zoom;
                            k = l.aH(V - a)
                        }
                        return {
                            easeFunc: (O, V, H, q) => {
                                e.setZoom(O === 1 ? y : a + l.aa(V));
                                const W = O === 1 ? m : Fi(e.worldSize, v.add(T.mult(H)).mult(V));
                                e.setLocationAtPoint(e.renderWorldCopies ? W.wrap() : W, q)
                            }
                            ,
                            scaleOfZoom: A,
                            targetCenter: m,
                            scaleOfMinZoom: k,
                            pixelPathLength: S
                        }
                    }
                }
                class Vt {
                    constructor(e, i, o) {
                        this.blendFunction = e,
                        this.blendColor = i,
                        this.mask = o
                    }
                }
                Vt.Replace = [1, 0],
                Vt.disabled = new Vt(Vt.Replace,l.b6.transparent,[!1, !1, !1, !1]),
                Vt.unblended = new Vt(Vt.Replace,l.b6.transparent,[!0, !0, !0, !0]),
                Vt.alphaBlended = new Vt([1, 771],l.b6.transparent,[!0, !0, !0, !0]);
                const Ro = 2305;
                class pt {
                    constructor(e, i, o) {
                        this.enable = e,
                        this.mode = i,
                        this.frontFace = o
                    }
                }
                pt.disabled = new pt(!1,1029,Ro),
                pt.backCCW = new pt(!0,1029,Ro),
                pt.frontCCW = new pt(!0,1028,Ro);
                class ot {
                    constructor(e, i, o) {
                        this.func = e,
                        this.mask = i,
                        this.range = o
                    }
                }
                ot.ReadOnly = !1,
                ot.ReadWrite = !0,
                ot.disabled = new ot(519,ot.ReadOnly,[0, 1]);
                const Es = 7680;
                class mt {
                    constructor(e, i, o, a, h, m) {
                        this.test = e,
                        this.ref = i,
                        this.mask = o,
                        this.fail = a,
                        this.depthFail = h,
                        this.pass = m
                    }
                }
                mt.disabled = new mt({
                    func: 519,
                    mask: 0
                },0,0,Es,Es,Es);
                const no = new WeakMap;
                function Ir(u) {
                    var e;
                    if (no.has(u))
                        return no.get(u);
                    {
                        const i = (e = u.getParameter(u.VERSION)) === null || e === void 0 ? void 0 : e.startsWith("WebGL 2.0");
                        return no.set(u, i),
                        i
                    }
                }
                class so {
                    get awaitingQuery() {
                        return !!this._readbackQueue
                    }
                    constructor(e) {
                        this._readbackWaitFrames = 4,
                        this._measureWaitFrames = 6,
                        this._texWidth = 1,
                        this._texHeight = 1,
                        this._measuredError = 0,
                        this._updateCount = 0,
                        this._lastReadbackFrame = -1e3,
                        this._readbackQueue = null,
                        this._cachedRenderContext = e;
                        const i = e.context
                          , o = i.gl;
                        this._texFormat = o.RGBA,
                        this._texType = o.UNSIGNED_BYTE;
                        const a = new l.aE;
                        a.emplaceBack(-1, -1),
                        a.emplaceBack(2, -1),
                        a.emplaceBack(-1, 2);
                        const h = new l.aG;
                        h.emplaceBack(0, 1, 2),
                        this._fullscreenTriangle = new lr(i.createVertexBuffer(a, Mr.members),i.createIndexBuffer(h),l.aF.simpleSegment(0, 0, a.length, h.length)),
                        this._resultBuffer = new Uint8Array(4),
                        i.activeTexture.set(o.TEXTURE1);
                        const m = o.createTexture();
                        o.bindTexture(o.TEXTURE_2D, m),
                        o.texParameteri(o.TEXTURE_2D, o.TEXTURE_WRAP_S, o.CLAMP_TO_EDGE),
                        o.texParameteri(o.TEXTURE_2D, o.TEXTURE_WRAP_T, o.CLAMP_TO_EDGE),
                        o.texParameteri(o.TEXTURE_2D, o.TEXTURE_MIN_FILTER, o.NEAREST),
                        o.texParameteri(o.TEXTURE_2D, o.TEXTURE_MAG_FILTER, o.NEAREST),
                        o.texImage2D(o.TEXTURE_2D, 0, this._texFormat, this._texWidth, this._texHeight, 0, this._texFormat, this._texType, null),
                        this._fbo = i.createFramebuffer(this._texWidth, this._texHeight, !1, !1),
                        this._fbo.colorAttachment.set(m),
                        Ir(o) && (this._pbo = o.createBuffer(),
                        o.bindBuffer(o.PIXEL_PACK_BUFFER, this._pbo),
                        o.bufferData(o.PIXEL_PACK_BUFFER, 4, o.STREAM_READ),
                        o.bindBuffer(o.PIXEL_PACK_BUFFER, null))
                    }
                    destroy() {
                        const e = this._cachedRenderContext.context.gl;
                        this._fullscreenTriangle.destroy(),
                        this._fbo.destroy(),
                        e.deleteBuffer(this._pbo),
                        this._fullscreenTriangle = null,
                        this._fbo = null,
                        this._pbo = null,
                        this._resultBuffer = null
                    }
                    updateErrorLoop(e, i) {
                        const o = this._updateCount;
                        return this._readbackQueue ? o >= this._readbackQueue.frameNumberIssued + this._readbackWaitFrames && this._tryReadback() : o >= this._lastReadbackFrame + this._measureWaitFrames && this._renderErrorTexture(e, i),
                        this._updateCount++,
                        this._measuredError
                    }
                    _bindFramebuffer() {
                        const e = this._cachedRenderContext.context
                          , i = e.gl;
                        e.activeTexture.set(i.TEXTURE1),
                        i.bindTexture(i.TEXTURE_2D, this._fbo.colorAttachment.get()),
                        e.bindFramebuffer.set(this._fbo.framebuffer)
                    }
                    _renderErrorTexture(e, i) {
                        const o = this._cachedRenderContext.context
                          , a = o.gl;
                        if (this._bindFramebuffer(),
                        o.viewport.set([0, 0, this._texWidth, this._texHeight]),
                        o.clear({
                            color: l.b6.transparent
                        }),
                        this._cachedRenderContext.useProgram("projectionErrorMeasurement").draw(o, a.TRIANGLES, ot.disabled, mt.disabled, Vt.unblended, pt.disabled, ( (h, m) => ({
                            u_input: h,
                            u_output_expected: m
                        }))(e, i), null, null, "$clipping", this._fullscreenTriangle.vertexBuffer, this._fullscreenTriangle.indexBuffer, this._fullscreenTriangle.segments),
                        this._pbo && Ir(a)) {
                            a.bindBuffer(a.PIXEL_PACK_BUFFER, this._pbo),
                            a.readBuffer(a.COLOR_ATTACHMENT0),
                            a.readPixels(0, 0, this._texWidth, this._texHeight, this._texFormat, this._texType, 0),
                            a.bindBuffer(a.PIXEL_PACK_BUFFER, null);
                            const h = a.fenceSync(a.SYNC_GPU_COMMANDS_COMPLETE, 0);
                            a.flush(),
                            this._readbackQueue = {
                                frameNumberIssued: this._updateCount,
                                sync: h
                            }
                        } else
                            this._readbackQueue = {
                                frameNumberIssued: this._updateCount,
                                sync: null
                            }
                    }
                    _tryReadback() {
                        const e = this._cachedRenderContext.context.gl;
                        if (this._pbo && this._readbackQueue && Ir(e)) {
                            const i = e.clientWaitSync(this._readbackQueue.sync, 0, 0);
                            if (i === e.WAIT_FAILED)
                                return l.w("WebGL2 clientWaitSync failed."),
                                this._readbackQueue = null,
                                void (this._lastReadbackFrame = this._updateCount);
                            if (i === e.TIMEOUT_EXPIRED)
                                return;
                            e.bindBuffer(e.PIXEL_PACK_BUFFER, this._pbo),
                            e.getBufferSubData(e.PIXEL_PACK_BUFFER, 0, this._resultBuffer, 0, 4),
                            e.bindBuffer(e.PIXEL_PACK_BUFFER, null)
                        } else
                            this._bindFramebuffer(),
                            e.readPixels(0, 0, this._texWidth, this._texHeight, this._texFormat, this._texType, this._resultBuffer);
                        this._readbackQueue = null,
                        this._measuredError = so._parseRGBA8float(this._resultBuffer),
                        this._lastReadbackFrame = this._updateCount
                    }
                    static _parseRGBA8float(e) {
                        let i = 0;
                        return i += e[0] / 256,
                        i += e[1] / 65536,
                        i += e[2] / 16777216,
                        e[3] < 127 && (i = -i),
                        i / 128
                    }
                }
                const Fo = l.Z / 128;
                function oo(u, e) {
                    const i = u.granularity !== void 0 ? Math.max(u.granularity, 1) : 1
                      , o = i + (u.generateBorders ? 2 : 0)
                      , a = i + (u.extendToNorthPole || u.generateBorders ? 1 : 0) + (u.extendToSouthPole || u.generateBorders ? 1 : 0)
                      , h = o + 1
                      , m = a + 1
                      , y = u.generateBorders ? -1 : 0
                      , v = u.generateBorders || u.extendToNorthPole ? -1 : 0
                      , T = i + (u.generateBorders ? 1 : 0)
                      , S = i + (u.generateBorders || u.extendToSouthPole ? 1 : 0)
                      , A = h * m
                      , k = o * a * 6
                      , O = h * m > 65536;
                    if (O && e === "16bit")
                        throw new Error("Granularity is too large and meshes would not fit inside 16 bit vertex indices.");
                    const V = O || e === "32bit"
                      , H = new Int16Array(2 * A);
                    let q = 0;
                    for (let te = v; te <= S; te++)
                        for (let ie = y; ie <= T; ie++) {
                            let ne = ie / i * l.Z;
                            ie === -1 && (ne = -64),
                            ie === i + 1 && (ne = l.Z + Fo);
                            let le = te / i * l.Z;
                            te === -1 && (le = u.extendToNorthPole ? l.b8 : -64),
                            te === i + 1 && (le = u.extendToSouthPole ? l.b9 : l.Z + Fo),
                            H[q++] = ne,
                            H[q++] = le
                        }
                    const W = V ? new Uint32Array(k) : new Uint16Array(k);
                    let J = 0;
                    for (let te = 0; te < a; te++)
                        for (let ie = 0; ie < o; ie++) {
                            const ne = ie + 1 + te * h
                              , le = ie + (te + 1) * h
                              , se = ie + 1 + (te + 1) * h;
                            W[J++] = ie + te * h,
                            W[J++] = le,
                            W[J++] = ne,
                            W[J++] = ne,
                            W[J++] = le,
                            W[J++] = se
                        }
                    return {
                        vertices: H.buffer.slice(0),
                        indices: W.buffer.slice(0),
                        uses32bitIndices: V
                    }
                }
                const As = new l.aD({
                    fill: new l.ba(128,2),
                    line: new l.ba(512,0),
                    tile: new l.ba(128,32),
                    stencil: new l.ba(128,1),
                    circle: 3
                });
                class zs {
                    constructor() {
                        this._tileMeshCache = {},
                        this._errorCorrectionUsable = 0,
                        this._errorMeasurementLastValue = 0,
                        this._errorCorrectionPreviousValue = 0,
                        this._errorMeasurementLastChangeTime = -1e3
                    }
                    get name() {
                        return "vertical-perspective"
                    }
                    get transitionState() {
                        return 1
                    }
                    get useSubdivision() {
                        return !0
                    }
                    get shaderVariantName() {
                        return "globe"
                    }
                    get shaderDefine() {
                        return "#define GLOBE"
                    }
                    get shaderPreludeCode() {
                        return jr.projectionGlobe
                    }
                    get vertexShaderPreludeCode() {
                        return jr.projectionMercator.vertexSource
                    }
                    get subdivisionGranularity() {
                        return As
                    }
                    get useGlobeControls() {
                        return !0
                    }
                    get latitudeErrorCorrectionRadians() {
                        return this._errorCorrectionUsable
                    }
                    destroy() {
                        this._errorMeasurement && this._errorMeasurement.destroy()
                    }
                    updateGPUdependent(e) {
                        this._errorMeasurement || (this._errorMeasurement = new so(e));
                        const i = l.S(this._errorQueryLatitudeDegrees)
                          , o = 2 * Math.atan(Math.exp(Math.PI - i * Math.PI * 2)) - .5 * Math.PI
                          , a = this._errorMeasurement.updateErrorLoop(i, o)
                          , h = oe.now();
                        a !== this._errorMeasurementLastValue && (this._errorCorrectionPreviousValue = this._errorCorrectionUsable,
                        this._errorMeasurementLastValue = a,
                        this._errorMeasurementLastChangeTime = h);
                        const m = Math.min(Math.max((h - this._errorMeasurementLastChangeTime) / 1e3 / .5, 0), 1);
                        this._errorCorrectionUsable = l.bb(this._errorCorrectionPreviousValue, -this._errorMeasurementLastValue, l.bc(m))
                    }
                    _getMeshKey(e) {
                        return `${e.granularity.toString(36)}_${e.generateBorders ? "b" : ""}${e.extendToNorthPole ? "n" : ""}${e.extendToSouthPole ? "s" : ""}`
                    }
                    getMeshFromTileID(e, i, o, a, h) {
                        const m = (h === "stencil" ? As.stencil : As.tile).getGranularityForZoomLevel(i.z);
                        return this._getMesh(e, {
                            granularity: m,
                            generateBorders: o,
                            extendToNorthPole: i.y === 0 && a,
                            extendToSouthPole: i.y === (1 << i.z) - 1 && a
                        })
                    }
                    _getMesh(e, i) {
                        const o = this._getMeshKey(i);
                        if (o in this._tileMeshCache)
                            return this._tileMeshCache[o];
                        const a = function(h, m) {
                            const y = oo(m, "16bit")
                              , v = l.aE.deserialize({
                                arrayBuffer: y.vertices,
                                length: y.vertices.byteLength / 2 / 2
                            })
                              , T = l.aG.deserialize({
                                arrayBuffer: y.indices,
                                length: y.indices.byteLength / 2 / 3
                            });
                            return new lr(h.createVertexBuffer(v, Mr.members),h.createIndexBuffer(T),l.aF.simpleSegment(0, 0, v.length, T.length))
                        }(e, i);
                        return this._tileMeshCache[o] = a,
                        a
                    }
                    recalculate(e) {}
                    hasTransition() {
                        const e = oe.now();
                        let i = !1;
                        return i = i || (e - this._errorMeasurementLastChangeTime) / 1e3 < .7,
                        i = i || this._errorMeasurement && this._errorMeasurement.awaitingQuery,
                        i
                    }
                    setErrorQueryLatitudeDegrees(e) {
                        this._errorQueryLatitudeDegrees = e
                    }
                }
                const Qu = new l.r({
                    type: new l.D(l.v.projection.type)
                });
                class Bo extends l.E {
                    constructor(e) {
                        super(),
                        this._transitionable = new l.T(Qu),
                        this.setProjection(e),
                        this._transitioning = this._transitionable.untransitioned(),
                        this.recalculate(new l.C(0)),
                        this._mercatorProjection = new Ka,
                        this._verticalPerspectiveProjection = new zs
                    }
                    get transitionState() {
                        const e = this.properties.get("type");
                        if (typeof e == "string" && e === "mercator")
                            return 0;
                        if (typeof e == "string" && e === "vertical-perspective")
                            return 1;
                        if (e instanceof l.bd) {
                            if (e.from === "vertical-perspective" && e.to === "mercator")
                                return 1 - e.transition;
                            if (e.from === "mercator" && e.to === "vertical-perspective")
                                return e.transition
                        }
                        return 1
                    }
                    get useGlobeRendering() {
                        return this.transitionState > 0
                    }
                    get latitudeErrorCorrectionRadians() {
                        return this._verticalPerspectiveProjection.latitudeErrorCorrectionRadians
                    }
                    get currentProjection() {
                        return this.useGlobeRendering ? this._verticalPerspectiveProjection : this._mercatorProjection
                    }
                    get name() {
                        return "globe"
                    }
                    get useSubdivision() {
                        return this.currentProjection.useSubdivision
                    }
                    get shaderVariantName() {
                        return this.currentProjection.shaderVariantName
                    }
                    get shaderDefine() {
                        return this.currentProjection.shaderDefine
                    }
                    get shaderPreludeCode() {
                        return this.currentProjection.shaderPreludeCode
                    }
                    get vertexShaderPreludeCode() {
                        return this.currentProjection.vertexShaderPreludeCode
                    }
                    get subdivisionGranularity() {
                        return this.currentProjection.subdivisionGranularity
                    }
                    get useGlobeControls() {
                        return this.transitionState > 0
                    }
                    destroy() {
                        this._mercatorProjection.destroy(),
                        this._verticalPerspectiveProjection.destroy()
                    }
                    updateGPUdependent(e) {
                        this._mercatorProjection.updateGPUdependent(e),
                        this._verticalPerspectiveProjection.updateGPUdependent(e)
                    }
                    getMeshFromTileID(e, i, o, a, h) {
                        return this.currentProjection.getMeshFromTileID(e, i, o, a, h)
                    }
                    setProjection(e) {
                        this._transitionable.setValue("type", e?.type || "mercator")
                    }
                    updateTransitions(e) {
                        this._transitioning = this._transitionable.transitioned(e, this._transitioning)
                    }
                    hasTransition() {
                        return this._transitioning.hasTransition() || this.currentProjection.hasTransition()
                    }
                    recalculate(e) {
                        this.properties = this._transitioning.possiblyEvaluate(e)
                    }
                    setErrorQueryLatitudeDegrees(e) {
                        this._verticalPerspectiveProjection.setErrorQueryLatitudeDegrees(e),
                        this._mercatorProjection.setErrorQueryLatitudeDegrees(e)
                    }
                }
                function Qa(u) {
                    const e = Zi(u.worldSize, u.center.lat);
                    return 2 * Math.PI * e
                }
                function ao(u, e, i, o, a) {
                    const h = 1 / (1 << a)
                      , m = e / l.Z * h + o * h
                      , y = l.bf((u / l.Z * h + i * h) * Math.PI * 2 + Math.PI, 2 * Math.PI)
                      , v = 2 * Math.atan(Math.exp(Math.PI - m * Math.PI * 2)) - .5 * Math.PI
                      , T = Math.cos(v)
                      , S = new Float64Array(3);
                    return S[0] = Math.sin(y) * T,
                    S[1] = Math.sin(v),
                    S[2] = Math.cos(y) * T,
                    S
                }
                function Ui(u) {
                    return function(e, i) {
                        const o = Math.cos(i)
                          , a = new Float64Array(3);
                        return a[0] = Math.sin(e) * o,
                        a[1] = Math.sin(i),
                        a[2] = Math.cos(e) * o,
                        a
                    }(u.lng * Math.PI / 180, u.lat * Math.PI / 180)
                }
                function Zi(u, e) {
                    return u / (2 * Math.PI) / Math.cos(e * Math.PI / 180)
                }
                function Oo(u) {
                    const e = Math.asin(u[1]) / Math.PI * 180
                      , i = Math.sqrt(u[0] * u[0] + u[2] * u[2]);
                    if (i > 1e-6) {
                        const o = u[0] / i
                          , a = Math.acos(u[2] / i)
                          , h = (o > 0 ? a : -a) / Math.PI * 180;
                        return new l.Q(l.aK(h, -180, 180),e)
                    }
                    return new l.Q(0,e)
                }
                function cr(u) {
                    return Math.cos(u * Math.PI / 180)
                }
                function ai(u, e) {
                    const i = cr(u)
                      , o = cr(e);
                    return l.aa(o / i)
                }
                function el(u, e) {
                    const i = u.rotate(e.bearingInRadians)
                      , o = e.zoom + ai(e.center.lat, 0)
                      , a = l.bb(1 / cr(e.center.lat), 1 / cr(Math.min(Math.abs(e.center.lat), 60)), l.be(o, 7, 3, 0, 1))
                      , h = 360 / Qa({
                        worldSize: e.worldSize,
                        center: {
                            lat: e.center.lat
                        }
                    });
                    return new l.Q(e.center.lng - i.x * h * a,l.ad(e.center.lat + i.y * h, -85.051129, l.aI))
                }
                function No(u) {
                    const e = .5 * u
                      , i = Math.sin(e)
                      , o = Math.cos(e);
                    return Math.log(i + o) - Math.log(o - i)
                }
                function ts(u, e, i, o) {
                    const a = u.lat + i * o;
                    if (Math.abs(i) > 1) {
                        const h = (Math.sign(u.lat + i) !== Math.sign(u.lat) ? -Math.abs(u.lat) : Math.abs(u.lat)) * Math.PI / 180
                          , m = Math.abs(u.lat + i) * Math.PI / 180
                          , y = No(h + o * (m - h))
                          , v = No(h)
                          , T = No(m);
                        return new l.Q(u.lng + e * ((y - v) / (T - v)),a)
                    }
                    return new l.Q(u.lng + e * o,a)
                }
                class eh {
                    constructor(e) {
                        this._cachePrevious = new Map,
                        this._cache = new Map,
                        this._hadAnyChanges = !1,
                        this._aabbFactory = e
                    }
                    recalculateCache() {
                        if (!this._hadAnyChanges)
                            return;
                        const e = this._cachePrevious;
                        this._cachePrevious = this._cache,
                        this._cache = e,
                        this._cache.clear(),
                        this._hadAnyChanges = !1
                    }
                    getTileAABB(e, i, o, a) {
                        const h = `${e.z}_${e.x}_${e.y}`
                          , m = this._cache.get(h);
                        if (m)
                            return m;
                        const y = this._cachePrevious.get(h);
                        if (y)
                            return this._cache.set(h, y),
                            y;
                        const v = this._aabbFactory(e, i, o, a);
                        return this._cache.set(h, v),
                        this._hadAnyChanges = !0,
                        v
                    }
                }
                function jo(u, e, i) {
                    const o = u - e;
                    return o < 0 ? -o : Math.max(0, o - i)
                }
                function tl(u, e, i, o, a) {
                    const h = u - i;
                    let m;
                    return m = h < 0 ? Math.min(-h, 1 + h - a) : h > 1 ? Math.min(Math.max(h - a, 0), 1 - h) : 0,
                    Math.max(m, jo(e, o, a))
                }
                class th {
                    constructor() {
                        this._aabbCache = new eh(this._computeTileAABB)
                    }
                    recalculateCache() {
                        this._aabbCache.recalculateCache()
                    }
                    distanceToTile2d(e, i, o, a) {
                        const h = 1 << o.z
                          , m = 1 / h
                          , y = o.x / h
                          , v = o.y / h;
                        let T = 2;
                        return T = Math.min(T, tl(e, i, y, v, m)),
                        T = Math.min(T, tl(e, i, y + .5, -v - m, m)),
                        T = Math.min(T, tl(e, i, y + .5, 2 - v - m, m)),
                        T
                    }
                    getWrap(e, i, o) {
                        const a = 1 << i.z
                          , h = 1 / a
                          , m = i.x / a
                          , y = jo(e.x, m, h)
                          , v = jo(e.x, m - 1, h)
                          , T = jo(e.x, m + 1, h)
                          , S = Math.min(y, v, T);
                        return S === T ? 1 : S === v ? -1 : 0
                    }
                    allowVariableZoom(e, i) {
                        return _n(e, i) > 4
                    }
                    allowWorldCopies() {
                        return !1
                    }
                    getTileAABB(e, i, o, a) {
                        return this._aabbCache.getTileAABB(e, i, o, a)
                    }
                    _computeTileAABB(e, i, o, a) {
                        if (e.z <= 0)
                            return new Vr([-1, -1, -1],[1, 1, 1]);
                        if (e.z === 1)
                            return new Vr([e.x === 0 ? -1 : 0, e.y === 0 ? 0 : -1, -1],[e.x === 0 ? 0 : 1, e.y === 0 ? 1 : 0, 1]);
                        {
                            const h = [ao(0, 0, e.x, e.y, e.z), ao(l.Z, 0, e.x, e.y, e.z), ao(l.Z, l.Z, e.x, e.y, e.z), ao(0, l.Z, e.x, e.y, e.z)]
                              , m = [1, 1, 1]
                              , y = [-1, -1, -1];
                            for (const v of h)
                                for (let T = 0; T < 3; T++)
                                    m[T] = Math.min(m[T], v[T]),
                                    y[T] = Math.max(y[T], v[T]);
                            if (e.y === 0 || e.y === (1 << e.z) - 1) {
                                const v = [0, e.y === 0 ? 1 : -1, 0];
                                for (let T = 0; T < 3; T++)
                                    m[T] = Math.min(m[T], v[T]),
                                    y[T] = Math.max(y[T], v[T])
                            }
                            return new Vr(m,y)
                        }
                    }
                }
                class Vo {
                    get pixelsToClipSpaceMatrix() {
                        return this._helper.pixelsToClipSpaceMatrix
                    }
                    get clipSpaceToPixelsMatrix() {
                        return this._helper.clipSpaceToPixelsMatrix
                    }
                    get pixelsToGLUnits() {
                        return this._helper.pixelsToGLUnits
                    }
                    get centerOffset() {
                        return this._helper.centerOffset
                    }
                    get size() {
                        return this._helper.size
                    }
                    get rotationMatrix() {
                        return this._helper.rotationMatrix
                    }
                    get centerPoint() {
                        return this._helper.centerPoint
                    }
                    get pixelsPerMeter() {
                        return this._helper.pixelsPerMeter
                    }
                    setMinZoom(e) {
                        this._helper.setMinZoom(e)
                    }
                    setMaxZoom(e) {
                        this._helper.setMaxZoom(e)
                    }
                    setMinPitch(e) {
                        this._helper.setMinPitch(e)
                    }
                    setMaxPitch(e) {
                        this._helper.setMaxPitch(e)
                    }
                    setRenderWorldCopies(e) {
                        this._helper.setRenderWorldCopies(e)
                    }
                    setBearing(e) {
                        this._helper.setBearing(e)
                    }
                    setPitch(e) {
                        this._helper.setPitch(e)
                    }
                    setRoll(e) {
                        this._helper.setRoll(e)
                    }
                    setFov(e) {
                        this._helper.setFov(e)
                    }
                    setZoom(e) {
                        this._helper.setZoom(e)
                    }
                    setCenter(e) {
                        this._helper.setCenter(e)
                    }
                    setElevation(e) {
                        this._helper.setElevation(e)
                    }
                    setMinElevationForCurrentTile(e) {
                        this._helper.setMinElevationForCurrentTile(e)
                    }
                    setPadding(e) {
                        this._helper.setPadding(e)
                    }
                    interpolatePadding(e, i, o) {
                        return this._helper.interpolatePadding(e, i, o)
                    }
                    isPaddingEqual(e) {
                        return this._helper.isPaddingEqual(e)
                    }
                    resize(e, i) {
                        this._helper.resize(e, i)
                    }
                    getMaxBounds() {
                        return this._helper.getMaxBounds()
                    }
                    setMaxBounds(e) {
                        this._helper.setMaxBounds(e)
                    }
                    overrideNearFarZ(e, i) {
                        this._helper.overrideNearFarZ(e, i)
                    }
                    clearNearFarZOverride() {
                        this._helper.clearNearFarZOverride()
                    }
                    getCameraQueryGeometry(e) {
                        return this._helper.getCameraQueryGeometry(this.getCameraPoint(), e)
                    }
                    get tileSize() {
                        return this._helper.tileSize
                    }
                    get tileZoom() {
                        return this._helper.tileZoom
                    }
                    get scale() {
                        return this._helper.scale
                    }
                    get worldSize() {
                        return this._helper.worldSize
                    }
                    get width() {
                        return this._helper.width
                    }
                    get height() {
                        return this._helper.height
                    }
                    get lngRange() {
                        return this._helper.lngRange
                    }
                    get latRange() {
                        return this._helper.latRange
                    }
                    get minZoom() {
                        return this._helper.minZoom
                    }
                    get maxZoom() {
                        return this._helper.maxZoom
                    }
                    get zoom() {
                        return this._helper.zoom
                    }
                    get center() {
                        return this._helper.center
                    }
                    get minPitch() {
                        return this._helper.minPitch
                    }
                    get maxPitch() {
                        return this._helper.maxPitch
                    }
                    get pitch() {
                        return this._helper.pitch
                    }
                    get pitchInRadians() {
                        return this._helper.pitchInRadians
                    }
                    get roll() {
                        return this._helper.roll
                    }
                    get rollInRadians() {
                        return this._helper.rollInRadians
                    }
                    get bearing() {
                        return this._helper.bearing
                    }
                    get bearingInRadians() {
                        return this._helper.bearingInRadians
                    }
                    get fov() {
                        return this._helper.fov
                    }
                    get fovInRadians() {
                        return this._helper.fovInRadians
                    }
                    get elevation() {
                        return this._helper.elevation
                    }
                    get minElevationForCurrentTile() {
                        return this._helper.minElevationForCurrentTile
                    }
                    get padding() {
                        return this._helper.padding
                    }
                    get unmodified() {
                        return this._helper.unmodified
                    }
                    get renderWorldCopies() {
                        return this._helper.renderWorldCopies
                    }
                    get nearZ() {
                        return this._helper.nearZ
                    }
                    get farZ() {
                        return this._helper.farZ
                    }
                    get autoCalculateNearFarZ() {
                        return this._helper.autoCalculateNearFarZ
                    }
                    setTransitionState(e) {}
                    constructor() {
                        this._cachedClippingPlane = l.bg(),
                        this._projectionMatrix = l.b0(),
                        this._globeViewProjMatrix32f = l.a$(),
                        this._globeViewProjMatrixNoCorrection = l.b0(),
                        this._globeViewProjMatrixNoCorrectionInverted = l.b0(),
                        this._globeProjMatrixInverted = l.b0(),
                        this._cameraPosition = l.bh(),
                        this._globeLatitudeErrorCorrectionRadians = 0,
                        this._helper = new Do({
                            calcMatrices: () => {
                                this._calcMatrices()
                            }
                            ,
                            getConstrained: (e, i) => this.getConstrained(e, i)
                        }),
                        this._coveringTilesDetailsProvider = new th
                    }
                    clone() {
                        const e = new Vo;
                        return e.apply(this),
                        e
                    }
                    apply(e, i) {
                        this._globeLatitudeErrorCorrectionRadians = i || 0,
                        this._helper.apply(e)
                    }
                    get projectionMatrix() {
                        return this._projectionMatrix
                    }
                    get modelViewProjectionMatrix() {
                        return this._globeViewProjMatrixNoCorrection
                    }
                    get inverseProjectionMatrix() {
                        return this._globeProjMatrixInverted
                    }
                    get cameraPosition() {
                        const e = l.bh();
                        return e[0] = this._cameraPosition[0],
                        e[1] = this._cameraPosition[1],
                        e[2] = this._cameraPosition[2],
                        e
                    }
                    get cameraToCenterDistance() {
                        return this._helper.cameraToCenterDistance
                    }
                    getProjectionData(e) {
                        const {overscaledTileID: i, applyGlobeMatrix: o} = e
                          , a = this._helper.getMercatorTileCoordinates(i);
                        return {
                            mainMatrix: this._globeViewProjMatrix32f,
                            tileMercatorCoords: a,
                            clippingPlane: this._cachedClippingPlane,
                            projectionTransition: o ? 1 : 0,
                            fallbackMatrix: this._globeViewProjMatrix32f
                        }
                    }
                    _computeClippingPlane(e) {
                        const i = this.pitchInRadians
                          , o = this.cameraToCenterDistance / e
                          , a = Math.sin(i) * o
                          , h = Math.cos(i) * o + 1
                          , m = 1 / Math.sqrt(a * a + h * h) * 1;
                        let y = -a
                          , v = h;
                        const T = Math.sqrt(y * y + v * v);
                        y /= T,
                        v /= T;
                        const S = [0, y, v];
                        return l.bi(S, S, [0, 0, 0], -this.bearingInRadians),
                        l.bj(S, S, [0, 0, 0], -1 * this.center.lat * Math.PI / 180),
                        l.bk(S, S, [0, 0, 0], this.center.lng * Math.PI / 180),
                        l.aN(S, S, .25),
                        [...S, .25 * -m]
                    }
                    isLocationOccluded(e) {
                        return !this.isSurfacePointVisible(Ui(e))
                    }
                    transformLightDirection(e) {
                        const i = this._helper._center.lng * Math.PI / 180
                          , o = this._helper._center.lat * Math.PI / 180
                          , a = Math.cos(o)
                          , h = [Math.sin(i) * a, Math.sin(o), Math.cos(i) * a]
                          , m = [h[2], 0, -h[0]]
                          , y = [0, 0, 0];
                        l.aT(y, m, h),
                        l.aS(m, m),
                        l.aS(y, y);
                        const v = [0, 0, 0];
                        return l.aS(v, [m[0] * e[0] + y[0] * e[1] + h[0] * e[2], m[1] * e[0] + y[1] * e[1] + h[1] * e[2], m[2] * e[0] + y[2] * e[1] + h[2] * e[2]]),
                        v
                    }
                    getPixelScale() {
                        return 1 / Math.cos(this._helper._center.lat * Math.PI / 180)
                    }
                    getCircleRadiusCorrection() {
                        return Math.cos(this._helper._center.lat * Math.PI / 180)
                    }
                    getPitchedTextCorrection(e, i, o) {
                        const a = function(y, v, T) {
                            const S = 1 / (1 << T.z);
                            return new l.$(y / l.Z * S + T.x * S,v / l.Z * S + T.y * S)
                        }(e, i, o.canonical)
                          , h = (m = a.y,
                        [l.bf(a.x * Math.PI * 2 + Math.PI, 2 * Math.PI), 2 * Math.atan(Math.exp(Math.PI - m * Math.PI * 2)) - .5 * Math.PI]);
                        var m;
                        return this.getCircleRadiusCorrection() / Math.cos(h[1])
                    }
                    projectTileCoordinates(e, i, o, a) {
                        const h = o.canonical
                          , m = ao(e, i, h.x, h.y, h.z)
                          , y = 1 + (a ? a(e, i) : 0) / l.bq
                          , v = [m[0] * y, m[1] * y, m[2] * y, 1];
                        l.ao(v, v, this._globeViewProjMatrixNoCorrection);
                        const T = this._cachedClippingPlane
                          , S = T[0] * m[0] + T[1] * m[1] + T[2] * m[2] + T[3] < 0;
                        return {
                            point: new l.P(v[0] / v[3],v[1] / v[3]),
                            signedDistanceFromCamera: v[3],
                            isOccluded: S
                        }
                    }
                    _calcMatrices() {
                        if (!this._helper._width || !this._helper._height)
                            return;
                        const e = Zi(this.worldSize, this.center.lat)
                          , i = l.b1()
                          , o = l.b1();
                        this._helper.autoCalculateNearFarZ && (this._helper._nearZ = .5,
                        this._helper._farZ = this.cameraToCenterDistance + 2 * e),
                        l.aX(i, this.fovInRadians, this.width / this.height, this._helper._nearZ, this._helper._farZ);
                        const a = this.centerOffset;
                        i[8] = 2 * -a.x / this._helper._width,
                        i[9] = 2 * a.y / this._helper._height,
                        this._projectionMatrix = l.aY(i),
                        this._globeProjMatrixInverted = l.b1(),
                        l.ai(this._globeProjMatrixInverted, i),
                        l.L(i, i, [0, 0, -this.cameraToCenterDistance]),
                        l.aZ(i, i, this.rollInRadians),
                        l.a_(i, i, -this.pitchInRadians),
                        l.aZ(i, i, this.bearingInRadians),
                        l.L(i, i, [0, 0, -e]);
                        const h = l.bh();
                        h[0] = e,
                        h[1] = e,
                        h[2] = e,
                        l.a_(o, i, this.center.lat * Math.PI / 180),
                        l.bl(o, o, -this.center.lng * Math.PI / 180),
                        l.M(o, o, h),
                        this._globeViewProjMatrixNoCorrection = o,
                        l.a_(i, i, this.center.lat * Math.PI / 180 - this._globeLatitudeErrorCorrectionRadians),
                        l.bl(i, i, -this.center.lng * Math.PI / 180),
                        l.M(i, i, h),
                        this._globeViewProjMatrix32f = new Float32Array(i),
                        this._globeViewProjMatrixNoCorrectionInverted = l.b1(),
                        l.ai(this._globeViewProjMatrixNoCorrectionInverted, o);
                        const m = l.bh();
                        this._cameraPosition = l.bh(),
                        this._cameraPosition[2] = this.cameraToCenterDistance / e,
                        l.bi(this._cameraPosition, this._cameraPosition, m, -this.rollInRadians),
                        l.bj(this._cameraPosition, this._cameraPosition, m, this.pitchInRadians),
                        l.bi(this._cameraPosition, this._cameraPosition, m, -this.bearingInRadians),
                        l.aO(this._cameraPosition, this._cameraPosition, [0, 0, 1]),
                        l.bj(this._cameraPosition, this._cameraPosition, m, -this.center.lat * Math.PI / 180),
                        l.bk(this._cameraPosition, this._cameraPosition, m, this.center.lng * Math.PI / 180),
                        this._cachedClippingPlane = this._computeClippingPlane(e);
                        const y = l.aY(this._globeViewProjMatrixNoCorrectionInverted);
                        l.M(y, y, [1, 1, -1]),
                        this._cachedFrustum = Fn.fromInvProjectionMatrix(y)
                    }
                    calculateFogMatrix(e) {
                        l.w("calculateFogMatrix is not supported on globe projection.");
                        const i = l.b1();
                        return l.as(i),
                        i
                    }
                    getVisibleUnwrappedCoordinates(e) {
                        return [new l.aV(0,e)]
                    }
                    getCameraFrustum() {
                        return this._cachedFrustum
                    }
                    getClippingPlane() {
                        return this._cachedClippingPlane
                    }
                    getCoveringTilesDetailsProvider() {
                        return this._coveringTilesDetailsProvider
                    }
                    recalculateZoomAndCenter(e) {
                        e && l.w("terrain is not fully supported on vertical perspective projection."),
                        this._helper.recalculateZoomAndCenter(0)
                    }
                    maxPitchScaleFactor() {
                        return 1
                    }
                    getCameraPoint() {
                        return this._helper.getCameraPoint()
                    }
                    getCameraAltitude() {
                        return this._helper.getCameraAltitude()
                    }
                    getCameraLngLat() {
                        return this._helper.getCameraLngLat()
                    }
                    lngLatToCameraDepth(e, i) {
                        if (!this._globeViewProjMatrixNoCorrection)
                            return 1;
                        const o = Ui(e);
                        l.aN(o, o, 1 + i / l.bq);
                        const a = l.bg();
                        return l.ao(a, [o[0], o[1], o[2], 1], this._globeViewProjMatrixNoCorrection),
                        a[2] / a[3]
                    }
                    populateCache(e) {}
                    getBounds() {
                        const e = .5 * this.width
                          , i = .5 * this.height
                          , o = [new l.P(0,0), new l.P(e,0), new l.P(this.width,0), new l.P(this.width,i), new l.P(this.width,this.height), new l.P(e,this.height), new l.P(0,this.height), new l.P(0,i)]
                          , a = [];
                        for (const A of o)
                            a.push(this.unprojectScreenPoint(A));
                        let h = 0
                          , m = 0
                          , y = 0
                          , v = 0;
                        const T = this.center;
                        for (const A of a) {
                            const k = l.bm(T.lng, A.lng)
                              , O = l.bm(T.lat, A.lat);
                            k < m && (m = k),
                            k > h && (h = k),
                            O < v && (v = O),
                            O > y && (y = O)
                        }
                        const S = [T.lng + m, T.lat + v, T.lng + h, T.lat + y];
                        return this.isSurfacePointOnScreen([0, 1, 0]) && (S[3] = 90,
                        S[0] = -180,
                        S[2] = 180),
                        this.isSurfacePointOnScreen([0, -1, 0]) && (S[1] = -90,
                        S[0] = -180,
                        S[2] = 180),
                        new oi(S)
                    }
                    getConstrained(e, i) {
                        const o = l.ad(e.lat, -85.051129, l.aI)
                          , a = l.ad(+i, this.minZoom + ai(0, o), this.maxZoom);
                        return {
                            center: new l.Q(e.lng,o),
                            zoom: a
                        }
                    }
                    calculateCenterFromCameraLngLatAlt(e, i, o, a) {
                        return this._helper.calculateCenterFromCameraLngLatAlt(e, i, o, a)
                    }
                    setLocationAtPoint(e, i) {
                        const o = Ui(this.unprojectScreenPoint(i))
                          , a = Ui(e)
                          , h = l.bh();
                        l.bn(h);
                        const m = l.bh();
                        l.bk(m, o, h, -this.center.lng * Math.PI / 180),
                        l.bj(m, m, h, this.center.lat * Math.PI / 180);
                        const y = a[0] * a[0] + a[2] * a[2]
                          , v = m[0] * m[0];
                        if (y < v)
                            return;
                        const T = Math.sqrt(y - v)
                          , S = -T
                          , A = l.bo(a[0], a[2], m[0], T)
                          , k = l.bo(a[0], a[2], m[0], S)
                          , O = l.bh();
                        l.bk(O, a, h, -A);
                        const V = l.bo(O[1], O[2], m[1], m[2])
                          , H = l.bh();
                        l.bk(H, a, h, -k);
                        const q = l.bo(H[1], H[2], m[1], m[2])
                          , W = .5 * Math.PI
                          , J = V >= -W && V <= W
                          , te = q >= -W && q <= W;
                        let ie, ne;
                        if (J && te) {
                            const xe = this.center.lng * Math.PI / 180
                              , Pe = this.center.lat * Math.PI / 180;
                            l.br(A, xe) + l.br(V, Pe) < l.br(k, xe) + l.br(q, Pe) ? (ie = A,
                            ne = V) : (ie = k,
                            ne = q)
                        } else if (J)
                            ie = A,
                            ne = V;
                        else {
                            if (!te)
                                return;
                            ie = k,
                            ne = q
                        }
                        const le = ie / Math.PI * 180
                          , se = ne / Math.PI * 180
                          , _e = this.center.lat;
                        this.setCenter(new l.Q(le,l.ad(se, -90, 90))),
                        this.setZoom(this.zoom + ai(_e, this.center.lat))
                    }
                    locationToScreenPoint(e, i) {
                        const o = Ui(e);
                        if (i) {
                            const a = i.getElevationForLngLatZoom(e, this._helper._tileZoom);
                            l.aN(o, o, 1 + a / l.bq)
                        }
                        return this._projectSurfacePointToScreen(o)
                    }
                    _projectSurfacePointToScreen(e) {
                        const i = l.bg();
                        return l.ao(i, [...e, 1], this._globeViewProjMatrixNoCorrection),
                        i[0] /= i[3],
                        i[1] /= i[3],
                        new l.P((.5 * i[0] + .5) * this.width,(.5 * -i[1] + .5) * this.height)
                    }
                    screenPointToMercatorCoordinate(e, i) {
                        if (i) {
                            const o = i.pointCoordinate(e);
                            if (o)
                                return o
                        }
                        return l.$.fromLngLat(this.unprojectScreenPoint(e))
                    }
                    screenPointToLocation(e, i) {
                        var o;
                        return (o = this.screenPointToMercatorCoordinate(e, i)) === null || o === void 0 ? void 0 : o.toLngLat()
                    }
                    isPointOnMapSurface(e, i) {
                        const o = this._cameraPosition
                          , a = this.getRayDirectionFromPixel(e);
                        return !!this.rayPlanetIntersection(o, a)
                    }
                    getRayDirectionFromPixel(e) {
                        const i = l.bg();
                        i[0] = e.x / this.width * 2 - 1,
                        i[1] = -1 * (e.y / this.height * 2 - 1),
                        i[2] = 1,
                        i[3] = 1,
                        l.ao(i, i, this._globeViewProjMatrixNoCorrectionInverted),
                        i[0] /= i[3],
                        i[1] /= i[3],
                        i[2] /= i[3];
                        const o = l.bh();
                        o[0] = i[0] - this._cameraPosition[0],
                        o[1] = i[1] - this._cameraPosition[1],
                        o[2] = i[2] - this._cameraPosition[2];
                        const a = l.bh();
                        return l.aS(a, o),
                        a
                    }
                    isSurfacePointVisible(e) {
                        const i = this._cachedClippingPlane;
                        return i[0] * e[0] + i[1] * e[1] + i[2] * e[2] + i[3] >= 0
                    }
                    isSurfacePointOnScreen(e) {
                        if (!this.isSurfacePointVisible(e))
                            return !1;
                        const i = l.bg();
                        return l.ao(i, [...e, 1], this._globeViewProjMatrixNoCorrection),
                        i[0] /= i[3],
                        i[1] /= i[3],
                        i[2] /= i[3],
                        i[0] > -1 && i[0] < 1 && i[1] > -1 && i[1] < 1 && i[2] > -1 && i[2] < 1
                    }
                    rayPlanetIntersection(e, i) {
                        const o = l.aU(e, i)
                          , a = l.bh()
                          , h = l.bh();
                        l.aN(h, i, o),
                        l.aR(a, e, h);
                        const m = 1 - l.aU(a, a);
                        if (m < 0)
                            return null;
                        const y = l.aU(e, e) - 1
                          , v = -o + (o < 0 ? 1 : -1) * Math.sqrt(m)
                          , T = y / v
                          , S = v;
                        return {
                            tMin: Math.min(T, S),
                            tMax: Math.max(T, S)
                        }
                    }
                    unprojectScreenPoint(e) {
                        const i = this._cameraPosition
                          , o = this.getRayDirectionFromPixel(e)
                          , a = this.rayPlanetIntersection(i, o);
                        if (a) {
                            const T = l.bh();
                            l.aO(T, i, [o[0] * a.tMin, o[1] * a.tMin, o[2] * a.tMin]);
                            const S = l.bh();
                            return l.aS(S, T),
                            Oo(S)
                        }
                        const h = this._cachedClippingPlane[0] * o[0] + this._cachedClippingPlane[1] * o[1] + this._cachedClippingPlane[2] * o[2]
                          , m = -l.bp(this._cachedClippingPlane, i) / h
                          , y = l.bh();
                        if (m > 0)
                            l.aO(y, i, [o[0] * m, o[1] * m, o[2] * m]);
                        else {
                            const T = l.bh();
                            l.aO(T, i, [2 * o[0], 2 * o[1], 2 * o[2]]);
                            const S = l.bp(this._cachedClippingPlane, T);
                            l.aR(y, T, [this._cachedClippingPlane[0] * S, this._cachedClippingPlane[1] * S, this._cachedClippingPlane[2] * S])
                        }
                        const v = l.bh();
                        return l.aS(v, y),
                        Oo(v)
                    }
                    getMatrixForModel(e, i) {
                        const o = l.Q.convert(e)
                          , a = 1 / l.bq
                          , h = l.b0();
                        return l.bl(h, h, o.lng / 180 * Math.PI),
                        l.a_(h, h, -o.lat / 180 * Math.PI),
                        l.L(h, h, [0, 0, 1 + i / l.bq]),
                        l.a_(h, h, .5 * Math.PI),
                        l.M(h, h, [a, a, a]),
                        h
                    }
                    getProjectionDataForCustomLayer(e=!0) {
                        const i = this.getProjectionData({
                            overscaledTileID: new l.Y(0,0,0,0,0),
                            applyGlobeMatrix: e
                        });
                        return i.tileMercatorCoords = [0, 0, 1, 1],
                        i
                    }
                    getFastPathSimpleProjectionMatrix(e) {}
                }
                class Uo {
                    get pixelsToClipSpaceMatrix() {
                        return this._helper.pixelsToClipSpaceMatrix
                    }
                    get clipSpaceToPixelsMatrix() {
                        return this._helper.clipSpaceToPixelsMatrix
                    }
                    get pixelsToGLUnits() {
                        return this._helper.pixelsToGLUnits
                    }
                    get centerOffset() {
                        return this._helper.centerOffset
                    }
                    get size() {
                        return this._helper.size
                    }
                    get rotationMatrix() {
                        return this._helper.rotationMatrix
                    }
                    get centerPoint() {
                        return this._helper.centerPoint
                    }
                    get pixelsPerMeter() {
                        return this._helper.pixelsPerMeter
                    }
                    setMinZoom(e) {
                        this._helper.setMinZoom(e)
                    }
                    setMaxZoom(e) {
                        this._helper.setMaxZoom(e)
                    }
                    setMinPitch(e) {
                        this._helper.setMinPitch(e)
                    }
                    setMaxPitch(e) {
                        this._helper.setMaxPitch(e)
                    }
                    setRenderWorldCopies(e) {
                        this._helper.setRenderWorldCopies(e)
                    }
                    setBearing(e) {
                        this._helper.setBearing(e)
                    }
                    setPitch(e) {
                        this._helper.setPitch(e)
                    }
                    setRoll(e) {
                        this._helper.setRoll(e)
                    }
                    setFov(e) {
                        this._helper.setFov(e)
                    }
                    setZoom(e) {
                        this._helper.setZoom(e)
                    }
                    setCenter(e) {
                        this._helper.setCenter(e)
                    }
                    setElevation(e) {
                        this._helper.setElevation(e)
                    }
                    setMinElevationForCurrentTile(e) {
                        this._helper.setMinElevationForCurrentTile(e)
                    }
                    setPadding(e) {
                        this._helper.setPadding(e)
                    }
                    interpolatePadding(e, i, o) {
                        return this._helper.interpolatePadding(e, i, o)
                    }
                    isPaddingEqual(e) {
                        return this._helper.isPaddingEqual(e)
                    }
                    resize(e, i, o=!0) {
                        this._helper.resize(e, i, o)
                    }
                    getMaxBounds() {
                        return this._helper.getMaxBounds()
                    }
                    setMaxBounds(e) {
                        this._helper.setMaxBounds(e)
                    }
                    overrideNearFarZ(e, i) {
                        this._helper.overrideNearFarZ(e, i)
                    }
                    clearNearFarZOverride() {
                        this._helper.clearNearFarZOverride()
                    }
                    getCameraQueryGeometry(e) {
                        return this._helper.getCameraQueryGeometry(this.getCameraPoint(), e)
                    }
                    get tileSize() {
                        return this._helper.tileSize
                    }
                    get tileZoom() {
                        return this._helper.tileZoom
                    }
                    get scale() {
                        return this._helper.scale
                    }
                    get worldSize() {
                        return this._helper.worldSize
                    }
                    get width() {
                        return this._helper.width
                    }
                    get height() {
                        return this._helper.height
                    }
                    get lngRange() {
                        return this._helper.lngRange
                    }
                    get latRange() {
                        return this._helper.latRange
                    }
                    get minZoom() {
                        return this._helper.minZoom
                    }
                    get maxZoom() {
                        return this._helper.maxZoom
                    }
                    get zoom() {
                        return this._helper.zoom
                    }
                    get center() {
                        return this._helper.center
                    }
                    get minPitch() {
                        return this._helper.minPitch
                    }
                    get maxPitch() {
                        return this._helper.maxPitch
                    }
                    get pitch() {
                        return this._helper.pitch
                    }
                    get pitchInRadians() {
                        return this._helper.pitchInRadians
                    }
                    get roll() {
                        return this._helper.roll
                    }
                    get rollInRadians() {
                        return this._helper.rollInRadians
                    }
                    get bearing() {
                        return this._helper.bearing
                    }
                    get bearingInRadians() {
                        return this._helper.bearingInRadians
                    }
                    get fov() {
                        return this._helper.fov
                    }
                    get fovInRadians() {
                        return this._helper.fovInRadians
                    }
                    get elevation() {
                        return this._helper.elevation
                    }
                    get minElevationForCurrentTile() {
                        return this._helper.minElevationForCurrentTile
                    }
                    get padding() {
                        return this._helper.padding
                    }
                    get unmodified() {
                        return this._helper.unmodified
                    }
                    get renderWorldCopies() {
                        return this._helper.renderWorldCopies
                    }
                    get cameraToCenterDistance() {
                        return this._helper.cameraToCenterDistance
                    }
                    get nearZ() {
                        return this._helper.nearZ
                    }
                    get farZ() {
                        return this._helper.farZ
                    }
                    get autoCalculateNearFarZ() {
                        return this._helper.autoCalculateNearFarZ
                    }
                    get isGlobeRendering() {
                        return this._globeness > 0
                    }
                    setTransitionState(e, i) {
                        this._globeness = e,
                        this._globeLatitudeErrorCorrectionRadians = i,
                        this._calcMatrices(),
                        this._verticalPerspectiveTransform.getCoveringTilesDetailsProvider().recalculateCache(),
                        this._mercatorTransform.getCoveringTilesDetailsProvider().recalculateCache()
                    }
                    get currentTransform() {
                        return this.isGlobeRendering ? this._verticalPerspectiveTransform : this._mercatorTransform
                    }
                    constructor() {
                        this._globeLatitudeErrorCorrectionRadians = 0,
                        this._globeness = 1,
                        this._helper = new Do({
                            calcMatrices: () => {
                                this._calcMatrices()
                            }
                            ,
                            getConstrained: (e, i) => this.getConstrained(e, i)
                        }),
                        this._globeness = 1,
                        this._mercatorTransform = new Pr,
                        this._verticalPerspectiveTransform = new Vo
                    }
                    clone() {
                        const e = new Uo;
                        return e._globeness = this._globeness,
                        e._globeLatitudeErrorCorrectionRadians = this._globeLatitudeErrorCorrectionRadians,
                        e.apply(this),
                        e
                    }
                    apply(e) {
                        this._helper.apply(e),
                        this._mercatorTransform.apply(this),
                        this._verticalPerspectiveTransform.apply(this, this._globeLatitudeErrorCorrectionRadians)
                    }
                    get projectionMatrix() {
                        return this.currentTransform.projectionMatrix
                    }
                    get modelViewProjectionMatrix() {
                        return this.currentTransform.modelViewProjectionMatrix
                    }
                    get inverseProjectionMatrix() {
                        return this.currentTransform.inverseProjectionMatrix
                    }
                    get cameraPosition() {
                        return this.currentTransform.cameraPosition
                    }
                    getProjectionData(e) {
                        const i = this._mercatorTransform.getProjectionData(e)
                          , o = this._verticalPerspectiveTransform.getProjectionData(e);
                        return {
                            mainMatrix: this.isGlobeRendering ? o.mainMatrix : i.mainMatrix,
                            clippingPlane: o.clippingPlane,
                            tileMercatorCoords: o.tileMercatorCoords,
                            projectionTransition: e.applyGlobeMatrix ? this._globeness : 0,
                            fallbackMatrix: i.fallbackMatrix
                        }
                    }
                    isLocationOccluded(e) {
                        return this.currentTransform.isLocationOccluded(e)
                    }
                    transformLightDirection(e) {
                        return this.currentTransform.transformLightDirection(e)
                    }
                    getPixelScale() {
                        return l.bb(this._mercatorTransform.getPixelScale(), this._verticalPerspectiveTransform.getPixelScale(), this._globeness)
                    }
                    getCircleRadiusCorrection() {
                        return l.bb(this._mercatorTransform.getCircleRadiusCorrection(), this._verticalPerspectiveTransform.getCircleRadiusCorrection(), this._globeness)
                    }
                    getPitchedTextCorrection(e, i, o) {
                        const a = this._mercatorTransform.getPitchedTextCorrection(e, i, o)
                          , h = this._verticalPerspectiveTransform.getPitchedTextCorrection(e, i, o);
                        return l.bb(a, h, this._globeness)
                    }
                    projectTileCoordinates(e, i, o, a) {
                        return this.currentTransform.projectTileCoordinates(e, i, o, a)
                    }
                    _calcMatrices() {
                        this._helper._width && this._helper._height && (this._verticalPerspectiveTransform.apply(this, this._globeLatitudeErrorCorrectionRadians),
                        this._helper._nearZ = this._verticalPerspectiveTransform.nearZ,
                        this._helper._farZ = this._verticalPerspectiveTransform.farZ,
                        this._mercatorTransform.apply(this, !0, this.isGlobeRendering),
                        this._helper._nearZ = this._mercatorTransform.nearZ,
                        this._helper._farZ = this._mercatorTransform.farZ)
                    }
                    calculateFogMatrix(e) {
                        return this.currentTransform.calculateFogMatrix(e)
                    }
                    getVisibleUnwrappedCoordinates(e) {
                        return this.currentTransform.getVisibleUnwrappedCoordinates(e)
                    }
                    getCameraFrustum() {
                        return this.currentTransform.getCameraFrustum()
                    }
                    getClippingPlane() {
                        return this.currentTransform.getClippingPlane()
                    }
                    getCoveringTilesDetailsProvider() {
                        return this.currentTransform.getCoveringTilesDetailsProvider()
                    }
                    recalculateZoomAndCenter(e) {
                        this._mercatorTransform.recalculateZoomAndCenter(e),
                        this._verticalPerspectiveTransform.recalculateZoomAndCenter(e)
                    }
                    maxPitchScaleFactor() {
                        return this._mercatorTransform.maxPitchScaleFactor()
                    }
                    getCameraPoint() {
                        return this._helper.getCameraPoint()
                    }
                    getCameraAltitude() {
                        return this._helper.getCameraAltitude()
                    }
                    getCameraLngLat() {
                        return this._helper.getCameraLngLat()
                    }
                    lngLatToCameraDepth(e, i) {
                        return this.currentTransform.lngLatToCameraDepth(e, i)
                    }
                    populateCache(e) {
                        this._mercatorTransform.populateCache(e),
                        this._verticalPerspectiveTransform.populateCache(e)
                    }
                    getBounds() {
                        return this.currentTransform.getBounds()
                    }
                    getConstrained(e, i) {
                        return this.currentTransform.getConstrained(e, i)
                    }
                    calculateCenterFromCameraLngLatAlt(e, i, o, a) {
                        return this._helper.calculateCenterFromCameraLngLatAlt(e, i, o, a)
                    }
                    setLocationAtPoint(e, i) {
                        if (!this.isGlobeRendering)
                            return this._mercatorTransform.setLocationAtPoint(e, i),
                            void this.apply(this._mercatorTransform);
                        this._verticalPerspectiveTransform.setLocationAtPoint(e, i),
                        this.apply(this._verticalPerspectiveTransform)
                    }
                    locationToScreenPoint(e, i) {
                        return this.currentTransform.locationToScreenPoint(e, i)
                    }
                    screenPointToMercatorCoordinate(e, i) {
                        return this.currentTransform.screenPointToMercatorCoordinate(e, i)
                    }
                    screenPointToLocation(e, i) {
                        return this.currentTransform.screenPointToLocation(e, i)
                    }
                    isPointOnMapSurface(e, i) {
                        return this.currentTransform.isPointOnMapSurface(e, i)
                    }
                    getRayDirectionFromPixel(e) {
                        return this._verticalPerspectiveTransform.getRayDirectionFromPixel(e)
                    }
                    getMatrixForModel(e, i) {
                        return this.currentTransform.getMatrixForModel(e, i)
                    }
                    getProjectionDataForCustomLayer(e=!0) {
                        const i = this._mercatorTransform.getProjectionDataForCustomLayer(e);
                        if (!this.isGlobeRendering)
                            return i;
                        const o = this._verticalPerspectiveTransform.getProjectionDataForCustomLayer(e);
                        return o.fallbackMatrix = i.mainMatrix,
                        o
                    }
                    getFastPathSimpleProjectionMatrix(e) {
                        return this.currentTransform.getFastPathSimpleProjectionMatrix(e)
                    }
                }
                class tr {
                    get useGlobeControls() {
                        return !0
                    }
                    handlePanInertia(e, i) {
                        const o = el(e, i);
                        return Math.abs(o.lng - i.center.lng) > 180 && (o.lng = i.center.lng + 179.5 * Math.sign(o.lng - i.center.lng)),
                        {
                            easingCenter: o,
                            easingOffset: new l.P(0,0)
                        }
                    }
                    handleMapControlsRollPitchBearingZoom(e, i) {
                        const o = e.around
                          , a = i.screenPointToLocation(o);
                        e.bearingDelta && i.setBearing(i.bearing + e.bearingDelta),
                        e.pitchDelta && i.setPitch(i.pitch + e.pitchDelta),
                        e.rollDelta && i.setRoll(i.roll + e.rollDelta);
                        const h = i.zoom;
                        e.zoomDelta && i.setZoom(i.zoom + e.zoomDelta);
                        const m = i.zoom - h;
                        if (m === 0)
                            return;
                        const y = l.bm(i.center.lng, a.lng)
                          , v = y / (Math.abs(y / 180) + 1)
                          , T = l.bm(i.center.lat, a.lat)
                          , S = i.getRayDirectionFromPixel(o)
                          , A = i.cameraPosition
                          , k = -1 * l.aU(A, S)
                          , O = l.bh();
                        l.aO(O, A, [S[0] * k, S[1] * k, S[2] * k]);
                        const V = l.bs(O) - 1
                          , H = Math.exp(.5 * -Math.max(V - .3, 0))
                          , q = Zi(i.worldSize, i.center.lat) / Math.min(i.width, i.height)
                          , W = l.be(q, .9, .5, 1, .25)
                          , J = (1 - l.aH(-m)) * Math.min(H, W)
                          , te = i.center.lat
                          , ie = i.zoom
                          , ne = new l.Q(i.center.lng + v * J,l.ad(i.center.lat + T * J, -85.051129, l.aI));
                        i.setLocationAtPoint(a, o);
                        const le = i.center
                          , se = l.be(Math.abs(y), 45, 85, 0, 1)
                          , _e = l.be(q, .75, .35, 0, 1)
                          , xe = Math.pow(Math.max(se, _e), .25)
                          , Pe = l.bm(le.lng, ne.lng)
                          , Ie = l.bm(le.lat, ne.lat);
                        i.setCenter(new l.Q(le.lng + Pe * xe,le.lat + Ie * xe).wrap()),
                        i.setZoom(ie + ai(te, i.center.lat))
                    }
                    handleMapControlsPan(e, i, o) {
                        if (!e.panDelta)
                            return;
                        const a = i.center.lat
                          , h = i.zoom;
                        i.setCenter(el(e.panDelta, i).wrap()),
                        i.setZoom(h + ai(a, i.center.lat))
                    }
                    cameraForBoxAndBearing(e, i, o, a, h) {
                        const m = Ya(e, i, o, a, h)
                          , y = i.left / h.width * 2 - 1
                          , v = (h.width - i.right) / h.width * 2 - 1
                          , T = i.top / h.height * -2 + 1
                          , S = (h.height - i.bottom) / h.height * -2 + 1
                          , A = l.bm(o.getWest(), o.getEast()) < 0
                          , k = A ? o.getEast() : o.getWest()
                          , O = A ? o.getWest() : o.getEast()
                          , V = Math.max(o.getNorth(), o.getSouth())
                          , H = Math.min(o.getNorth(), o.getSouth())
                          , q = k + .5 * l.bm(k, O)
                          , W = V + .5 * l.bm(V, H)
                          , J = h.clone();
                        J.setCenter(m.center),
                        J.setBearing(m.bearing),
                        J.setPitch(0),
                        J.setRoll(0),
                        J.setZoom(m.zoom);
                        const te = J.modelViewProjectionMatrix
                          , ie = [Ui(o.getNorthWest()), Ui(o.getNorthEast()), Ui(o.getSouthWest()), Ui(o.getSouthEast()), Ui(new l.Q(O,W)), Ui(new l.Q(k,W)), Ui(new l.Q(q,V)), Ui(new l.Q(q,H))]
                          , ne = Ui(m.center);
                        let le = Number.POSITIVE_INFINITY;
                        for (const se of ie)
                            y < 0 && (le = tr.getLesserNonNegativeNonNull(le, tr.solveVectorScale(se, ne, te, "x", y))),
                            v > 0 && (le = tr.getLesserNonNegativeNonNull(le, tr.solveVectorScale(se, ne, te, "x", v))),
                            T > 0 && (le = tr.getLesserNonNegativeNonNull(le, tr.solveVectorScale(se, ne, te, "y", T))),
                            S < 0 && (le = tr.getLesserNonNegativeNonNull(le, tr.solveVectorScale(se, ne, te, "y", S)));
                        if (Number.isFinite(le) && le !== 0)
                            return m.zoom = J.zoom + l.aa(le),
                            m;
                        ro()
                    }
                    handleJumpToCenterZoom(e, i) {
                        const o = e.center.lat
                          , a = e.getConstrained(i.center ? l.Q.convert(i.center) : e.center, e.zoom).center;
                        e.setCenter(a.wrap());
                        const h = i.zoom !== void 0 ? +i.zoom : e.zoom + ai(o, a.lat);
                        e.zoom !== h && e.setZoom(h)
                    }
                    handleEaseTo(e, i) {
                        const o = e.zoom
                          , a = e.center
                          , h = e.padding
                          , m = {
                            roll: e.roll,
                            pitch: e.pitch,
                            bearing: e.bearing
                        }
                          , y = {
                            roll: i.roll === void 0 ? e.roll : i.roll,
                            pitch: i.pitch === void 0 ? e.pitch : i.pitch,
                            bearing: i.bearing === void 0 ? e.bearing : i.bearing
                        }
                          , v = i.zoom !== void 0
                          , T = !e.isPaddingEqual(i.padding);
                        let S = !1;
                        const A = i.center ? l.Q.convert(i.center) : a
                          , k = e.getConstrained(A, o).center;
                        Ki(e, k);
                        const O = e.clone();
                        O.setCenter(k),
                        O.setZoom(v ? +i.zoom : o + ai(a.lat, A.lat)),
                        O.setBearing(i.bearing);
                        const V = new l.P(l.ad(e.centerPoint.x + i.offsetAsPoint.x, 0, e.width),l.ad(e.centerPoint.y + i.offsetAsPoint.y, 0, e.height));
                        O.setLocationAtPoint(k, V);
                        const H = (i.offset && i.offsetAsPoint.mag()) > 0 ? O.center : k
                          , q = v ? +i.zoom : o + ai(a.lat, H.lat)
                          , W = o + ai(a.lat, 0)
                          , J = q + ai(H.lat, 0)
                          , te = l.bm(a.lng, H.lng)
                          , ie = l.bm(a.lat, H.lat)
                          , ne = l.aH(J - W);
                        return S = q !== o,
                        {
                            easeFunc: le => {
                                if (l.b5(m, y) || Sr({
                                    startEulerAngles: m,
                                    endEulerAngles: y,
                                    tr: e,
                                    k: le,
                                    useSlerp: m.roll != y.roll
                                }),
                                T && e.interpolatePadding(h, i.padding, le),
                                i.around)
                                    l.w("Easing around a point is not supported under globe projection."),
                                    e.setLocationAtPoint(i.around, i.aroundPoint);
                                else {
                                    const se = J > W ? Math.min(2, ne) : Math.max(.5, ne)
                                      , _e = Math.pow(se, 1 - le)
                                      , xe = ts(a, te, ie, le * _e);
                                    e.setCenter(xe.wrap())
                                }
                                if (S) {
                                    const se = l.B.number(W, J, le) + ai(0, e.center.lat);
                                    e.setZoom(se)
                                }
                            }
                            ,
                            isZooming: S,
                            elevationCenter: H
                        }
                    }
                    handleFlyTo(e, i) {
                        const o = i.zoom !== void 0
                          , a = e.center
                          , h = e.zoom
                          , m = e.padding
                          , y = !e.isPaddingEqual(i.padding)
                          , v = e.getConstrained(l.Q.convert(i.center || i.locationAtOffset), h).center
                          , T = o ? +i.zoom : e.zoom + ai(e.center.lat, v.lat)
                          , S = e.clone();
                        S.setCenter(v),
                        S.setZoom(T),
                        S.setBearing(i.bearing);
                        const A = new l.P(l.ad(e.centerPoint.x + i.offsetAsPoint.x, 0, e.width),l.ad(e.centerPoint.y + i.offsetAsPoint.y, 0, e.height));
                        S.setLocationAtPoint(v, A);
                        const k = S.center;
                        Ki(e, k);
                        const O = function(ie, ne, le) {
                            const se = Ui(ne)
                              , _e = Ui(le)
                              , xe = l.aU(se, _e)
                              , Pe = Math.acos(xe)
                              , Ie = Qa(ie);
                            return Pe / (2 * Math.PI) * Ie
                        }(e, a, k)
                          , V = h + ai(a.lat, 0)
                          , H = T + ai(k.lat, 0)
                          , q = l.aH(H - V);
                        let W;
                        if (typeof i.minZoom == "number") {
                            const ie = +i.minZoom + ai(k.lat, 0)
                              , ne = Math.min(ie, V, H) + ai(0, k.lat)
                              , le = e.getConstrained(k, ne).zoom + ai(k.lat, 0);
                            W = l.aH(le - V)
                        }
                        const J = l.bm(a.lng, k.lng)
                          , te = l.bm(a.lat, k.lat);
                        return {
                            easeFunc: (ie, ne, le, se) => {
                                const _e = ts(a, J, te, le);
                                y && e.interpolatePadding(m, i.padding, ie);
                                const xe = ie === 1 ? k : _e;
                                e.setCenter(xe.wrap());
                                const Pe = V + l.aa(ne);
                                e.setZoom(ie === 1 ? T : Pe + ai(0, xe.lat))
                            }
                            ,
                            scaleOfZoom: q,
                            targetCenter: k,
                            scaleOfMinZoom: W,
                            pixelPathLength: O
                        }
                    }
                    static solveVectorScale(e, i, o, a, h) {
                        const m = a === "x" ? [o[0], o[4], o[8], o[12]] : [o[1], o[5], o[9], o[13]]
                          , y = [o[3], o[7], o[11], o[15]]
                          , v = e[0] * m[0] + e[1] * m[1] + e[2] * m[2]
                          , T = e[0] * y[0] + e[1] * y[1] + e[2] * y[2]
                          , S = i[0] * m[0] + i[1] * m[1] + i[2] * m[2]
                          , A = i[0] * y[0] + i[1] * y[1] + i[2] * y[2];
                        return S + h * T === v + h * A || y[3] * (v - S) + m[3] * (A - T) + v * A == S * T ? null : (S + m[3] - h * A - h * y[3]) / (S - v - h * A + h * T)
                    }
                    static getLesserNonNegativeNonNull(e, i) {
                        return i !== null && i >= 0 && i < e ? i : e
                    }
                }
                class Zo {
                    constructor(e) {
                        this._globe = e,
                        this._mercatorCameraHelper = new Ur,
                        this._verticalPerspectiveCameraHelper = new tr
                    }
                    get useGlobeControls() {
                        return this._globe.useGlobeRendering
                    }
                    get currentHelper() {
                        return this.useGlobeControls ? this._verticalPerspectiveCameraHelper : this._mercatorCameraHelper
                    }
                    handlePanInertia(e, i) {
                        return this.currentHelper.handlePanInertia(e, i)
                    }
                    handleMapControlsRollPitchBearingZoom(e, i) {
                        return this.currentHelper.handleMapControlsRollPitchBearingZoom(e, i)
                    }
                    handleMapControlsPan(e, i, o) {
                        this.currentHelper.handleMapControlsPan(e, i, o)
                    }
                    cameraForBoxAndBearing(e, i, o, a, h) {
                        return this.currentHelper.cameraForBoxAndBearing(e, i, o, a, h)
                    }
                    handleJumpToCenterZoom(e, i) {
                        this.currentHelper.handleJumpToCenterZoom(e, i)
                    }
                    handleEaseTo(e, i) {
                        return this.currentHelper.handleEaseTo(e, i)
                    }
                    handleFlyTo(e, i) {
                        return this.currentHelper.handleFlyTo(e, i)
                    }
                }
                const is = (u, e) => l.x(u, e && e.filter(i => i.identifier !== "source.canvas"))
                  , il = l.bt();
                class lo extends l.E {
                    constructor(e, i={}) {
                        super(),
                        this._rtlPluginLoaded = () => {
                            for (const o in this.sourceCaches) {
                                const a = this.sourceCaches[o].getSource().type;
                                a !== "vector" && a !== "geojson" || this.sourceCaches[o].reload()
                            }
                        }
                        ,
                        this.map = e,
                        this.dispatcher = new Xi(Yi(),e._getMapId()),
                        this.dispatcher.registerMessageHandler("GG", (o, a) => this.getGlyphs(o, a)),
                        this.dispatcher.registerMessageHandler("GI", (o, a) => this.getImages(o, a)),
                        this.imageManager = new ei,
                        this.imageManager.setEventedParent(this),
                        this.glyphManager = new ti(e._requestManager,i.localIdeographFontFamily),
                        this.lineAtlas = new wr(256,512),
                        this.crossTileSymbolIndex = new Xa,
                        this._spritesImagesIds = {},
                        this._layers = {},
                        this._order = [],
                        this.sourceCaches = {},
                        this.zoomHistory = new l.bu,
                        this._loaded = !1,
                        this._availableImages = [],
                        this._resetUpdates(),
                        this.dispatcher.broadcast("SR", l.bv()),
                        gn().on(Ts, this._rtlPluginLoaded),
                        this.on("data", o => {
                            if (o.dataType !== "source" || o.sourceDataType !== "metadata")
                                return;
                            const a = this.sourceCaches[o.sourceId];
                            if (!a)
                                return;
                            const h = a.getSource();
                            if (h && h.vectorLayerIds)
                                for (const m in this._layers) {
                                    const y = this._layers[m];
                                    y.source === h.id && this._validateLayer(y)
                                }
                        }
                        )
                    }
                    loadURL(e, i={}, o) {
                        this.fire(new l.l("dataloading",{
                            dataType: "style"
                        })),
                        i.validate = typeof i.validate != "boolean" || i.validate;
                        const a = this.map._requestManager.transformRequest(e, "Style");
                        this._loadStyleRequest = new AbortController;
                        const h = this._loadStyleRequest;
                        l.j(a, this._loadStyleRequest).then(m => {
                            this._loadStyleRequest = null,
                            this._load(m.data, i, o)
                        }
                        ).catch(m => {
                            this._loadStyleRequest = null,
                            m && !h.signal.aborted && this.fire(new l.k(m))
                        }
                        )
                    }
                    loadJSON(e, i={}, o) {
                        this.fire(new l.l("dataloading",{
                            dataType: "style"
                        })),
                        this._frameRequest = new AbortController,
                        oe.frameAsync(this._frameRequest).then( () => {
                            this._frameRequest = null,
                            i.validate = i.validate !== !1,
                            this._load(e, i, o)
                        }
                        ).catch( () => {}
                        )
                    }
                    loadEmpty() {
                        this.fire(new l.l("dataloading",{
                            dataType: "style"
                        })),
                        this._load(il, {
                            validate: !1
                        })
                    }
                    _load(e, i, o) {
                        var a, h;
                        const m = i.transformStyle ? i.transformStyle(o, e) : e;
                        if (!i.validate || !is(this, l.y(m))) {
                            this._loaded = !0,
                            this.stylesheet = m;
                            for (const y in m.sources)
                                this.addSource(y, m.sources[y], {
                                    validate: !1
                                });
                            m.sprite ? this._loadSprite(m.sprite) : this.imageManager.setLoaded(!0),
                            this.glyphManager.setURL(m.glyphs),
                            this._createLayers(),
                            this.light = new or(this.stylesheet.light),
                            this._setProjectionInternal(((a = this.stylesheet.projection) === null || a === void 0 ? void 0 : a.type) || "mercator"),
                            this.sky = new mi(this.stylesheet.sky),
                            this.map.setTerrain((h = this.stylesheet.terrain) !== null && h !== void 0 ? h : null),
                            this.fire(new l.l("data",{
                                dataType: "style"
                            })),
                            this.fire(new l.l("style.load"))
                        }
                    }
                    _createLayers() {
                        const e = l.bw(this.stylesheet.layers);
                        this.dispatcher.broadcast("SL", e),
                        this._order = e.map(i => i.id),
                        this._layers = {},
                        this._serializedLayers = null;
                        for (const i of e) {
                            const o = l.bx(i);
                            o.setEventedParent(this, {
                                layer: {
                                    id: i.id
                                }
                            }),
                            this._layers[i.id] = o
                        }
                    }
                    _loadSprite(e, i=!1, o=void 0) {
                        let a;
                        this.imageManager.setLoaded(!1),
                        this._spriteRequest = new AbortController,
                        function(h, m, y, v) {
                            return l._(this, void 0, void 0, function*() {
                                const T = Mt(h)
                                  , S = y > 1 ? "@2x" : ""
                                  , A = {}
                                  , k = {};
                                for (const {id: O, url: V} of T) {
                                    const H = m.transformRequest(gt(V, S, ".json"), "SpriteJSON");
                                    A[O] = l.j(H, v);
                                    const q = m.transformRequest(gt(V, S, ".png"), "SpriteImage");
                                    k[O] = Wt.getImage(q, v)
                                }
                                return yield Promise.all([...Object.values(A), ...Object.values(k)]),
                                function(O, V) {
                                    return l._(this, void 0, void 0, function*() {
                                        const H = {};
                                        for (const q in O) {
                                            H[q] = {};
                                            const W = oe.getImageCanvasContext((yield V[q]).data)
                                              , J = (yield O[q]).data;
                                            for (const te in J) {
                                                const {width: ie, height: ne, x: le, y: se, sdf: _e, pixelRatio: xe, stretchX: Pe, stretchY: Ie, content: Ce, textFitWidth: Ne, textFitHeight: Oe} = J[te];
                                                H[q][te] = {
                                                    data: null,
                                                    pixelRatio: xe,
                                                    sdf: _e,
                                                    stretchX: Pe,
                                                    stretchY: Ie,
                                                    content: Ce,
                                                    textFitWidth: Ne,
                                                    textFitHeight: Oe,
                                                    spriteData: {
                                                        width: ie,
                                                        height: ne,
                                                        x: le,
                                                        y: se,
                                                        context: W
                                                    }
                                                }
                                            }
                                        }
                                        return H
                                    })
                                }(A, k)
                            })
                        }(e, this.map._requestManager, this.map.getPixelRatio(), this._spriteRequest).then(h => {
                            if (this._spriteRequest = null,
                            h)
                                for (const m in h) {
                                    this._spritesImagesIds[m] = [];
                                    const y = this._spritesImagesIds[m] ? this._spritesImagesIds[m].filter(v => !(v in h)) : [];
                                    for (const v of y)
                                        this.imageManager.removeImage(v),
                                        this._changedImages[v] = !0;
                                    for (const v in h[m]) {
                                        const T = m === "default" ? v : `${m}:${v}`;
                                        this._spritesImagesIds[m].push(T),
                                        T in this.imageManager.images ? this.imageManager.updateImage(T, h[m][v], !1) : this.imageManager.addImage(T, h[m][v]),
                                        i && (this._changedImages[T] = !0)
                                    }
                                }
                        }
                        ).catch(h => {
                            this._spriteRequest = null,
                            a = h,
                            this.fire(new l.k(a))
                        }
                        ).finally( () => {
                            this.imageManager.setLoaded(!0),
                            this._availableImages = this.imageManager.listImages(),
                            i && (this._changed = !0),
                            this.dispatcher.broadcast("SI", this._availableImages),
                            this.fire(new l.l("data",{
                                dataType: "style"
                            })),
                            o && o(a)
                        }
                        )
                    }
                    _unloadSprite() {
                        for (const e of Object.values(this._spritesImagesIds).flat())
                            this.imageManager.removeImage(e),
                            this._changedImages[e] = !0;
                        this._spritesImagesIds = {},
                        this._availableImages = this.imageManager.listImages(),
                        this._changed = !0,
                        this.dispatcher.broadcast("SI", this._availableImages),
                        this.fire(new l.l("data",{
                            dataType: "style"
                        }))
                    }
                    _validateLayer(e) {
                        const i = this.sourceCaches[e.source];
                        if (!i)
                            return;
                        const o = e.sourceLayer;
                        if (!o)
                            return;
                        const a = i.getSource();
                        (a.type === "geojson" || a.vectorLayerIds && a.vectorLayerIds.indexOf(o) === -1) && this.fire(new l.k(new Error(`Source layer "${o}" does not exist on source "${a.id}" as specified by style layer "${e.id}".`)))
                    }
                    loaded() {
                        if (!this._loaded || Object.keys(this._updatedSources).length)
                            return !1;
                        for (const e in this.sourceCaches)
                            if (!this.sourceCaches[e].loaded())
                                return !1;
                        return !!this.imageManager.isLoaded()
                    }
                    _serializeByIds(e, i=!1) {
                        const o = this._serializedAllLayers();
                        if (!e || e.length === 0)
                            return Object.values(i ? l.by(o) : o);
                        const a = [];
                        for (const h of e)
                            if (o[h]) {
                                const m = i ? l.by(o[h]) : o[h];
                                a.push(m)
                            }
                        return a
                    }
                    _serializedAllLayers() {
                        let e = this._serializedLayers;
                        if (e)
                            return e;
                        e = this._serializedLayers = {};
                        const i = Object.keys(this._layers);
                        for (const o of i) {
                            const a = this._layers[o];
                            a.type !== "custom" && (e[o] = a.serialize())
                        }
                        return e
                    }
                    hasTransitions() {
                        var e, i, o;
                        if (!((e = this.light) === null || e === void 0) && e.hasTransition() || !((i = this.sky) === null || i === void 0) && i.hasTransition() || !((o = this.projection) === null || o === void 0) && o.hasTransition())
                            return !0;
                        for (const a in this.sourceCaches)
                            if (this.sourceCaches[a].hasTransition())
                                return !0;
                        for (const a in this._layers)
                            if (this._layers[a].hasTransition())
                                return !0;
                        return !1
                    }
                    _checkLoaded() {
                        if (!this._loaded)
                            throw new Error("Style is not done loading.")
                    }
                    update(e) {
                        if (!this._loaded)
                            return;
                        const i = this._changed;
                        if (i) {
                            const a = Object.keys(this._updatedLayers)
                              , h = Object.keys(this._removedLayers);
                            (a.length || h.length) && this._updateWorkerLayers(a, h);
                            for (const m in this._updatedSources) {
                                const y = this._updatedSources[m];
                                if (y === "reload")
                                    this._reloadSource(m);
                                else {
                                    if (y !== "clear")
                                        throw new Error(`Invalid action ${y}`);
                                    this._clearSource(m)
                                }
                            }
                            this._updateTilesForChangedImages(),
                            this._updateTilesForChangedGlyphs();
                            for (const m in this._updatedPaintProps)
                                this._layers[m].updateTransitions(e);
                            this.light.updateTransitions(e),
                            this.sky.updateTransitions(e),
                            this._resetUpdates()
                        }
                        const o = {};
                        for (const a in this.sourceCaches) {
                            const h = this.sourceCaches[a];
                            o[a] = h.used,
                            h.used = !1
                        }
                        for (const a of this._order) {
                            const h = this._layers[a];
                            h.recalculate(e, this._availableImages),
                            !h.isHidden(e.zoom) && h.source && (this.sourceCaches[h.source].used = !0)
                        }
                        for (const a in o) {
                            const h = this.sourceCaches[a];
                            !!o[a] != !!h.used && h.fire(new l.l("data",{
                                sourceDataType: "visibility",
                                dataType: "source",
                                sourceId: a
                            }))
                        }
                        this.light.recalculate(e),
                        this.sky.recalculate(e),
                        this.projection.recalculate(e),
                        this.z = e.zoom,
                        i && this.fire(new l.l("data",{
                            dataType: "style"
                        }))
                    }
                    _updateTilesForChangedImages() {
                        const e = Object.keys(this._changedImages);
                        if (e.length) {
                            for (const i in this.sourceCaches)
                                this.sourceCaches[i].reloadTilesForDependencies(["icons", "patterns"], e);
                            this._changedImages = {}
                        }
                    }
                    _updateTilesForChangedGlyphs() {
                        if (this._glyphsDidChange) {
                            for (const e in this.sourceCaches)
                                this.sourceCaches[e].reloadTilesForDependencies(["glyphs"], [""]);
                            this._glyphsDidChange = !1
                        }
                    }
                    _updateWorkerLayers(e, i) {
                        this.dispatcher.broadcast("UL", {
                            layers: this._serializeByIds(e, !1),
                            removedIds: i
                        })
                    }
                    _resetUpdates() {
                        this._changed = !1,
                        this._updatedLayers = {},
                        this._removedLayers = {},
                        this._updatedSources = {},
                        this._updatedPaintProps = {},
                        this._changedImages = {},
                        this._glyphsDidChange = !1
                    }
                    setState(e, i={}) {
                        var o;
                        this._checkLoaded();
                        const a = this.serialize();
                        if (e = i.transformStyle ? i.transformStyle(a, e) : e,
                        ((o = i.validate) === null || o === void 0 || o) && is(this, l.y(e)))
                            return !1;
                        (e = l.by(e)).layers = l.bw(e.layers);
                        const h = l.bz(a, e)
                          , m = this._getOperationsToPerform(h);
                        if (m.unimplemented.length > 0)
                            throw new Error(`Unimplemented: ${m.unimplemented.join(", ")}.`);
                        if (m.operations.length === 0)
                            return !1;
                        for (const y of m.operations)
                            y();
                        return this.stylesheet = e,
                        this._serializedLayers = null,
                        !0
                    }
                    _getOperationsToPerform(e) {
                        const i = []
                          , o = [];
                        for (const a of e)
                            switch (a.command) {
                            case "setCenter":
                            case "setZoom":
                            case "setBearing":
                            case "setPitch":
                            case "setRoll":
                                continue;
                            case "addLayer":
                                i.push( () => this.addLayer.apply(this, a.args));
                                break;
                            case "removeLayer":
                                i.push( () => this.removeLayer.apply(this, a.args));
                                break;
                            case "setPaintProperty":
                                i.push( () => this.setPaintProperty.apply(this, a.args));
                                break;
                            case "setLayoutProperty":
                                i.push( () => this.setLayoutProperty.apply(this, a.args));
                                break;
                            case "setFilter":
                                i.push( () => this.setFilter.apply(this, a.args));
                                break;
                            case "addSource":
                                i.push( () => this.addSource.apply(this, a.args));
                                break;
                            case "removeSource":
                                i.push( () => this.removeSource.apply(this, a.args));
                                break;
                            case "setLayerZoomRange":
                                i.push( () => this.setLayerZoomRange.apply(this, a.args));
                                break;
                            case "setLight":
                                i.push( () => this.setLight.apply(this, a.args));
                                break;
                            case "setGeoJSONSourceData":
                                i.push( () => this.setGeoJSONSourceData.apply(this, a.args));
                                break;
                            case "setGlyphs":
                                i.push( () => this.setGlyphs.apply(this, a.args));
                                break;
                            case "setSprite":
                                i.push( () => this.setSprite.apply(this, a.args));
                                break;
                            case "setTerrain":
                                i.push( () => this.map.setTerrain.apply(this, a.args));
                                break;
                            case "setSky":
                                i.push( () => this.setSky.apply(this, a.args));
                                break;
                            case "setProjection":
                                this.setProjection.apply(this, a.args);
                                break;
                            case "setTransition":
                                i.push( () => {}
                                );
                                break;
                            default:
                                o.push(a.command)
                            }
                        return {
                            operations: i,
                            unimplemented: o
                        }
                    }
                    addImage(e, i) {
                        if (this.getImage(e))
                            return this.fire(new l.k(new Error(`An image named "${e}" already exists.`)));
                        this.imageManager.addImage(e, i),
                        this._afterImageUpdated(e)
                    }
                    updateImage(e, i) {
                        this.imageManager.updateImage(e, i)
                    }
                    getImage(e) {
                        return this.imageManager.getImage(e)
                    }
                    removeImage(e) {
                        if (!this.getImage(e))
                            return this.fire(new l.k(new Error(`An image named "${e}" does not exist.`)));
                        this.imageManager.removeImage(e),
                        this._afterImageUpdated(e)
                    }
                    _afterImageUpdated(e) {
                        this._availableImages = this.imageManager.listImages(),
                        this._changedImages[e] = !0,
                        this._changed = !0,
                        this.dispatcher.broadcast("SI", this._availableImages),
                        this.fire(new l.l("data",{
                            dataType: "style"
                        }))
                    }
                    listImages() {
                        return this._checkLoaded(),
                        this.imageManager.listImages()
                    }
                    addSource(e, i, o={}) {
                        if (this._checkLoaded(),
                        this.sourceCaches[e] !== void 0)
                            throw new Error(`Source "${e}" already exists.`);
                        if (!i.type)
                            throw new Error(`The type property must be defined, but only the following properties were given: ${Object.keys(i).join(", ")}.`);
                        if (["vector", "raster", "geojson", "video", "image"].indexOf(i.type) >= 0 && this._validate(l.y.source, `sources.${e}`, i, null, o))
                            return;
                        this.map && this.map._collectResourceTiming && (i.collectResourceTiming = !0);
                        const a = this.sourceCaches[e] = new E(e,i,this.dispatcher);
                        a.style = this,
                        a.setEventedParent(this, () => ({
                            isSourceLoaded: a.loaded(),
                            source: a.serialize(),
                            sourceId: e
                        })),
                        a.onAdd(this.map),
                        this._changed = !0
                    }
                    removeSource(e) {
                        if (this._checkLoaded(),
                        this.sourceCaches[e] === void 0)
                            throw new Error("There is no source with this ID");
                        for (const o in this._layers)
                            if (this._layers[o].source === e)
                                return this.fire(new l.k(new Error(`Source "${e}" cannot be removed while layer "${o}" is using it.`)));
                        const i = this.sourceCaches[e];
                        delete this.sourceCaches[e],
                        delete this._updatedSources[e],
                        i.fire(new l.l("data",{
                            sourceDataType: "metadata",
                            dataType: "source",
                            sourceId: e
                        })),
                        i.setEventedParent(null),
                        i.onRemove(this.map),
                        this._changed = !0
                    }
                    setGeoJSONSourceData(e, i) {
                        if (this._checkLoaded(),
                        this.sourceCaches[e] === void 0)
                            throw new Error(`There is no source with this ID=${e}`);
                        const o = this.sourceCaches[e].getSource();
                        if (o.type !== "geojson")
                            throw new Error(`geojsonSource.type is ${o.type}, which is !== 'geojson`);
                        o.setData(i),
                        this._changed = !0
                    }
                    getSource(e) {
                        return this.sourceCaches[e] && this.sourceCaches[e].getSource()
                    }
                    addLayer(e, i, o={}) {
                        this._checkLoaded();
                        const a = e.id;
                        if (this.getLayer(a))
                            return void this.fire(new l.k(new Error(`Layer "${a}" already exists on this map.`)));
                        let h;
                        if (e.type === "custom") {
                            if (is(this, l.bA(e)))
                                return;
                            h = l.bx(e)
                        } else {
                            if ("source"in e && typeof e.source == "object" && (this.addSource(a, e.source),
                            e = l.by(e),
                            e = l.e(e, {
                                source: a
                            })),
                            this._validate(l.y.layer, `layers.${a}`, e, {
                                arrayIndex: -1
                            }, o))
                                return;
                            h = l.bx(e),
                            this._validateLayer(h),
                            h.setEventedParent(this, {
                                layer: {
                                    id: a
                                }
                            })
                        }
                        const m = i ? this._order.indexOf(i) : this._order.length;
                        if (i && m === -1)
                            this.fire(new l.k(new Error(`Cannot add layer "${a}" before non-existing layer "${i}".`)));
                        else {
                            if (this._order.splice(m, 0, a),
                            this._layerOrderChanged = !0,
                            this._layers[a] = h,
                            this._removedLayers[a] && h.source && h.type !== "custom") {
                                const y = this._removedLayers[a];
                                delete this._removedLayers[a],
                                y.type !== h.type ? this._updatedSources[h.source] = "clear" : (this._updatedSources[h.source] = "reload",
                                this.sourceCaches[h.source].pause())
                            }
                            this._updateLayer(h),
                            h.onAdd && h.onAdd(this.map)
                        }
                    }
                    moveLayer(e, i) {
                        if (this._checkLoaded(),
                        this._changed = !0,
                        !this._layers[e])
                            return void this.fire(new l.k(new Error(`The layer '${e}' does not exist in the map's style and cannot be moved.`)));
                        if (e === i)
                            return;
                        const o = this._order.indexOf(e);
                        this._order.splice(o, 1);
                        const a = i ? this._order.indexOf(i) : this._order.length;
                        i && a === -1 ? this.fire(new l.k(new Error(`Cannot move layer "${e}" before non-existing layer "${i}".`))) : (this._order.splice(a, 0, e),
                        this._layerOrderChanged = !0)
                    }
                    removeLayer(e) {
                        this._checkLoaded();
                        const i = this._layers[e];
                        if (!i)
                            return void this.fire(new l.k(new Error(`Cannot remove non-existing layer "${e}".`)));
                        i.setEventedParent(null);
                        const o = this._order.indexOf(e);
                        this._order.splice(o, 1),
                        this._layerOrderChanged = !0,
                        this._changed = !0,
                        this._removedLayers[e] = i,
                        delete this._layers[e],
                        this._serializedLayers && delete this._serializedLayers[e],
                        delete this._updatedLayers[e],
                        delete this._updatedPaintProps[e],
                        i.onRemove && i.onRemove(this.map)
                    }
                    getLayer(e) {
                        return this._layers[e]
                    }
                    getLayersOrder() {
                        return [...this._order]
                    }
                    hasLayer(e) {
                        return e in this._layers
                    }
                    setLayerZoomRange(e, i, o) {
                        this._checkLoaded();
                        const a = this.getLayer(e);
                        a ? a.minzoom === i && a.maxzoom === o || (i != null && (a.minzoom = i),
                        o != null && (a.maxzoom = o),
                        this._updateLayer(a)) : this.fire(new l.k(new Error(`Cannot set the zoom range of non-existing layer "${e}".`)))
                    }
                    setFilter(e, i, o={}) {
                        this._checkLoaded();
                        const a = this.getLayer(e);
                        if (a) {
                            if (!l.bB(a.filter, i))
                                return i == null ? (a.filter = void 0,
                                void this._updateLayer(a)) : void (this._validate(l.y.filter, `layers.${a.id}.filter`, i, null, o) || (a.filter = l.by(i),
                                this._updateLayer(a)))
                        } else
                            this.fire(new l.k(new Error(`Cannot filter non-existing layer "${e}".`)))
                    }
                    getFilter(e) {
                        return l.by(this.getLayer(e).filter)
                    }
                    setLayoutProperty(e, i, o, a={}) {
                        this._checkLoaded();
                        const h = this.getLayer(e);
                        h ? l.bB(h.getLayoutProperty(i), o) || (h.setLayoutProperty(i, o, a),
                        this._updateLayer(h)) : this.fire(new l.k(new Error(`Cannot style non-existing layer "${e}".`)))
                    }
                    getLayoutProperty(e, i) {
                        const o = this.getLayer(e);
                        if (o)
                            return o.getLayoutProperty(i);
                        this.fire(new l.k(new Error(`Cannot get style of non-existing layer "${e}".`)))
                    }
                    setPaintProperty(e, i, o, a={}) {
                        this._checkLoaded();
                        const h = this.getLayer(e);
                        h ? l.bB(h.getPaintProperty(i), o) || (h.setPaintProperty(i, o, a) && this._updateLayer(h),
                        this._changed = !0,
                        this._updatedPaintProps[e] = !0,
                        this._serializedLayers = null) : this.fire(new l.k(new Error(`Cannot style non-existing layer "${e}".`)))
                    }
                    getPaintProperty(e, i) {
                        return this.getLayer(e).getPaintProperty(i)
                    }
                    setFeatureState(e, i) {
                        this._checkLoaded();
                        const o = e.source
                          , a = e.sourceLayer
                          , h = this.sourceCaches[o];
                        if (h === void 0)
                            return void this.fire(new l.k(new Error(`The source '${o}' does not exist in the map's style.`)));
                        const m = h.getSource().type;
                        m === "geojson" && a ? this.fire(new l.k(new Error("GeoJSON sources cannot have a sourceLayer parameter."))) : m !== "vector" || a ? (e.id === void 0 && this.fire(new l.k(new Error("The feature id parameter must be provided."))),
                        h.setFeatureState(a, e.id, i)) : this.fire(new l.k(new Error("The sourceLayer parameter must be provided for vector source types.")))
                    }
                    removeFeatureState(e, i) {
                        this._checkLoaded();
                        const o = e.source
                          , a = this.sourceCaches[o];
                        if (a === void 0)
                            return void this.fire(new l.k(new Error(`The source '${o}' does not exist in the map's style.`)));
                        const h = a.getSource().type
                          , m = h === "vector" ? e.sourceLayer : void 0;
                        h !== "vector" || m ? i && typeof e.id != "string" && typeof e.id != "number" ? this.fire(new l.k(new Error("A feature id is required to remove its specific state property."))) : a.removeFeatureState(m, e.id, i) : this.fire(new l.k(new Error("The sourceLayer parameter must be provided for vector source types.")))
                    }
                    getFeatureState(e) {
                        this._checkLoaded();
                        const i = e.source
                          , o = e.sourceLayer
                          , a = this.sourceCaches[i];
                        if (a !== void 0)
                            return a.getSource().type !== "vector" || o ? (e.id === void 0 && this.fire(new l.k(new Error("The feature id parameter must be provided."))),
                            a.getFeatureState(o, e.id)) : void this.fire(new l.k(new Error("The sourceLayer parameter must be provided for vector source types.")));
                        this.fire(new l.k(new Error(`The source '${i}' does not exist in the map's style.`)))
                    }
                    getTransition() {
                        return l.e({
                            duration: 300,
                            delay: 0
                        }, this.stylesheet && this.stylesheet.transition)
                    }
                    serialize() {
                        if (!this._loaded)
                            return;
                        const e = l.bC(this.sourceCaches, h => h.serialize())
                          , i = this._serializeByIds(this._order, !0)
                          , o = this.map.getTerrain() || void 0
                          , a = this.stylesheet;
                        return l.bD({
                            version: a.version,
                            name: a.name,
                            metadata: a.metadata,
                            light: a.light,
                            sky: a.sky,
                            center: a.center,
                            zoom: a.zoom,
                            bearing: a.bearing,
                            pitch: a.pitch,
                            sprite: a.sprite,
                            glyphs: a.glyphs,
                            transition: a.transition,
                            projection: a.projection,
                            sources: e,
                            layers: i,
                            terrain: o
                        }, h => h !== void 0)
                    }
                    _updateLayer(e) {
                        this._updatedLayers[e.id] = !0,
                        e.source && !this._updatedSources[e.source] && this.sourceCaches[e.source].getSource().type !== "raster" && (this._updatedSources[e.source] = "reload",
                        this.sourceCaches[e.source].pause()),
                        this._serializedLayers = null,
                        this._changed = !0
                    }
                    _flattenAndSortRenderedFeatures(e) {
                        const i = m => this._layers[m].type === "fill-extrusion"
                          , o = {}
                          , a = [];
                        for (let m = this._order.length - 1; m >= 0; m--) {
                            const y = this._order[m];
                            if (i(y)) {
                                o[y] = m;
                                for (const v of e) {
                                    const T = v[y];
                                    if (T)
                                        for (const S of T)
                                            a.push(S)
                                }
                            }
                        }
                        a.sort( (m, y) => y.intersectionZ - m.intersectionZ);
                        const h = [];
                        for (let m = this._order.length - 1; m >= 0; m--) {
                            const y = this._order[m];
                            if (i(y))
                                for (let v = a.length - 1; v >= 0; v--) {
                                    const T = a[v].feature;
                                    if (o[T.layer.id] < m)
                                        break;
                                    h.push(T),
                                    a.pop()
                                }
                            else
                                for (const v of e) {
                                    const T = v[y];
                                    if (T)
                                        for (const S of T)
                                            h.push(S.feature)
                                }
                        }
                        return h
                    }
                    queryRenderedFeatures(e, i, o) {
                        i && i.filter && this._validate(l.y.filter, "queryRenderedFeatures.filter", i.filter, null, i);
                        const a = {};
                        if (i && i.layers) {
                            if (!(Array.isArray(i.layers) || i.layers instanceof Set))
                                return this.fire(new l.k(new Error("parameters.layers must be an Array or a Set of strings"))),
                                [];
                            for (const T of i.layers) {
                                const S = this._layers[T];
                                if (!S)
                                    return this.fire(new l.k(new Error(`The layer '${T}' does not exist in the map's style and cannot be queried for features.`))),
                                    [];
                                a[S.source] = !0
                            }
                        }
                        const h = [];
                        i.availableImages = this._availableImages;
                        const m = this._serializedAllLayers()
                          , y = i.layers instanceof Set ? i.layers : Array.isArray(i.layers) ? new Set(i.layers) : null
                          , v = Object.assign(Object.assign({}, i), {
                            layers: y
                        });
                        for (const T in this.sourceCaches)
                            i.layers && !a[T] || h.push(Hn(this.sourceCaches[T], this._layers, m, e, v, o));
                        return this.placement && h.push(function(T, S, A, k, O, V, H) {
                            const q = {}
                              , W = V.queryRenderedSymbols(k)
                              , J = [];
                            for (const te of Object.keys(W).map(Number))
                                J.push(H[te]);
                            J.sort(yi);
                            for (const te of J) {
                                const ie = te.featureIndex.lookupSymbolFeatures(W[te.bucketInstanceId], S, te.bucketIndex, te.sourceLayerIndex, O.filter, O.layers, O.availableImages, T);
                                for (const ne in ie) {
                                    const le = q[ne] = q[ne] || []
                                      , se = ie[ne];
                                    se.sort( (_e, xe) => {
                                        const Pe = te.featureSortOrder;
                                        if (Pe) {
                                            const Ie = Pe.indexOf(_e.featureIndex);
                                            return Pe.indexOf(xe.featureIndex) - Ie
                                        }
                                        return xe.featureIndex - _e.featureIndex
                                    }
                                    );
                                    for (const _e of se)
                                        le.push(_e)
                                }
                            }
                            return function(te, ie, ne) {
                                for (const le in te)
                                    for (const se of te[le])
                                        ii(se, ne[ie[le].source]);
                                return te
                            }(q, T, A)
                        }(this._layers, m, this.sourceCaches, e, v, this.placement.collisionIndex, this.placement.retainedQueryData)),
                        this._flattenAndSortRenderedFeatures(h)
                    }
                    querySourceFeatures(e, i) {
                        i && i.filter && this._validate(l.y.filter, "querySourceFeatures.filter", i.filter, null, i);
                        const o = this.sourceCaches[e];
                        return o ? function(a, h) {
                            const m = a.getRenderableIds().map(T => a.getTileByID(T))
                              , y = []
                              , v = {};
                            for (let T = 0; T < m.length; T++) {
                                const S = m[T]
                                  , A = S.tileID.canonical.key;
                                v[A] || (v[A] = !0,
                                S.querySourceFeatures(y, h))
                            }
                            return y
                        }(o, i) : []
                    }
                    getLight() {
                        return this.light.getLight()
                    }
                    setLight(e, i={}) {
                        this._checkLoaded();
                        const o = this.light.getLight();
                        let a = !1;
                        for (const m in e)
                            if (!l.bB(e[m], o[m])) {
                                a = !0;
                                break
                            }
                        if (!a)
                            return;
                        const h = {
                            now: oe.now(),
                            transition: l.e({
                                duration: 300,
                                delay: 0
                            }, this.stylesheet.transition)
                        };
                        this.light.setLight(e, i),
                        this.light.updateTransitions(h)
                    }
                    getProjection() {
                        var e;
                        return (e = this.stylesheet) === null || e === void 0 ? void 0 : e.projection
                    }
                    setProjection(e) {
                        if (this._checkLoaded(),
                        this.projection) {
                            if (this.projection.name === e.type)
                                return;
                            this.projection.destroy(),
                            delete this.projection
                        }
                        this.stylesheet.projection = e,
                        this._setProjectionInternal(e.type)
                    }
                    getSky() {
                        var e;
                        return (e = this.stylesheet) === null || e === void 0 ? void 0 : e.sky
                    }
                    setSky(e, i={}) {
                        this._checkLoaded();
                        const o = this.getSky();
                        let a = !1;
                        if (!e && !o)
                            return;
                        if (e && !o)
                            a = !0;
                        else if (!e && o)
                            a = !0;
                        else
                            for (const m in e)
                                if (!l.bB(e[m], o[m])) {
                                    a = !0;
                                    break
                                }
                        if (!a)
                            return;
                        const h = {
                            now: oe.now(),
                            transition: l.e({
                                duration: 300,
                                delay: 0
                            }, this.stylesheet.transition)
                        };
                        this.stylesheet.sky = e,
                        this.sky.setSky(e, i),
                        this.sky.updateTransitions(h)
                    }
                    _setProjectionInternal(e) {
                        const i = function(o) {
                            if (Array.isArray(o)) {
                                const a = new Bo({
                                    type: o
                                });
                                return {
                                    projection: a,
                                    transform: new Uo,
                                    cameraHelper: new Zo(a)
                                }
                            }
                            switch (o) {
                            case "mercator":
                                return {
                                    projection: new Ka,
                                    transform: new Pr,
                                    cameraHelper: new Ur
                                };
                            case "globe":
                                {
                                    const a = new Bo({
                                        type: ["interpolate", ["linear"], ["zoom"], 11, "vertical-perspective", 12, "mercator"]
                                    });
                                    return {
                                        projection: a,
                                        transform: new Uo,
                                        cameraHelper: new Zo(a)
                                    }
                                }
                            case "vertical-perspective":
                                return {
                                    projection: new zs,
                                    transform: new Vo,
                                    cameraHelper: new tr
                                };
                            default:
                                return l.w(`Unknown projection name: ${o}. Falling back to mercator projection.`),
                                {
                                    projection: new Ka,
                                    transform: new Pr,
                                    cameraHelper: new Ur
                                }
                            }
                        }(e);
                        this.projection = i.projection,
                        this.map.migrateProjection(i.transform, i.cameraHelper);
                        for (const o in this.sourceCaches)
                            this.sourceCaches[o].reload()
                    }
                    _validate(e, i, o, a, h={}) {
                        return (!h || h.validate !== !1) && is(this, e.call(l.y, l.e({
                            key: i,
                            style: this.serialize(),
                            value: o,
                            styleSpec: l.v
                        }, a)))
                    }
                    _remove(e=!0) {
                        this._frameRequest && (this._frameRequest.abort(),
                        this._frameRequest = null),
                        this._loadStyleRequest && (this._loadStyleRequest.abort(),
                        this._loadStyleRequest = null),
                        this._spriteRequest && (this._spriteRequest.abort(),
                        this._spriteRequest = null),
                        gn().off(Ts, this._rtlPluginLoaded);
                        for (const i in this._layers)
                            this._layers[i].setEventedParent(null);
                        for (const i in this.sourceCaches) {
                            const o = this.sourceCaches[i];
                            o.setEventedParent(null),
                            o.onRemove(this.map)
                        }
                        this.imageManager.setEventedParent(null),
                        this.setEventedParent(null),
                        e && this.dispatcher.broadcast("RM", void 0),
                        this.dispatcher.remove(e)
                    }
                    _clearSource(e) {
                        this.sourceCaches[e].clearTiles()
                    }
                    _reloadSource(e) {
                        this.sourceCaches[e].resume(),
                        this.sourceCaches[e].reload()
                    }
                    _updateSources(e) {
                        for (const i in this.sourceCaches)
                            this.sourceCaches[i].update(e, this.map.terrain)
                    }
                    _generateCollisionBoxes() {
                        for (const e in this.sourceCaches)
                            this._reloadSource(e)
                    }
                    _updatePlacement(e, i, o, a, h=!1) {
                        let m = !1
                          , y = !1;
                        const v = {};
                        for (const T of this._order) {
                            const S = this._layers[T];
                            if (S.type !== "symbol")
                                continue;
                            if (!v[S.source]) {
                                const k = this.sourceCaches[S.source];
                                v[S.source] = k.getRenderableIds(!0).map(O => k.getTileByID(O)).sort( (O, V) => V.tileID.overscaledZ - O.tileID.overscaledZ || (O.tileID.isLessThan(V.tileID) ? -1 : 1))
                            }
                            const A = this.crossTileSymbolIndex.addLayer(S, v[S.source], e.center.lng);
                            m = m || A
                        }
                        if (this.crossTileSymbolIndex.pruneUnusedLayers(this._order),
                        ((h = h || this._layerOrderChanged || o === 0) || !this.pauseablePlacement || this.pauseablePlacement.isDone() && !this.placement.stillRecent(oe.now(), e.zoom)) && (this.pauseablePlacement = new qa(e,this.map.terrain,this._order,h,i,o,a,this.placement),
                        this._layerOrderChanged = !1),
                        this.pauseablePlacement.isDone() ? this.placement.setStale() : (this.pauseablePlacement.continuePlacement(this._order, this._layers, v),
                        this.pauseablePlacement.isDone() && (this.placement = this.pauseablePlacement.commit(oe.now()),
                        y = !0),
                        m && this.pauseablePlacement.placement.setStale()),
                        y || m)
                            for (const T of this._order) {
                                const S = this._layers[T];
                                S.type === "symbol" && this.placement.updateLayerOpacities(S, v[S.source])
                            }
                        return !this.pauseablePlacement.isDone() || this.placement.hasTransitions(oe.now())
                    }
                    _releaseSymbolFadeTiles() {
                        for (const e in this.sourceCaches)
                            this.sourceCaches[e].releaseSymbolFadeTiles()
                    }
                    getImages(e, i) {
                        return l._(this, void 0, void 0, function*() {
                            const o = yield this.imageManager.getImages(i.icons);
                            this._updateTilesForChangedImages();
                            const a = this.sourceCaches[i.source];
                            return a && a.setDependencies(i.tileID.key, i.type, i.icons),
                            o
                        })
                    }
                    getGlyphs(e, i) {
                        return l._(this, void 0, void 0, function*() {
                            const o = yield this.glyphManager.getGlyphs(i.stacks)
                              , a = this.sourceCaches[i.source];
                            return a && a.setDependencies(i.tileID.key, i.type, [""]),
                            o
                        })
                    }
                    getGlyphsUrl() {
                        return this.stylesheet.glyphs || null
                    }
                    setGlyphs(e, i={}) {
                        this._checkLoaded(),
                        e && this._validate(l.y.glyphs, "glyphs", e, null, i) || (this._glyphsDidChange = !0,
                        this.stylesheet.glyphs = e,
                        this.glyphManager.entries = {},
                        this.glyphManager.setURL(e))
                    }
                    addSprite(e, i, o={}, a) {
                        this._checkLoaded();
                        const h = [{
                            id: e,
                            url: i
                        }]
                          , m = [...Mt(this.stylesheet.sprite), ...h];
                        this._validate(l.y.sprite, "sprite", m, null, o) || (this.stylesheet.sprite = m,
                        this._loadSprite(h, !0, a))
                    }
                    removeSprite(e) {
                        this._checkLoaded();
                        const i = Mt(this.stylesheet.sprite);
                        if (i.find(o => o.id === e)) {
                            if (this._spritesImagesIds[e])
                                for (const o of this._spritesImagesIds[e])
                                    this.imageManager.removeImage(o),
                                    this._changedImages[o] = !0;
                            i.splice(i.findIndex(o => o.id === e), 1),
                            this.stylesheet.sprite = i.length > 0 ? i : void 0,
                            delete this._spritesImagesIds[e],
                            this._availableImages = this.imageManager.listImages(),
                            this._changed = !0,
                            this.dispatcher.broadcast("SI", this._availableImages),
                            this.fire(new l.l("data",{
                                dataType: "style"
                            }))
                        } else
                            this.fire(new l.k(new Error(`Sprite "${e}" doesn't exists on this map.`)))
                    }
                    getSprite() {
                        return Mt(this.stylesheet.sprite)
                    }
                    setSprite(e, i={}, o) {
                        this._checkLoaded(),
                        e && this._validate(l.y.sprite, "sprite", e, null, i) || (this.stylesheet.sprite = e,
                        e ? this._loadSprite(e, !0, o) : (this._unloadSprite(),
                        o && o(null)))
                    }
                }
                var rn = l.aC([{
                    name: "a_pos",
                    type: "Int16",
                    components: 2
                }, {
                    name: "a_texture_pos",
                    type: "Int16",
                    components: 2
                }]);
                class ih {
                    constructor() {
                        this.boundProgram = null,
                        this.boundLayoutVertexBuffer = null,
                        this.boundPaintVertexBuffers = [],
                        this.boundIndexBuffer = null,
                        this.boundVertexOffset = null,
                        this.boundDynamicVertexBuffer = null,
                        this.vao = null
                    }
                    bind(e, i, o, a, h, m, y, v, T) {
                        this.context = e;
                        let S = this.boundPaintVertexBuffers.length !== a.length;
                        for (let A = 0; !S && A < a.length; A++)
                            this.boundPaintVertexBuffers[A] !== a[A] && (S = !0);
                        !this.vao || this.boundProgram !== i || this.boundLayoutVertexBuffer !== o || S || this.boundIndexBuffer !== h || this.boundVertexOffset !== m || this.boundDynamicVertexBuffer !== y || this.boundDynamicVertexBuffer2 !== v || this.boundDynamicVertexBuffer3 !== T ? this.freshBind(i, o, a, h, m, y, v, T) : (e.bindVertexArray.set(this.vao),
                        y && y.bind(),
                        h && h.dynamicDraw && h.bind(),
                        v && v.bind(),
                        T && T.bind())
                    }
                    freshBind(e, i, o, a, h, m, y, v) {
                        const T = e.numAttributes
                          , S = this.context
                          , A = S.gl;
                        this.vao && this.destroy(),
                        this.vao = S.createVertexArray(),
                        S.bindVertexArray.set(this.vao),
                        this.boundProgram = e,
                        this.boundLayoutVertexBuffer = i,
                        this.boundPaintVertexBuffers = o,
                        this.boundIndexBuffer = a,
                        this.boundVertexOffset = h,
                        this.boundDynamicVertexBuffer = m,
                        this.boundDynamicVertexBuffer2 = y,
                        this.boundDynamicVertexBuffer3 = v,
                        i.enableAttributes(A, e);
                        for (const k of o)
                            k.enableAttributes(A, e);
                        m && m.enableAttributes(A, e),
                        y && y.enableAttributes(A, e),
                        v && v.enableAttributes(A, e),
                        i.bind(),
                        i.setVertexAttribPointers(A, e, h);
                        for (const k of o)
                            k.bind(),
                            k.setVertexAttribPointers(A, e, h);
                        m && (m.bind(),
                        m.setVertexAttribPointers(A, e, h)),
                        a && a.bind(),
                        y && (y.bind(),
                        y.setVertexAttribPointers(A, e, h)),
                        v && (v.bind(),
                        v.setVertexAttribPointers(A, e, h)),
                        S.currentNumAttributes = T
                    }
                    destroy() {
                        this.vao && (this.context.deleteVertexArray(this.vao),
                        this.vao = null)
                    }
                }
                const rl = (u, e, i, o, a) => ({
                    u_texture: 0,
                    u_ele_delta: u,
                    u_fog_matrix: e,
                    u_fog_color: i ? i.properties.get("fog-color") : l.b6.white,
                    u_fog_ground_blend: i ? i.properties.get("fog-ground-blend") : 1,
                    u_fog_ground_blend_opacity: a ? 0 : i ? i.calculateFogBlendOpacity(o) : 0,
                    u_horizon_color: i ? i.properties.get("horizon-color") : l.b6.white,
                    u_horizon_fog_blend: i ? i.properties.get("horizon-fog-blend") : 1,
                    u_is_globe_mode: a ? 1 : 0
                })
                  , co = {
                    mainMatrix: "u_projection_matrix",
                    tileMercatorCoords: "u_projection_tile_mercator_coords",
                    clippingPlane: "u_projection_clipping_plane",
                    projectionTransition: "u_projection_transition",
                    fallbackMatrix: "u_projection_fallback_matrix"
                };
                function Bn(u) {
                    const e = [];
                    for (let i = 0; i < u.length; i++) {
                        if (u[i] === null)
                            continue;
                        const o = u[i].split(" ");
                        e.push(o.pop())
                    }
                    return e
                }
                class rh {
                    constructor(e, i, o, a, h, m, y, v) {
                        const T = e.gl;
                        this.program = T.createProgram();
                        const S = Bn(i.staticAttributes)
                          , A = o ? o.getBinderAttributes() : []
                          , k = S.concat(A)
                          , O = jr.prelude.staticUniforms ? Bn(jr.prelude.staticUniforms) : []
                          , V = y.staticUniforms ? Bn(y.staticUniforms) : []
                          , H = i.staticUniforms ? Bn(i.staticUniforms) : []
                          , q = o ? o.getBinderUniforms() : []
                          , W = O.concat(V).concat(H).concat(q)
                          , J = [];
                        for (const xe of W)
                            J.indexOf(xe) < 0 && J.push(xe);
                        const te = o ? o.defines() : [];
                        Ir(T) && te.unshift("#version 300 es"),
                        h && te.push("#define OVERDRAW_INSPECTOR;"),
                        m && te.push("#define TERRAIN3D;"),
                        v && te.push(v);
                        let ie = te.concat(jr.prelude.fragmentSource, y.fragmentSource, i.fragmentSource).join(`
`)
                          , ne = te.concat(jr.prelude.vertexSource, y.vertexSource, i.vertexSource).join(`
`);
                        Ir(T) || (ie = function(xe) {
                            return xe.replace(/\bin\s/g, "varying ").replace("out highp vec4 fragColor;", "").replace(/fragColor/g, "gl_FragColor").replace(/texture\(/g, "texture2D(")
                        }(ie),
                        ne = function(xe) {
                            return xe.replace(/\bin\s/g, "attribute ").replace(/\bout\s/g, "varying ").replace(/texture\(/g, "texture2D(")
                        }(ne));
                        const le = T.createShader(T.FRAGMENT_SHADER);
                        if (T.isContextLost())
                            return void (this.failedToCreate = !0);
                        if (T.shaderSource(le, ie),
                        T.compileShader(le),
                        !T.getShaderParameter(le, T.COMPILE_STATUS))
                            throw new Error(`Could not compile fragment shader: ${T.getShaderInfoLog(le)}`);
                        T.attachShader(this.program, le);
                        const se = T.createShader(T.VERTEX_SHADER);
                        if (T.isContextLost())
                            return void (this.failedToCreate = !0);
                        if (T.shaderSource(se, ne),
                        T.compileShader(se),
                        !T.getShaderParameter(se, T.COMPILE_STATUS))
                            throw new Error(`Could not compile vertex shader: ${T.getShaderInfoLog(se)}`);
                        T.attachShader(this.program, se),
                        this.attributes = {};
                        const _e = {};
                        this.numAttributes = k.length;
                        for (let xe = 0; xe < this.numAttributes; xe++)
                            k[xe] && (T.bindAttribLocation(this.program, xe, k[xe]),
                            this.attributes[k[xe]] = xe);
                        if (T.linkProgram(this.program),
                        !T.getProgramParameter(this.program, T.LINK_STATUS))
                            throw new Error(`Program failed to link: ${T.getProgramInfoLog(this.program)}`);
                        T.deleteShader(se),
                        T.deleteShader(le);
                        for (let xe = 0; xe < J.length; xe++) {
                            const Pe = J[xe];
                            if (Pe && !_e[Pe]) {
                                const Ie = T.getUniformLocation(this.program, Pe);
                                Ie && (_e[Pe] = Ie)
                            }
                        }
                        this.fixedUniforms = a(e, _e),
                        this.terrainUniforms = ( (xe, Pe) => ({
                            u_depth: new l.bE(xe,Pe.u_depth),
                            u_terrain: new l.bE(xe,Pe.u_terrain),
                            u_terrain_dim: new l.b7(xe,Pe.u_terrain_dim),
                            u_terrain_matrix: new l.bG(xe,Pe.u_terrain_matrix),
                            u_terrain_unpack: new l.bH(xe,Pe.u_terrain_unpack),
                            u_terrain_exaggeration: new l.b7(xe,Pe.u_terrain_exaggeration)
                        }))(e, _e),
                        this.projectionUniforms = ( (xe, Pe) => ({
                            u_projection_matrix: new l.bG(xe,Pe.u_projection_matrix),
                            u_projection_tile_mercator_coords: new l.bH(xe,Pe.u_projection_tile_mercator_coords),
                            u_projection_clipping_plane: new l.bH(xe,Pe.u_projection_clipping_plane),
                            u_projection_transition: new l.b7(xe,Pe.u_projection_transition),
                            u_projection_fallback_matrix: new l.bG(xe,Pe.u_projection_fallback_matrix)
                        }))(e, _e),
                        this.binderUniforms = o ? o.getUniforms(e, _e) : []
                    }
                    draw(e, i, o, a, h, m, y, v, T, S, A, k, O, V, H, q, W, J, te) {
                        const ie = e.gl;
                        if (this.failedToCreate)
                            return;
                        if (e.program.set(this.program),
                        e.setDepthMode(o),
                        e.setStencilMode(a),
                        e.setColorMode(h),
                        e.setCullFace(m),
                        v) {
                            e.activeTexture.set(ie.TEXTURE2),
                            ie.bindTexture(ie.TEXTURE_2D, v.depthTexture),
                            e.activeTexture.set(ie.TEXTURE3),
                            ie.bindTexture(ie.TEXTURE_2D, v.texture);
                            for (const le in this.terrainUniforms)
                                this.terrainUniforms[le].set(v[le])
                        }
                        if (T)
                            for (const le in T)
                                this.projectionUniforms[co[le]].set(T[le]);
                        if (y)
                            for (const le in this.fixedUniforms)
                                this.fixedUniforms[le].set(y[le]);
                        q && q.setUniforms(e, this.binderUniforms, V, {
                            zoom: H
                        });
                        let ne = 0;
                        switch (i) {
                        case ie.LINES:
                            ne = 2;
                            break;
                        case ie.TRIANGLES:
                            ne = 3;
                            break;
                        case ie.LINE_STRIP:
                            ne = 1
                        }
                        for (const le of O.get()) {
                            const se = le.vaos || (le.vaos = {});
                            (se[S] || (se[S] = new ih)).bind(e, this, A, q ? q.getPaintVertexBuffers() : [], k, le.vertexOffset, W, J, te),
                            ie.drawElements(i, le.primitiveLength * ne, ie.UNSIGNED_SHORT, le.primitiveOffset * ne * 2)
                        }
                    }
                }
                function uo(u, e, i) {
                    const o = 1 / l.av(i, 1, e.transform.tileZoom)
                      , a = Math.pow(2, i.tileID.overscaledZ)
                      , h = i.tileSize * Math.pow(2, e.transform.tileZoom) / a
                      , m = h * (i.tileID.canonical.x + i.tileID.wrap * a)
                      , y = h * i.tileID.canonical.y;
                    return {
                        u_image: 0,
                        u_texsize: i.imageAtlasTexture.size,
                        u_scale: [o, u.fromScale, u.toScale],
                        u_fade: u.t,
                        u_pixel_coord_upper: [m >> 16, y >> 16],
                        u_pixel_coord_lower: [65535 & m, 65535 & y]
                    }
                }
                const Tc = (u, e, i, o) => {
                    const a = u.style.light
                      , h = a.properties.get("position")
                      , m = [h.x, h.y, h.z]
                      , y = l.bK();
                    a.properties.get("anchor") === "viewport" && l.bL(y, u.transform.bearingInRadians),
                    l.bM(m, m, y);
                    const v = u.transform.transformLightDirection(m)
                      , T = a.properties.get("color");
                    return {
                        u_lightpos: m,
                        u_lightpos_globe: v,
                        u_lightintensity: a.properties.get("intensity"),
                        u_lightcolor: [T.r, T.g, T.b],
                        u_vertical_gradient: +e,
                        u_opacity: i,
                        u_fill_translate: o
                    }
                }
                  , ks = (u, e, i, o, a, h, m) => l.e(Tc(u, e, i, o), uo(h, u, m), {
                    u_height_factor: -Math.pow(2, a.overscaledZ) / m.tileSize / 8
                })
                  , Mc = (u, e, i, o) => l.e(uo(e, u, i), {
                    u_fill_translate: o
                })
                  , Cc = (u, e) => ({
                    u_world: u,
                    u_fill_translate: e
                })
                  , nh = (u, e, i, o, a) => l.e(Mc(u, e, i, a), {
                    u_world: o
                })
                  , Pc = (u, e, i, o, a) => {
                    const h = u.transform;
                    let m, y, v = 0;
                    if (i.paint.get("circle-pitch-alignment") === "map") {
                        const T = l.av(e, 1, h.zoom);
                        m = !0,
                        y = [T, T],
                        v = T / (l.Z * Math.pow(2, e.tileID.overscaledZ)) * 2 * Math.PI * a
                    } else
                        m = !1,
                        y = h.pixelsToGLUnits;
                    return {
                        u_camera_to_center_distance: h.cameraToCenterDistance,
                        u_scale_with_map: +(i.paint.get("circle-pitch-scale") === "map"),
                        u_pitch_with_map: +m,
                        u_device_pixel_ratio: u.pixelRatio,
                        u_extrude_scale: y,
                        u_globe_extrude_scale: v,
                        u_translate: o
                    }
                }
                  , nl = u => ({
                    u_pixel_extrude_scale: [1 / u.width, 1 / u.height]
                })
                  , Sc = u => ({
                    u_viewport_size: [u.width, u.height]
                })
                  , sl = (u, e=1) => ({
                    u_color: u,
                    u_overlay: 0,
                    u_overlay_scale: e
                })
                  , ol = (u, e, i, o) => {
                    const a = l.av(u, 1, e) / (l.Z * Math.pow(2, u.tileID.overscaledZ)) * 2 * Math.PI * o;
                    return {
                        u_extrude_scale: l.av(u, 1, e),
                        u_intensity: i,
                        u_globe_extrude_scale: a
                    }
                }
                  , al = (u, e, i, o) => {
                    const a = l.K();
                    l.bN(a, 0, u.width, u.height, 0, 0, 1);
                    const h = u.context.gl;
                    return {
                        u_matrix: a,
                        u_world: [h.drawingBufferWidth, h.drawingBufferHeight],
                        u_image: i,
                        u_color_ramp: o,
                        u_opacity: e.paint.get("heatmap-opacity")
                    }
                }
                  , rs = (u, e, i) => {
                    const o = i.paint.get("hillshade-shadow-color")
                      , a = i.paint.get("hillshade-highlight-color")
                      , h = i.paint.get("hillshade-accent-color");
                    let m = i.paint.get("hillshade-illumination-direction") * (Math.PI / 180);
                    return i.paint.get("hillshade-illumination-anchor") === "viewport" && (m += u.transform.bearingInRadians),
                    {
                        u_image: 0,
                        u_latrange: Ec(0, e.tileID),
                        u_light: [i.paint.get("hillshade-exaggeration"), m],
                        u_shadow: o,
                        u_highlight: a,
                        u_accent: h
                    }
                }
                  , Ic = (u, e) => {
                    const i = e.stride
                      , o = l.K();
                    return l.bN(o, 0, l.Z, -8192, 0, 0, 1),
                    l.L(o, o, [0, -8192, 0]),
                    {
                        u_matrix: o,
                        u_image: 1,
                        u_dimension: [i, i],
                        u_zoom: u.overscaledZ,
                        u_unpack: e.getUnpackVector()
                    }
                }
                ;
                function Ec(u, e) {
                    const i = Math.pow(2, e.canonical.z)
                      , o = e.canonical.y;
                    return [new l.$(0,o / i).toLngLat().lat, new l.$(0,(o + 1) / i).toLngLat().lat]
                }
                const ns = (u, e, i, o) => {
                    const a = u.transform;
                    return {
                        u_translation: ll(u, e, i),
                        u_ratio: o / l.av(e, 1, a.zoom),
                        u_device_pixel_ratio: u.pixelRatio,
                        u_units_to_pixels: [1 / a.pixelsToGLUnits[0], 1 / a.pixelsToGLUnits[1]]
                    }
                }
                  , sh = (u, e, i, o, a) => l.e(ns(u, e, i, o), {
                    u_image: 0,
                    u_image_height: a
                })
                  , Go = (u, e, i, o, a) => {
                    const h = u.transform
                      , m = Ac(e, h);
                    return {
                        u_translation: ll(u, e, i),
                        u_texsize: e.imageAtlasTexture.size,
                        u_ratio: o / l.av(e, 1, h.zoom),
                        u_device_pixel_ratio: u.pixelRatio,
                        u_image: 0,
                        u_scale: [m, a.fromScale, a.toScale],
                        u_fade: a.t,
                        u_units_to_pixels: [1 / h.pixelsToGLUnits[0], 1 / h.pixelsToGLUnits[1]]
                    }
                }
                  , oh = (u, e, i, o, a, h) => {
                    const m = u.lineAtlas
                      , y = Ac(e, u.transform)
                      , v = i.layout.get("line-cap") === "round"
                      , T = m.getDash(a.from, v)
                      , S = m.getDash(a.to, v)
                      , A = T.width * h.fromScale
                      , k = S.width * h.toScale;
                    return l.e(ns(u, e, i, o), {
                        u_patternscale_a: [y / A, -T.height / 2],
                        u_patternscale_b: [y / k, -S.height / 2],
                        u_sdfgamma: m.width / (256 * Math.min(A, k) * u.pixelRatio) / 2,
                        u_image: 0,
                        u_tex_y_a: T.y,
                        u_tex_y_b: S.y,
                        u_mix: h.t
                    })
                }
                ;
                function Ac(u, e) {
                    return 1 / l.av(u, 1, e.tileZoom)
                }
                function ll(u, e, i) {
                    return l.aw(u.transform, e, i.paint.get("line-translate"), i.paint.get("line-translate-anchor"))
                }
                const zc = (u, e, i, o, a) => {
                    return {
                        u_tl_parent: u,
                        u_scale_parent: e,
                        u_buffer_scale: 1,
                        u_fade_t: i.mix,
                        u_opacity: i.opacity * o.paint.get("raster-opacity"),
                        u_image0: 0,
                        u_image1: 1,
                        u_brightness_low: o.paint.get("raster-brightness-min"),
                        u_brightness_high: o.paint.get("raster-brightness-max"),
                        u_saturation_factor: (m = o.paint.get("raster-saturation"),
                        m > 0 ? 1 - 1 / (1.001 - m) : -m),
                        u_contrast_factor: (h = o.paint.get("raster-contrast"),
                        h > 0 ? 1 / (1 - h) : 1 + h),
                        u_spin_weights: kc(o.paint.get("raster-hue-rotate")),
                        u_coords_top: [a[0].x, a[0].y, a[1].x, a[1].y],
                        u_coords_bottom: [a[3].x, a[3].y, a[2].x, a[2].y]
                    };
                    var h, m
                }
                ;
                function kc(u) {
                    u *= Math.PI / 180;
                    const e = Math.sin(u)
                      , i = Math.cos(u);
                    return [(2 * i + 1) / 3, (-Math.sqrt(3) * e - i + 1) / 3, (Math.sqrt(3) * e - i + 1) / 3]
                }
                const $o = (u, e, i, o, a, h, m, y, v, T, S, A, k) => {
                    const O = m.transform;
                    return {
                        u_is_size_zoom_constant: +(u === "constant" || u === "source"),
                        u_is_size_feature_constant: +(u === "constant" || u === "camera"),
                        u_size_t: e ? e.uSizeT : 0,
                        u_size: e ? e.uSize : 0,
                        u_camera_to_center_distance: O.cameraToCenterDistance,
                        u_pitch: O.pitch / 360 * 2 * Math.PI,
                        u_rotate_symbol: +i,
                        u_aspect_ratio: O.width / O.height,
                        u_fade_change: m.options.fadeDuration ? m.symbolFadeChange : 1,
                        u_label_plane_matrix: y,
                        u_coord_matrix: v,
                        u_is_text: +S,
                        u_pitch_with_map: +o,
                        u_is_along_line: a,
                        u_is_variable_anchor: h,
                        u_texsize: A,
                        u_texture: 0,
                        u_translation: T,
                        u_pitched_scale: k
                    }
                }
                  , cl = (u, e, i, o, a, h, m, y, v, T, S, A, k, O) => {
                    const V = m.transform;
                    return l.e($o(u, e, i, o, a, h, m, y, v, T, S, A, O), {
                        u_gamma_scale: o ? Math.cos(V.pitch * Math.PI / 180) * V.cameraToCenterDistance : 1,
                        u_device_pixel_ratio: m.pixelRatio,
                        u_is_halo: 1
                    })
                }
                  , qo = (u, e, i, o, a, h, m, y, v, T, S, A, k) => l.e(cl(u, e, i, o, a, h, m, y, v, T, !0, S, 0, k), {
                    u_texsize_icon: A,
                    u_texture_icon: 1
                })
                  , yn = (u, e) => ({
                    u_opacity: u,
                    u_color: e
                })
                  , ul = (u, e, i, o, a) => l.e(function(h, m, y, v) {
                    const T = y.imageManager.getPattern(h.from.toString())
                      , S = y.imageManager.getPattern(h.to.toString())
                      , {width: A, height: k} = y.imageManager.getPixelSize()
                      , O = Math.pow(2, v.tileID.overscaledZ)
                      , V = v.tileSize * Math.pow(2, y.transform.tileZoom) / O
                      , H = V * (v.tileID.canonical.x + v.tileID.wrap * O)
                      , q = V * v.tileID.canonical.y;
                    return {
                        u_image: 0,
                        u_pattern_tl_a: T.tl,
                        u_pattern_br_a: T.br,
                        u_pattern_tl_b: S.tl,
                        u_pattern_br_b: S.br,
                        u_texsize: [A, k],
                        u_mix: m.t,
                        u_pattern_size_a: T.displaySize,
                        u_pattern_size_b: S.displaySize,
                        u_scale_a: m.fromScale,
                        u_scale_b: m.toScale,
                        u_tile_units_to_pixels: 1 / l.av(v, 1, y.transform.tileZoom),
                        u_pixel_coord_upper: [H >> 16, q >> 16],
                        u_pixel_coord_lower: [65535 & H, 65535 & q]
                    }
                }(i, a, e, o), {
                    u_opacity: u
                })
                  , Ho = (u, e) => {}
                  , hl = {
                    fillExtrusion: (u, e) => ({
                        u_lightpos: new l.bI(u,e.u_lightpos),
                        u_lightpos_globe: new l.bI(u,e.u_lightpos_globe),
                        u_lightintensity: new l.b7(u,e.u_lightintensity),
                        u_lightcolor: new l.bI(u,e.u_lightcolor),
                        u_vertical_gradient: new l.b7(u,e.u_vertical_gradient),
                        u_opacity: new l.b7(u,e.u_opacity),
                        u_fill_translate: new l.bJ(u,e.u_fill_translate)
                    }),
                    fillExtrusionPattern: (u, e) => ({
                        u_lightpos: new l.bI(u,e.u_lightpos),
                        u_lightpos_globe: new l.bI(u,e.u_lightpos_globe),
                        u_lightintensity: new l.b7(u,e.u_lightintensity),
                        u_lightcolor: new l.bI(u,e.u_lightcolor),
                        u_vertical_gradient: new l.b7(u,e.u_vertical_gradient),
                        u_height_factor: new l.b7(u,e.u_height_factor),
                        u_opacity: new l.b7(u,e.u_opacity),
                        u_fill_translate: new l.bJ(u,e.u_fill_translate),
                        u_image: new l.bE(u,e.u_image),
                        u_texsize: new l.bJ(u,e.u_texsize),
                        u_pixel_coord_upper: new l.bJ(u,e.u_pixel_coord_upper),
                        u_pixel_coord_lower: new l.bJ(u,e.u_pixel_coord_lower),
                        u_scale: new l.bI(u,e.u_scale),
                        u_fade: new l.b7(u,e.u_fade)
                    }),
                    fill: (u, e) => ({
                        u_fill_translate: new l.bJ(u,e.u_fill_translate)
                    }),
                    fillPattern: (u, e) => ({
                        u_image: new l.bE(u,e.u_image),
                        u_texsize: new l.bJ(u,e.u_texsize),
                        u_pixel_coord_upper: new l.bJ(u,e.u_pixel_coord_upper),
                        u_pixel_coord_lower: new l.bJ(u,e.u_pixel_coord_lower),
                        u_scale: new l.bI(u,e.u_scale),
                        u_fade: new l.b7(u,e.u_fade),
                        u_fill_translate: new l.bJ(u,e.u_fill_translate)
                    }),
                    fillOutline: (u, e) => ({
                        u_world: new l.bJ(u,e.u_world),
                        u_fill_translate: new l.bJ(u,e.u_fill_translate)
                    }),
                    fillOutlinePattern: (u, e) => ({
                        u_world: new l.bJ(u,e.u_world),
                        u_image: new l.bE(u,e.u_image),
                        u_texsize: new l.bJ(u,e.u_texsize),
                        u_pixel_coord_upper: new l.bJ(u,e.u_pixel_coord_upper),
                        u_pixel_coord_lower: new l.bJ(u,e.u_pixel_coord_lower),
                        u_scale: new l.bI(u,e.u_scale),
                        u_fade: new l.b7(u,e.u_fade),
                        u_fill_translate: new l.bJ(u,e.u_fill_translate)
                    }),
                    circle: (u, e) => ({
                        u_camera_to_center_distance: new l.b7(u,e.u_camera_to_center_distance),
                        u_scale_with_map: new l.bE(u,e.u_scale_with_map),
                        u_pitch_with_map: new l.bE(u,e.u_pitch_with_map),
                        u_extrude_scale: new l.bJ(u,e.u_extrude_scale),
                        u_device_pixel_ratio: new l.b7(u,e.u_device_pixel_ratio),
                        u_globe_extrude_scale: new l.b7(u,e.u_globe_extrude_scale),
                        u_translate: new l.bJ(u,e.u_translate)
                    }),
                    collisionBox: (u, e) => ({
                        u_pixel_extrude_scale: new l.bJ(u,e.u_pixel_extrude_scale)
                    }),
                    collisionCircle: (u, e) => ({
                        u_viewport_size: new l.bJ(u,e.u_viewport_size)
                    }),
                    debug: (u, e) => ({
                        u_color: new l.bF(u,e.u_color),
                        u_overlay: new l.bE(u,e.u_overlay),
                        u_overlay_scale: new l.b7(u,e.u_overlay_scale)
                    }),
                    depth: Ho,
                    clippingMask: Ho,
                    heatmap: (u, e) => ({
                        u_extrude_scale: new l.b7(u,e.u_extrude_scale),
                        u_intensity: new l.b7(u,e.u_intensity),
                        u_globe_extrude_scale: new l.b7(u,e.u_globe_extrude_scale)
                    }),
                    heatmapTexture: (u, e) => ({
                        u_matrix: new l.bG(u,e.u_matrix),
                        u_world: new l.bJ(u,e.u_world),
                        u_image: new l.bE(u,e.u_image),
                        u_color_ramp: new l.bE(u,e.u_color_ramp),
                        u_opacity: new l.b7(u,e.u_opacity)
                    }),
                    hillshade: (u, e) => ({
                        u_image: new l.bE(u,e.u_image),
                        u_latrange: new l.bJ(u,e.u_latrange),
                        u_light: new l.bJ(u,e.u_light),
                        u_shadow: new l.bF(u,e.u_shadow),
                        u_highlight: new l.bF(u,e.u_highlight),
                        u_accent: new l.bF(u,e.u_accent)
                    }),
                    hillshadePrepare: (u, e) => ({
                        u_matrix: new l.bG(u,e.u_matrix),
                        u_image: new l.bE(u,e.u_image),
                        u_dimension: new l.bJ(u,e.u_dimension),
                        u_zoom: new l.b7(u,e.u_zoom),
                        u_unpack: new l.bH(u,e.u_unpack)
                    }),
                    line: (u, e) => ({
                        u_translation: new l.bJ(u,e.u_translation),
                        u_ratio: new l.b7(u,e.u_ratio),
                        u_device_pixel_ratio: new l.b7(u,e.u_device_pixel_ratio),
                        u_units_to_pixels: new l.bJ(u,e.u_units_to_pixels)
                    }),
                    lineGradient: (u, e) => ({
                        u_translation: new l.bJ(u,e.u_translation),
                        u_ratio: new l.b7(u,e.u_ratio),
                        u_device_pixel_ratio: new l.b7(u,e.u_device_pixel_ratio),
                        u_units_to_pixels: new l.bJ(u,e.u_units_to_pixels),
                        u_image: new l.bE(u,e.u_image),
                        u_image_height: new l.b7(u,e.u_image_height)
                    }),
                    linePattern: (u, e) => ({
                        u_translation: new l.bJ(u,e.u_translation),
                        u_texsize: new l.bJ(u,e.u_texsize),
                        u_ratio: new l.b7(u,e.u_ratio),
                        u_device_pixel_ratio: new l.b7(u,e.u_device_pixel_ratio),
                        u_image: new l.bE(u,e.u_image),
                        u_units_to_pixels: new l.bJ(u,e.u_units_to_pixels),
                        u_scale: new l.bI(u,e.u_scale),
                        u_fade: new l.b7(u,e.u_fade)
                    }),
                    lineSDF: (u, e) => ({
                        u_translation: new l.bJ(u,e.u_translation),
                        u_ratio: new l.b7(u,e.u_ratio),
                        u_device_pixel_ratio: new l.b7(u,e.u_device_pixel_ratio),
                        u_units_to_pixels: new l.bJ(u,e.u_units_to_pixels),
                        u_patternscale_a: new l.bJ(u,e.u_patternscale_a),
                        u_patternscale_b: new l.bJ(u,e.u_patternscale_b),
                        u_sdfgamma: new l.b7(u,e.u_sdfgamma),
                        u_image: new l.bE(u,e.u_image),
                        u_tex_y_a: new l.b7(u,e.u_tex_y_a),
                        u_tex_y_b: new l.b7(u,e.u_tex_y_b),
                        u_mix: new l.b7(u,e.u_mix)
                    }),
                    raster: (u, e) => ({
                        u_tl_parent: new l.bJ(u,e.u_tl_parent),
                        u_scale_parent: new l.b7(u,e.u_scale_parent),
                        u_buffer_scale: new l.b7(u,e.u_buffer_scale),
                        u_fade_t: new l.b7(u,e.u_fade_t),
                        u_opacity: new l.b7(u,e.u_opacity),
                        u_image0: new l.bE(u,e.u_image0),
                        u_image1: new l.bE(u,e.u_image1),
                        u_brightness_low: new l.b7(u,e.u_brightness_low),
                        u_brightness_high: new l.b7(u,e.u_brightness_high),
                        u_saturation_factor: new l.b7(u,e.u_saturation_factor),
                        u_contrast_factor: new l.b7(u,e.u_contrast_factor),
                        u_spin_weights: new l.bI(u,e.u_spin_weights),
                        u_coords_top: new l.bH(u,e.u_coords_top),
                        u_coords_bottom: new l.bH(u,e.u_coords_bottom)
                    }),
                    symbolIcon: (u, e) => ({
                        u_is_size_zoom_constant: new l.bE(u,e.u_is_size_zoom_constant),
                        u_is_size_feature_constant: new l.bE(u,e.u_is_size_feature_constant),
                        u_size_t: new l.b7(u,e.u_size_t),
                        u_size: new l.b7(u,e.u_size),
                        u_camera_to_center_distance: new l.b7(u,e.u_camera_to_center_distance),
                        u_pitch: new l.b7(u,e.u_pitch),
                        u_rotate_symbol: new l.bE(u,e.u_rotate_symbol),
                        u_aspect_ratio: new l.b7(u,e.u_aspect_ratio),
                        u_fade_change: new l.b7(u,e.u_fade_change),
                        u_label_plane_matrix: new l.bG(u,e.u_label_plane_matrix),
                        u_coord_matrix: new l.bG(u,e.u_coord_matrix),
                        u_is_text: new l.bE(u,e.u_is_text),
                        u_pitch_with_map: new l.bE(u,e.u_pitch_with_map),
                        u_is_along_line: new l.bE(u,e.u_is_along_line),
                        u_is_variable_anchor: new l.bE(u,e.u_is_variable_anchor),
                        u_texsize: new l.bJ(u,e.u_texsize),
                        u_texture: new l.bE(u,e.u_texture),
                        u_translation: new l.bJ(u,e.u_translation),
                        u_pitched_scale: new l.b7(u,e.u_pitched_scale)
                    }),
                    symbolSDF: (u, e) => ({
                        u_is_size_zoom_constant: new l.bE(u,e.u_is_size_zoom_constant),
                        u_is_size_feature_constant: new l.bE(u,e.u_is_size_feature_constant),
                        u_size_t: new l.b7(u,e.u_size_t),
                        u_size: new l.b7(u,e.u_size),
                        u_camera_to_center_distance: new l.b7(u,e.u_camera_to_center_distance),
                        u_pitch: new l.b7(u,e.u_pitch),
                        u_rotate_symbol: new l.bE(u,e.u_rotate_symbol),
                        u_aspect_ratio: new l.b7(u,e.u_aspect_ratio),
                        u_fade_change: new l.b7(u,e.u_fade_change),
                        u_label_plane_matrix: new l.bG(u,e.u_label_plane_matrix),
                        u_coord_matrix: new l.bG(u,e.u_coord_matrix),
                        u_is_text: new l.bE(u,e.u_is_text),
                        u_pitch_with_map: new l.bE(u,e.u_pitch_with_map),
                        u_is_along_line: new l.bE(u,e.u_is_along_line),
                        u_is_variable_anchor: new l.bE(u,e.u_is_variable_anchor),
                        u_texsize: new l.bJ(u,e.u_texsize),
                        u_texture: new l.bE(u,e.u_texture),
                        u_gamma_scale: new l.b7(u,e.u_gamma_scale),
                        u_device_pixel_ratio: new l.b7(u,e.u_device_pixel_ratio),
                        u_is_halo: new l.bE(u,e.u_is_halo),
                        u_translation: new l.bJ(u,e.u_translation),
                        u_pitched_scale: new l.b7(u,e.u_pitched_scale)
                    }),
                    symbolTextAndIcon: (u, e) => ({
                        u_is_size_zoom_constant: new l.bE(u,e.u_is_size_zoom_constant),
                        u_is_size_feature_constant: new l.bE(u,e.u_is_size_feature_constant),
                        u_size_t: new l.b7(u,e.u_size_t),
                        u_size: new l.b7(u,e.u_size),
                        u_camera_to_center_distance: new l.b7(u,e.u_camera_to_center_distance),
                        u_pitch: new l.b7(u,e.u_pitch),
                        u_rotate_symbol: new l.bE(u,e.u_rotate_symbol),
                        u_aspect_ratio: new l.b7(u,e.u_aspect_ratio),
                        u_fade_change: new l.b7(u,e.u_fade_change),
                        u_label_plane_matrix: new l.bG(u,e.u_label_plane_matrix),
                        u_coord_matrix: new l.bG(u,e.u_coord_matrix),
                        u_is_text: new l.bE(u,e.u_is_text),
                        u_pitch_with_map: new l.bE(u,e.u_pitch_with_map),
                        u_is_along_line: new l.bE(u,e.u_is_along_line),
                        u_is_variable_anchor: new l.bE(u,e.u_is_variable_anchor),
                        u_texsize: new l.bJ(u,e.u_texsize),
                        u_texsize_icon: new l.bJ(u,e.u_texsize_icon),
                        u_texture: new l.bE(u,e.u_texture),
                        u_texture_icon: new l.bE(u,e.u_texture_icon),
                        u_gamma_scale: new l.b7(u,e.u_gamma_scale),
                        u_device_pixel_ratio: new l.b7(u,e.u_device_pixel_ratio),
                        u_is_halo: new l.bE(u,e.u_is_halo),
                        u_translation: new l.bJ(u,e.u_translation),
                        u_pitched_scale: new l.b7(u,e.u_pitched_scale)
                    }),
                    background: (u, e) => ({
                        u_opacity: new l.b7(u,e.u_opacity),
                        u_color: new l.bF(u,e.u_color)
                    }),
                    backgroundPattern: (u, e) => ({
                        u_opacity: new l.b7(u,e.u_opacity),
                        u_image: new l.bE(u,e.u_image),
                        u_pattern_tl_a: new l.bJ(u,e.u_pattern_tl_a),
                        u_pattern_br_a: new l.bJ(u,e.u_pattern_br_a),
                        u_pattern_tl_b: new l.bJ(u,e.u_pattern_tl_b),
                        u_pattern_br_b: new l.bJ(u,e.u_pattern_br_b),
                        u_texsize: new l.bJ(u,e.u_texsize),
                        u_mix: new l.b7(u,e.u_mix),
                        u_pattern_size_a: new l.bJ(u,e.u_pattern_size_a),
                        u_pattern_size_b: new l.bJ(u,e.u_pattern_size_b),
                        u_scale_a: new l.b7(u,e.u_scale_a),
                        u_scale_b: new l.b7(u,e.u_scale_b),
                        u_pixel_coord_upper: new l.bJ(u,e.u_pixel_coord_upper),
                        u_pixel_coord_lower: new l.bJ(u,e.u_pixel_coord_lower),
                        u_tile_units_to_pixels: new l.b7(u,e.u_tile_units_to_pixels)
                    }),
                    terrain: (u, e) => ({
                        u_texture: new l.bE(u,e.u_texture),
                        u_ele_delta: new l.b7(u,e.u_ele_delta),
                        u_fog_matrix: new l.bG(u,e.u_fog_matrix),
                        u_fog_color: new l.bF(u,e.u_fog_color),
                        u_fog_ground_blend: new l.b7(u,e.u_fog_ground_blend),
                        u_fog_ground_blend_opacity: new l.b7(u,e.u_fog_ground_blend_opacity),
                        u_horizon_color: new l.bF(u,e.u_horizon_color),
                        u_horizon_fog_blend: new l.b7(u,e.u_horizon_fog_blend),
                        u_is_globe_mode: new l.b7(u,e.u_is_globe_mode)
                    }),
                    terrainDepth: (u, e) => ({
                        u_ele_delta: new l.b7(u,e.u_ele_delta)
                    }),
                    terrainCoords: (u, e) => ({
                        u_texture: new l.bE(u,e.u_texture),
                        u_terrain_coords_id: new l.b7(u,e.u_terrain_coords_id),
                        u_ele_delta: new l.b7(u,e.u_ele_delta)
                    }),
                    projectionErrorMeasurement: (u, e) => ({
                        u_input: new l.b7(u,e.u_input),
                        u_output_expected: new l.b7(u,e.u_output_expected)
                    }),
                    atmosphere: (u, e) => ({
                        u_sun_pos: new l.bI(u,e.u_sun_pos),
                        u_atmosphere_blend: new l.b7(u,e.u_atmosphere_blend),
                        u_globe_position: new l.bI(u,e.u_globe_position),
                        u_globe_radius: new l.b7(u,e.u_globe_radius),
                        u_inv_proj_matrix: new l.bG(u,e.u_inv_proj_matrix)
                    }),
                    sky: (u, e) => ({
                        u_sky_color: new l.bF(u,e.u_sky_color),
                        u_horizon_color: new l.bF(u,e.u_horizon_color),
                        u_horizon: new l.bJ(u,e.u_horizon),
                        u_horizon_normal: new l.bJ(u,e.u_horizon_normal),
                        u_sky_horizon_blend: new l.b7(u,e.u_sky_horizon_blend),
                        u_sky_blend: new l.b7(u,e.u_sky_blend)
                    })
                };
                class Lc {
                    constructor(e, i, o) {
                        this.context = e;
                        const a = e.gl;
                        this.buffer = a.createBuffer(),
                        this.dynamicDraw = !!o,
                        this.context.unbindVAO(),
                        e.bindElementBuffer.set(this.buffer),
                        a.bufferData(a.ELEMENT_ARRAY_BUFFER, i.arrayBuffer, this.dynamicDraw ? a.DYNAMIC_DRAW : a.STATIC_DRAW),
                        this.dynamicDraw || delete i.arrayBuffer
                    }
                    bind() {
                        this.context.bindElementBuffer.set(this.buffer)
                    }
                    updateData(e) {
                        const i = this.context.gl;
                        if (!this.dynamicDraw)
                            throw new Error("Attempted to update data while not in dynamic mode.");
                        this.context.unbindVAO(),
                        this.bind(),
                        i.bufferSubData(i.ELEMENT_ARRAY_BUFFER, 0, e.arrayBuffer)
                    }
                    destroy() {
                        this.buffer && (this.context.gl.deleteBuffer(this.buffer),
                        delete this.buffer)
                    }
                }
                const dl = {
                    Int8: "BYTE",
                    Uint8: "UNSIGNED_BYTE",
                    Int16: "SHORT",
                    Uint16: "UNSIGNED_SHORT",
                    Int32: "INT",
                    Uint32: "UNSIGNED_INT",
                    Float32: "FLOAT"
                };
                class ss {
                    constructor(e, i, o, a) {
                        this.length = i.length,
                        this.attributes = o,
                        this.itemSize = i.bytesPerElement,
                        this.dynamicDraw = a,
                        this.context = e;
                        const h = e.gl;
                        this.buffer = h.createBuffer(),
                        e.bindVertexBuffer.set(this.buffer),
                        h.bufferData(h.ARRAY_BUFFER, i.arrayBuffer, this.dynamicDraw ? h.DYNAMIC_DRAW : h.STATIC_DRAW),
                        this.dynamicDraw || delete i.arrayBuffer
                    }
                    bind() {
                        this.context.bindVertexBuffer.set(this.buffer)
                    }
                    updateData(e) {
                        if (e.length !== this.length)
                            throw new Error(`Length of new data is ${e.length}, which doesn't match current length of ${this.length}`);
                        const i = this.context.gl;
                        this.bind(),
                        i.bufferSubData(i.ARRAY_BUFFER, 0, e.arrayBuffer)
                    }
                    enableAttributes(e, i) {
                        for (let o = 0; o < this.attributes.length; o++) {
                            const a = i.attributes[this.attributes[o].name];
                            a !== void 0 && e.enableVertexAttribArray(a)
                        }
                    }
                    setVertexAttribPointers(e, i, o) {
                        for (let a = 0; a < this.attributes.length; a++) {
                            const h = this.attributes[a]
                              , m = i.attributes[h.name];
                            m !== void 0 && e.vertexAttribPointer(m, h.components, e[dl[h.type]], !1, this.itemSize, h.offset + this.itemSize * (o || 0))
                        }
                    }
                    destroy() {
                        this.buffer && (this.context.gl.deleteBuffer(this.buffer),
                        delete this.buffer)
                    }
                }
                class bt {
                    constructor(e) {
                        this.gl = e.gl,
                        this.default = this.getDefault(),
                        this.current = this.default,
                        this.dirty = !1
                    }
                    get() {
                        return this.current
                    }
                    set(e) {}
                    getDefault() {
                        return this.default
                    }
                    setDefault() {
                        this.set(this.default)
                    }
                }
                class ah extends bt {
                    getDefault() {
                        return l.b6.transparent
                    }
                    set(e) {
                        const i = this.current;
                        (e.r !== i.r || e.g !== i.g || e.b !== i.b || e.a !== i.a || this.dirty) && (this.gl.clearColor(e.r, e.g, e.b, e.a),
                        this.current = e,
                        this.dirty = !1)
                    }
                }
                class lh extends bt {
                    getDefault() {
                        return 1
                    }
                    set(e) {
                        (e !== this.current || this.dirty) && (this.gl.clearDepth(e),
                        this.current = e,
                        this.dirty = !1)
                    }
                }
                class ch extends bt {
                    getDefault() {
                        return 0
                    }
                    set(e) {
                        (e !== this.current || this.dirty) && (this.gl.clearStencil(e),
                        this.current = e,
                        this.dirty = !1)
                    }
                }
                class uh extends bt {
                    getDefault() {
                        return [!0, !0, !0, !0]
                    }
                    set(e) {
                        const i = this.current;
                        (e[0] !== i[0] || e[1] !== i[1] || e[2] !== i[2] || e[3] !== i[3] || this.dirty) && (this.gl.colorMask(e[0], e[1], e[2], e[3]),
                        this.current = e,
                        this.dirty = !1)
                    }
                }
                class Dc extends bt {
                    getDefault() {
                        return !0
                    }
                    set(e) {
                        (e !== this.current || this.dirty) && (this.gl.depthMask(e),
                        this.current = e,
                        this.dirty = !1)
                    }
                }
                class hh extends bt {
                    getDefault() {
                        return 255
                    }
                    set(e) {
                        (e !== this.current || this.dirty) && (this.gl.stencilMask(e),
                        this.current = e,
                        this.dirty = !1)
                    }
                }
                class Rc extends bt {
                    getDefault() {
                        return {
                            func: this.gl.ALWAYS,
                            ref: 0,
                            mask: 255
                        }
                    }
                    set(e) {
                        const i = this.current;
                        (e.func !== i.func || e.ref !== i.ref || e.mask !== i.mask || this.dirty) && (this.gl.stencilFunc(e.func, e.ref, e.mask),
                        this.current = e,
                        this.dirty = !1)
                    }
                }
                class Wo extends bt {
                    getDefault() {
                        const e = this.gl;
                        return [e.KEEP, e.KEEP, e.KEEP]
                    }
                    set(e) {
                        const i = this.current;
                        (e[0] !== i[0] || e[1] !== i[1] || e[2] !== i[2] || this.dirty) && (this.gl.stencilOp(e[0], e[1], e[2]),
                        this.current = e,
                        this.dirty = !1)
                    }
                }
                class Xo extends bt {
                    getDefault() {
                        return !1
                    }
                    set(e) {
                        if (e === this.current && !this.dirty)
                            return;
                        const i = this.gl;
                        e ? i.enable(i.STENCIL_TEST) : i.disable(i.STENCIL_TEST),
                        this.current = e,
                        this.dirty = !1
                    }
                }
                class Ko extends bt {
                    getDefault() {
                        return [0, 1]
                    }
                    set(e) {
                        const i = this.current;
                        (e[0] !== i[0] || e[1] !== i[1] || this.dirty) && (this.gl.depthRange(e[0], e[1]),
                        this.current = e,
                        this.dirty = !1)
                    }
                }
                class pl extends bt {
                    getDefault() {
                        return !1
                    }
                    set(e) {
                        if (e === this.current && !this.dirty)
                            return;
                        const i = this.gl;
                        e ? i.enable(i.DEPTH_TEST) : i.disable(i.DEPTH_TEST),
                        this.current = e,
                        this.dirty = !1
                    }
                }
                class os extends bt {
                    getDefault() {
                        return this.gl.LESS
                    }
                    set(e) {
                        (e !== this.current || this.dirty) && (this.gl.depthFunc(e),
                        this.current = e,
                        this.dirty = !1)
                    }
                }
                class Ls extends bt {
                    getDefault() {
                        return !1
                    }
                    set(e) {
                        if (e === this.current && !this.dirty)
                            return;
                        const i = this.gl;
                        e ? i.enable(i.BLEND) : i.disable(i.BLEND),
                        this.current = e,
                        this.dirty = !1
                    }
                }
                class Er extends bt {
                    getDefault() {
                        const e = this.gl;
                        return [e.ONE, e.ZERO]
                    }
                    set(e) {
                        const i = this.current;
                        (e[0] !== i[0] || e[1] !== i[1] || this.dirty) && (this.gl.blendFunc(e[0], e[1]),
                        this.current = e,
                        this.dirty = !1)
                    }
                }
                class Fc extends bt {
                    getDefault() {
                        return l.b6.transparent
                    }
                    set(e) {
                        const i = this.current;
                        (e.r !== i.r || e.g !== i.g || e.b !== i.b || e.a !== i.a || this.dirty) && (this.gl.blendColor(e.r, e.g, e.b, e.a),
                        this.current = e,
                        this.dirty = !1)
                    }
                }
                class Bc extends bt {
                    getDefault() {
                        return this.gl.FUNC_ADD
                    }
                    set(e) {
                        (e !== this.current || this.dirty) && (this.gl.blendEquation(e),
                        this.current = e,
                        this.dirty = !1)
                    }
                }
                class fl extends bt {
                    getDefault() {
                        return !1
                    }
                    set(e) {
                        if (e === this.current && !this.dirty)
                            return;
                        const i = this.gl;
                        e ? i.enable(i.CULL_FACE) : i.disable(i.CULL_FACE),
                        this.current = e,
                        this.dirty = !1
                    }
                }
                class as extends bt {
                    getDefault() {
                        return this.gl.BACK
                    }
                    set(e) {
                        (e !== this.current || this.dirty) && (this.gl.cullFace(e),
                        this.current = e,
                        this.dirty = !1)
                    }
                }
                class Jo extends bt {
                    getDefault() {
                        return this.gl.CCW
                    }
                    set(e) {
                        (e !== this.current || this.dirty) && (this.gl.frontFace(e),
                        this.current = e,
                        this.dirty = !1)
                    }
                }
                class Yo extends bt {
                    getDefault() {
                        return null
                    }
                    set(e) {
                        (e !== this.current || this.dirty) && (this.gl.useProgram(e),
                        this.current = e,
                        this.dirty = !1)
                    }
                }
                class ho extends bt {
                    getDefault() {
                        return this.gl.TEXTURE0
                    }
                    set(e) {
                        (e !== this.current || this.dirty) && (this.gl.activeTexture(e),
                        this.current = e,
                        this.dirty = !1)
                    }
                }
                class Qo extends bt {
                    getDefault() {
                        const e = this.gl;
                        return [0, 0, e.drawingBufferWidth, e.drawingBufferHeight]
                    }
                    set(e) {
                        const i = this.current;
                        (e[0] !== i[0] || e[1] !== i[1] || e[2] !== i[2] || e[3] !== i[3] || this.dirty) && (this.gl.viewport(e[0], e[1], e[2], e[3]),
                        this.current = e,
                        this.dirty = !1)
                    }
                }
                class Oc extends bt {
                    getDefault() {
                        return null
                    }
                    set(e) {
                        if (e === this.current && !this.dirty)
                            return;
                        const i = this.gl;
                        i.bindFramebuffer(i.FRAMEBUFFER, e),
                        this.current = e,
                        this.dirty = !1
                    }
                }
                class Ds extends bt {
                    getDefault() {
                        return null
                    }
                    set(e) {
                        if (e === this.current && !this.dirty)
                            return;
                        const i = this.gl;
                        i.bindRenderbuffer(i.RENDERBUFFER, e),
                        this.current = e,
                        this.dirty = !1
                    }
                }
                class Rs extends bt {
                    getDefault() {
                        return null
                    }
                    set(e) {
                        if (e === this.current && !this.dirty)
                            return;
                        const i = this.gl;
                        i.bindTexture(i.TEXTURE_2D, e),
                        this.current = e,
                        this.dirty = !1
                    }
                }
                class Nc extends bt {
                    getDefault() {
                        return null
                    }
                    set(e) {
                        if (e === this.current && !this.dirty)
                            return;
                        const i = this.gl;
                        i.bindBuffer(i.ARRAY_BUFFER, e),
                        this.current = e,
                        this.dirty = !1
                    }
                }
                class ml extends bt {
                    getDefault() {
                        return null
                    }
                    set(e) {
                        const i = this.gl;
                        i.bindBuffer(i.ELEMENT_ARRAY_BUFFER, e),
                        this.current = e,
                        this.dirty = !1
                    }
                }
                class xt extends bt {
                    getDefault() {
                        return null
                    }
                    set(e) {
                        var i;
                        if (e === this.current && !this.dirty)
                            return;
                        const o = this.gl;
                        Ir(o) ? o.bindVertexArray(e) : (i = o.getExtension("OES_vertex_array_object")) === null || i === void 0 || i.bindVertexArrayOES(e),
                        this.current = e,
                        this.dirty = !1
                    }
                }
                class ea extends bt {
                    getDefault() {
                        return 4
                    }
                    set(e) {
                        if (e === this.current && !this.dirty)
                            return;
                        const i = this.gl;
                        i.pixelStorei(i.UNPACK_ALIGNMENT, e),
                        this.current = e,
                        this.dirty = !1
                    }
                }
                class dh extends bt {
                    getDefault() {
                        return !1
                    }
                    set(e) {
                        if (e === this.current && !this.dirty)
                            return;
                        const i = this.gl;
                        i.pixelStorei(i.UNPACK_PREMULTIPLY_ALPHA_WEBGL, e),
                        this.current = e,
                        this.dirty = !1
                    }
                }
                class jc extends bt {
                    getDefault() {
                        return !1
                    }
                    set(e) {
                        if (e === this.current && !this.dirty)
                            return;
                        const i = this.gl;
                        i.pixelStorei(i.UNPACK_FLIP_Y_WEBGL, e),
                        this.current = e,
                        this.dirty = !1
                    }
                }
                class ls extends bt {
                    constructor(e, i) {
                        super(e),
                        this.context = e,
                        this.parent = i
                    }
                    getDefault() {
                        return null
                    }
                }
                class ph extends ls {
                    setDirty() {
                        this.dirty = !0
                    }
                    set(e) {
                        if (e === this.current && !this.dirty)
                            return;
                        this.context.bindFramebuffer.set(this.parent);
                        const i = this.gl;
                        i.framebufferTexture2D(i.FRAMEBUFFER, i.COLOR_ATTACHMENT0, i.TEXTURE_2D, e, 0),
                        this.current = e,
                        this.dirty = !1
                    }
                }
                class fh extends ls {
                    set(e) {
                        if (e === this.current && !this.dirty)
                            return;
                        this.context.bindFramebuffer.set(this.parent);
                        const i = this.gl;
                        i.framebufferRenderbuffer(i.FRAMEBUFFER, i.DEPTH_ATTACHMENT, i.RENDERBUFFER, e),
                        this.current = e,
                        this.dirty = !1
                    }
                }
                class Vc extends ls {
                    set(e) {
                        if (e === this.current && !this.dirty)
                            return;
                        this.context.bindFramebuffer.set(this.parent);
                        const i = this.gl;
                        i.framebufferRenderbuffer(i.FRAMEBUFFER, i.DEPTH_STENCIL_ATTACHMENT, i.RENDERBUFFER, e),
                        this.current = e,
                        this.dirty = !1
                    }
                }
                const Uc = "Framebuffer is not complete";
                class gl {
                    constructor(e, i, o, a, h) {
                        this.context = e,
                        this.width = i,
                        this.height = o;
                        const m = e.gl
                          , y = this.framebuffer = m.createFramebuffer();
                        if (this.colorAttachment = new ph(e,y),
                        a)
                            this.depthAttachment = h ? new Vc(e,y) : new fh(e,y);
                        else if (h)
                            throw new Error("Stencil cannot be set without depth");
                        if (m.checkFramebufferStatus(m.FRAMEBUFFER) !== m.FRAMEBUFFER_COMPLETE)
                            throw new Error(Uc)
                    }
                    destroy() {
                        const e = this.context.gl
                          , i = this.colorAttachment.get();
                        if (i && e.deleteTexture(i),
                        this.depthAttachment) {
                            const o = this.depthAttachment.get();
                            o && e.deleteRenderbuffer(o)
                        }
                        e.deleteFramebuffer(this.framebuffer)
                    }
                }
                class ta {
                    constructor(e) {
                        var i, o;
                        if (this.gl = e,
                        this.clearColor = new ah(this),
                        this.clearDepth = new lh(this),
                        this.clearStencil = new ch(this),
                        this.colorMask = new uh(this),
                        this.depthMask = new Dc(this),
                        this.stencilMask = new hh(this),
                        this.stencilFunc = new Rc(this),
                        this.stencilOp = new Wo(this),
                        this.stencilTest = new Xo(this),
                        this.depthRange = new Ko(this),
                        this.depthTest = new pl(this),
                        this.depthFunc = new os(this),
                        this.blend = new Ls(this),
                        this.blendFunc = new Er(this),
                        this.blendColor = new Fc(this),
                        this.blendEquation = new Bc(this),
                        this.cullFace = new fl(this),
                        this.cullFaceSide = new as(this),
                        this.frontFace = new Jo(this),
                        this.program = new Yo(this),
                        this.activeTexture = new ho(this),
                        this.viewport = new Qo(this),
                        this.bindFramebuffer = new Oc(this),
                        this.bindRenderbuffer = new Ds(this),
                        this.bindTexture = new Rs(this),
                        this.bindVertexBuffer = new Nc(this),
                        this.bindElementBuffer = new ml(this),
                        this.bindVertexArray = new xt(this),
                        this.pixelStoreUnpack = new ea(this),
                        this.pixelStoreUnpackPremultiplyAlpha = new dh(this),
                        this.pixelStoreUnpackFlipY = new jc(this),
                        this.extTextureFilterAnisotropic = e.getExtension("EXT_texture_filter_anisotropic") || e.getExtension("MOZ_EXT_texture_filter_anisotropic") || e.getExtension("WEBKIT_EXT_texture_filter_anisotropic"),
                        this.extTextureFilterAnisotropic && (this.extTextureFilterAnisotropicMax = e.getParameter(this.extTextureFilterAnisotropic.MAX_TEXTURE_MAX_ANISOTROPY_EXT)),
                        this.maxTextureSize = e.getParameter(e.MAX_TEXTURE_SIZE),
                        Ir(e)) {
                            this.HALF_FLOAT = e.HALF_FLOAT;
                            const a = e.getExtension("EXT_color_buffer_half_float");
                            this.RGBA16F = (i = e.RGBA16F) !== null && i !== void 0 ? i : a?.RGBA16F_EXT,
                            this.RGB16F = (o = e.RGB16F) !== null && o !== void 0 ? o : a?.RGB16F_EXT,
                            e.getExtension("EXT_color_buffer_float")
                        } else {
                            e.getExtension("EXT_color_buffer_half_float"),
                            e.getExtension("OES_texture_half_float_linear");
                            const a = e.getExtension("OES_texture_half_float");
                            this.HALF_FLOAT = a?.HALF_FLOAT_OES
                        }
                    }
                    setDefault() {
                        this.unbindVAO(),
                        this.clearColor.setDefault(),
                        this.clearDepth.setDefault(),
                        this.clearStencil.setDefault(),
                        this.colorMask.setDefault(),
                        this.depthMask.setDefault(),
                        this.stencilMask.setDefault(),
                        this.stencilFunc.setDefault(),
                        this.stencilOp.setDefault(),
                        this.stencilTest.setDefault(),
                        this.depthRange.setDefault(),
                        this.depthTest.setDefault(),
                        this.depthFunc.setDefault(),
                        this.blend.setDefault(),
                        this.blendFunc.setDefault(),
                        this.blendColor.setDefault(),
                        this.blendEquation.setDefault(),
                        this.cullFace.setDefault(),
                        this.cullFaceSide.setDefault(),
                        this.frontFace.setDefault(),
                        this.program.setDefault(),
                        this.activeTexture.setDefault(),
                        this.bindFramebuffer.setDefault(),
                        this.pixelStoreUnpack.setDefault(),
                        this.pixelStoreUnpackPremultiplyAlpha.setDefault(),
                        this.pixelStoreUnpackFlipY.setDefault()
                    }
                    setDirty() {
                        this.clearColor.dirty = !0,
                        this.clearDepth.dirty = !0,
                        this.clearStencil.dirty = !0,
                        this.colorMask.dirty = !0,
                        this.depthMask.dirty = !0,
                        this.stencilMask.dirty = !0,
                        this.stencilFunc.dirty = !0,
                        this.stencilOp.dirty = !0,
                        this.stencilTest.dirty = !0,
                        this.depthRange.dirty = !0,
                        this.depthTest.dirty = !0,
                        this.depthFunc.dirty = !0,
                        this.blend.dirty = !0,
                        this.blendFunc.dirty = !0,
                        this.blendColor.dirty = !0,
                        this.blendEquation.dirty = !0,
                        this.cullFace.dirty = !0,
                        this.cullFaceSide.dirty = !0,
                        this.frontFace.dirty = !0,
                        this.program.dirty = !0,
                        this.activeTexture.dirty = !0,
                        this.viewport.dirty = !0,
                        this.bindFramebuffer.dirty = !0,
                        this.bindRenderbuffer.dirty = !0,
                        this.bindTexture.dirty = !0,
                        this.bindVertexBuffer.dirty = !0,
                        this.bindElementBuffer.dirty = !0,
                        this.bindVertexArray.dirty = !0,
                        this.pixelStoreUnpack.dirty = !0,
                        this.pixelStoreUnpackPremultiplyAlpha.dirty = !0,
                        this.pixelStoreUnpackFlipY.dirty = !0
                    }
                    createIndexBuffer(e, i) {
                        return new Lc(this,e,i)
                    }
                    createVertexBuffer(e, i, o) {
                        return new ss(this,e,i,o)
                    }
                    createRenderbuffer(e, i, o) {
                        const a = this.gl
                          , h = a.createRenderbuffer();
                        return this.bindRenderbuffer.set(h),
                        a.renderbufferStorage(a.RENDERBUFFER, e, i, o),
                        this.bindRenderbuffer.set(null),
                        h
                    }
                    createFramebuffer(e, i, o, a) {
                        return new gl(this,e,i,o,a)
                    }
                    clear({color: e, depth: i, stencil: o}) {
                        const a = this.gl;
                        let h = 0;
                        e && (h |= a.COLOR_BUFFER_BIT,
                        this.clearColor.set(e),
                        this.colorMask.set([!0, !0, !0, !0])),
                        i !== void 0 && (h |= a.DEPTH_BUFFER_BIT,
                        this.depthRange.set([0, 1]),
                        this.clearDepth.set(i),
                        this.depthMask.set(!0)),
                        o !== void 0 && (h |= a.STENCIL_BUFFER_BIT,
                        this.clearStencil.set(o),
                        this.stencilMask.set(255)),
                        a.clear(h)
                    }
                    setCullFace(e) {
                        e.enable === !1 ? this.cullFace.set(!1) : (this.cullFace.set(!0),
                        this.cullFaceSide.set(e.mode),
                        this.frontFace.set(e.frontFace))
                    }
                    setDepthMode(e) {
                        e.func !== this.gl.ALWAYS || e.mask ? (this.depthTest.set(!0),
                        this.depthFunc.set(e.func),
                        this.depthMask.set(e.mask),
                        this.depthRange.set(e.range)) : this.depthTest.set(!1)
                    }
                    setStencilMode(e) {
                        e.test.func !== this.gl.ALWAYS || e.mask ? (this.stencilTest.set(!0),
                        this.stencilMask.set(e.mask),
                        this.stencilOp.set([e.fail, e.depthFail, e.pass]),
                        this.stencilFunc.set({
                            func: e.test.func,
                            ref: e.ref,
                            mask: e.test.mask
                        })) : this.stencilTest.set(!1)
                    }
                    setColorMode(e) {
                        l.bB(e.blendFunction, Vt.Replace) ? this.blend.set(!1) : (this.blend.set(!0),
                        this.blendFunc.set(e.blendFunction),
                        this.blendColor.set(e.blendColor)),
                        this.colorMask.set(e.mask)
                    }
                    createVertexArray() {
                        var e;
                        return Ir(this.gl) ? this.gl.createVertexArray() : (e = this.gl.getExtension("OES_vertex_array_object")) === null || e === void 0 ? void 0 : e.createVertexArrayOES()
                    }
                    deleteVertexArray(e) {
                        var i;
                        return Ir(this.gl) ? this.gl.deleteVertexArray(e) : (i = this.gl.getExtension("OES_vertex_array_object")) === null || i === void 0 ? void 0 : i.deleteVertexArrayOES(e)
                    }
                    unbindVAO() {
                        this.bindVertexArray.set(null)
                    }
                }
                let cs;
                function ia(u, e, i, o, a) {
                    const h = u.context
                      , m = u.transform
                      , y = h.gl
                      , v = u.useProgram("collisionBox")
                      , T = [];
                    let S = 0
                      , A = 0;
                    for (let W = 0; W < o.length; W++) {
                        const J = o[W]
                          , te = e.getTile(J).getBucket(i);
                        if (!te)
                            continue;
                        const ie = a ? te.textCollisionBox : te.iconCollisionBox
                          , ne = te.collisionCircleArray;
                        ne.length > 0 && (T.push({
                            circleArray: ne,
                            circleOffset: A,
                            coord: J
                        }),
                        S += ne.length / 4,
                        A = S),
                        ie && v.draw(h, y.LINES, ot.disabled, mt.disabled, u.colorModeForRenderPass(), pt.disabled, nl(u.transform), u.style.map.terrain && u.style.map.terrain.getTerrainData(J), m.getProjectionData({
                            overscaledTileID: J,
                            applyGlobeMatrix: !0,
                            applyTerrainMatrix: !0
                        }), i.id, ie.layoutVertexBuffer, ie.indexBuffer, ie.segments, null, u.transform.zoom, null, null, ie.collisionVertexBuffer)
                    }
                    if (!a || !T.length)
                        return;
                    const k = u.useProgram("collisionCircle")
                      , O = new l.bO;
                    O.resize(4 * S),
                    O._trim();
                    let V = 0;
                    for (const W of T)
                        for (let J = 0; J < W.circleArray.length / 4; J++) {
                            const te = 4 * J
                              , ie = W.circleArray[te + 0]
                              , ne = W.circleArray[te + 1]
                              , le = W.circleArray[te + 2]
                              , se = W.circleArray[te + 3];
                            O.emplace(V++, ie, ne, le, se, 0),
                            O.emplace(V++, ie, ne, le, se, 1),
                            O.emplace(V++, ie, ne, le, se, 2),
                            O.emplace(V++, ie, ne, le, se, 3)
                        }
                    (!cs || cs.length < 2 * S) && (cs = function(W) {
                        const J = 2 * W
                          , te = new l.bQ;
                        te.resize(J),
                        te._trim();
                        for (let ie = 0; ie < J; ie++) {
                            const ne = 6 * ie;
                            te.uint16[ne + 0] = 4 * ie + 0,
                            te.uint16[ne + 1] = 4 * ie + 1,
                            te.uint16[ne + 2] = 4 * ie + 2,
                            te.uint16[ne + 3] = 4 * ie + 2,
                            te.uint16[ne + 4] = 4 * ie + 3,
                            te.uint16[ne + 5] = 4 * ie + 0
                        }
                        return te
                    }(S));
                    const H = h.createIndexBuffer(cs, !0)
                      , q = h.createVertexBuffer(O, l.bP.members, !0);
                    for (const W of T) {
                        const J = Sc(u.transform);
                        k.draw(h, y.TRIANGLES, ot.disabled, mt.disabled, u.colorModeForRenderPass(), pt.disabled, J, u.style.map.terrain && u.style.map.terrain.getTerrainData(W.coord), null, i.id, q, H, l.aF.simpleSegment(0, 2 * W.circleOffset, W.circleArray.length, W.circleArray.length / 2), null, u.transform.zoom, null, null, null)
                    }
                    q.destroy(),
                    H.destroy()
                }
                const _l = l.as(new Float32Array(16));
                function Zc(u, e, i, o, a, h) {
                    const {horizontalAlign: m, verticalAlign: y} = l.aA(u);
                    return new l.P((-(m - .5) * e / a + o[0]) * h,(-(y - .5) * i / a + o[1]) * h)
                }
                function ra(u, e, i, o, a, h) {
                    const m = e.tileAnchorPoint.add(new l.P(e.translation[0],e.translation[1]));
                    if (e.pitchWithMap) {
                        let y = o.mult(h);
                        i || (y = y.rotate(-a));
                        const v = m.add(y);
                        return we(v.x, v.y, e.pitchedLabelPlaneMatrix, e.getElevation).point
                    }
                    if (i) {
                        const y = Ge(e.tileAnchorPoint.x + 1, e.tileAnchorPoint.y, e).point.sub(u)
                          , v = Math.atan(y.y / y.x) + (y.x < 0 ? Math.PI : 0);
                        return u.add(o.rotate(v))
                    }
                    return u.add(o)
                }
                function na(u, e, i, o, a, h, m, y, v, T, S, A) {
                    const k = u.text.placedSymbolArray
                      , O = u.text.dynamicLayoutVertexArray
                      , V = u.icon.dynamicLayoutVertexArray
                      , H = {};
                    O.clear();
                    for (let q = 0; q < k.length; q++) {
                        const W = k.get(q)
                          , J = W.hidden || !W.crossTileID || u.allowVerticalPlacement && !W.placedOrientation ? null : o[W.crossTileID];
                        if (J) {
                            const te = new l.P(W.anchorX,W.anchorY)
                              , ie = {
                                getElevation: A,
                                width: a.width,
                                height: a.height,
                                pitchedLabelPlaneMatrix: h,
                                pitchWithMap: i,
                                transform: a,
                                tileAnchorPoint: te,
                                translation: T,
                                unwrappedTileID: S
                            }
                              , ne = i ? at(te.x, te.y, ie) : Ge(te.x, te.y, ie)
                              , le = fe(a.cameraToCenterDistance, ne.signedDistanceFromCamera);
                            let se = l.ah(u.textSizeData, y, W) * le / l.au;
                            i && (se *= u.tilePixelRatio / m);
                            const {width: _e, height: xe, anchor: Pe, textOffset: Ie, textBoxScale: Ce} = J
                              , Ne = Zc(Pe, _e, xe, Ie, Ce, se)
                              , Oe = a.getPitchedTextCorrection(te.x + T[0], te.y + T[1], S)
                              , De = ra(ne.point, ie, e, Ne, -a.bearingInRadians, Oe)
                              , $e = u.allowVerticalPlacement && W.placedOrientation === l.ag.vertical ? Math.PI / 2 : 0;
                            for (let Ke = 0; Ke < W.numGlyphs; Ke++)
                                l.an(O, De, $e);
                            v && W.associatedIconIndex >= 0 && (H[W.associatedIconIndex] = {
                                shiftedAnchor: De,
                                angle: $e
                            })
                        } else
                            ui(W.numGlyphs, O)
                    }
                    if (v) {
                        V.clear();
                        const q = u.icon.placedSymbolArray;
                        for (let W = 0; W < q.length; W++) {
                            const J = q.get(W);
                            if (J.hidden)
                                ui(J.numGlyphs, V);
                            else {
                                const te = H[W];
                                if (te)
                                    for (let ie = 0; ie < J.numGlyphs; ie++)
                                        l.an(V, te.shiftedAnchor, te.angle);
                                else
                                    ui(J.numGlyphs, V)
                            }
                        }
                        u.icon.dynamicLayoutVertexBuffer.updateData(V)
                    }
                    u.text.dynamicLayoutVertexBuffer.updateData(O)
                }
                function yl(u, e, i) {
                    return i.iconsInText && e ? "symbolTextAndIcon" : u ? "symbolSDF" : "symbolIcon"
                }
                function Gc(u, e, i, o, a, h, m, y, v, T, S, A, k) {
                    const O = u.context
                      , V = O.gl
                      , H = u.transform
                      , q = y === "map"
                      , W = v === "map"
                      , J = y !== "viewport" && i.layout.get("symbol-placement") !== "point"
                      , te = q && !W && !J
                      , ie = !i.layout.get("symbol-sort-key").isConstant();
                    let ne = !1;
                    const le = u.getDepthModeForSublayer(0, ot.ReadOnly)
                      , se = i._unevaluatedLayout.hasValue("text-variable-anchor") || i._unevaluatedLayout.hasValue("text-variable-anchor-offset")
                      , _e = []
                      , xe = H.getCircleRadiusCorrection();
                    for (const Pe of o) {
                        const Ie = e.getTile(Pe)
                          , Ce = Ie.getBucket(i);
                        if (!Ce)
                            continue;
                        const Ne = a ? Ce.text : Ce.icon;
                        if (!Ne || !Ne.segments.get().length || !Ne.hasVisibleVertices)
                            continue;
                        const Oe = Ne.programConfigurations.get(i.id)
                          , De = a || Ce.sdfIcons
                          , $e = a ? Ce.textSizeData : Ce.iconSizeData
                          , Ke = W || H.pitch !== 0
                          , wt = u.useProgram(yl(De, a, Ce), Oe)
                          , Dt = l.af($e, H.zoom)
                          , Et = u.style.map.terrain && u.style.map.terrain.getTerrainData(Pe);
                        let Zt, Ot, Ct, At, Ei = [0, 0], Ai = null;
                        if (a)
                            Ot = Ie.glyphAtlasTexture,
                            Ct = V.LINEAR,
                            Zt = Ie.glyphAtlasTexture.size,
                            Ce.iconsInText && (Ei = Ie.imageAtlasTexture.size,
                            Ai = Ie.imageAtlasTexture,
                            At = Ke || u.options.rotating || u.options.zooming || $e.kind === "composite" || $e.kind === "camera" ? V.LINEAR : V.NEAREST);
                        else {
                            const Rt = i.layout.get("icon-size").constantOr(0) !== 1 || Ce.iconsNeedLinear;
                            Ot = Ie.imageAtlasTexture,
                            Ct = De || u.options.rotating || u.options.zooming || Rt || Ke ? V.LINEAR : V.NEAREST,
                            Zt = Ie.imageAtlasTexture.size
                        }
                        const vi = l.av(Ie, 1, u.transform.zoom)
                          , Bi = ve(q, u.transform, vi)
                          , Un = l.K();
                        l.ai(Un, Bi);
                        const vn = ue(W, q, u.transform, vi)
                          , an = l.aw(H, Ie, h, m)
                          , kr = H.getProjectionData({
                            overscaledTileID: Pe,
                            applyGlobeMatrix: !k,
                            applyTerrainMatrix: !0
                        })
                          , ms = se && Ce.hasTextData()
                          , To = i.layout.get("icon-text-fit") !== "none" && ms && Ce.hasIconData();
                        if (J) {
                            const Rt = u.style.map.terrain ? (bi, wi) => u.style.map.terrain.getElevation(Pe, bi, wi) : null
                              , kt = i.layout.get("text-rotation-alignment") === "map";
                            me(Ce, u, a, Bi, Un, W, T, kt, Pe.toUnwrapped(), H.width, H.height, an, Rt)
                        }
                        const gs = a && se || To
                          , Lr = J || gs ? _l : W ? Bi : u.transform.clipSpaceToPixelsMatrix
                          , ln = De && i.paint.get(a ? "text-halo-width" : "icon-halo-width").constantOr(1) !== 0;
                        let Zr;
                        Zr = De ? Ce.iconsInText ? qo($e.kind, Dt, te, W, J, gs, u, Lr, vn, an, Zt, Ei, xe) : cl($e.kind, Dt, te, W, J, gs, u, Lr, vn, an, a, Zt, 0, xe) : $o($e.kind, Dt, te, W, J, gs, u, Lr, vn, an, a, Zt, xe);
                        const cn = {
                            program: wt,
                            buffers: Ne,
                            uniformValues: Zr,
                            projectionData: kr,
                            atlasTexture: Ot,
                            atlasTextureIcon: Ai,
                            atlasInterpolation: Ct,
                            atlasInterpolationIcon: At,
                            isSDF: De,
                            hasHalo: ln
                        };
                        if (ie && Ce.canOverlap) {
                            ne = !0;
                            const Rt = Ne.segments.get();
                            for (const kt of Rt)
                                _e.push({
                                    segments: new l.aF([kt]),
                                    sortKey: kt.sortKey,
                                    state: cn,
                                    terrainData: Et
                                })
                        } else
                            _e.push({
                                segments: Ne.segments,
                                sortKey: 0,
                                state: cn,
                                terrainData: Et
                            })
                    }
                    ne && _e.sort( (Pe, Ie) => Pe.sortKey - Ie.sortKey);
                    for (const Pe of _e) {
                        const Ie = Pe.state;
                        if (O.activeTexture.set(V.TEXTURE0),
                        Ie.atlasTexture.bind(Ie.atlasInterpolation, V.CLAMP_TO_EDGE),
                        Ie.atlasTextureIcon && (O.activeTexture.set(V.TEXTURE1),
                        Ie.atlasTextureIcon && Ie.atlasTextureIcon.bind(Ie.atlasInterpolationIcon, V.CLAMP_TO_EDGE)),
                        Ie.isSDF) {
                            const Ce = Ie.uniformValues;
                            Ie.hasHalo && (Ce.u_is_halo = 1,
                            sa(Ie.buffers, Pe.segments, i, u, Ie.program, le, S, A, Ce, Ie.projectionData, Pe.terrainData)),
                            Ce.u_is_halo = 0
                        }
                        sa(Ie.buffers, Pe.segments, i, u, Ie.program, le, S, A, Ie.uniformValues, Ie.projectionData, Pe.terrainData)
                    }
                }
                function sa(u, e, i, o, a, h, m, y, v, T, S) {
                    const A = o.context;
                    a.draw(A, A.gl.TRIANGLES, h, m, y, pt.backCCW, v, S, T, i.id, u.layoutVertexBuffer, u.indexBuffer, e, i.paint, o.transform.zoom, u.programConfigurations.get(i.id), u.dynamicLayoutVertexBuffer, u.opacityVertexBuffer)
                }
                function mh(u, e, i, o, a) {
                    const h = u.context
                      , m = h.gl
                      , y = mt.disabled
                      , v = new Vt([m.ONE, m.ONE],l.b6.transparent,[!0, !0, !0, !0])
                      , T = e.getBucket(i);
                    if (!T)
                        return;
                    const S = o.key;
                    let A = i.heatmapFbos.get(S);
                    A || (A = po(h, e.tileSize, e.tileSize),
                    i.heatmapFbos.set(S, A)),
                    h.bindFramebuffer.set(A.framebuffer),
                    h.viewport.set([0, 0, e.tileSize, e.tileSize]),
                    h.clear({
                        color: l.b6.transparent
                    });
                    const k = T.programConfigurations.get(i.id)
                      , O = u.useProgram("heatmap", k, !a)
                      , V = u.transform.getProjectionData({
                        overscaledTileID: e.tileID,
                        applyGlobeMatrix: !0,
                        applyTerrainMatrix: !0
                    })
                      , H = u.style.map.terrain.getTerrainData(o);
                    O.draw(h, m.TRIANGLES, ot.disabled, y, v, pt.disabled, ol(e, u.transform.zoom, i.paint.get("heatmap-intensity"), 1), H, V, i.id, T.layoutVertexBuffer, T.indexBuffer, T.segments, i.paint, u.transform.zoom, k)
                }
                function $c(u, e, i, o, a) {
                    const h = u.context
                      , m = h.gl
                      , y = u.transform;
                    h.setColorMode(u.colorModeForRenderPass());
                    const v = oa(h, e)
                      , T = i.key
                      , S = e.heatmapFbos.get(T);
                    if (!S)
                        return;
                    h.activeTexture.set(m.TEXTURE0),
                    m.bindTexture(m.TEXTURE_2D, S.colorAttachment.get()),
                    h.activeTexture.set(m.TEXTURE1),
                    v.bind(m.LINEAR, m.CLAMP_TO_EDGE);
                    const A = y.getProjectionData({
                        overscaledTileID: i,
                        applyTerrainMatrix: a,
                        applyGlobeMatrix: !o
                    });
                    u.useProgram("heatmapTexture").draw(h, m.TRIANGLES, ot.disabled, mt.disabled, u.colorModeForRenderPass(), pt.disabled, al(u, e, 0, 1), null, A, e.id, u.rasterBoundsBuffer, u.quadTriangleIndexBuffer, u.rasterBoundsSegments, e.paint, y.zoom),
                    S.destroy(),
                    e.heatmapFbos.delete(T)
                }
                function po(u, e, i) {
                    var o, a;
                    const h = u.gl
                      , m = h.createTexture();
                    h.bindTexture(h.TEXTURE_2D, m),
                    h.texParameteri(h.TEXTURE_2D, h.TEXTURE_WRAP_S, h.CLAMP_TO_EDGE),
                    h.texParameteri(h.TEXTURE_2D, h.TEXTURE_WRAP_T, h.CLAMP_TO_EDGE),
                    h.texParameteri(h.TEXTURE_2D, h.TEXTURE_MIN_FILTER, h.LINEAR),
                    h.texParameteri(h.TEXTURE_2D, h.TEXTURE_MAG_FILTER, h.LINEAR);
                    const y = (o = u.HALF_FLOAT) !== null && o !== void 0 ? o : h.UNSIGNED_BYTE
                      , v = (a = u.RGBA16F) !== null && a !== void 0 ? a : h.RGBA;
                    h.texImage2D(h.TEXTURE_2D, 0, v, e, i, 0, h.RGBA, y, null);
                    const T = u.createFramebuffer(e, i, !1, !1);
                    return T.colorAttachment.set(m),
                    T
                }
                function oa(u, e) {
                    return e.colorRampTexture || (e.colorRampTexture = new It(u,e.colorRamp,u.gl.RGBA)),
                    e.colorRampTexture
                }
                function xl(u, e, i, o, a) {
                    if (!i || !o || !o.imageAtlas)
                        return;
                    const h = o.imageAtlas.patternPositions;
                    let m = h[i.to.toString()]
                      , y = h[i.from.toString()];
                    if (!m && y && (m = y),
                    !y && m && (y = m),
                    !m || !y) {
                        const v = a.getPaintProperty(e);
                        m = h[v],
                        y = h[v]
                    }
                    m && y && u.setConstantPatternPositions(m, y)
                }
                function vl(u, e, i, o, a, h, m, y) {
                    const v = u.context.gl
                      , T = "fill-pattern"
                      , S = i.paint.get(T)
                      , A = S && S.constantOr(1)
                      , k = i.getCrossfadeParameters();
                    let O, V, H, q, W;
                    const J = u.transform
                      , te = i.paint.get("fill-translate")
                      , ie = i.paint.get("fill-translate-anchor");
                    m ? (V = A && !i.getPaintProperty("fill-outline-color") ? "fillOutlinePattern" : "fillOutline",
                    O = v.LINES) : (V = A ? "fillPattern" : "fill",
                    O = v.TRIANGLES);
                    const ne = S.constantOr(null);
                    for (const le of o) {
                        const se = e.getTile(le);
                        if (A && !se.patternsLoaded())
                            continue;
                        const _e = se.getBucket(i);
                        if (!_e)
                            continue;
                        const xe = _e.programConfigurations.get(i.id)
                          , Pe = u.useProgram(V, xe)
                          , Ie = u.style.map.terrain && u.style.map.terrain.getTerrainData(le);
                        A && (u.context.activeTexture.set(v.TEXTURE0),
                        se.imageAtlasTexture.bind(v.LINEAR, v.CLAMP_TO_EDGE),
                        xe.updatePaintBuffers(k)),
                        xl(xe, T, ne, se, i);
                        const Ce = J.getProjectionData({
                            overscaledTileID: le,
                            applyGlobeMatrix: !y,
                            applyTerrainMatrix: !0
                        })
                          , Ne = l.aw(J, se, te, ie);
                        if (m) {
                            q = _e.indexBuffer2,
                            W = _e.segments2;
                            const De = [v.drawingBufferWidth, v.drawingBufferHeight];
                            H = V === "fillOutlinePattern" && A ? nh(u, k, se, De, Ne) : Cc(De, Ne)
                        } else
                            q = _e.indexBuffer,
                            W = _e.segments,
                            H = A ? Mc(u, k, se, Ne) : {
                                u_fill_translate: Ne
                            };
                        let Oe;
                        if (u.renderPass === "translucent" && y) {
                            const [De] = u.getStencilConfigForOverlapAndUpdateStencilID(o);
                            Oe = De[le.overscaledZ]
                        } else
                            Oe = u.stencilModeForClipping(le);
                        Pe.draw(u.context, O, a, Oe, h, pt.backCCW, H, Ie, Ce, i.id, _e.layoutVertexBuffer, q, W, i.paint, u.transform.zoom, xe)
                    }
                }
                function Fs(u, e, i, o, a, h, m, y) {
                    const v = u.context
                      , T = v.gl
                      , S = "fill-extrusion-pattern"
                      , A = i.paint.get(S)
                      , k = A.constantOr(1)
                      , O = i.getCrossfadeParameters()
                      , V = i.paint.get("fill-extrusion-opacity")
                      , H = A.constantOr(null)
                      , q = u.transform;
                    for (const W of o) {
                        const J = e.getTile(W)
                          , te = J.getBucket(i);
                        if (!te)
                            continue;
                        const ie = u.style.map.terrain && u.style.map.terrain.getTerrainData(W)
                          , ne = te.programConfigurations.get(i.id)
                          , le = u.useProgram(k ? "fillExtrusionPattern" : "fillExtrusion", ne);
                        k && (u.context.activeTexture.set(T.TEXTURE0),
                        J.imageAtlasTexture.bind(T.LINEAR, T.CLAMP_TO_EDGE),
                        ne.updatePaintBuffers(O));
                        const se = q.getProjectionData({
                            overscaledTileID: W,
                            applyGlobeMatrix: !y,
                            applyTerrainMatrix: !0
                        });
                        xl(ne, S, H, J, i);
                        const _e = l.aw(q, J, i.paint.get("fill-extrusion-translate"), i.paint.get("fill-extrusion-translate-anchor"))
                          , xe = i.paint.get("fill-extrusion-vertical-gradient")
                          , Pe = k ? ks(u, xe, V, _e, W, O, J) : Tc(u, xe, V, _e);
                        le.draw(v, v.gl.TRIANGLES, a, h, m, pt.backCCW, Pe, ie, se, i.id, te.layoutVertexBuffer, te.indexBuffer, te.segments, i.paint, u.transform.zoom, ne, u.style.map.terrain && te.centroidVertexBuffer)
                    }
                }
                function fo(u, e, i, o, a, h, m, y, v) {
                    var T;
                    const S = u.style.projection
                      , A = u.context
                      , k = u.transform
                      , O = A.gl
                      , V = u.useProgram("hillshade")
                      , H = !u.options.moving;
                    for (const q of o) {
                        const W = e.getTile(q)
                          , J = W.fbo;
                        if (!J)
                            continue;
                        const te = S.getMeshFromTileID(A, q.canonical, y, !0, "raster")
                          , ie = (T = u.style.map.terrain) === null || T === void 0 ? void 0 : T.getTerrainData(q);
                        A.activeTexture.set(O.TEXTURE0),
                        O.bindTexture(O.TEXTURE_2D, J.colorAttachment.get());
                        const ne = k.getProjectionData({
                            overscaledTileID: q,
                            aligned: H,
                            applyGlobeMatrix: !v,
                            applyTerrainMatrix: !0
                        });
                        V.draw(A, O.TRIANGLES, h, a[q.overscaledZ], m, pt.backCCW, rs(u, W, i), ie, ne, i.id, te.vertexBuffer, te.indexBuffer, te.segments)
                    }
                }
                const bl = [new l.P(0,0), new l.P(l.Z,0), new l.P(l.Z,l.Z), new l.P(0,l.Z)];
                function mo(u, e, i, o, a, h, m, y, v=!1, T=!1) {
                    const S = o[o.length - 1].overscaledZ
                      , A = u.context
                      , k = A.gl
                      , O = u.useProgram("raster")
                      , V = u.transform
                      , H = u.style.projection
                      , q = u.colorModeForRenderPass()
                      , W = !u.options.moving;
                    for (const J of o) {
                        const te = u.getDepthModeForSublayer(J.overscaledZ - S, i.paint.get("raster-opacity") === 1 ? ot.ReadWrite : ot.ReadOnly, k.LESS)
                          , ie = e.getTile(J);
                        ie.registerFadeDuration(i.paint.get("raster-fade-duration"));
                        const ne = e.findLoadedParent(J, 0)
                          , le = e.findLoadedSibling(J)
                          , se = ri(ie, ne || le || null, e, i, u.transform, u.style.map.terrain);
                        let _e, xe;
                        const Pe = i.paint.get("raster-resampling") === "nearest" ? k.NEAREST : k.LINEAR;
                        A.activeTexture.set(k.TEXTURE0),
                        ie.texture.bind(Pe, k.CLAMP_TO_EDGE, k.LINEAR_MIPMAP_NEAREST),
                        A.activeTexture.set(k.TEXTURE1),
                        ne ? (ne.texture.bind(Pe, k.CLAMP_TO_EDGE, k.LINEAR_MIPMAP_NEAREST),
                        _e = Math.pow(2, ne.tileID.overscaledZ - ie.tileID.overscaledZ),
                        xe = [ie.tileID.canonical.x * _e % 1, ie.tileID.canonical.y * _e % 1]) : ie.texture.bind(Pe, k.CLAMP_TO_EDGE, k.LINEAR_MIPMAP_NEAREST),
                        ie.texture.useMipmap && A.extTextureFilterAnisotropic && u.transform.pitch > 20 && k.texParameterf(k.TEXTURE_2D, A.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, A.extTextureFilterAnisotropicMax);
                        const Ie = u.style.map.terrain && u.style.map.terrain.getTerrainData(J)
                          , Ce = V.getProjectionData({
                            overscaledTileID: J,
                            aligned: W,
                            applyGlobeMatrix: !T,
                            applyTerrainMatrix: !0
                        })
                          , Ne = zc(xe || [0, 0], _e || 1, se, i, y)
                          , Oe = H.getMeshFromTileID(A, J.canonical, h, m, "raster");
                        O.draw(A, k.TRIANGLES, te, a ? a[J.overscaledZ] : mt.disabled, q, v ? pt.frontCCW : pt.backCCW, Ne, Ie, Ce, i.id, Oe.vertexBuffer, Oe.indexBuffer, Oe.segments)
                    }
                }
                function ri(u, e, i, o, a, h) {
                    const m = o.paint.get("raster-fade-duration");
                    if (!h && m > 0) {
                        const y = oe.now()
                          , v = (y - u.timeAdded) / m
                          , T = e ? (y - e.timeAdded) / m : -1
                          , S = i.getSource()
                          , A = _n(a, {
                            tileSize: S.tileSize,
                            roundZoom: S.roundZoom
                        })
                          , k = !e || Math.abs(e.tileID.overscaledZ - A) > Math.abs(u.tileID.overscaledZ - A)
                          , O = k && u.refreshedUponExpiration ? 1 : l.ad(k ? v : 1 - T, 0, 1);
                        return u.refreshedUponExpiration && v >= 1 && (u.refreshedUponExpiration = !1),
                        e ? {
                            opacity: 1,
                            mix: 1 - O
                        } : {
                            opacity: O,
                            mix: 0
                        }
                    }
                    return {
                        opacity: 1,
                        mix: 0
                    }
                }
                const us = new l.b6(1,0,0,1)
                  , Ar = new l.b6(0,1,0,1)
                  , wl = new l.b6(0,0,1,1)
                  , Tl = new l.b6(1,0,1,1)
                  , qc = new l.b6(0,1,1,1);
                function hs(u, e, i, o) {
                    Os(u, 0, e + i / 2, u.transform.width, i, o)
                }
                function Bs(u, e, i, o) {
                    Os(u, e - i / 2, 0, i, u.transform.height, o)
                }
                function Os(u, e, i, o, a, h) {
                    const m = u.context
                      , y = m.gl;
                    y.enable(y.SCISSOR_TEST),
                    y.scissor(e * u.pixelRatio, i * u.pixelRatio, o * u.pixelRatio, a * u.pixelRatio),
                    m.clear({
                        color: h
                    }),
                    y.disable(y.SCISSOR_TEST)
                }
                function Hc(u, e, i) {
                    const o = u.context
                      , a = o.gl
                      , h = u.useProgram("debug")
                      , m = ot.disabled
                      , y = mt.disabled
                      , v = u.colorModeForRenderPass()
                      , T = "$debug"
                      , S = u.style.map.terrain && u.style.map.terrain.getTerrainData(i);
                    o.activeTexture.set(a.TEXTURE0);
                    const A = e.getTileByID(i.key).latestRawTileData
                      , k = Math.floor((A && A.byteLength || 0) / 1024)
                      , O = e.getTile(i).tileSize
                      , V = 512 / Math.min(O, 512) * (i.overscaledZ / u.transform.zoom) * .5;
                    let H = i.canonical.toString();
                    i.overscaledZ !== i.canonical.z && (H += ` => ${i.overscaledZ}`),
                    function(W, J) {
                        W.initDebugOverlayCanvas();
                        const te = W.debugOverlayCanvas
                          , ie = W.context.gl
                          , ne = W.debugOverlayCanvas.getContext("2d");
                        ne.clearRect(0, 0, te.width, te.height),
                        ne.shadowColor = "white",
                        ne.shadowBlur = 2,
                        ne.lineWidth = 1.5,
                        ne.strokeStyle = "white",
                        ne.textBaseline = "top",
                        ne.font = "bold 36px Open Sans, sans-serif",
                        ne.fillText(J, 5, 5),
                        ne.strokeText(J, 5, 5),
                        W.debugOverlayTexture.update(te),
                        W.debugOverlayTexture.bind(ie.LINEAR, ie.CLAMP_TO_EDGE)
                    }(u, `${H} ${k}kB`);
                    const q = u.transform.getProjectionData({
                        overscaledTileID: i,
                        applyGlobeMatrix: !0,
                        applyTerrainMatrix: !0
                    });
                    h.draw(o, a.TRIANGLES, m, y, Vt.alphaBlended, pt.disabled, sl(l.b6.transparent, V), null, q, T, u.debugBuffer, u.quadTriangleIndexBuffer, u.debugSegments),
                    h.draw(o, a.LINE_STRIP, m, y, v, pt.disabled, sl(l.b6.red), S, q, T, u.debugBuffer, u.tileBorderIndexBuffer, u.debugSegments)
                }
                function Ml(u, e, i, o) {
                    const {isRenderingGlobe: a} = o
                      , h = u.context
                      , m = h.gl
                      , y = u.transform
                      , v = u.colorModeForRenderPass()
                      , T = u.getDepthModeFor3D()
                      , S = u.useProgram("terrain");
                    h.bindFramebuffer.set(null),
                    h.viewport.set([0, 0, u.width, u.height]);
                    for (const A of i) {
                        const k = e.getTerrainMesh(A.tileID)
                          , O = u.renderToTexture.getTexture(A)
                          , V = e.getTerrainData(A.tileID);
                        h.activeTexture.set(m.TEXTURE0),
                        m.bindTexture(m.TEXTURE_2D, O.texture);
                        const H = e.getMeshFrameDelta(y.zoom)
                          , q = y.calculateFogMatrix(A.tileID.toUnwrapped())
                          , W = rl(H, q, u.style.sky, y.pitch, a)
                          , J = y.getProjectionData({
                            overscaledTileID: A.tileID,
                            applyTerrainMatrix: !1,
                            applyGlobeMatrix: !0
                        });
                        S.draw(h, m.TRIANGLES, T, mt.disabled, v, pt.backCCW, W, V, J, "terrain", k.vertexBuffer, k.indexBuffer, k.segments)
                    }
                }
                function Cl(u, e) {
                    if (!e.mesh) {
                        const i = new l.aE;
                        i.emplaceBack(-1, -1),
                        i.emplaceBack(1, -1),
                        i.emplaceBack(1, 1),
                        i.emplaceBack(-1, 1);
                        const o = new l.aG;
                        o.emplaceBack(0, 1, 2),
                        o.emplaceBack(0, 2, 3),
                        e.mesh = new lr(u.createVertexBuffer(i, Mr.members),u.createIndexBuffer(o),l.aF.simpleSegment(0, 0, i.length, o.length))
                    }
                    return e.mesh
                }
                class Wc {
                    constructor(e, i) {
                        this.context = new ta(e),
                        this.transform = i,
                        this._tileTextures = {},
                        this.terrainFacilitator = {
                            dirty: !0,
                            matrix: l.as(new Float64Array(16)),
                            renderTime: 0
                        },
                        this.setup(),
                        this.numSublayers = E.maxUnderzooming + E.maxOverzooming + 1,
                        this.depthEpsilon = 1 / Math.pow(2, 16),
                        this.crossTileSymbolIndex = new Xa
                    }
                    resize(e, i, o) {
                        if (this.width = Math.floor(e * o),
                        this.height = Math.floor(i * o),
                        this.pixelRatio = o,
                        this.context.viewport.set([0, 0, this.width, this.height]),
                        this.style)
                            for (const a of this.style._order)
                                this.style._layers[a].resize()
                    }
                    setup() {
                        const e = this.context
                          , i = new l.aE;
                        i.emplaceBack(0, 0),
                        i.emplaceBack(l.Z, 0),
                        i.emplaceBack(0, l.Z),
                        i.emplaceBack(l.Z, l.Z),
                        this.tileExtentBuffer = e.createVertexBuffer(i, Mr.members),
                        this.tileExtentSegments = l.aF.simpleSegment(0, 0, 4, 2);
                        const o = new l.aE;
                        o.emplaceBack(0, 0),
                        o.emplaceBack(l.Z, 0),
                        o.emplaceBack(0, l.Z),
                        o.emplaceBack(l.Z, l.Z),
                        this.debugBuffer = e.createVertexBuffer(o, Mr.members),
                        this.debugSegments = l.aF.simpleSegment(0, 0, 4, 5);
                        const a = new l.bV;
                        a.emplaceBack(0, 0, 0, 0),
                        a.emplaceBack(l.Z, 0, l.Z, 0),
                        a.emplaceBack(0, l.Z, 0, l.Z),
                        a.emplaceBack(l.Z, l.Z, l.Z, l.Z),
                        this.rasterBoundsBuffer = e.createVertexBuffer(a, rn.members),
                        this.rasterBoundsSegments = l.aF.simpleSegment(0, 0, 4, 2);
                        const h = new l.aE;
                        h.emplaceBack(0, 0),
                        h.emplaceBack(l.Z, 0),
                        h.emplaceBack(0, l.Z),
                        h.emplaceBack(l.Z, l.Z),
                        this.rasterBoundsBufferPosOnly = e.createVertexBuffer(h, Mr.members),
                        this.rasterBoundsSegmentsPosOnly = l.aF.simpleSegment(0, 0, 4, 5);
                        const m = new l.aE;
                        m.emplaceBack(0, 0),
                        m.emplaceBack(1, 0),
                        m.emplaceBack(0, 1),
                        m.emplaceBack(1, 1),
                        this.viewportBuffer = e.createVertexBuffer(m, Mr.members),
                        this.viewportSegments = l.aF.simpleSegment(0, 0, 4, 2);
                        const y = new l.bW;
                        y.emplaceBack(0),
                        y.emplaceBack(1),
                        y.emplaceBack(3),
                        y.emplaceBack(2),
                        y.emplaceBack(0),
                        this.tileBorderIndexBuffer = e.createIndexBuffer(y);
                        const v = new l.aG;
                        v.emplaceBack(1, 0, 2),
                        v.emplaceBack(1, 2, 3),
                        this.quadTriangleIndexBuffer = e.createIndexBuffer(v);
                        const T = this.context.gl;
                        this.stencilClearMode = new mt({
                            func: T.ALWAYS,
                            mask: 0
                        },0,255,T.ZERO,T.ZERO,T.ZERO),
                        this.tileExtentMesh = new lr(this.tileExtentBuffer,this.quadTriangleIndexBuffer,this.tileExtentSegments)
                    }
                    clearStencil() {
                        const e = this.context
                          , i = e.gl;
                        this.nextStencilID = 1,
                        this.currentStencilSource = void 0;
                        const o = l.K();
                        l.bN(o, 0, this.width, this.height, 0, 0, 1),
                        l.M(o, o, [i.drawingBufferWidth, i.drawingBufferHeight, 0]);
                        const a = {
                            mainMatrix: o,
                            tileMercatorCoords: [0, 0, 1, 1],
                            clippingPlane: [0, 0, 0, 0],
                            projectionTransition: 0,
                            fallbackMatrix: o
                        };
                        this.useProgram("clippingMask", null, !0).draw(e, i.TRIANGLES, ot.disabled, this.stencilClearMode, Vt.disabled, pt.disabled, null, null, a, "$clipping", this.viewportBuffer, this.quadTriangleIndexBuffer, this.viewportSegments)
                    }
                    _renderTileClippingMasks(e, i, o) {
                        if (this.currentStencilSource === e.source || !e.isTileClipped() || !i || !i.length)
                            return;
                        this.currentStencilSource = e.source,
                        this.nextStencilID + i.length > 256 && this.clearStencil();
                        const a = this.context;
                        a.setColorMode(Vt.disabled),
                        a.setDepthMode(ot.disabled);
                        const h = {};
                        for (const m of i)
                            h[m.key] = this.nextStencilID++;
                        this._renderTileMasks(h, i, o, !0),
                        this._renderTileMasks(h, i, o, !1),
                        this._tileClippingMaskIDs = h
                    }
                    _renderTileMasks(e, i, o, a) {
                        const h = this.context
                          , m = h.gl
                          , y = this.style.projection
                          , v = this.transform
                          , T = this.useProgram("clippingMask");
                        for (const S of i) {
                            const A = e[S.key]
                              , k = this.style.map.terrain && this.style.map.terrain.getTerrainData(S)
                              , O = y.getMeshFromTileID(this.context, S.canonical, a, !0, "stencil")
                              , V = v.getProjectionData({
                                overscaledTileID: S,
                                applyGlobeMatrix: !0,
                                applyTerrainMatrix: !0
                            });
                            T.draw(h, m.TRIANGLES, ot.disabled, new mt({
                                func: m.ALWAYS,
                                mask: 0
                            },A,255,m.KEEP,m.KEEP,m.REPLACE), Vt.disabled, o ? pt.disabled : pt.backCCW, null, k, V, "$clipping", O.vertexBuffer, O.indexBuffer, O.segments)
                        }
                    }
                    _renderTilesDepthBuffer() {
                        const e = this.context
                          , i = e.gl
                          , o = this.style.projection
                          , a = this.transform
                          , h = this.useProgram("depth")
                          , m = this.getDepthModeFor3D()
                          , y = pe(a, {
                            tileSize: a.tileSize
                        });
                        for (const v of y) {
                            const T = this.style.map.terrain && this.style.map.terrain.getTerrainData(v)
                              , S = o.getMeshFromTileID(this.context, v.canonical, !0, !0, "raster")
                              , A = a.getProjectionData({
                                overscaledTileID: v,
                                applyGlobeMatrix: !0,
                                applyTerrainMatrix: !0
                            });
                            h.draw(e, i.TRIANGLES, m, mt.disabled, Vt.disabled, pt.backCCW, null, T, A, "$clipping", S.vertexBuffer, S.indexBuffer, S.segments)
                        }
                    }
                    stencilModeFor3D() {
                        this.currentStencilSource = void 0,
                        this.nextStencilID + 1 > 256 && this.clearStencil();
                        const e = this.nextStencilID++
                          , i = this.context.gl;
                        return new mt({
                            func: i.NOTEQUAL,
                            mask: 255
                        },e,255,i.KEEP,i.KEEP,i.REPLACE)
                    }
                    stencilModeForClipping(e) {
                        const i = this.context.gl;
                        return new mt({
                            func: i.EQUAL,
                            mask: 255
                        },this._tileClippingMaskIDs[e.key],0,i.KEEP,i.KEEP,i.REPLACE)
                    }
                    getStencilConfigForOverlapAndUpdateStencilID(e) {
                        const i = this.context.gl
                          , o = e.sort( (m, y) => y.overscaledZ - m.overscaledZ)
                          , a = o[o.length - 1].overscaledZ
                          , h = o[0].overscaledZ - a + 1;
                        if (h > 1) {
                            this.currentStencilSource = void 0,
                            this.nextStencilID + h > 256 && this.clearStencil();
                            const m = {};
                            for (let y = 0; y < h; y++)
                                m[y + a] = new mt({
                                    func: i.GEQUAL,
                                    mask: 255
                                },y + this.nextStencilID,255,i.KEEP,i.KEEP,i.REPLACE);
                            return this.nextStencilID += h,
                            [m, o]
                        }
                        return [{
                            [a]: mt.disabled
                        }, o]
                    }
                    stencilConfigForOverlapTwoPass(e) {
                        const i = this.context.gl
                          , o = e.sort( (m, y) => y.overscaledZ - m.overscaledZ)
                          , a = o[o.length - 1].overscaledZ
                          , h = o[0].overscaledZ - a + 1;
                        if (this.clearStencil(),
                        h > 1) {
                            const m = {}
                              , y = {};
                            for (let v = 0; v < h; v++)
                                m[v + a] = new mt({
                                    func: i.GREATER,
                                    mask: 255
                                },h + 1 + v,255,i.KEEP,i.KEEP,i.REPLACE),
                                y[v + a] = new mt({
                                    func: i.GREATER,
                                    mask: 255
                                },1 + v,255,i.KEEP,i.KEEP,i.REPLACE);
                            return this.nextStencilID = 2 * h + 1,
                            [m, y, o]
                        }
                        return this.nextStencilID = 3,
                        [{
                            [a]: new mt({
                                func: i.GREATER,
                                mask: 255
                            },2,255,i.KEEP,i.KEEP,i.REPLACE)
                        }, {
                            [a]: new mt({
                                func: i.GREATER,
                                mask: 255
                            },1,255,i.KEEP,i.KEEP,i.REPLACE)
                        }, o]
                    }
                    colorModeForRenderPass() {
                        const e = this.context.gl;
                        return this._showOverdrawInspector ? new Vt([e.CONSTANT_COLOR, e.ONE],new l.b6(.125,.125,.125,0),[!0, !0, !0, !0]) : this.renderPass === "opaque" ? Vt.unblended : Vt.alphaBlended
                    }
                    getDepthModeForSublayer(e, i, o) {
                        if (!this.opaquePassEnabledForLayer())
                            return ot.disabled;
                        const a = 1 - ((1 + this.currentLayer) * this.numSublayers + e) * this.depthEpsilon;
                        return new ot(o || this.context.gl.LEQUAL,i,[a, a])
                    }
                    getDepthModeFor3D() {
                        return new ot(this.context.gl.LEQUAL,ot.ReadWrite,this.depthRangeFor3D)
                    }
                    opaquePassEnabledForLayer() {
                        return this.currentLayer < this.opaquePassCutoff
                    }
                    render(e, i) {
                        var o, a;
                        this.style = e,
                        this.options = i,
                        this.lineAtlas = e.lineAtlas,
                        this.imageManager = e.imageManager,
                        this.glyphManager = e.glyphManager,
                        this.symbolFadeChange = e.placement.symbolFadeChange(oe.now()),
                        this.imageManager.beginFrame();
                        const h = this.style._order
                          , m = this.style.sourceCaches
                          , y = {}
                          , v = {}
                          , T = {}
                          , S = {
                            isRenderingToTexture: !1,
                            isRenderingGlobe: ((o = e.projection) === null || o === void 0 ? void 0 : o.transitionState) > 0
                        };
                        for (const k in m) {
                            const O = m[k];
                            O.used && O.prepare(this.context),
                            y[k] = O.getVisibleCoordinates(!1),
                            v[k] = y[k].slice().reverse(),
                            T[k] = O.getVisibleCoordinates(!0).reverse()
                        }
                        this.opaquePassCutoff = 1 / 0;
                        for (let k = 0; k < h.length; k++)
                            if (this.style._layers[h[k]].is3D()) {
                                this.opaquePassCutoff = k;
                                break
                            }
                        this.maybeDrawDepthAndCoords(!1),
                        this.renderToTexture && (this.renderToTexture.prepareForRender(this.style, this.transform.zoom),
                        this.opaquePassCutoff = 0),
                        this.renderPass = "offscreen";
                        for (const k of h) {
                            const O = this.style._layers[k];
                            if (!O.hasOffscreenPass() || O.isHidden(this.transform.zoom))
                                continue;
                            const V = v[O.source];
                            (O.type === "custom" || V.length) && this.renderLayer(this, m[O.source], O, V, S)
                        }
                        if ((a = this.style.projection) === null || a === void 0 || a.updateGPUdependent({
                            context: this.context,
                            useProgram: k => this.useProgram(k)
                        }),
                        this.context.viewport.set([0, 0, this.width, this.height]),
                        this.context.bindFramebuffer.set(null),
                        this.context.clear({
                            color: i.showOverdrawInspector ? l.b6.black : l.b6.transparent,
                            depth: 1
                        }),
                        this.clearStencil(),
                        this.style.sky && function(k, O) {
                            const V = k.context
                              , H = V.gl
                              , q = ( (le, se, _e) => {
                                const xe = Math.cos(se.rollInRadians)
                                  , Pe = Math.sin(se.rollInRadians)
                                  , Ie = Si(se)
                                  , Ce = se.getProjectionData({
                                    overscaledTileID: null,
                                    applyGlobeMatrix: !0,
                                    applyTerrainMatrix: !0
                                }).projectionTransition;
                                return {
                                    u_sky_color: le.properties.get("sky-color"),
                                    u_horizon_color: le.properties.get("horizon-color"),
                                    u_horizon: [(se.width / 2 - Ie * Pe) * _e, (se.height / 2 + Ie * xe) * _e],
                                    u_horizon_normal: [-Pe, xe],
                                    u_sky_horizon_blend: le.properties.get("sky-horizon-blend") * se.height / 2 * _e,
                                    u_sky_blend: Ce
                                }
                            }
                            )(O, k.style.map.transform, k.pixelRatio)
                              , W = new ot(H.LEQUAL,ot.ReadWrite,[0, 1])
                              , J = mt.disabled
                              , te = k.colorModeForRenderPass()
                              , ie = k.useProgram("sky")
                              , ne = Cl(V, O);
                            ie.draw(V, H.TRIANGLES, W, J, te, pt.disabled, q, null, void 0, "sky", ne.vertexBuffer, ne.indexBuffer, ne.segments)
                        }(this, this.style.sky),
                        this._showOverdrawInspector = i.showOverdrawInspector,
                        this.depthRangeFor3D = [0, 1 - (e._order.length + 2) * this.numSublayers * this.depthEpsilon],
                        !this.renderToTexture)
                            for (this.renderPass = "opaque",
                            this.currentLayer = h.length - 1; this.currentLayer >= 0; this.currentLayer--) {
                                const k = this.style._layers[h[this.currentLayer]]
                                  , O = m[k.source]
                                  , V = y[k.source];
                                this._renderTileClippingMasks(k, V, !1),
                                this.renderLayer(this, O, k, V, S)
                            }
                        this.renderPass = "translucent";
                        let A = !1;
                        for (this.currentLayer = 0; this.currentLayer < h.length; this.currentLayer++) {
                            const k = this.style._layers[h[this.currentLayer]]
                              , O = m[k.source];
                            if (this.renderToTexture && this.renderToTexture.renderLayer(k, S))
                                continue;
                            this.opaquePassEnabledForLayer() || A || (A = !0,
                            S.isRenderingGlobe && !this.style.map.terrain && this._renderTilesDepthBuffer());
                            const V = (k.type === "symbol" ? T : v)[k.source];
                            this._renderTileClippingMasks(k, y[k.source], !1),
                            this.renderLayer(this, O, k, V, S)
                        }
                        if (S.isRenderingGlobe && function(k, O, V) {
                            const H = k.context
                              , q = H.gl
                              , W = k.useProgram("atmosphere")
                              , J = new ot(q.LEQUAL,ot.ReadOnly,[0, 1])
                              , te = k.transform
                              , ie = function(Ce, Ne) {
                                const Oe = Ce.properties.get("position")
                                  , De = [-Oe.x, -Oe.y, -Oe.z]
                                  , $e = l.as(new Float64Array(16));
                                return Ce.properties.get("anchor") === "map" && (l.aZ($e, $e, Ne.rollInRadians),
                                l.a_($e, $e, -Ne.pitchInRadians),
                                l.aZ($e, $e, Ne.bearingInRadians),
                                l.a_($e, $e, Ne.center.lat * Math.PI / 180),
                                l.bl($e, $e, -Ne.center.lng * Math.PI / 180)),
                                l.bU(De, De, $e),
                                De
                            }(V, k.transform)
                              , ne = te.getProjectionData({
                                overscaledTileID: null,
                                applyGlobeMatrix: !0,
                                applyTerrainMatrix: !0
                            })
                              , le = O.properties.get("atmosphere-blend") * ne.projectionTransition;
                            if (le === 0)
                                return;
                            const se = Zi(te.worldSize, te.center.lat)
                              , _e = te.inverseProjectionMatrix
                              , xe = new Float64Array(4);
                            xe[3] = 1,
                            l.ao(xe, xe, te.modelViewProjectionMatrix),
                            xe[0] /= xe[3],
                            xe[1] /= xe[3],
                            xe[2] /= xe[3],
                            xe[3] = 1,
                            l.ao(xe, xe, _e),
                            xe[0] /= xe[3],
                            xe[1] /= xe[3],
                            xe[2] /= xe[3],
                            xe[3] = 1;
                            const Pe = ( (Ce, Ne, Oe, De, $e) => ({
                                u_sun_pos: Ce,
                                u_atmosphere_blend: Ne,
                                u_globe_position: Oe,
                                u_globe_radius: De,
                                u_inv_proj_matrix: $e
                            }))(ie, le, [xe[0], xe[1], xe[2]], se, _e)
                              , Ie = Cl(H, O);
                            W.draw(H, q.TRIANGLES, J, mt.disabled, Vt.alphaBlended, pt.disabled, Pe, null, null, "atmosphere", Ie.vertexBuffer, Ie.indexBuffer, Ie.segments)
                        }(this, this.style.sky, this.style.light),
                        this.options.showTileBoundaries) {
                            const k = function(O, V) {
                                let H = null;
                                const q = Object.values(O._layers).flatMap(ie => ie.source && !ie.isHidden(V) ? [O.sourceCaches[ie.source]] : [])
                                  , W = q.filter(ie => ie.getSource().type === "vector")
                                  , J = q.filter(ie => ie.getSource().type !== "vector")
                                  , te = ie => {
                                    (!H || H.getSource().maxzoom < ie.getSource().maxzoom) && (H = ie)
                                }
                                ;
                                return W.forEach(ie => te(ie)),
                                H || J.forEach(ie => te(ie)),
                                H
                            }(this.style, this.transform.zoom);
                            k && function(O, V, H) {
                                for (let q = 0; q < H.length; q++)
                                    Hc(O, V, H[q])
                            }(this, k, k.getVisibleCoordinates())
                        }
                        this.options.showPadding && function(k) {
                            const O = k.transform.padding;
                            hs(k, k.transform.height - (O.top || 0), 3, us),
                            hs(k, O.bottom || 0, 3, Ar),
                            Bs(k, O.left || 0, 3, wl),
                            Bs(k, k.transform.width - (O.right || 0), 3, Tl);
                            const V = k.transform.centerPoint;
                            (function(H, q, W, J) {
                                Os(H, q - 1, W - 10, 2, 20, J),
                                Os(H, q - 10, W - 1, 20, 2, J)
                            }
                            )(k, V.x, k.transform.height - V.y, qc)
                        }(this),
                        this.context.setDefault()
                    }
                    maybeDrawDepthAndCoords(e) {
                        if (!this.style || !this.style.map || !this.style.map.terrain)
                            return;
                        const i = this.terrainFacilitator.matrix
                          , o = this.transform.modelViewProjectionMatrix;
                        let a = this.terrainFacilitator.dirty;
                        a || (a = e ? !l.bX(i, o) : !l.bY(i, o)),
                        a || (a = this.style.map.terrain.sourceCache.anyTilesAfterTime(this.terrainFacilitator.renderTime)),
                        a && (l.bZ(i, o),
                        this.terrainFacilitator.renderTime = Date.now(),
                        this.terrainFacilitator.dirty = !1,
                        function(h, m) {
                            const y = h.context
                              , v = y.gl
                              , T = h.transform
                              , S = Vt.unblended
                              , A = new ot(v.LEQUAL,ot.ReadWrite,[0, 1])
                              , k = m.sourceCache.getRenderableTiles()
                              , O = h.useProgram("terrainDepth");
                            y.bindFramebuffer.set(m.getFramebuffer("depth").framebuffer),
                            y.viewport.set([0, 0, h.width / devicePixelRatio, h.height / devicePixelRatio]),
                            y.clear({
                                color: l.b6.transparent,
                                depth: 1
                            });
                            for (const V of k) {
                                const H = m.getTerrainMesh(V.tileID)
                                  , q = m.getTerrainData(V.tileID)
                                  , W = T.getProjectionData({
                                    overscaledTileID: V.tileID,
                                    applyTerrainMatrix: !1,
                                    applyGlobeMatrix: !0
                                })
                                  , J = {
                                    u_ele_delta: m.getMeshFrameDelta(T.zoom)
                                };
                                O.draw(y, v.TRIANGLES, A, mt.disabled, S, pt.backCCW, J, q, W, "terrain", H.vertexBuffer, H.indexBuffer, H.segments)
                            }
                            y.bindFramebuffer.set(null),
                            y.viewport.set([0, 0, h.width, h.height])
                        }(this, this.style.map.terrain),
                        function(h, m) {
                            const y = h.context
                              , v = y.gl
                              , T = h.transform
                              , S = Vt.unblended
                              , A = new ot(v.LEQUAL,ot.ReadWrite,[0, 1])
                              , k = m.getCoordsTexture()
                              , O = m.sourceCache.getRenderableTiles()
                              , V = h.useProgram("terrainCoords");
                            y.bindFramebuffer.set(m.getFramebuffer("coords").framebuffer),
                            y.viewport.set([0, 0, h.width / devicePixelRatio, h.height / devicePixelRatio]),
                            y.clear({
                                color: l.b6.transparent,
                                depth: 1
                            }),
                            m.coordsIndex = [];
                            for (const H of O) {
                                const q = m.getTerrainMesh(H.tileID)
                                  , W = m.getTerrainData(H.tileID);
                                y.activeTexture.set(v.TEXTURE0),
                                v.bindTexture(v.TEXTURE_2D, k.texture);
                                const J = {
                                    u_terrain_coords_id: (255 - m.coordsIndex.length) / 255,
                                    u_texture: 0,
                                    u_ele_delta: m.getMeshFrameDelta(T.zoom)
                                }
                                  , te = T.getProjectionData({
                                    overscaledTileID: H.tileID,
                                    applyTerrainMatrix: !1,
                                    applyGlobeMatrix: !0
                                });
                                V.draw(y, v.TRIANGLES, A, mt.disabled, S, pt.backCCW, J, W, te, "terrain", q.vertexBuffer, q.indexBuffer, q.segments),
                                m.coordsIndex.push(H.tileID.key)
                            }
                            y.bindFramebuffer.set(null),
                            y.viewport.set([0, 0, h.width, h.height])
                        }(this, this.style.map.terrain))
                    }
                    renderLayer(e, i, o, a, h) {
                        o.isHidden(this.transform.zoom) || (o.type === "background" || o.type === "custom" || (a || []).length) && (this.id = o.id,
                        l.b_(o) ? function(m, y, v, T, S, A) {
                            if (m.renderPass !== "translucent")
                                return;
                            const {isRenderingToTexture: k} = A
                              , O = mt.disabled
                              , V = m.colorModeForRenderPass();
                            (v._unevaluatedLayout.hasValue("text-variable-anchor") || v._unevaluatedLayout.hasValue("text-variable-anchor-offset")) && function(H, q, W, J, te, ie, ne, le, se) {
                                const _e = q.transform
                                  , xe = q.style.map.terrain
                                  , Pe = te === "map"
                                  , Ie = ie === "map";
                                for (const Ce of H) {
                                    const Ne = J.getTile(Ce)
                                      , Oe = Ne.getBucket(W);
                                    if (!Oe || !Oe.text || !Oe.text.segments.get().length)
                                        continue;
                                    const De = l.af(Oe.textSizeData, _e.zoom)
                                      , $e = l.av(Ne, 1, q.transform.zoom)
                                      , Ke = ve(Pe, q.transform, $e)
                                      , wt = W.layout.get("icon-text-fit") !== "none" && Oe.hasIconData();
                                    if (De) {
                                        const Dt = Math.pow(2, _e.zoom - Ne.tileID.overscaledZ)
                                          , Et = xe ? (Zt, Ot) => xe.getElevation(Ce, Zt, Ot) : null;
                                        na(Oe, Pe, Ie, se, _e, Ke, Dt, De, wt, l.aw(_e, Ne, ne, le), Ce.toUnwrapped(), Et)
                                    }
                                }
                            }(T, m, v, y, v.layout.get("text-rotation-alignment"), v.layout.get("text-pitch-alignment"), v.paint.get("text-translate"), v.paint.get("text-translate-anchor"), S),
                            v.paint.get("icon-opacity").constantOr(1) !== 0 && Gc(m, y, v, T, !1, v.paint.get("icon-translate"), v.paint.get("icon-translate-anchor"), v.layout.get("icon-rotation-alignment"), v.layout.get("icon-pitch-alignment"), v.layout.get("icon-keep-upright"), O, V, k),
                            v.paint.get("text-opacity").constantOr(1) !== 0 && Gc(m, y, v, T, !0, v.paint.get("text-translate"), v.paint.get("text-translate-anchor"), v.layout.get("text-rotation-alignment"), v.layout.get("text-pitch-alignment"), v.layout.get("text-keep-upright"), O, V, k),
                            y.map.showCollisionBoxes && (ia(m, y, v, T, !0),
                            ia(m, y, v, T, !1))
                        }(e, i, o, a, this.style.placement.variableOffsets, h) : l.b$(o) ? function(m, y, v, T, S) {
                            if (m.renderPass !== "translucent")
                                return;
                            const {isRenderingToTexture: A} = S
                              , k = v.paint.get("circle-opacity")
                              , O = v.paint.get("circle-stroke-width")
                              , V = v.paint.get("circle-stroke-opacity")
                              , H = !v.layout.get("circle-sort-key").isConstant();
                            if (k.constantOr(1) === 0 && (O.constantOr(1) === 0 || V.constantOr(1) === 0))
                                return;
                            const q = m.context
                              , W = q.gl
                              , J = m.transform
                              , te = m.getDepthModeForSublayer(0, ot.ReadOnly)
                              , ie = mt.disabled
                              , ne = m.colorModeForRenderPass()
                              , le = []
                              , se = J.getCircleRadiusCorrection();
                            for (let _e = 0; _e < T.length; _e++) {
                                const xe = T[_e]
                                  , Pe = y.getTile(xe)
                                  , Ie = Pe.getBucket(v);
                                if (!Ie)
                                    continue;
                                const Ce = v.paint.get("circle-translate")
                                  , Ne = v.paint.get("circle-translate-anchor")
                                  , Oe = l.aw(J, Pe, Ce, Ne)
                                  , De = Ie.programConfigurations.get(v.id)
                                  , $e = m.useProgram("circle", De)
                                  , Ke = Ie.layoutVertexBuffer
                                  , wt = Ie.indexBuffer
                                  , Dt = m.style.map.terrain && m.style.map.terrain.getTerrainData(xe)
                                  , Et = {
                                    programConfiguration: De,
                                    program: $e,
                                    layoutVertexBuffer: Ke,
                                    indexBuffer: wt,
                                    uniformValues: Pc(m, Pe, v, Oe, se),
                                    terrainData: Dt,
                                    projectionData: J.getProjectionData({
                                        overscaledTileID: xe,
                                        applyGlobeMatrix: !A,
                                        applyTerrainMatrix: !0
                                    })
                                };
                                if (H) {
                                    const Zt = Ie.segments.get();
                                    for (const Ot of Zt)
                                        le.push({
                                            segments: new l.aF([Ot]),
                                            sortKey: Ot.sortKey,
                                            state: Et
                                        })
                                } else
                                    le.push({
                                        segments: Ie.segments,
                                        sortKey: 0,
                                        state: Et
                                    })
                            }
                            H && le.sort( (_e, xe) => _e.sortKey - xe.sortKey);
                            for (const _e of le) {
                                const {programConfiguration: xe, program: Pe, layoutVertexBuffer: Ie, indexBuffer: Ce, uniformValues: Ne, terrainData: Oe, projectionData: De} = _e.state;
                                Pe.draw(q, W.TRIANGLES, te, ie, ne, pt.backCCW, Ne, Oe, De, v.id, Ie, Ce, _e.segments, v.paint, m.transform.zoom, xe)
                            }
                        }(e, i, o, a, h) : l.c0(o) ? function(m, y, v, T, S) {
                            if (v.paint.get("heatmap-opacity") === 0)
                                return;
                            const A = m.context
                              , {isRenderingToTexture: k, isRenderingGlobe: O} = S;
                            if (m.style.map.terrain) {
                                for (const V of T) {
                                    const H = y.getTile(V);
                                    y.hasRenderableParent(V) || (m.renderPass === "offscreen" ? mh(m, H, v, V, O) : m.renderPass === "translucent" && $c(m, v, V, k, O))
                                }
                                A.viewport.set([0, 0, m.width, m.height])
                            } else
                                m.renderPass === "offscreen" ? function(V, H, q, W) {
                                    const J = V.context
                                      , te = J.gl
                                      , ie = V.transform
                                      , ne = mt.disabled
                                      , le = new Vt([te.ONE, te.ONE],l.b6.transparent,[!0, !0, !0, !0]);
                                    (function(se, _e, xe) {
                                        const Pe = se.gl;
                                        se.activeTexture.set(Pe.TEXTURE1),
                                        se.viewport.set([0, 0, _e.width / 4, _e.height / 4]);
                                        let Ie = xe.heatmapFbos.get(l.bR);
                                        Ie ? (Pe.bindTexture(Pe.TEXTURE_2D, Ie.colorAttachment.get()),
                                        se.bindFramebuffer.set(Ie.framebuffer)) : (Ie = po(se, _e.width / 4, _e.height / 4),
                                        xe.heatmapFbos.set(l.bR, Ie))
                                    }
                                    )(J, V, q),
                                    J.clear({
                                        color: l.b6.transparent
                                    });
                                    for (let se = 0; se < W.length; se++) {
                                        const _e = W[se];
                                        if (H.hasRenderableParent(_e))
                                            continue;
                                        const xe = H.getTile(_e)
                                          , Pe = xe.getBucket(q);
                                        if (!Pe)
                                            continue;
                                        const Ie = Pe.programConfigurations.get(q.id)
                                          , Ce = V.useProgram("heatmap", Ie)
                                          , Ne = ie.getProjectionData({
                                            overscaledTileID: _e,
                                            applyGlobeMatrix: !0,
                                            applyTerrainMatrix: !1
                                        })
                                          , Oe = ie.getCircleRadiusCorrection();
                                        Ce.draw(J, te.TRIANGLES, ot.disabled, ne, le, pt.backCCW, ol(xe, ie.zoom, q.paint.get("heatmap-intensity"), Oe), null, Ne, q.id, Pe.layoutVertexBuffer, Pe.indexBuffer, Pe.segments, q.paint, ie.zoom, Ie)
                                    }
                                    J.viewport.set([0, 0, V.width, V.height])
                                }(m, y, v, T) : m.renderPass === "translucent" && function(V, H) {
                                    const q = V.context
                                      , W = q.gl;
                                    q.setColorMode(V.colorModeForRenderPass());
                                    const J = H.heatmapFbos.get(l.bR);
                                    J && (q.activeTexture.set(W.TEXTURE0),
                                    W.bindTexture(W.TEXTURE_2D, J.colorAttachment.get()),
                                    q.activeTexture.set(W.TEXTURE1),
                                    oa(q, H).bind(W.LINEAR, W.CLAMP_TO_EDGE),
                                    V.useProgram("heatmapTexture").draw(q, W.TRIANGLES, ot.disabled, mt.disabled, V.colorModeForRenderPass(), pt.disabled, al(V, H, 0, 1), null, null, H.id, V.viewportBuffer, V.quadTriangleIndexBuffer, V.viewportSegments, H.paint, V.transform.zoom))
                                }(m, v)
                        }(e, i, o, a, h) : l.c1(o) ? function(m, y, v, T, S) {
                            if (m.renderPass !== "translucent")
                                return;
                            const {isRenderingToTexture: A} = S
                              , k = v.paint.get("line-opacity")
                              , O = v.paint.get("line-width");
                            if (k.constantOr(1) === 0 || O.constantOr(1) === 0)
                                return;
                            const V = m.getDepthModeForSublayer(0, ot.ReadOnly)
                              , H = m.colorModeForRenderPass()
                              , q = v.paint.get("line-dasharray")
                              , W = v.paint.get("line-pattern")
                              , J = W.constantOr(1)
                              , te = v.paint.get("line-gradient")
                              , ie = v.getCrossfadeParameters()
                              , ne = J ? "linePattern" : q ? "lineSDF" : te ? "lineGradient" : "line"
                              , le = m.context
                              , se = le.gl
                              , _e = m.transform;
                            let xe = !0;
                            for (const Pe of T) {
                                const Ie = y.getTile(Pe);
                                if (J && !Ie.patternsLoaded())
                                    continue;
                                const Ce = Ie.getBucket(v);
                                if (!Ce)
                                    continue;
                                const Ne = Ce.programConfigurations.get(v.id)
                                  , Oe = m.context.program.get()
                                  , De = m.useProgram(ne, Ne)
                                  , $e = xe || De.program !== Oe
                                  , Ke = m.style.map.terrain && m.style.map.terrain.getTerrainData(Pe)
                                  , wt = W.constantOr(null);
                                if (wt && Ie.imageAtlas) {
                                    const Ct = Ie.imageAtlas
                                      , At = Ct.patternPositions[wt.to.toString()]
                                      , Ei = Ct.patternPositions[wt.from.toString()];
                                    At && Ei && Ne.setConstantPatternPositions(At, Ei)
                                }
                                const Dt = _e.getProjectionData({
                                    overscaledTileID: Pe,
                                    applyGlobeMatrix: !A,
                                    applyTerrainMatrix: !0
                                })
                                  , Et = _e.getPixelScale()
                                  , Zt = J ? Go(m, Ie, v, Et, ie) : q ? oh(m, Ie, v, Et, q, ie) : te ? sh(m, Ie, v, Et, Ce.lineClipsArray.length) : ns(m, Ie, v, Et);
                                if (J)
                                    le.activeTexture.set(se.TEXTURE0),
                                    Ie.imageAtlasTexture.bind(se.LINEAR, se.CLAMP_TO_EDGE),
                                    Ne.updatePaintBuffers(ie);
                                else if (q && ($e || m.lineAtlas.dirty))
                                    le.activeTexture.set(se.TEXTURE0),
                                    m.lineAtlas.bind(le);
                                else if (te) {
                                    const Ct = Ce.gradients[v.id];
                                    let At = Ct.texture;
                                    if (v.gradientVersion !== Ct.version) {
                                        let Ei = 256;
                                        if (v.stepInterpolant) {
                                            const Ai = y.getSource().maxzoom
                                              , vi = Pe.canonical.z === Ai ? Math.ceil(1 << m.transform.maxZoom - Pe.canonical.z) : 1;
                                            Ei = l.ad(l.bS(Ce.maxLineLength / l.Z * 1024 * vi), 256, le.maxTextureSize)
                                        }
                                        Ct.gradient = l.bT({
                                            expression: v.gradientExpression(),
                                            evaluationKey: "lineProgress",
                                            resolution: Ei,
                                            image: Ct.gradient || void 0,
                                            clips: Ce.lineClipsArray
                                        }),
                                        Ct.texture ? Ct.texture.update(Ct.gradient) : Ct.texture = new It(le,Ct.gradient,se.RGBA),
                                        Ct.version = v.gradientVersion,
                                        At = Ct.texture
                                    }
                                    le.activeTexture.set(se.TEXTURE0),
                                    At.bind(v.stepInterpolant ? se.NEAREST : se.LINEAR, se.CLAMP_TO_EDGE)
                                }
                                let Ot;
                                if (A) {
                                    const [Ct] = m.getStencilConfigForOverlapAndUpdateStencilID(T);
                                    Ot = Ct[Pe.overscaledZ]
                                } else
                                    Ot = m.stencilModeForClipping(Pe);
                                De.draw(le, se.TRIANGLES, V, Ot, H, pt.disabled, Zt, Ke, Dt, v.id, Ce.layoutVertexBuffer, Ce.indexBuffer, Ce.segments, v.paint, m.transform.zoom, Ne, Ce.layoutVertexBuffer2),
                                xe = !1
                            }
                        }(e, i, o, a, h) : l.c2(o) ? function(m, y, v, T, S) {
                            const A = v.paint.get("fill-color")
                              , k = v.paint.get("fill-opacity");
                            if (k.constantOr(1) === 0)
                                return;
                            const {isRenderingToTexture: O} = S
                              , V = m.colorModeForRenderPass()
                              , H = v.paint.get("fill-pattern")
                              , q = m.opaquePassEnabledForLayer() && !H.constantOr(1) && A.constantOr(l.b6.transparent).a === 1 && k.constantOr(0) === 1 ? "opaque" : "translucent";
                            if (m.renderPass === q) {
                                const W = m.getDepthModeForSublayer(1, m.renderPass === "opaque" ? ot.ReadWrite : ot.ReadOnly);
                                vl(m, y, v, T, W, V, !1, O)
                            }
                            if (m.renderPass === "translucent" && v.paint.get("fill-antialias")) {
                                const W = m.getDepthModeForSublayer(v.getPaintProperty("fill-outline-color") ? 2 : 0, ot.ReadOnly);
                                vl(m, y, v, T, W, V, !0, O)
                            }
                        }(e, i, o, a, h) : l.c3(o) ? function(m, y, v, T, S) {
                            const A = v.paint.get("fill-extrusion-opacity");
                            if (A === 0)
                                return;
                            const {isRenderingToTexture: k} = S;
                            if (m.renderPass === "translucent") {
                                const O = new ot(m.context.gl.LEQUAL,ot.ReadWrite,m.depthRangeFor3D);
                                if (A !== 1 || v.paint.get("fill-extrusion-pattern").constantOr(1))
                                    Fs(m, y, v, T, O, mt.disabled, Vt.disabled, k),
                                    Fs(m, y, v, T, O, m.stencilModeFor3D(), m.colorModeForRenderPass(), k);
                                else {
                                    const V = m.colorModeForRenderPass();
                                    Fs(m, y, v, T, O, mt.disabled, V, k)
                                }
                            }
                        }(e, i, o, a, h) : l.c4(o) ? function(m, y, v, T, S) {
                            if (m.renderPass !== "offscreen" && m.renderPass !== "translucent")
                                return;
                            const {isRenderingToTexture: A} = S
                              , k = m.context
                              , O = m.style.projection.useSubdivision
                              , V = m.getDepthModeForSublayer(0, ot.ReadOnly)
                              , H = m.colorModeForRenderPass();
                            if (m.renderPass === "offscreen")
                                (function(q, W, J, te, ie, ne, le) {
                                    const se = q.context
                                      , _e = se.gl;
                                    for (const xe of J) {
                                        const Pe = W.getTile(xe)
                                          , Ie = Pe.dem;
                                        if (!Ie || !Ie.data || !Pe.needsHillshadePrepare)
                                            continue;
                                        const Ce = Ie.dim
                                          , Ne = Ie.stride
                                          , Oe = Ie.getPixels();
                                        if (se.activeTexture.set(_e.TEXTURE1),
                                        se.pixelStoreUnpackPremultiplyAlpha.set(!1),
                                        Pe.demTexture = Pe.demTexture || q.getTileTexture(Ne),
                                        Pe.demTexture) {
                                            const $e = Pe.demTexture;
                                            $e.update(Oe, {
                                                premultiply: !1
                                            }),
                                            $e.bind(_e.NEAREST, _e.CLAMP_TO_EDGE)
                                        } else
                                            Pe.demTexture = new It(se,Oe,_e.RGBA,{
                                                premultiply: !1
                                            }),
                                            Pe.demTexture.bind(_e.NEAREST, _e.CLAMP_TO_EDGE);
                                        se.activeTexture.set(_e.TEXTURE0);
                                        let De = Pe.fbo;
                                        if (!De) {
                                            const $e = new It(se,{
                                                width: Ce,
                                                height: Ce,
                                                data: null
                                            },_e.RGBA);
                                            $e.bind(_e.LINEAR, _e.CLAMP_TO_EDGE),
                                            De = Pe.fbo = se.createFramebuffer(Ce, Ce, !0, !1),
                                            De.colorAttachment.set($e.texture)
                                        }
                                        se.bindFramebuffer.set(De.framebuffer),
                                        se.viewport.set([0, 0, Ce, Ce]),
                                        q.useProgram("hillshadePrepare").draw(se, _e.TRIANGLES, ie, ne, le, pt.disabled, Ic(Pe.tileID, Ie), null, null, te.id, q.rasterBoundsBuffer, q.quadTriangleIndexBuffer, q.rasterBoundsSegments),
                                        Pe.needsHillshadePrepare = !1
                                    }
                                }
                                )(m, y, T, v, V, mt.disabled, H),
                                k.viewport.set([0, 0, m.width, m.height]);
                            else if (m.renderPass === "translucent")
                                if (O) {
                                    const [q,W,J] = m.stencilConfigForOverlapTwoPass(T);
                                    fo(m, y, v, J, q, V, H, !1, A),
                                    fo(m, y, v, J, W, V, H, !0, A)
                                } else {
                                    const [q,W] = m.getStencilConfigForOverlapAndUpdateStencilID(T);
                                    fo(m, y, v, W, q, V, H, !1, A)
                                }
                        }(e, i, o, a, h) : l.c5(o) ? function(m, y, v, T, S) {
                            if (m.renderPass !== "translucent" || v.paint.get("raster-opacity") === 0 || !T.length)
                                return;
                            const {isRenderingToTexture: A} = S
                              , k = y.getSource()
                              , O = m.style.projection.useSubdivision;
                            if (k instanceof tn)
                                mo(m, y, v, T, null, !1, !1, k.tileCoords, k.flippedWindingOrder, A);
                            else if (O) {
                                const [V,H,q] = m.stencilConfigForOverlapTwoPass(T);
                                mo(m, y, v, q, V, !1, !0, bl, !1, A),
                                mo(m, y, v, q, H, !0, !0, bl, !1, A)
                            } else {
                                const [V,H] = m.getStencilConfigForOverlapAndUpdateStencilID(T);
                                mo(m, y, v, H, V, !1, !0, bl, !1, A)
                            }
                        }(e, i, o, a, h) : l.c6(o) ? function(m, y, v, T, S) {
                            const A = v.paint.get("background-color")
                              , k = v.paint.get("background-opacity");
                            if (k === 0)
                                return;
                            const {isRenderingToTexture: O} = S
                              , V = m.context
                              , H = V.gl
                              , q = m.style.projection
                              , W = m.transform
                              , J = W.tileSize
                              , te = v.paint.get("background-pattern");
                            if (m.isPatternMissing(te))
                                return;
                            const ie = !te && A.a === 1 && k === 1 && m.opaquePassEnabledForLayer() ? "opaque" : "translucent";
                            if (m.renderPass !== ie)
                                return;
                            const ne = mt.disabled
                              , le = m.getDepthModeForSublayer(0, ie === "opaque" ? ot.ReadWrite : ot.ReadOnly)
                              , se = m.colorModeForRenderPass()
                              , _e = m.useProgram(te ? "backgroundPattern" : "background")
                              , xe = T || pe(W, {
                                tileSize: J,
                                terrain: m.style.map.terrain
                            });
                            te && (V.activeTexture.set(H.TEXTURE0),
                            m.imageManager.bind(m.context));
                            const Pe = v.getCrossfadeParameters();
                            for (const Ie of xe) {
                                const Ce = W.getProjectionData({
                                    overscaledTileID: Ie,
                                    applyGlobeMatrix: !O,
                                    applyTerrainMatrix: !0
                                })
                                  , Ne = te ? ul(k, m, te, {
                                    tileID: Ie,
                                    tileSize: J
                                }, Pe) : yn(k, A)
                                  , Oe = m.style.map.terrain && m.style.map.terrain.getTerrainData(Ie)
                                  , De = q.getMeshFromTileID(V, Ie.canonical, !1, !0, "raster");
                                _e.draw(V, H.TRIANGLES, le, ne, se, pt.backCCW, Ne, Oe, Ce, v.id, De.vertexBuffer, De.indexBuffer, De.segments)
                            }
                        }(e, 0, o, a, h) : l.c7(o) && function(m, y, v, T) {
                            const {isRenderingGlobe: S} = T
                              , A = m.context
                              , k = v.implementation
                              , O = m.style.projection
                              , V = m.transform
                              , H = V.getProjectionDataForCustomLayer(S)
                              , q = {
                                farZ: V.farZ,
                                nearZ: V.nearZ,
                                fov: V.fov * Math.PI / 180,
                                modelViewProjectionMatrix: V.modelViewProjectionMatrix,
                                projectionMatrix: V.projectionMatrix,
                                shaderData: {
                                    variantName: O.shaderVariantName,
                                    vertexShaderPrelude: `const float PI = 3.141592653589793;
uniform mat4 u_projection_matrix;
${O.shaderPreludeCode.vertexSource}`,
                                    define: O.shaderDefine
                                },
                                defaultProjectionData: H
                            }
                              , W = k.renderingMode ? k.renderingMode : "2d";
                            if (m.renderPass === "offscreen") {
                                const J = k.prerender;
                                J && (m.setCustomLayerDefaults(),
                                A.setColorMode(m.colorModeForRenderPass()),
                                J.call(k, A.gl, q),
                                A.setDirty(),
                                m.setBaseState())
                            } else if (m.renderPass === "translucent") {
                                m.setCustomLayerDefaults(),
                                A.setColorMode(m.colorModeForRenderPass()),
                                A.setStencilMode(mt.disabled);
                                const J = W === "3d" ? m.getDepthModeFor3D() : m.getDepthModeForSublayer(0, ot.ReadOnly);
                                A.setDepthMode(J),
                                k.render(A.gl, q),
                                A.setDirty(),
                                m.setBaseState(),
                                A.bindFramebuffer.set(null)
                            }
                        }(e, 0, o, h))
                    }
                    saveTileTexture(e) {
                        const i = this._tileTextures[e.size[0]];
                        i ? i.push(e) : this._tileTextures[e.size[0]] = [e]
                    }
                    getTileTexture(e) {
                        const i = this._tileTextures[e];
                        return i && i.length > 0 ? i.pop() : null
                    }
                    isPatternMissing(e) {
                        if (!e)
                            return !1;
                        if (!e.from || !e.to)
                            return !0;
                        const i = this.imageManager.getPattern(e.from.toString())
                          , o = this.imageManager.getPattern(e.to.toString());
                        return !i || !o
                    }
                    useProgram(e, i, o=!1) {
                        this.cache = this.cache || {};
                        const a = !!this.style.map.terrain
                          , h = this.style.projection
                          , m = e + (i ? i.cacheKey : "") + `/${o ? Lo : h.shaderVariantName}` + (this._showOverdrawInspector ? "/overdraw" : "") + (a ? "/terrain" : "");
                        return this.cache[m] || (this.cache[m] = new rh(this.context,jr[e],i,hl[e],this._showOverdrawInspector,a,o ? jr.projectionMercator : h.shaderPreludeCode,o ? yt : h.shaderDefine)),
                        this.cache[m]
                    }
                    setCustomLayerDefaults() {
                        this.context.unbindVAO(),
                        this.context.cullFace.setDefault(),
                        this.context.activeTexture.setDefault(),
                        this.context.pixelStoreUnpack.setDefault(),
                        this.context.pixelStoreUnpackPremultiplyAlpha.setDefault(),
                        this.context.pixelStoreUnpackFlipY.setDefault()
                    }
                    setBaseState() {
                        const e = this.context.gl;
                        this.context.cullFace.set(!1),
                        this.context.viewport.set([0, 0, this.width, this.height]),
                        this.context.blendEquation.set(e.FUNC_ADD)
                    }
                    initDebugOverlayCanvas() {
                        this.debugOverlayCanvas == null && (this.debugOverlayCanvas = document.createElement("canvas"),
                        this.debugOverlayCanvas.width = 512,
                        this.debugOverlayCanvas.height = 512,
                        this.debugOverlayTexture = new It(this.context,this.debugOverlayCanvas,this.context.gl.RGBA))
                    }
                    destroy() {
                        this.debugOverlayTexture && this.debugOverlayTexture.destroy()
                    }
                    overLimit() {
                        const {drawingBufferWidth: e, drawingBufferHeight: i} = this.context.gl;
                        return this.width !== e || this.height !== i
                    }
                }
                function Pl(u, e) {
                    let i, o = !1, a = null, h = null;
                    const m = () => {
                        a = null,
                        o && (u.apply(h, i),
                        a = setTimeout(m, e),
                        o = !1)
                    }
                    ;
                    return (...y) => (o = !0,
                    h = this,
                    i = y,
                    a || m(),
                    a)
                }
                class On {
                    constructor(e) {
                        this._getCurrentHash = () => {
                            const i = window.location.hash.replace("#", "");
                            if (this._hashName) {
                                let o;
                                return i.split("&").map(a => a.split("=")).forEach(a => {
                                    a[0] === this._hashName && (o = a)
                                }
                                ),
                                (o && o[1] || "").split("/")
                            }
                            return i.split("/")
                        }
                        ,
                        this._onHashChange = () => {
                            const i = this._getCurrentHash();
                            if (!this._isValidHash(i))
                                return !1;
                            const o = this._map.dragRotate.isEnabled() && this._map.touchZoomRotate.isEnabled() ? +(i[3] || 0) : this._map.getBearing();
                            return this._map.jumpTo({
                                center: [+i[2], +i[1]],
                                zoom: +i[0],
                                bearing: o,
                                pitch: +(i[4] || 0)
                            }),
                            !0
                        }
                        ,
                        this._updateHashUnthrottled = () => {
                            const i = window.location.href.replace(/(#.*)?$/, this.getHashString());
                            window.history.replaceState(window.history.state, null, i)
                        }
                        ,
                        this._removeHash = () => {
                            const i = this._getCurrentHash();
                            if (i.length === 0)
                                return;
                            const o = i.join("/");
                            let a = o;
                            a.split("&").length > 0 && (a = a.split("&")[0]),
                            this._hashName && (a = `${this._hashName}=${o}`);
                            let h = window.location.hash.replace(a, "");
                            h.startsWith("#&") ? h = h.slice(0, 1) + h.slice(2) : h === "#" && (h = "");
                            let m = window.location.href.replace(/(#.+)?$/, h);
                            m = m.replace("&&", "&"),
                            window.history.replaceState(window.history.state, null, m)
                        }
                        ,
                        this._updateHash = Pl(this._updateHashUnthrottled, 300),
                        this._hashName = e && encodeURIComponent(e)
                    }
                    addTo(e) {
                        return this._map = e,
                        addEventListener("hashchange", this._onHashChange, !1),
                        this._map.on("moveend", this._updateHash),
                        this
                    }
                    remove() {
                        return removeEventListener("hashchange", this._onHashChange, !1),
                        this._map.off("moveend", this._updateHash),
                        clearTimeout(this._updateHash()),
                        this._removeHash(),
                        delete this._map,
                        this
                    }
                    getHashString(e) {
                        const i = this._map.getCenter()
                          , o = Math.round(100 * this._map.getZoom()) / 100
                          , a = Math.ceil((o * Math.LN2 + Math.log(512 / 360 / .5)) / Math.LN10)
                          , h = Math.pow(10, a)
                          , m = Math.round(i.lng * h) / h
                          , y = Math.round(i.lat * h) / h
                          , v = this._map.getBearing()
                          , T = this._map.getPitch();
                        let S = "";
                        if (S += e ? `/${m}/${y}/${o}` : `${o}/${y}/${m}`,
                        (v || T) && (S += "/" + Math.round(10 * v) / 10),
                        T && (S += `/${Math.round(T)}`),
                        this._hashName) {
                            const A = this._hashName;
                            let k = !1;
                            const O = window.location.hash.slice(1).split("&").map(V => {
                                const H = V.split("=")[0];
                                return H === A ? (k = !0,
                                `${H}=${S}`) : V
                            }
                            ).filter(V => V);
                            return k || O.push(`${A}=${S}`),
                            `#${O.join("&")}`
                        }
                        return `#${S}`
                    }
                    _isValidHash(e) {
                        if (e.length < 3 || e.some(isNaN))
                            return !1;
                        try {
                            new l.Q(+e[2],+e[1])
                        } catch {
                            return !1
                        }
                        const i = +e[0]
                          , o = +(e[3] || 0)
                          , a = +(e[4] || 0);
                        return i >= this._map.getMinZoom() && i <= this._map.getMaxZoom() && o >= -180 && o <= 180 && a >= this._map.getMinPitch() && a <= this._map.getMaxPitch()
                    }
                }
                const Ns = {
                    linearity: .3,
                    easing: l.c8(0, 0, .3, 1)
                }
                  , Xc = l.e({
                    deceleration: 2500,
                    maxSpeed: 1400
                }, Ns)
                  , Kc = l.e({
                    deceleration: 20,
                    maxSpeed: 1400
                }, Ns)
                  , Jc = l.e({
                    deceleration: 1e3,
                    maxSpeed: 360
                }, Ns)
                  , Yc = l.e({
                    deceleration: 1e3,
                    maxSpeed: 90
                }, Ns)
                  , Qc = l.e({
                    deceleration: 1e3,
                    maxSpeed: 360
                }, Ns);
                class eu {
                    constructor(e) {
                        this._map = e,
                        this.clear()
                    }
                    clear() {
                        this._inertiaBuffer = []
                    }
                    record(e) {
                        this._drainInertiaBuffer(),
                        this._inertiaBuffer.push({
                            time: oe.now(),
                            settings: e
                        })
                    }
                    _drainInertiaBuffer() {
                        const e = this._inertiaBuffer
                          , i = oe.now();
                        for (; e.length > 0 && i - e[0].time > 160; )
                            e.shift()
                    }
                    _onMoveEnd(e) {
                        if (this._drainInertiaBuffer(),
                        this._inertiaBuffer.length < 2)
                            return;
                        const i = {
                            zoom: 0,
                            bearing: 0,
                            pitch: 0,
                            roll: 0,
                            pan: new l.P(0,0),
                            pinchAround: void 0,
                            around: void 0
                        };
                        for (const {settings: h} of this._inertiaBuffer)
                            i.zoom += h.zoomDelta || 0,
                            i.bearing += h.bearingDelta || 0,
                            i.pitch += h.pitchDelta || 0,
                            i.roll += h.rollDelta || 0,
                            h.panDelta && i.pan._add(h.panDelta),
                            h.around && (i.around = h.around),
                            h.pinchAround && (i.pinchAround = h.pinchAround);
                        const o = this._inertiaBuffer[this._inertiaBuffer.length - 1].time - this._inertiaBuffer[0].time
                          , a = {};
                        if (i.pan.mag()) {
                            const h = js(i.pan.mag(), o, l.e({}, Xc, e || {}))
                              , m = i.pan.mult(h.amount / i.pan.mag())
                              , y = this._map.cameraHelper.handlePanInertia(m, this._map.transform);
                            a.center = y.easingCenter,
                            a.offset = y.easingOffset,
                            Nn(a, h)
                        }
                        if (i.zoom) {
                            const h = js(i.zoom, o, Kc);
                            a.zoom = this._map.transform.zoom + h.amount,
                            Nn(a, h)
                        }
                        if (i.bearing) {
                            const h = js(i.bearing, o, Jc);
                            a.bearing = this._map.transform.bearing + l.ad(h.amount, -179, 179),
                            Nn(a, h)
                        }
                        if (i.pitch) {
                            const h = js(i.pitch, o, Yc);
                            a.pitch = this._map.transform.pitch + h.amount,
                            Nn(a, h)
                        }
                        if (i.roll) {
                            const h = js(i.roll, o, Qc);
                            a.roll = this._map.transform.roll + l.ad(h.amount, -179, 179),
                            Nn(a, h)
                        }
                        if (a.zoom || a.bearing) {
                            const h = i.pinchAround === void 0 ? i.around : i.pinchAround;
                            a.around = h ? this._map.unproject(h) : this._map.getCenter()
                        }
                        return this.clear(),
                        l.e(a, {
                            noMoveStart: !0
                        })
                    }
                }
                function Nn(u, e) {
                    (!u.duration || u.duration < e.duration) && (u.duration = e.duration,
                    u.easing = e.easing)
                }
                function js(u, e, i) {
                    const {maxSpeed: o, linearity: a, deceleration: h} = i
                      , m = l.ad(u * a / (e / 1e3), -o, o)
                      , y = Math.abs(m) / (h * a);
                    return {
                        easing: i.easing,
                        duration: 1e3 * y,
                        amount: m * (y / 2)
                    }
                }
                class Kt extends l.l {
                    preventDefault() {
                        this._defaultPrevented = !0
                    }
                    get defaultPrevented() {
                        return this._defaultPrevented
                    }
                    constructor(e, i, o, a={}) {
                        const h = Y.mousePos(i.getCanvas(), o)
                          , m = i.unproject(h);
                        super(e, l.e({
                            point: h,
                            lngLat: m,
                            originalEvent: o
                        }, a)),
                        this._defaultPrevented = !1,
                        this.target = i
                    }
                }
                class ir extends l.l {
                    preventDefault() {
                        this._defaultPrevented = !0
                    }
                    get defaultPrevented() {
                        return this._defaultPrevented
                    }
                    constructor(e, i, o) {
                        const a = e === "touchend" ? o.changedTouches : o.touches
                          , h = Y.touchPos(i.getCanvasContainer(), a)
                          , m = h.map(v => i.unproject(v))
                          , y = h.reduce( (v, T, S, A) => v.add(T.div(A.length)), new l.P(0,0));
                        super(e, {
                            points: h,
                            point: y,
                            lngLats: m,
                            lngLat: i.unproject(y),
                            originalEvent: o
                        }),
                        this._defaultPrevented = !1
                    }
                }
                class Sl extends l.l {
                    preventDefault() {
                        this._defaultPrevented = !0
                    }
                    get defaultPrevented() {
                        return this._defaultPrevented
                    }
                    constructor(e, i, o) {
                        super(e, {
                            originalEvent: o
                        }),
                        this._defaultPrevented = !1
                    }
                }
                class nn {
                    constructor(e, i) {
                        this._map = e,
                        this._clickTolerance = i.clickTolerance
                    }
                    reset() {
                        delete this._mousedownPos
                    }
                    wheel(e) {
                        return this._firePreventable(new Sl(e.type,this._map,e))
                    }
                    mousedown(e, i) {
                        return this._mousedownPos = i,
                        this._firePreventable(new Kt(e.type,this._map,e))
                    }
                    mouseup(e) {
                        this._map.fire(new Kt(e.type,this._map,e))
                    }
                    click(e, i) {
                        this._mousedownPos && this._mousedownPos.dist(i) >= this._clickTolerance || this._map.fire(new Kt(e.type,this._map,e))
                    }
                    dblclick(e) {
                        return this._firePreventable(new Kt(e.type,this._map,e))
                    }
                    mouseover(e) {
                        this._map.fire(new Kt(e.type,this._map,e))
                    }
                    mouseout(e) {
                        this._map.fire(new Kt(e.type,this._map,e))
                    }
                    touchstart(e) {
                        return this._firePreventable(new ir(e.type,this._map,e))
                    }
                    touchmove(e) {
                        this._map.fire(new ir(e.type,this._map,e))
                    }
                    touchend(e) {
                        this._map.fire(new ir(e.type,this._map,e))
                    }
                    touchcancel(e) {
                        this._map.fire(new ir(e.type,this._map,e))
                    }
                    _firePreventable(e) {
                        if (this._map.fire(e),
                        e.defaultPrevented)
                            return {}
                    }
                    isEnabled() {
                        return !0
                    }
                    isActive() {
                        return !1
                    }
                    enable() {}
                    disable() {}
                }
                class Vs {
                    constructor(e) {
                        this._map = e
                    }
                    reset() {
                        this._delayContextMenu = !1,
                        this._ignoreContextMenu = !0,
                        delete this._contextMenuEvent
                    }
                    mousemove(e) {
                        this._map.fire(new Kt(e.type,this._map,e))
                    }
                    mousedown() {
                        this._delayContextMenu = !0,
                        this._ignoreContextMenu = !1
                    }
                    mouseup() {
                        this._delayContextMenu = !1,
                        this._contextMenuEvent && (this._map.fire(new Kt("contextmenu",this._map,this._contextMenuEvent)),
                        delete this._contextMenuEvent)
                    }
                    contextmenu(e) {
                        this._delayContextMenu ? this._contextMenuEvent = e : this._ignoreContextMenu || this._map.fire(new Kt(e.type,this._map,e)),
                        this._map.listens("contextmenu") && e.preventDefault()
                    }
                    isEnabled() {
                        return !0
                    }
                    isActive() {
                        return !1
                    }
                    enable() {}
                    disable() {}
                }
                class go {
                    constructor(e) {
                        this._map = e
                    }
                    get transform() {
                        return this._map._requestedCameraState || this._map.transform
                    }
                    get center() {
                        return {
                            lng: this.transform.center.lng,
                            lat: this.transform.center.lat
                        }
                    }
                    get zoom() {
                        return this.transform.zoom
                    }
                    get pitch() {
                        return this.transform.pitch
                    }
                    get bearing() {
                        return this.transform.bearing
                    }
                    unproject(e) {
                        return this.transform.screenPointToLocation(l.P.convert(e), this._map.terrain)
                    }
                }
                class tu {
                    constructor(e, i) {
                        this._map = e,
                        this._tr = new go(e),
                        this._el = e.getCanvasContainer(),
                        this._container = e.getContainer(),
                        this._clickTolerance = i.clickTolerance || 1
                    }
                    isEnabled() {
                        return !!this._enabled
                    }
                    isActive() {
                        return !!this._active
                    }
                    enable() {
                        this.isEnabled() || (this._enabled = !0)
                    }
                    disable() {
                        this.isEnabled() && (this._enabled = !1)
                    }
                    mousedown(e, i) {
                        this.isEnabled() && e.shiftKey && e.button === 0 && (Y.disableDrag(),
                        this._startPos = this._lastPos = i,
                        this._active = !0)
                    }
                    mousemoveWindow(e, i) {
                        if (!this._active)
                            return;
                        const o = i;
                        if (this._lastPos.equals(o) || !this._box && o.dist(this._startPos) < this._clickTolerance)
                            return;
                        const a = this._startPos;
                        this._lastPos = o,
                        this._box || (this._box = Y.create("div", "maplibregl-boxzoom", this._container),
                        this._container.classList.add("maplibregl-crosshair"),
                        this._fireEvent("boxzoomstart", e));
                        const h = Math.min(a.x, o.x)
                          , m = Math.max(a.x, o.x)
                          , y = Math.min(a.y, o.y)
                          , v = Math.max(a.y, o.y);
                        Y.setTransform(this._box, `translate(${h}px,${y}px)`),
                        this._box.style.width = m - h + "px",
                        this._box.style.height = v - y + "px"
                    }
                    mouseupWindow(e, i) {
                        if (!this._active || e.button !== 0)
                            return;
                        const o = this._startPos
                          , a = i;
                        if (this.reset(),
                        Y.suppressClick(),
                        o.x !== a.x || o.y !== a.y)
                            return this._map.fire(new l.l("boxzoomend",{
                                originalEvent: e
                            })),
                            {
                                cameraAnimation: h => h.fitScreenCoordinates(o, a, this._tr.bearing, {
                                    linear: !0
                                })
                            };
                        this._fireEvent("boxzoomcancel", e)
                    }
                    keydown(e) {
                        this._active && e.keyCode === 27 && (this.reset(),
                        this._fireEvent("boxzoomcancel", e))
                    }
                    reset() {
                        this._active = !1,
                        this._container.classList.remove("maplibregl-crosshair"),
                        this._box && (Y.remove(this._box),
                        this._box = null),
                        Y.enableDrag(),
                        delete this._startPos,
                        delete this._lastPos
                    }
                    _fireEvent(e, i) {
                        return this._map.fire(new l.l(e,{
                            originalEvent: i
                        }))
                    }
                }
                function Il(u, e) {
                    if (u.length !== e.length)
                        throw new Error(`The number of touches and points are not equal - touches ${u.length}, points ${e.length}`);
                    const i = {};
                    for (let o = 0; o < u.length; o++)
                        i[u[o].identifier] = e[o];
                    return i
                }
                class gh {
                    constructor(e) {
                        this.reset(),
                        this.numTouches = e.numTouches
                    }
                    reset() {
                        delete this.centroid,
                        delete this.startTime,
                        delete this.touches,
                        this.aborted = !1
                    }
                    touchstart(e, i, o) {
                        (this.centroid || o.length > this.numTouches) && (this.aborted = !0),
                        this.aborted || (this.startTime === void 0 && (this.startTime = e.timeStamp),
                        o.length === this.numTouches && (this.centroid = function(a) {
                            const h = new l.P(0,0);
                            for (const m of a)
                                h._add(m);
                            return h.div(a.length)
                        }(i),
                        this.touches = Il(o, i)))
                    }
                    touchmove(e, i, o) {
                        if (this.aborted || !this.centroid)
                            return;
                        const a = Il(o, i);
                        for (const h in this.touches) {
                            const m = a[h];
                            (!m || m.dist(this.touches[h]) > 30) && (this.aborted = !0)
                        }
                    }
                    touchend(e, i, o) {
                        if ((!this.centroid || e.timeStamp - this.startTime > 500) && (this.aborted = !0),
                        o.length === 0) {
                            const a = !this.aborted && this.centroid;
                            if (this.reset(),
                            a)
                                return a
                        }
                    }
                }
                class aa {
                    constructor(e) {
                        this.singleTap = new gh(e),
                        this.numTaps = e.numTaps,
                        this.reset()
                    }
                    reset() {
                        this.lastTime = 1 / 0,
                        delete this.lastTap,
                        this.count = 0,
                        this.singleTap.reset()
                    }
                    touchstart(e, i, o) {
                        this.singleTap.touchstart(e, i, o)
                    }
                    touchmove(e, i, o) {
                        this.singleTap.touchmove(e, i, o)
                    }
                    touchend(e, i, o) {
                        const a = this.singleTap.touchend(e, i, o);
                        if (a) {
                            const h = e.timeStamp - this.lastTime < 500
                              , m = !this.lastTap || this.lastTap.dist(a) < 30;
                            if (h && m || this.reset(),
                            this.count++,
                            this.lastTime = e.timeStamp,
                            this.lastTap = a,
                            this.count === this.numTaps)
                                return this.reset(),
                                a
                        }
                    }
                }
                class _o {
                    constructor(e) {
                        this._tr = new go(e),
                        this._zoomIn = new aa({
                            numTouches: 1,
                            numTaps: 2
                        }),
                        this._zoomOut = new aa({
                            numTouches: 2,
                            numTaps: 1
                        }),
                        this.reset()
                    }
                    reset() {
                        this._active = !1,
                        this._zoomIn.reset(),
                        this._zoomOut.reset()
                    }
                    touchstart(e, i, o) {
                        this._zoomIn.touchstart(e, i, o),
                        this._zoomOut.touchstart(e, i, o)
                    }
                    touchmove(e, i, o) {
                        this._zoomIn.touchmove(e, i, o),
                        this._zoomOut.touchmove(e, i, o)
                    }
                    touchend(e, i, o) {
                        const a = this._zoomIn.touchend(e, i, o)
                          , h = this._zoomOut.touchend(e, i, o)
                          , m = this._tr;
                        return a ? (this._active = !0,
                        e.preventDefault(),
                        setTimeout( () => this.reset(), 0),
                        {
                            cameraAnimation: y => y.easeTo({
                                duration: 300,
                                zoom: m.zoom + 1,
                                around: m.unproject(a)
                            }, {
                                originalEvent: e
                            })
                        }) : h ? (this._active = !0,
                        e.preventDefault(),
                        setTimeout( () => this.reset(), 0),
                        {
                            cameraAnimation: y => y.easeTo({
                                duration: 300,
                                zoom: m.zoom - 1,
                                around: m.unproject(h)
                            }, {
                                originalEvent: e
                            })
                        }) : void 0
                    }
                    touchcancel() {
                        this.reset()
                    }
                    enable() {
                        this._enabled = !0
                    }
                    disable() {
                        this._enabled = !1,
                        this.reset()
                    }
                    isEnabled() {
                        return this._enabled
                    }
                    isActive() {
                        return this._active
                    }
                }
                class ur {
                    constructor(e) {
                        this._enabled = !!e.enable,
                        this._moveStateManager = e.moveStateManager,
                        this._clickTolerance = e.clickTolerance || 1,
                        this._moveFunction = e.move,
                        this._activateOnStart = !!e.activateOnStart,
                        e.assignEvents(this),
                        this.reset()
                    }
                    reset(e) {
                        this._active = !1,
                        this._moved = !1,
                        delete this._lastPoint,
                        this._moveStateManager.endMove(e)
                    }
                    _move(...e) {
                        const i = this._moveFunction(...e);
                        if (i.bearingDelta || i.pitchDelta || i.rollDelta || i.around || i.panDelta)
                            return this._active = !0,
                            i
                    }
                    dragStart(e, i) {
                        this.isEnabled() && !this._lastPoint && this._moveStateManager.isValidStartEvent(e) && (this._moveStateManager.startMove(e),
                        this._lastPoint = Array.isArray(i) ? i[0] : i,
                        this._activateOnStart && this._lastPoint && (this._active = !0))
                    }
                    dragMove(e, i) {
                        if (!this.isEnabled())
                            return;
                        const o = this._lastPoint;
                        if (!o)
                            return;
                        if (e.preventDefault(),
                        !this._moveStateManager.isValidMoveEvent(e))
                            return void this.reset(e);
                        const a = Array.isArray(i) ? i[0] : i;
                        return !this._moved && a.dist(o) < this._clickTolerance ? void 0 : (this._moved = !0,
                        this._lastPoint = a,
                        this._move(o, a))
                    }
                    dragEnd(e) {
                        this.isEnabled() && this._lastPoint && this._moveStateManager.isValidEndEvent(e) && (this._moved && Y.suppressClick(),
                        this.reset(e))
                    }
                    enable() {
                        this._enabled = !0
                    }
                    disable() {
                        this._enabled = !1,
                        this.reset()
                    }
                    isEnabled() {
                        return this._enabled
                    }
                    isActive() {
                        return this._active
                    }
                    getClickTolerance() {
                        return this._clickTolerance
                    }
                }
                const Ve = {
                    0: 1,
                    2: 2
                };
                class Us {
                    constructor(e) {
                        this._correctEvent = e.checkCorrectEvent
                    }
                    startMove(e) {
                        const i = Y.mouseButton(e);
                        this._eventButton = i
                    }
                    endMove(e) {
                        delete this._eventButton
                    }
                    isValidStartEvent(e) {
                        return this._correctEvent(e)
                    }
                    isValidMoveEvent(e) {
                        return !function(i, o) {
                            const a = Ve[o];
                            return i.buttons === void 0 || (i.buttons & a) !== a
                        }(e, this._eventButton)
                    }
                    isValidEndEvent(e) {
                        return Y.mouseButton(e) === this._eventButton
                    }
                }
                class El {
                    constructor() {
                        this._firstTouch = void 0
                    }
                    _isOneFingerTouch(e) {
                        return e.targetTouches.length === 1
                    }
                    _isSameTouchEvent(e) {
                        return e.targetTouches[0].identifier === this._firstTouch
                    }
                    startMove(e) {
                        this._firstTouch = e.targetTouches[0].identifier
                    }
                    endMove(e) {
                        delete this._firstTouch
                    }
                    isValidStartEvent(e) {
                        return this._isOneFingerTouch(e)
                    }
                    isValidMoveEvent(e) {
                        return this._isOneFingerTouch(e) && this._isSameTouchEvent(e)
                    }
                    isValidEndEvent(e) {
                        return this._isOneFingerTouch(e) && this._isSameTouchEvent(e)
                    }
                }
                class iu {
                    constructor(e=new Us({
                        checkCorrectEvent: () => !0
                    }), i=new El) {
                        this.mouseMoveStateManager = e,
                        this.oneFingerTouchMoveStateManager = i
                    }
                    _executeRelevantHandler(e, i, o) {
                        return e instanceof MouseEvent ? i(e) : typeof TouchEvent < "u" && e instanceof TouchEvent ? o(e) : void 0
                    }
                    startMove(e) {
                        this._executeRelevantHandler(e, i => this.mouseMoveStateManager.startMove(i), i => this.oneFingerTouchMoveStateManager.startMove(i))
                    }
                    endMove(e) {
                        this._executeRelevantHandler(e, i => this.mouseMoveStateManager.endMove(i), i => this.oneFingerTouchMoveStateManager.endMove(i))
                    }
                    isValidStartEvent(e) {
                        return this._executeRelevantHandler(e, i => this.mouseMoveStateManager.isValidStartEvent(i), i => this.oneFingerTouchMoveStateManager.isValidStartEvent(i))
                    }
                    isValidMoveEvent(e) {
                        return this._executeRelevantHandler(e, i => this.mouseMoveStateManager.isValidMoveEvent(i), i => this.oneFingerTouchMoveStateManager.isValidMoveEvent(i))
                    }
                    isValidEndEvent(e) {
                        return this._executeRelevantHandler(e, i => this.mouseMoveStateManager.isValidEndEvent(i), i => this.oneFingerTouchMoveStateManager.isValidEndEvent(i))
                    }
                }
                const jn = u => {
                    u.mousedown = u.dragStart,
                    u.mousemoveWindow = u.dragMove,
                    u.mouseup = u.dragEnd,
                    u.contextmenu = e => {
                        e.preventDefault()
                    }
                }
                ;
                class yo {
                    constructor(e, i) {
                        this._clickTolerance = e.clickTolerance || 1,
                        this._map = i,
                        this.reset()
                    }
                    reset() {
                        this._active = !1,
                        this._touches = {},
                        this._sum = new l.P(0,0)
                    }
                    _shouldBePrevented(e) {
                        return e < (this._map.cooperativeGestures.isEnabled() ? 2 : 1)
                    }
                    touchstart(e, i, o) {
                        return this._calculateTransform(e, i, o)
                    }
                    touchmove(e, i, o) {
                        if (this._active) {
                            if (!this._shouldBePrevented(o.length))
                                return e.preventDefault(),
                                this._calculateTransform(e, i, o);
                            this._map.cooperativeGestures.notifyGestureBlocked("touch_pan", e)
                        }
                    }
                    touchend(e, i, o) {
                        this._calculateTransform(e, i, o),
                        this._active && this._shouldBePrevented(o.length) && this.reset()
                    }
                    touchcancel() {
                        this.reset()
                    }
                    _calculateTransform(e, i, o) {
                        o.length > 0 && (this._active = !0);
                        const a = Il(o, i)
                          , h = new l.P(0,0)
                          , m = new l.P(0,0);
                        let y = 0;
                        for (const T in a) {
                            const S = a[T]
                              , A = this._touches[T];
                            A && (h._add(S),
                            m._add(S.sub(A)),
                            y++,
                            a[T] = S)
                        }
                        if (this._touches = a,
                        this._shouldBePrevented(y) || !m.mag())
                            return;
                        const v = m.div(y);
                        return this._sum._add(v),
                        this._sum.mag() < this._clickTolerance ? void 0 : {
                            around: h.div(y),
                            panDelta: v
                        }
                    }
                    enable() {
                        this._enabled = !0
                    }
                    disable() {
                        this._enabled = !1,
                        this.reset()
                    }
                    isEnabled() {
                        return this._enabled
                    }
                    isActive() {
                        return this._active
                    }
                }
                class la {
                    constructor() {
                        this.reset()
                    }
                    reset() {
                        this._active = !1,
                        delete this._firstTwoTouches
                    }
                    touchstart(e, i, o) {
                        this._firstTwoTouches || o.length < 2 || (this._firstTwoTouches = [o[0].identifier, o[1].identifier],
                        this._start([i[0], i[1]]))
                    }
                    touchmove(e, i, o) {
                        if (!this._firstTwoTouches)
                            return;
                        e.preventDefault();
                        const [a,h] = this._firstTwoTouches
                          , m = ct(o, i, a)
                          , y = ct(o, i, h);
                        if (!m || !y)
                            return;
                        const v = this._aroundCenter ? null : m.add(y).div(2);
                        return this._move([m, y], v, e)
                    }
                    touchend(e, i, o) {
                        if (!this._firstTwoTouches)
                            return;
                        const [a,h] = this._firstTwoTouches
                          , m = ct(o, i, a)
                          , y = ct(o, i, h);
                        m && y || (this._active && Y.suppressClick(),
                        this.reset())
                    }
                    touchcancel() {
                        this.reset()
                    }
                    enable(e) {
                        this._enabled = !0,
                        this._aroundCenter = !!e && e.around === "center"
                    }
                    disable() {
                        this._enabled = !1,
                        this.reset()
                    }
                    isEnabled() {
                        return !!this._enabled
                    }
                    isActive() {
                        return !!this._active
                    }
                }
                function ct(u, e, i) {
                    for (let o = 0; o < u.length; o++)
                        if (u[o].identifier === i)
                            return e[o]
                }
                function ca(u, e) {
                    return Math.log(u / e) / Math.LN2
                }
                class ru extends la {
                    reset() {
                        super.reset(),
                        delete this._distance,
                        delete this._startDistance
                    }
                    _start(e) {
                        this._startDistance = this._distance = e[0].dist(e[1])
                    }
                    _move(e, i) {
                        const o = this._distance;
                        if (this._distance = e[0].dist(e[1]),
                        this._active || !(Math.abs(ca(this._distance, this._startDistance)) < .1))
                            return this._active = !0,
                            {
                                zoomDelta: ca(this._distance, o),
                                pinchAround: i
                            }
                    }
                }
                function ua(u, e) {
                    return 180 * u.angleWith(e) / Math.PI
                }
                class nu extends la {
                    reset() {
                        super.reset(),
                        delete this._minDiameter,
                        delete this._startVector,
                        delete this._vector
                    }
                    _start(e) {
                        this._startVector = this._vector = e[0].sub(e[1]),
                        this._minDiameter = e[0].dist(e[1])
                    }
                    _move(e, i, o) {
                        const a = this._vector;
                        if (this._vector = e[0].sub(e[1]),
                        this._active || !this._isBelowThreshold(this._vector))
                            return this._active = !0,
                            {
                                bearingDelta: ua(this._vector, a),
                                pinchAround: i
                            }
                    }
                    _isBelowThreshold(e) {
                        this._minDiameter = Math.min(this._minDiameter, e.mag());
                        const i = 25 / (Math.PI * this._minDiameter) * 360
                          , o = ua(e, this._startVector);
                        return Math.abs(o) < i
                    }
                }
                function Al(u) {
                    return Math.abs(u.y) > Math.abs(u.x)
                }
                class zl extends la {
                    constructor(e) {
                        super(),
                        this._currentTouchCount = 0,
                        this._map = e
                    }
                    reset() {
                        super.reset(),
                        this._valid = void 0,
                        delete this._firstMove,
                        delete this._lastPoints
                    }
                    touchstart(e, i, o) {
                        super.touchstart(e, i, o),
                        this._currentTouchCount = o.length
                    }
                    _start(e) {
                        this._lastPoints = e,
                        Al(e[0].sub(e[1])) && (this._valid = !1)
                    }
                    _move(e, i, o) {
                        if (this._map.cooperativeGestures.isEnabled() && this._currentTouchCount < 3)
                            return;
                        const a = e[0].sub(this._lastPoints[0])
                          , h = e[1].sub(this._lastPoints[1]);
                        return this._valid = this.gestureBeginsVertically(a, h, o.timeStamp),
                        this._valid ? (this._lastPoints = e,
                        this._active = !0,
                        {
                            pitchDelta: (a.y + h.y) / 2 * -.5
                        }) : void 0
                    }
                    gestureBeginsVertically(e, i, o) {
                        if (this._valid !== void 0)
                            return this._valid;
                        const a = e.mag() >= 2
                          , h = i.mag() >= 2;
                        if (!a && !h)
                            return;
                        if (!a || !h)
                            return this._firstMove === void 0 && (this._firstMove = o),
                            o - this._firstMove < 100 && void 0;
                        const m = e.y > 0 == i.y > 0;
                        return Al(e) && Al(i) && m
                    }
                }
                const kl = {
                    panStep: 100,
                    bearingStep: 15,
                    pitchStep: 10
                };
                class Ll {
                    constructor(e) {
                        this._tr = new go(e);
                        const i = kl;
                        this._panStep = i.panStep,
                        this._bearingStep = i.bearingStep,
                        this._pitchStep = i.pitchStep,
                        this._rotationDisabled = !1
                    }
                    reset() {
                        this._active = !1
                    }
                    keydown(e) {
                        if (e.altKey || e.ctrlKey || e.metaKey)
                            return;
                        let i = 0
                          , o = 0
                          , a = 0
                          , h = 0
                          , m = 0;
                        switch (e.keyCode) {
                        case 61:
                        case 107:
                        case 171:
                        case 187:
                            i = 1;
                            break;
                        case 189:
                        case 109:
                        case 173:
                            i = -1;
                            break;
                        case 37:
                            e.shiftKey ? o = -1 : (e.preventDefault(),
                            h = -1);
                            break;
                        case 39:
                            e.shiftKey ? o = 1 : (e.preventDefault(),
                            h = 1);
                            break;
                        case 38:
                            e.shiftKey ? a = 1 : (e.preventDefault(),
                            m = -1);
                            break;
                        case 40:
                            e.shiftKey ? a = -1 : (e.preventDefault(),
                            m = 1);
                            break;
                        default:
                            return
                        }
                        return this._rotationDisabled && (o = 0,
                        a = 0),
                        {
                            cameraAnimation: y => {
                                const v = this._tr;
                                y.easeTo({
                                    duration: 300,
                                    easeId: "keyboardHandler",
                                    easing: _h,
                                    zoom: i ? Math.round(v.zoom) + i * (e.shiftKey ? 2 : 1) : v.zoom,
                                    bearing: v.bearing + o * this._bearingStep,
                                    pitch: v.pitch + a * this._pitchStep,
                                    offset: [-h * this._panStep, -m * this._panStep],
                                    center: v.center
                                }, {
                                    originalEvent: e
                                })
                            }
                        }
                    }
                    enable() {
                        this._enabled = !0
                    }
                    disable() {
                        this._enabled = !1,
                        this.reset()
                    }
                    isEnabled() {
                        return this._enabled
                    }
                    isActive() {
                        return this._active
                    }
                    disableRotation() {
                        this._rotationDisabled = !0
                    }
                    enableRotation() {
                        this._rotationDisabled = !1
                    }
                }
                function _h(u) {
                    return u * (2 - u)
                }
                const Dl = 4.000244140625;
                class su {
                    constructor(e, i) {
                        this._onTimeout = o => {
                            this._type = "wheel",
                            this._delta -= this._lastValue,
                            this._active || this._start(o)
                        }
                        ,
                        this._map = e,
                        this._tr = new go(e),
                        this._triggerRenderFrame = i,
                        this._delta = 0,
                        this._defaultZoomRate = .01,
                        this._wheelZoomRate = .0022222222222222222
                    }
                    setZoomRate(e) {
                        this._defaultZoomRate = e
                    }
                    setWheelZoomRate(e) {
                        this._wheelZoomRate = e
                    }
                    isEnabled() {
                        return !!this._enabled
                    }
                    isActive() {
                        return !!this._active || this._finishTimeout !== void 0
                    }
                    isZooming() {
                        return !!this._zooming
                    }
                    enable(e) {
                        this.isEnabled() || (this._enabled = !0,
                        this._aroundCenter = !!e && e.around === "center")
                    }
                    disable() {
                        this.isEnabled() && (this._enabled = !1)
                    }
                    _shouldBePrevented(e) {
                        return !!this._map.cooperativeGestures.isEnabled() && !(e.ctrlKey || this._map.cooperativeGestures.isBypassed(e))
                    }
                    wheel(e) {
                        if (!this.isEnabled())
                            return;
                        if (this._shouldBePrevented(e))
                            return void this._map.cooperativeGestures.notifyGestureBlocked("wheel_zoom", e);
                        let i = e.deltaMode === WheelEvent.DOM_DELTA_LINE ? 40 * e.deltaY : e.deltaY;
                        const o = oe.now()
                          , a = o - (this._lastWheelEventTime || 0);
                        this._lastWheelEventTime = o,
                        i !== 0 && i % Dl == 0 ? this._type = "wheel" : i !== 0 && Math.abs(i) < 4 ? this._type = "trackpad" : a > 400 ? (this._type = null,
                        this._lastValue = i,
                        this._timeout = setTimeout(this._onTimeout, 40, e)) : this._type || (this._type = Math.abs(a * i) < 200 ? "trackpad" : "wheel",
                        this._timeout && (clearTimeout(this._timeout),
                        this._timeout = null,
                        i += this._lastValue)),
                        e.shiftKey && i && (i /= 4),
                        this._type && (this._lastWheelEvent = e,
                        this._delta -= i,
                        this._active || this._start(e)),
                        e.preventDefault()
                    }
                    _start(e) {
                        if (!this._delta)
                            return;
                        this._frameId && (this._frameId = null),
                        this._active = !0,
                        this.isZooming() || (this._zooming = !0),
                        this._finishTimeout && (clearTimeout(this._finishTimeout),
                        delete this._finishTimeout);
                        const i = Y.mousePos(this._map.getCanvas(), e)
                          , o = this._tr;
                        this._aroundPoint = this._aroundCenter ? o.transform.locationToScreenPoint(l.Q.convert(o.center)) : i,
                        this._frameId || (this._frameId = !0,
                        this._triggerRenderFrame())
                    }
                    renderFrame() {
                        if (!this._frameId || (this._frameId = null,
                        !this.isActive()))
                            return;
                        const e = this._tr.transform;
                        if (typeof this._lastExpectedZoom == "number") {
                            const y = e.zoom - this._lastExpectedZoom;
                            typeof this._startZoom == "number" && (this._startZoom += y),
                            typeof this._targetZoom == "number" && (this._targetZoom += y)
                        }
                        if (this._delta !== 0) {
                            const y = this._type === "wheel" && Math.abs(this._delta) > Dl ? this._wheelZoomRate : this._defaultZoomRate;
                            let v = 2 / (1 + Math.exp(-Math.abs(this._delta * y)));
                            this._delta < 0 && v !== 0 && (v = 1 / v);
                            const T = typeof this._targetZoom != "number" ? e.scale : l.aH(this._targetZoom);
                            this._targetZoom = Math.min(e.maxZoom, Math.max(e.minZoom, l.aa(T * v))),
                            this._type === "wheel" && (this._startZoom = e.zoom,
                            this._easing = this._smoothOutEasing(200)),
                            this._delta = 0
                        }
                        const i = typeof this._targetZoom != "number" ? e.zoom : this._targetZoom
                          , o = this._startZoom
                          , a = this._easing;
                        let h, m = !1;
                        if (this._type === "wheel" && o && a) {
                            const y = oe.now() - this._lastWheelEventTime
                              , v = Math.min((y + 5) / 200, 1)
                              , T = a(v);
                            h = l.B.number(o, i, T),
                            v < 1 ? this._frameId || (this._frameId = !0) : m = !0
                        } else
                            h = i,
                            m = !0;
                        return this._active = !0,
                        m && (this._active = !1,
                        this._finishTimeout = setTimeout( () => {
                            this._zooming = !1,
                            this._triggerRenderFrame(),
                            delete this._targetZoom,
                            delete this._lastExpectedZoom,
                            delete this._finishTimeout
                        }
                        , 200)),
                        this._lastExpectedZoom = h,
                        {
                            noInertia: !0,
                            needsRenderFrame: !m,
                            zoomDelta: h - e.zoom,
                            around: this._aroundPoint,
                            originalEvent: this._lastWheelEvent
                        }
                    }
                    _smoothOutEasing(e) {
                        let i = l.ca;
                        if (this._prevEase) {
                            const o = this._prevEase
                              , a = (oe.now() - o.start) / o.duration
                              , h = o.easing(a + .01) - o.easing(a)
                              , m = .27 / Math.sqrt(h * h + 1e-4) * .01
                              , y = Math.sqrt(.0729 - m * m);
                            i = l.c8(m, y, .25, 1)
                        }
                        return this._prevEase = {
                            start: oe.now(),
                            duration: e,
                            easing: i
                        },
                        i
                    }
                    reset() {
                        this._active = !1,
                        this._zooming = !1,
                        delete this._targetZoom,
                        delete this._lastExpectedZoom,
                        this._finishTimeout && (clearTimeout(this._finishTimeout),
                        delete this._finishTimeout)
                    }
                }
                class ou {
                    constructor(e, i) {
                        this._clickZoom = e,
                        this._tapZoom = i
                    }
                    enable() {
                        this._clickZoom.enable(),
                        this._tapZoom.enable()
                    }
                    disable() {
                        this._clickZoom.disable(),
                        this._tapZoom.disable()
                    }
                    isEnabled() {
                        return this._clickZoom.isEnabled() && this._tapZoom.isEnabled()
                    }
                    isActive() {
                        return this._clickZoom.isActive() || this._tapZoom.isActive()
                    }
                }
                class Vn {
                    constructor(e) {
                        this._tr = new go(e),
                        this.reset()
                    }
                    reset() {
                        this._active = !1
                    }
                    dblclick(e, i) {
                        return e.preventDefault(),
                        {
                            cameraAnimation: o => {
                                o.easeTo({
                                    duration: 300,
                                    zoom: this._tr.zoom + (e.shiftKey ? -1 : 1),
                                    around: this._tr.unproject(i)
                                }, {
                                    originalEvent: e
                                })
                            }
                        }
                    }
                    enable() {
                        this._enabled = !0
                    }
                    disable() {
                        this._enabled = !1,
                        this.reset()
                    }
                    isEnabled() {
                        return this._enabled
                    }
                    isActive() {
                        return this._active
                    }
                }
                class Ut {
                    constructor() {
                        this._tap = new aa({
                            numTouches: 1,
                            numTaps: 1
                        }),
                        this.reset()
                    }
                    reset() {
                        this._active = !1,
                        delete this._swipePoint,
                        delete this._swipeTouch,
                        delete this._tapTime,
                        delete this._tapPoint,
                        this._tap.reset()
                    }
                    touchstart(e, i, o) {
                        if (!this._swipePoint)
                            if (this._tapTime) {
                                const a = i[0]
                                  , h = e.timeStamp - this._tapTime < 500
                                  , m = this._tapPoint.dist(a) < 30;
                                h && m ? o.length > 0 && (this._swipePoint = a,
                                this._swipeTouch = o[0].identifier) : this.reset()
                            } else
                                this._tap.touchstart(e, i, o)
                    }
                    touchmove(e, i, o) {
                        if (this._tapTime) {
                            if (this._swipePoint) {
                                if (o[0].identifier !== this._swipeTouch)
                                    return;
                                const a = i[0]
                                  , h = a.y - this._swipePoint.y;
                                return this._swipePoint = a,
                                e.preventDefault(),
                                this._active = !0,
                                {
                                    zoomDelta: h / 128
                                }
                            }
                        } else
                            this._tap.touchmove(e, i, o)
                    }
                    touchend(e, i, o) {
                        if (this._tapTime)
                            this._swipePoint && o.length === 0 && this.reset();
                        else {
                            const a = this._tap.touchend(e, i, o);
                            a && (this._tapTime = e.timeStamp,
                            this._tapPoint = a)
                        }
                    }
                    touchcancel() {
                        this.reset()
                    }
                    enable() {
                        this._enabled = !0
                    }
                    disable() {
                        this._enabled = !1,
                        this.reset()
                    }
                    isEnabled() {
                        return this._enabled
                    }
                    isActive() {
                        return this._active
                    }
                }
                class xo {
                    constructor(e, i, o) {
                        this._el = e,
                        this._mousePan = i,
                        this._touchPan = o
                    }
                    enable(e) {
                        this._inertiaOptions = e || {},
                        this._mousePan.enable(),
                        this._touchPan.enable(),
                        this._el.classList.add("maplibregl-touch-drag-pan")
                    }
                    disable() {
                        this._mousePan.disable(),
                        this._touchPan.disable(),
                        this._el.classList.remove("maplibregl-touch-drag-pan")
                    }
                    isEnabled() {
                        return this._mousePan.isEnabled() && this._touchPan.isEnabled()
                    }
                    isActive() {
                        return this._mousePan.isActive() || this._touchPan.isActive()
                    }
                }
                class ha {
                    constructor(e, i, o, a) {
                        this._pitchWithRotate = e.pitchWithRotate,
                        this._rollEnabled = e.rollEnabled,
                        this._mouseRotate = i,
                        this._mousePitch = o,
                        this._mouseRoll = a
                    }
                    enable() {
                        this._mouseRotate.enable(),
                        this._pitchWithRotate && this._mousePitch.enable(),
                        this._rollEnabled && this._mouseRoll.enable()
                    }
                    disable() {
                        this._mouseRotate.disable(),
                        this._mousePitch.disable(),
                        this._mouseRoll.disable()
                    }
                    isEnabled() {
                        return this._mouseRotate.isEnabled() && (!this._pitchWithRotate || this._mousePitch.isEnabled()) && (!this._rollEnabled || this._mouseRoll.isEnabled())
                    }
                    isActive() {
                        return this._mouseRotate.isActive() || this._mousePitch.isActive() || this._mouseRoll.isActive()
                    }
                }
                class Rl {
                    constructor(e, i, o, a) {
                        this._el = e,
                        this._touchZoom = i,
                        this._touchRotate = o,
                        this._tapDragZoom = a,
                        this._rotationDisabled = !1,
                        this._enabled = !0
                    }
                    enable(e) {
                        this._touchZoom.enable(e),
                        this._rotationDisabled || this._touchRotate.enable(e),
                        this._tapDragZoom.enable(),
                        this._el.classList.add("maplibregl-touch-zoom-rotate")
                    }
                    disable() {
                        this._touchZoom.disable(),
                        this._touchRotate.disable(),
                        this._tapDragZoom.disable(),
                        this._el.classList.remove("maplibregl-touch-zoom-rotate")
                    }
                    isEnabled() {
                        return this._touchZoom.isEnabled() && (this._rotationDisabled || this._touchRotate.isEnabled()) && this._tapDragZoom.isEnabled()
                    }
                    isActive() {
                        return this._touchZoom.isActive() || this._touchRotate.isActive() || this._tapDragZoom.isActive()
                    }
                    disableRotation() {
                        this._rotationDisabled = !0,
                        this._touchRotate.disable()
                    }
                    enableRotation() {
                        this._rotationDisabled = !1,
                        this._touchZoom.isEnabled() && this._touchRotate.enable()
                    }
                }
                class Fl {
                    constructor(e, i) {
                        this._bypassKey = navigator.userAgent.indexOf("Mac") !== -1 ? "metaKey" : "ctrlKey",
                        this._map = e,
                        this._options = i,
                        this._enabled = !1
                    }
                    isActive() {
                        return !1
                    }
                    reset() {}
                    _setupUI() {
                        if (this._container)
                            return;
                        const e = this._map.getCanvasContainer();
                        e.classList.add("maplibregl-cooperative-gestures"),
                        this._container = Y.create("div", "maplibregl-cooperative-gesture-screen", e);
                        let i = this._map._getUIString("CooperativeGesturesHandler.WindowsHelpText");
                        this._bypassKey === "metaKey" && (i = this._map._getUIString("CooperativeGesturesHandler.MacHelpText"));
                        const o = this._map._getUIString("CooperativeGesturesHandler.MobileHelpText")
                          , a = document.createElement("div");
                        a.className = "maplibregl-desktop-message",
                        a.textContent = i,
                        this._container.appendChild(a);
                        const h = document.createElement("div");
                        h.className = "maplibregl-mobile-message",
                        h.textContent = o,
                        this._container.appendChild(h),
                        this._container.setAttribute("aria-hidden", "true")
                    }
                    _destroyUI() {
                        this._container && (Y.remove(this._container),
                        this._map.getCanvasContainer().classList.remove("maplibregl-cooperative-gestures")),
                        delete this._container
                    }
                    enable() {
                        this._setupUI(),
                        this._enabled = !0
                    }
                    disable() {
                        this._enabled = !1,
                        this._destroyUI()
                    }
                    isEnabled() {
                        return this._enabled
                    }
                    isBypassed(e) {
                        return e[this._bypassKey]
                    }
                    notifyGestureBlocked(e, i) {
                        this._enabled && (this._map.fire(new l.l("cooperativegestureprevented",{
                            gestureType: e,
                            originalEvent: i
                        })),
                        this._container.classList.add("maplibregl-show"),
                        setTimeout( () => {
                            this._container.classList.remove("maplibregl-show")
                        }
                        , 100))
                    }
                }
                const vo = u => u.zoom || u.drag || u.roll || u.pitch || u.rotate;
                class yh extends l.l {
                }
                function zr(u) {
                    return u.panDelta && u.panDelta.mag() || u.zoomDelta || u.bearingDelta || u.pitchDelta || u.rollDelta
                }
                class da {
                    constructor(e, i) {
                        this.handleWindowEvent = a => {
                            this.handleEvent(a, `${a.type}Window`)
                        }
                        ,
                        this.handleEvent = (a, h) => {
                            if (a.type === "blur")
                                return void this.stop(!0);
                            this._updatingCamera = !0;
                            const m = a.type === "renderFrame" ? void 0 : a
                              , y = {
                                needsRenderFrame: !1
                            }
                              , v = {}
                              , T = {}
                              , S = a.touches
                              , A = S ? this._getMapTouches(S) : void 0
                              , k = A ? Y.touchPos(this._map.getCanvas(), A) : Y.mousePos(this._map.getCanvas(), a);
                            for (const {handlerName: H, handler: q, allowed: W} of this._handlers) {
                                if (!q.isEnabled())
                                    continue;
                                let J;
                                this._blockedByActive(T, W, H) ? q.reset() : q[h || a.type] && (J = q[h || a.type](a, k, A),
                                this.mergeHandlerResult(y, v, J, H, m),
                                J && J.needsRenderFrame && this._triggerRenderFrame()),
                                (J || q.isActive()) && (T[H] = q)
                            }
                            const O = {};
                            for (const H in this._previousActiveHandlers)
                                T[H] || (O[H] = m);
                            this._previousActiveHandlers = T,
                            (Object.keys(O).length || zr(y)) && (this._changes.push([y, v, O]),
                            this._triggerRenderFrame()),
                            (Object.keys(T).length || zr(y)) && this._map._stop(!0),
                            this._updatingCamera = !1;
                            const {cameraAnimation: V} = y;
                            V && (this._inertia.clear(),
                            this._fireEvents({}, {}, !0),
                            this._changes = [],
                            V(this._map))
                        }
                        ,
                        this._map = e,
                        this._el = this._map.getCanvasContainer(),
                        this._handlers = [],
                        this._handlersById = {},
                        this._changes = [],
                        this._inertia = new eu(e),
                        this._bearingSnap = i.bearingSnap,
                        this._previousActiveHandlers = {},
                        this._eventsInProgress = {},
                        this._addDefaultHandlers(i);
                        const o = this._el;
                        this._listeners = [[o, "touchstart", {
                            passive: !0
                        }], [o, "touchmove", {
                            passive: !1
                        }], [o, "touchend", void 0], [o, "touchcancel", void 0], [o, "mousedown", void 0], [o, "mousemove", void 0], [o, "mouseup", void 0], [document, "mousemove", {
                            capture: !0
                        }], [document, "mouseup", void 0], [o, "mouseover", void 0], [o, "mouseout", void 0], [o, "dblclick", void 0], [o, "click", void 0], [o, "keydown", {
                            capture: !1
                        }], [o, "keyup", void 0], [o, "wheel", {
                            passive: !1
                        }], [o, "contextmenu", void 0], [window, "blur", void 0]];
                        for (const [a,h,m] of this._listeners)
                            Y.addEventListener(a, h, a === document ? this.handleWindowEvent : this.handleEvent, m)
                    }
                    destroy() {
                        for (const [e,i,o] of this._listeners)
                            Y.removeEventListener(e, i, e === document ? this.handleWindowEvent : this.handleEvent, o)
                    }
                    _addDefaultHandlers(e) {
                        const i = this._map
                          , o = i.getCanvasContainer();
                        this._add("mapEvent", new nn(i,e));
                        const a = i.boxZoom = new tu(i,e);
                        this._add("boxZoom", a),
                        e.interactive && e.boxZoom && a.enable();
                        const h = i.cooperativeGestures = new Fl(i,e.cooperativeGestures);
                        this._add("cooperativeGestures", h),
                        e.cooperativeGestures && h.enable();
                        const m = new _o(i)
                          , y = new Vn(i);
                        i.doubleClickZoom = new ou(y,m),
                        this._add("tapZoom", m),
                        this._add("clickZoom", y),
                        e.interactive && e.doubleClickZoom && i.doubleClickZoom.enable();
                        const v = new Ut;
                        this._add("tapDragZoom", v);
                        const T = i.touchPitch = new zl(i);
                        this._add("touchPitch", T),
                        e.interactive && e.touchPitch && i.touchPitch.enable(e.touchPitch);
                        const S = () => i.project(i.getCenter())
                          , A = function({enable: ie, clickTolerance: ne, aroundCenter: le=!0, minPixelCenterThreshold: se=100, rotateDegreesPerPixelMoved: _e=.8}, xe) {
                            const Pe = new Us({
                                checkCorrectEvent: Ie => Y.mouseButton(Ie) === 0 && Ie.ctrlKey || Y.mouseButton(Ie) === 2 && !Ie.ctrlKey
                            });
                            return new ur({
                                clickTolerance: ne,
                                move: (Ie, Ce) => {
                                    const Ne = xe();
                                    if (le && Math.abs(Ne.y - Ie.y) > se)
                                        return {
                                            bearingDelta: l.c9(new l.P(Ie.x,Ce.y), Ce, Ne)
                                        };
                                    let Oe = (Ce.x - Ie.x) * _e;
                                    return le && Ce.y < Ne.y && (Oe = -Oe),
                                    {
                                        bearingDelta: Oe
                                    }
                                }
                                ,
                                moveStateManager: Pe,
                                enable: ie,
                                assignEvents: jn
                            })
                        }(e, S)
                          , k = function({enable: ie, clickTolerance: ne, pitchDegreesPerPixelMoved: le=-.5}) {
                            const se = new Us({
                                checkCorrectEvent: _e => Y.mouseButton(_e) === 0 && _e.ctrlKey || Y.mouseButton(_e) === 2
                            });
                            return new ur({
                                clickTolerance: ne,
                                move: (_e, xe) => ({
                                    pitchDelta: (xe.y - _e.y) * le
                                }),
                                moveStateManager: se,
                                enable: ie,
                                assignEvents: jn
                            })
                        }(e)
                          , O = function({enable: ie, clickTolerance: ne, rollDegreesPerPixelMoved: le=.3}, se) {
                            const _e = new Us({
                                checkCorrectEvent: xe => Y.mouseButton(xe) === 2 && xe.ctrlKey
                            });
                            return new ur({
                                clickTolerance: ne,
                                move: (xe, Pe) => {
                                    const Ie = se();
                                    let Ce = (Pe.x - xe.x) * le;
                                    return Pe.y < Ie.y && (Ce = -Ce),
                                    {
                                        rollDelta: Ce
                                    }
                                }
                                ,
                                moveStateManager: _e,
                                enable: ie,
                                assignEvents: jn
                            })
                        }(e, S);
                        i.dragRotate = new ha(e,A,k,O),
                        this._add("mouseRotate", A, ["mousePitch"]),
                        this._add("mousePitch", k, ["mouseRotate", "mouseRoll"]),
                        this._add("mouseRoll", O, ["mousePitch"]),
                        e.interactive && e.dragRotate && i.dragRotate.enable();
                        const V = function({enable: ie, clickTolerance: ne}) {
                            const le = new Us({
                                checkCorrectEvent: se => Y.mouseButton(se) === 0 && !se.ctrlKey
                            });
                            return new ur({
                                clickTolerance: ne,
                                move: (se, _e) => ({
                                    around: _e,
                                    panDelta: _e.sub(se)
                                }),
                                activateOnStart: !0,
                                moveStateManager: le,
                                enable: ie,
                                assignEvents: jn
                            })
                        }(e)
                          , H = new yo(e,i);
                        i.dragPan = new xo(o,V,H),
                        this._add("mousePan", V),
                        this._add("touchPan", H, ["touchZoom", "touchRotate"]),
                        e.interactive && e.dragPan && i.dragPan.enable(e.dragPan);
                        const q = new nu
                          , W = new ru;
                        i.touchZoomRotate = new Rl(o,W,q,v),
                        this._add("touchRotate", q, ["touchPan", "touchZoom"]),
                        this._add("touchZoom", W, ["touchPan", "touchRotate"]),
                        e.interactive && e.touchZoomRotate && i.touchZoomRotate.enable(e.touchZoomRotate);
                        const J = i.scrollZoom = new su(i, () => this._triggerRenderFrame());
                        this._add("scrollZoom", J, ["mousePan"]),
                        e.interactive && e.scrollZoom && i.scrollZoom.enable(e.scrollZoom);
                        const te = i.keyboard = new Ll(i);
                        this._add("keyboard", te),
                        e.interactive && e.keyboard && i.keyboard.enable(),
                        this._add("blockableMapEvent", new Vs(i))
                    }
                    _add(e, i, o) {
                        this._handlers.push({
                            handlerName: e,
                            handler: i,
                            allowed: o
                        }),
                        this._handlersById[e] = i
                    }
                    stop(e) {
                        if (!this._updatingCamera) {
                            for (const {handler: i} of this._handlers)
                                i.reset();
                            this._inertia.clear(),
                            this._fireEvents({}, {}, e),
                            this._changes = []
                        }
                    }
                    isActive() {
                        for (const {handler: e} of this._handlers)
                            if (e.isActive())
                                return !0;
                        return !1
                    }
                    isZooming() {
                        return !!this._eventsInProgress.zoom || this._map.scrollZoom.isZooming()
                    }
                    isRotating() {
                        return !!this._eventsInProgress.rotate
                    }
                    isMoving() {
                        return !!vo(this._eventsInProgress) || this.isZooming()
                    }
                    _blockedByActive(e, i, o) {
                        for (const a in e)
                            if (a !== o && (!i || i.indexOf(a) < 0))
                                return !0;
                        return !1
                    }
                    _getMapTouches(e) {
                        const i = [];
                        for (const o of e)
                            this._el.contains(o.target) && i.push(o);
                        return i
                    }
                    mergeHandlerResult(e, i, o, a, h) {
                        if (!o)
                            return;
                        l.e(e, o);
                        const m = {
                            handlerName: a,
                            originalEvent: o.originalEvent || h
                        };
                        o.zoomDelta !== void 0 && (i.zoom = m),
                        o.panDelta !== void 0 && (i.drag = m),
                        o.rollDelta !== void 0 && (i.roll = m),
                        o.pitchDelta !== void 0 && (i.pitch = m),
                        o.bearingDelta !== void 0 && (i.rotate = m)
                    }
                    _applyChanges() {
                        const e = {}
                          , i = {}
                          , o = {};
                        for (const [a,h,m] of this._changes)
                            a.panDelta && (e.panDelta = (e.panDelta || new l.P(0,0))._add(a.panDelta)),
                            a.zoomDelta && (e.zoomDelta = (e.zoomDelta || 0) + a.zoomDelta),
                            a.bearingDelta && (e.bearingDelta = (e.bearingDelta || 0) + a.bearingDelta),
                            a.pitchDelta && (e.pitchDelta = (e.pitchDelta || 0) + a.pitchDelta),
                            a.rollDelta && (e.rollDelta = (e.rollDelta || 0) + a.rollDelta),
                            a.around !== void 0 && (e.around = a.around),
                            a.pinchAround !== void 0 && (e.pinchAround = a.pinchAround),
                            a.noInertia && (e.noInertia = a.noInertia),
                            l.e(i, h),
                            l.e(o, m);
                        this._updateMapTransform(e, i, o),
                        this._changes = []
                    }
                    _updateMapTransform(e, i, o) {
                        const a = this._map
                          , h = a._getTransformForUpdate()
                          , m = a.terrain;
                        if (!(zr(e) || m && this._terrainMovement))
                            return this._fireEvents(i, o, !0);
                        a._stop(!0);
                        let {panDelta: y, zoomDelta: v, bearingDelta: T, pitchDelta: S, rollDelta: A, around: k, pinchAround: O} = e;
                        O !== void 0 && (k = O),
                        k = k || a.transform.centerPoint,
                        m && !h.isPointOnMapSurface(k) && (k = h.centerPoint);
                        const V = {
                            panDelta: y,
                            zoomDelta: v,
                            rollDelta: A,
                            pitchDelta: S,
                            bearingDelta: T,
                            around: k
                        };
                        this._map.cameraHelper.useGlobeControls && !h.isPointOnMapSurface(k) && (k = h.centerPoint);
                        const H = k.distSqr(h.centerPoint) < .01 ? h.center : h.screenPointToLocation(y ? k.sub(y) : k);
                        m ? (this._map.cameraHelper.handleMapControlsRollPitchBearingZoom(V, h),
                        this._terrainMovement || !i.drag && !i.zoom ? i.drag && this._terrainMovement ? h.setCenter(h.screenPointToLocation(h.centerPoint.sub(y))) : this._map.cameraHelper.handleMapControlsPan(V, h, H) : (this._terrainMovement = !0,
                        this._map._elevationFreeze = !0,
                        this._map.cameraHelper.handleMapControlsPan(V, h, H))) : (this._map.cameraHelper.handleMapControlsRollPitchBearingZoom(V, h),
                        this._map.cameraHelper.handleMapControlsPan(V, h, H)),
                        a._applyUpdatedTransform(h),
                        this._map._update(),
                        e.noInertia || this._inertia.record(e),
                        this._fireEvents(i, o, !0)
                    }
                    _fireEvents(e, i, o) {
                        const a = vo(this._eventsInProgress)
                          , h = vo(e)
                          , m = {};
                        for (const A in e) {
                            const {originalEvent: k} = e[A];
                            this._eventsInProgress[A] || (m[`${A}start`] = k),
                            this._eventsInProgress[A] = e[A]
                        }
                        !a && h && this._fireEvent("movestart", h.originalEvent);
                        for (const A in m)
                            this._fireEvent(A, m[A]);
                        h && this._fireEvent("move", h.originalEvent);
                        for (const A in e) {
                            const {originalEvent: k} = e[A];
                            this._fireEvent(A, k)
                        }
                        const y = {};
                        let v;
                        for (const A in this._eventsInProgress) {
                            const {handlerName: k, originalEvent: O} = this._eventsInProgress[A];
                            this._handlersById[k].isActive() || (delete this._eventsInProgress[A],
                            v = i[k] || O,
                            y[`${A}end`] = v)
                        }
                        for (const A in y)
                            this._fireEvent(A, y[A]);
                        const T = vo(this._eventsInProgress)
                          , S = (a || h) && !T;
                        if (S && this._terrainMovement) {
                            this._map._elevationFreeze = !1,
                            this._terrainMovement = !1;
                            const A = this._map._getTransformForUpdate();
                            this._map.getCenterClampedToGround() && A.recalculateZoomAndCenter(this._map.terrain),
                            this._map._applyUpdatedTransform(A)
                        }
                        if (o && S) {
                            this._updatingCamera = !0;
                            const A = this._inertia._onMoveEnd(this._map.dragPan._inertiaOptions)
                              , k = O => O !== 0 && -this._bearingSnap < O && O < this._bearingSnap;
                            !A || !A.essential && oe.prefersReducedMotion ? (this._map.fire(new l.l("moveend",{
                                originalEvent: v
                            })),
                            k(this._map.getBearing()) && this._map.resetNorth()) : (k(A.bearing || this._map.getBearing()) && (A.bearing = 0),
                            A.freezeElevation = !0,
                            this._map.easeTo(A, {
                                originalEvent: v
                            })),
                            this._updatingCamera = !1
                        }
                    }
                    _fireEvent(e, i) {
                        this._map.fire(new l.l(e,i ? {
                            originalEvent: i
                        } : {}))
                    }
                    _requestFrame() {
                        return this._map.triggerRepaint(),
                        this._map._renderTaskQueue.add(e => {
                            delete this._frameId,
                            this.handleEvent(new yh("renderFrame",{
                                timeStamp: e
                            })),
                            this._applyChanges()
                        }
                        )
                    }
                    _triggerRenderFrame() {
                        this._frameId === void 0 && (this._frameId = this._requestFrame())
                    }
                }
                class Xe extends l.E {
                    constructor(e, i, o) {
                        super(),
                        this._renderFrameCallback = () => {
                            const a = Math.min((oe.now() - this._easeStart) / this._easeOptions.duration, 1);
                            this._onEaseFrame(this._easeOptions.easing(a)),
                            a < 1 && this._easeFrameId ? this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback) : this.stop()
                        }
                        ,
                        this._moving = !1,
                        this._zooming = !1,
                        this.transform = e,
                        this._bearingSnap = o.bearingSnap,
                        this.cameraHelper = i,
                        this.on("moveend", () => {
                            delete this._requestedCameraState
                        }
                        )
                    }
                    migrateProjection(e, i) {
                        e.apply(this.transform),
                        this.transform = e,
                        this.cameraHelper = i
                    }
                    getCenter() {
                        return new l.Q(this.transform.center.lng,this.transform.center.lat)
                    }
                    setCenter(e, i) {
                        return this.jumpTo({
                            center: e
                        }, i)
                    }
                    getCenterElevation() {
                        return this.transform.elevation
                    }
                    setCenterElevation(e, i) {
                        return this.jumpTo({
                            elevation: e
                        }, i),
                        this
                    }
                    getCenterClampedToGround() {
                        return this._centerClampedToGround
                    }
                    setCenterClampedToGround(e) {
                        this._centerClampedToGround = e
                    }
                    panBy(e, i, o) {
                        return e = l.P.convert(e).mult(-1),
                        this.panTo(this.transform.center, l.e({
                            offset: e
                        }, i), o)
                    }
                    panTo(e, i, o) {
                        return this.easeTo(l.e({
                            center: e
                        }, i), o)
                    }
                    getZoom() {
                        return this.transform.zoom
                    }
                    setZoom(e, i) {
                        return this.jumpTo({
                            zoom: e
                        }, i),
                        this
                    }
                    zoomTo(e, i, o) {
                        return this.easeTo(l.e({
                            zoom: e
                        }, i), o)
                    }
                    zoomIn(e, i) {
                        return this.zoomTo(this.getZoom() + 1, e, i),
                        this
                    }
                    zoomOut(e, i) {
                        return this.zoomTo(this.getZoom() - 1, e, i),
                        this
                    }
                    getVerticalFieldOfView() {
                        return this.transform.fov
                    }
                    setVerticalFieldOfView(e, i) {
                        return e != this.transform.fov && (this.transform.setFov(e),
                        this.fire(new l.l("movestart",i)).fire(new l.l("move",i)).fire(new l.l("moveend",i))),
                        this
                    }
                    getBearing() {
                        return this.transform.bearing
                    }
                    setBearing(e, i) {
                        return this.jumpTo({
                            bearing: e
                        }, i),
                        this
                    }
                    getPadding() {
                        return this.transform.padding
                    }
                    setPadding(e, i) {
                        return this.jumpTo({
                            padding: e
                        }, i),
                        this
                    }
                    rotateTo(e, i, o) {
                        return this.easeTo(l.e({
                            bearing: e
                        }, i), o)
                    }
                    resetNorth(e, i) {
                        return this.rotateTo(0, l.e({
                            duration: 1e3
                        }, e), i),
                        this
                    }
                    resetNorthPitch(e, i) {
                        return this.easeTo(l.e({
                            bearing: 0,
                            pitch: 0,
                            roll: 0,
                            duration: 1e3
                        }, e), i),
                        this
                    }
                    snapToNorth(e, i) {
                        return Math.abs(this.getBearing()) < this._bearingSnap ? this.resetNorth(e, i) : this
                    }
                    getPitch() {
                        return this.transform.pitch
                    }
                    setPitch(e, i) {
                        return this.jumpTo({
                            pitch: e
                        }, i),
                        this
                    }
                    getRoll() {
                        return this.transform.roll
                    }
                    setRoll(e, i) {
                        return this.jumpTo({
                            roll: e
                        }, i),
                        this
                    }
                    cameraForBounds(e, i) {
                        e = oi.convert(e).adjustAntiMeridian();
                        const o = i && i.bearing || 0;
                        return this._cameraForBoxAndBearing(e.getNorthWest(), e.getSouthEast(), o, i)
                    }
                    _cameraForBoxAndBearing(e, i, o, a) {
                        const h = {
                            top: 0,
                            bottom: 0,
                            right: 0,
                            left: 0
                        };
                        if (typeof (a = l.e({
                            padding: h,
                            offset: [0, 0],
                            maxZoom: this.transform.maxZoom
                        }, a)).padding == "number") {
                            const T = a.padding;
                            a.padding = {
                                top: T,
                                bottom: T,
                                right: T,
                                left: T
                            }
                        }
                        const m = l.e(h, a.padding);
                        a.padding = m;
                        const y = this.transform
                          , v = new oi(e,i);
                        return this.cameraHelper.cameraForBoxAndBearing(a, m, v, o, y)
                    }
                    fitBounds(e, i, o) {
                        return this._fitInternal(this.cameraForBounds(e, i), i, o)
                    }
                    fitScreenCoordinates(e, i, o, a, h) {
                        return this._fitInternal(this._cameraForBoxAndBearing(this.transform.screenPointToLocation(l.P.convert(e)), this.transform.screenPointToLocation(l.P.convert(i)), o, a), a, h)
                    }
                    _fitInternal(e, i, o) {
                        return e ? (delete (i = l.e(e, i)).padding,
                        i.linear ? this.easeTo(i, o) : this.flyTo(i, o)) : this
                    }
                    jumpTo(e, i) {
                        this.stop();
                        const o = this._getTransformForUpdate();
                        let a = !1
                          , h = !1
                          , m = !1;
                        const y = o.zoom;
                        this.cameraHelper.handleJumpToCenterZoom(o, e);
                        const v = o.zoom !== y;
                        return "elevation"in e && o.elevation !== +e.elevation && o.setElevation(+e.elevation),
                        "bearing"in e && o.bearing !== +e.bearing && (a = !0,
                        o.setBearing(+e.bearing)),
                        "pitch"in e && o.pitch !== +e.pitch && (h = !0,
                        o.setPitch(+e.pitch)),
                        "roll"in e && o.roll !== +e.roll && (m = !0,
                        o.setRoll(+e.roll)),
                        e.padding == null || o.isPaddingEqual(e.padding) || o.setPadding(e.padding),
                        this._applyUpdatedTransform(o),
                        this.fire(new l.l("movestart",i)).fire(new l.l("move",i)),
                        v && this.fire(new l.l("zoomstart",i)).fire(new l.l("zoom",i)).fire(new l.l("zoomend",i)),
                        a && this.fire(new l.l("rotatestart",i)).fire(new l.l("rotate",i)).fire(new l.l("rotateend",i)),
                        h && this.fire(new l.l("pitchstart",i)).fire(new l.l("pitch",i)).fire(new l.l("pitchend",i)),
                        m && this.fire(new l.l("rollstart",i)).fire(new l.l("roll",i)).fire(new l.l("rollend",i)),
                        this.fire(new l.l("moveend",i))
                    }
                    calculateCameraOptionsFromTo(e, i, o, a=0) {
                        const h = l.$.fromLngLat(e, i)
                          , m = l.$.fromLngLat(o, a)
                          , y = m.x - h.x
                          , v = m.y - h.y
                          , T = m.z - h.z
                          , S = Math.hypot(y, v, T);
                        if (S === 0)
                            throw new Error("Can't calculate camera options with same From and To");
                        const A = Math.hypot(y, v)
                          , k = l.aa(this.transform.cameraToCenterDistance / S / this.transform.tileSize)
                          , O = 180 * Math.atan2(y, -v) / Math.PI;
                        let V = 180 * Math.acos(A / S) / Math.PI;
                        return V = T < 0 ? 90 - V : 90 + V,
                        {
                            center: m.toLngLat(),
                            elevation: a,
                            zoom: k,
                            pitch: V,
                            bearing: O
                        }
                    }
                    calculateCameraOptionsFromCameraLngLatAltRotation(e, i, o, a, h) {
                        const m = this.transform.calculateCenterFromCameraLngLatAlt(e, i, o, a);
                        return {
                            center: m.center,
                            elevation: m.elevation,
                            zoom: m.zoom,
                            bearing: o,
                            pitch: a,
                            roll: h
                        }
                    }
                    easeTo(e, i) {
                        this._stop(!1, e.easeId),
                        ((e = l.e({
                            offset: [0, 0],
                            duration: 500,
                            easing: l.ca
                        }, e)).animate === !1 || !e.essential && oe.prefersReducedMotion) && (e.duration = 0);
                        const o = this._getTransformForUpdate()
                          , a = this.getBearing()
                          , h = o.pitch
                          , m = o.roll
                          , y = "bearing"in e ? this._normalizeBearing(e.bearing, a) : a
                          , v = "pitch"in e ? +e.pitch : h
                          , T = "roll"in e ? this._normalizeBearing(e.roll, m) : m
                          , S = "padding"in e ? e.padding : o.padding
                          , A = l.P.convert(e.offset);
                        let k, O;
                        e.around && (k = l.Q.convert(e.around),
                        O = o.locationToScreenPoint(k));
                        const V = {
                            moving: this._moving,
                            zooming: this._zooming,
                            rotating: this._rotating,
                            pitching: this._pitching,
                            rolling: this._rolling
                        }
                          , H = this.cameraHelper.handleEaseTo(o, {
                            bearing: y,
                            pitch: v,
                            roll: T,
                            padding: S,
                            around: k,
                            aroundPoint: O,
                            offsetAsPoint: A,
                            offset: e.offset,
                            zoom: e.zoom,
                            center: e.center
                        });
                        return this._rotating = this._rotating || a !== y,
                        this._pitching = this._pitching || v !== h,
                        this._rolling = this._rolling || T !== m,
                        this._padding = !o.isPaddingEqual(S),
                        this._zooming = this._zooming || H.isZooming,
                        this._easeId = e.easeId,
                        this._prepareEase(i, e.noMoveStart, V),
                        this.terrain && this._prepareElevation(H.elevationCenter),
                        this._ease(q => {
                            H.easeFunc(q),
                            this.terrain && !e.freezeElevation && this._updateElevation(q),
                            this._applyUpdatedTransform(o),
                            this._fireMoveEvents(i)
                        }
                        , q => {
                            this.terrain && e.freezeElevation && this._finalizeElevation(),
                            this._afterEase(i, q)
                        }
                        , e),
                        this
                    }
                    _prepareEase(e, i, o={}) {
                        this._moving = !0,
                        i || o.moving || this.fire(new l.l("movestart",e)),
                        this._zooming && !o.zooming && this.fire(new l.l("zoomstart",e)),
                        this._rotating && !o.rotating && this.fire(new l.l("rotatestart",e)),
                        this._pitching && !o.pitching && this.fire(new l.l("pitchstart",e)),
                        this._rolling && !o.rolling && this.fire(new l.l("rollstart",e))
                    }
                    _prepareElevation(e) {
                        this._elevationCenter = e,
                        this._elevationStart = this.transform.elevation,
                        this._elevationTarget = this.terrain.getElevationForLngLatZoom(e, this.transform.tileZoom),
                        this._elevationFreeze = !0
                    }
                    _updateElevation(e) {
                        this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom));
                        const i = this.terrain.getElevationForLngLatZoom(this._elevationCenter, this.transform.tileZoom);
                        if (e < 1 && i !== this._elevationTarget) {
                            const o = this._elevationTarget - this._elevationStart;
                            this._elevationStart += e * (o - (i - (o * e + this._elevationStart)) / (1 - e)),
                            this._elevationTarget = i
                        }
                        this.transform.setElevation(l.B.number(this._elevationStart, this._elevationTarget, e))
                    }
                    _finalizeElevation() {
                        this._elevationFreeze = !1,
                        this.getCenterClampedToGround() && this.transform.recalculateZoomAndCenter(this.terrain)
                    }
                    _getTransformForUpdate() {
                        return this.transformCameraUpdate || this.terrain ? (this._requestedCameraState || (this._requestedCameraState = this.transform.clone()),
                        this._requestedCameraState) : this.transform
                    }
                    _elevateCameraIfInsideTerrain(e) {
                        if (!this.terrain && e.elevation >= 0 && e.pitch <= 90)
                            return {};
                        const i = e.getCameraLngLat()
                          , o = e.getCameraAltitude()
                          , a = this.terrain ? this.terrain.getElevationForLngLatZoom(i, e.zoom) : 0;
                        if (o < a) {
                            const h = this.calculateCameraOptionsFromTo(i, a, e.center, e.elevation);
                            return {
                                pitch: h.pitch,
                                zoom: h.zoom
                            }
                        }
                        return {}
                    }
                    _applyUpdatedTransform(e) {
                        const i = [];
                        if (i.push(a => this._elevateCameraIfInsideTerrain(a)),
                        this.transformCameraUpdate && i.push(a => this.transformCameraUpdate(a)),
                        !i.length)
                            return;
                        const o = e.clone();
                        for (const a of i) {
                            const h = o.clone()
                              , {center: m, zoom: y, roll: v, pitch: T, bearing: S, elevation: A} = a(h);
                            m && h.setCenter(m),
                            A !== void 0 && h.setElevation(A),
                            y !== void 0 && h.setZoom(y),
                            v !== void 0 && h.setRoll(v),
                            T !== void 0 && h.setPitch(T),
                            S !== void 0 && h.setBearing(S),
                            o.apply(h)
                        }
                        this.transform.apply(o)
                    }
                    _fireMoveEvents(e) {
                        this.fire(new l.l("move",e)),
                        this._zooming && this.fire(new l.l("zoom",e)),
                        this._rotating && this.fire(new l.l("rotate",e)),
                        this._pitching && this.fire(new l.l("pitch",e)),
                        this._rolling && this.fire(new l.l("roll",e))
                    }
                    _afterEase(e, i) {
                        if (this._easeId && i && this._easeId === i)
                            return;
                        delete this._easeId;
                        const o = this._zooming
                          , a = this._rotating
                          , h = this._pitching
                          , m = this._rolling;
                        this._moving = !1,
                        this._zooming = !1,
                        this._rotating = !1,
                        this._pitching = !1,
                        this._rolling = !1,
                        this._padding = !1,
                        o && this.fire(new l.l("zoomend",e)),
                        a && this.fire(new l.l("rotateend",e)),
                        h && this.fire(new l.l("pitchend",e)),
                        m && this.fire(new l.l("rollend",e)),
                        this.fire(new l.l("moveend",e))
                    }
                    flyTo(e, i) {
                        if (!e.essential && oe.prefersReducedMotion) {
                            const Ce = l.O(e, ["center", "zoom", "bearing", "pitch", "roll", "elevation"]);
                            return this.jumpTo(Ce, i)
                        }
                        this.stop(),
                        e = l.e({
                            offset: [0, 0],
                            speed: 1.2,
                            curve: 1.42,
                            easing: l.ca
                        }, e);
                        const o = this._getTransformForUpdate()
                          , a = o.bearing
                          , h = o.pitch
                          , m = o.roll
                          , y = o.padding
                          , v = "bearing"in e ? this._normalizeBearing(e.bearing, a) : a
                          , T = "pitch"in e ? +e.pitch : h
                          , S = "roll"in e ? this._normalizeBearing(e.roll, m) : m
                          , A = "padding"in e ? e.padding : o.padding
                          , k = l.P.convert(e.offset);
                        let O = o.centerPoint.add(k);
                        const V = o.screenPointToLocation(O)
                          , H = this.cameraHelper.handleFlyTo(o, {
                            bearing: v,
                            pitch: T,
                            roll: S,
                            padding: A,
                            locationAtOffset: V,
                            offsetAsPoint: k,
                            center: e.center,
                            minZoom: e.minZoom,
                            zoom: e.zoom
                        });
                        let q = e.curve;
                        const W = Math.max(o.width, o.height)
                          , J = W / H.scaleOfZoom
                          , te = H.pixelPathLength;
                        typeof H.scaleOfMinZoom == "number" && (q = Math.sqrt(W / H.scaleOfMinZoom / te * 2));
                        const ie = q * q;
                        function ne(Ce) {
                            const Ne = (J * J - W * W + (Ce ? -1 : 1) * ie * ie * te * te) / (2 * (Ce ? J : W) * ie * te);
                            return Math.log(Math.sqrt(Ne * Ne + 1) - Ne)
                        }
                        function le(Ce) {
                            return (Math.exp(Ce) - Math.exp(-Ce)) / 2
                        }
                        function se(Ce) {
                            return (Math.exp(Ce) + Math.exp(-Ce)) / 2
                        }
                        const _e = ne(!1);
                        let xe = function(Ce) {
                            return se(_e) / se(_e + q * Ce)
                        }
                          , Pe = function(Ce) {
                            return W * ((se(_e) * (le(Ne = _e + q * Ce) / se(Ne)) - le(_e)) / ie) / te;
                            var Ne
                        }
                          , Ie = (ne(!0) - _e) / q;
                        if (Math.abs(te) < 2e-6 || !isFinite(Ie)) {
                            if (Math.abs(W - J) < 1e-6)
                                return this.easeTo(e, i);
                            const Ce = J < W ? -1 : 1;
                            Ie = Math.abs(Math.log(J / W)) / q,
                            Pe = () => 0,
                            xe = Ne => Math.exp(Ce * q * Ne)
                        }
                        return e.duration = "duration"in e ? +e.duration : 1e3 * Ie / ("screenSpeed"in e ? +e.screenSpeed / q : +e.speed),
                        e.maxDuration && e.duration > e.maxDuration && (e.duration = 0),
                        this._zooming = !0,
                        this._rotating = a !== v,
                        this._pitching = T !== h,
                        this._rolling = S !== m,
                        this._padding = !o.isPaddingEqual(A),
                        this._prepareEase(i, !1),
                        this.terrain && this._prepareElevation(H.targetCenter),
                        this._ease(Ce => {
                            const Ne = Ce * Ie
                              , Oe = 1 / xe(Ne)
                              , De = Pe(Ne);
                            this._rotating && o.setBearing(l.B.number(a, v, Ce)),
                            this._pitching && o.setPitch(l.B.number(h, T, Ce)),
                            this._rolling && o.setRoll(l.B.number(m, S, Ce)),
                            this._padding && (o.interpolatePadding(y, A, Ce),
                            O = o.centerPoint.add(k)),
                            H.easeFunc(Ce, Oe, De, O),
                            this.terrain && !e.freezeElevation && this._updateElevation(Ce),
                            this._applyUpdatedTransform(o),
                            this._fireMoveEvents(i)
                        }
                        , () => {
                            this.terrain && e.freezeElevation && this._finalizeElevation(),
                            this._afterEase(i)
                        }
                        , e),
                        this
                    }
                    isEasing() {
                        return !!this._easeFrameId
                    }
                    stop() {
                        return this._stop()
                    }
                    _stop(e, i) {
                        var o;
                        if (this._easeFrameId && (this._cancelRenderFrame(this._easeFrameId),
                        delete this._easeFrameId,
                        delete this._onEaseFrame),
                        this._onEaseEnd) {
                            const a = this._onEaseEnd;
                            delete this._onEaseEnd,
                            a.call(this, i)
                        }
                        return e || (o = this.handlers) === null || o === void 0 || o.stop(!1),
                        this
                    }
                    _ease(e, i, o) {
                        o.animate === !1 || o.duration === 0 ? (e(1),
                        i()) : (this._easeStart = oe.now(),
                        this._easeOptions = o,
                        this._onEaseFrame = e,
                        this._onEaseEnd = i,
                        this._easeFrameId = this._requestRenderFrame(this._renderFrameCallback))
                    }
                    _normalizeBearing(e, i) {
                        e = l.aK(e, -180, 180);
                        const o = Math.abs(e - i);
                        return Math.abs(e - 360 - i) < o && (e -= 360),
                        Math.abs(e + 360 - i) < o && (e += 360),
                        e
                    }
                    queryTerrainElevation(e) {
                        return this.terrain ? this.terrain.getElevationForLngLatZoom(l.Q.convert(e), this.transform.tileZoom) : null
                    }
                }
                const et = {
                    compact: !0,
                    customAttribution: '<a href="https://maplibre.org/" target="_blank">MapLibre</a>'
                };
                class bo {
                    constructor(e=et) {
                        this._toggleAttribution = () => {
                            this._container.classList.contains("maplibregl-compact") && (this._container.classList.contains("maplibregl-compact-show") ? (this._container.setAttribute("open", ""),
                            this._container.classList.remove("maplibregl-compact-show")) : (this._container.classList.add("maplibregl-compact-show"),
                            this._container.removeAttribute("open")))
                        }
                        ,
                        this._updateData = i => {
                            !i || i.sourceDataType !== "metadata" && i.sourceDataType !== "visibility" && i.dataType !== "style" && i.type !== "terrain" || this._updateAttributions()
                        }
                        ,
                        this._updateCompact = () => {
                            this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? this._compact === !1 ? this._container.setAttribute("open", "") : this._container.classList.contains("maplibregl-compact") || this._container.classList.contains("maplibregl-attrib-empty") || (this._container.setAttribute("open", ""),
                            this._container.classList.add("maplibregl-compact", "maplibregl-compact-show")) : (this._container.setAttribute("open", ""),
                            this._container.classList.contains("maplibregl-compact") && this._container.classList.remove("maplibregl-compact", "maplibregl-compact-show"))
                        }
                        ,
                        this._updateCompactMinimize = () => {
                            this._container.classList.contains("maplibregl-compact") && this._container.classList.contains("maplibregl-compact-show") && this._container.classList.remove("maplibregl-compact-show")
                        }
                        ,
                        this.options = e
                    }
                    getDefaultPosition() {
                        return "bottom-right"
                    }
                    onAdd(e) {
                        return this._map = e,
                        this._compact = this.options.compact,
                        this._container = Y.create("details", "maplibregl-ctrl maplibregl-ctrl-attrib"),
                        this._compactButton = Y.create("summary", "maplibregl-ctrl-attrib-button", this._container),
                        this._compactButton.addEventListener("click", this._toggleAttribution),
                        this._setElementTitle(this._compactButton, "ToggleAttribution"),
                        this._innerContainer = Y.create("div", "maplibregl-ctrl-attrib-inner", this._container),
                        this._updateAttributions(),
                        this._updateCompact(),
                        this._map.on("styledata", this._updateData),
                        this._map.on("sourcedata", this._updateData),
                        this._map.on("terrain", this._updateData),
                        this._map.on("resize", this._updateCompact),
                        this._map.on("drag", this._updateCompactMinimize),
                        this._container
                    }
                    onRemove() {
                        Y.remove(this._container),
                        this._map.off("styledata", this._updateData),
                        this._map.off("sourcedata", this._updateData),
                        this._map.off("terrain", this._updateData),
                        this._map.off("resize", this._updateCompact),
                        this._map.off("drag", this._updateCompactMinimize),
                        this._map = void 0,
                        this._compact = void 0,
                        this._sanitizedAttributionHTML = void 0
                    }
                    _setElementTitle(e, i) {
                        const o = this._map._getUIString(`AttributionControl.${i}`);
                        e.title = o,
                        e.setAttribute("aria-label", o)
                    }
                    _updateAttributions() {
                        if (!this._map.style)
                            return;
                        let e = [];
                        if (this.options.customAttribution && (Array.isArray(this.options.customAttribution) ? e = e.concat(this.options.customAttribution.map(a => typeof a != "string" ? "" : a)) : typeof this.options.customAttribution == "string" && e.push(this.options.customAttribution)),
                        this._map.style.stylesheet) {
                            const a = this._map.style.stylesheet;
                            this.styleOwner = a.owner,
                            this.styleId = a.id
                        }
                        const i = this._map.style.sourceCaches;
                        for (const a in i) {
                            const h = i[a];
                            if (h.used || h.usedForTerrain) {
                                const m = h.getSource();
                                m.attribution && e.indexOf(m.attribution) < 0 && e.push(m.attribution)
                            }
                        }
                        e = e.filter(a => String(a).trim()),
                        e.sort( (a, h) => a.length - h.length),
                        e = e.filter( (a, h) => {
                            for (let m = h + 1; m < e.length; m++)
                                if (e[m].indexOf(a) >= 0)
                                    return !1;
                            return !0
                        }
                        );
                        const o = e.join(" | ");
                        o !== this._sanitizedAttributionHTML && (this._sanitizedAttributionHTML = Y.sanitize(o),
                        e.length ? (this._innerContainer.innerHTML = this._sanitizedAttributionHTML,
                        this._container.classList.remove("maplibregl-attrib-empty")) : this._container.classList.add("maplibregl-attrib-empty"),
                        this._updateCompact(),
                        this._editLink = null)
                    }
                }
                class pa {
                    constructor(e={}) {
                        this._updateCompact = () => {
                            const i = this._container.children;
                            if (i.length) {
                                const o = i[0];
                                this._map.getCanvasContainer().offsetWidth <= 640 || this._compact ? this._compact !== !1 && o.classList.add("maplibregl-compact") : o.classList.remove("maplibregl-compact")
                            }
                        }
                        ,
                        this.options = e
                    }
                    getDefaultPosition() {
                        return "bottom-left"
                    }
                    onAdd(e) {
                        this._map = e,
                        this._compact = this.options && this.options.compact,
                        this._container = Y.create("div", "maplibregl-ctrl");
                        const i = Y.create("a", "maplibregl-ctrl-logo");
                        return i.target = "_blank",
                        i.rel = "noopener nofollow",
                        i.href = "https://maplibre.org/",
                        i.setAttribute("aria-label", this._map._getUIString("LogoControl.Title")),
                        i.setAttribute("rel", "noopener nofollow"),
                        this._container.appendChild(i),
                        this._container.style.display = "block",
                        this._map.on("resize", this._updateCompact),
                        this._updateCompact(),
                        this._container
                    }
                    onRemove() {
                        Y.remove(this._container),
                        this._map.off("resize", this._updateCompact),
                        this._map = void 0,
                        this._compact = void 0
                    }
                }
                class Bl {
                    constructor() {
                        this._queue = [],
                        this._id = 0,
                        this._cleared = !1,
                        this._currentlyRunning = !1
                    }
                    add(e) {
                        const i = ++this._id;
                        return this._queue.push({
                            callback: e,
                            id: i,
                            cancelled: !1
                        }),
                        i
                    }
                    remove(e) {
                        const i = this._currentlyRunning
                          , o = i ? this._queue.concat(i) : this._queue;
                        for (const a of o)
                            if (a.id === e)
                                return void (a.cancelled = !0)
                    }
                    run(e=0) {
                        if (this._currentlyRunning)
                            throw new Error("Attempting to run(), but is already running.");
                        const i = this._currentlyRunning = this._queue;
                        this._queue = [];
                        for (const o of i)
                            if (!o.cancelled && (o.callback(e),
                            this._cleared))
                                break;
                        this._cleared = !1,
                        this._currentlyRunning = !1
                    }
                    clear() {
                        this._currentlyRunning && (this._cleared = !0),
                        this._queue = []
                    }
                }
                var rr = l.aC([{
                    name: "a_pos3d",
                    type: "Int16",
                    components: 3
                }]);
                class au extends l.E {
                    constructor(e) {
                        super(),
                        this._lastTilesetChange = oe.now(),
                        this.sourceCache = e,
                        this._tiles = {},
                        this._renderableTilesKeys = [],
                        this._sourceTileCache = {},
                        this.minzoom = 0,
                        this.maxzoom = 22,
                        this.deltaZoom = 1,
                        this.tileSize = e._source.tileSize * 2 ** this.deltaZoom,
                        e.usedForTerrain = !0,
                        e.tileSize = this.tileSize
                    }
                    destruct() {
                        this.sourceCache.usedForTerrain = !1,
                        this.sourceCache.tileSize = null
                    }
                    update(e, i) {
                        this.sourceCache.update(e, i),
                        this._renderableTilesKeys = [];
                        const o = {};
                        for (const a of pe(e, {
                            tileSize: this.tileSize,
                            minzoom: this.minzoom,
                            maxzoom: this.maxzoom,
                            reparseOverscaled: !1,
                            terrain: i,
                            calculateTileZoom: this.sourceCache._source.calculateTileZoom
                        }))
                            o[a.key] = !0,
                            this._renderableTilesKeys.push(a.key),
                            this._tiles[a.key] || (a.terrainRttPosMatrix32f = new Float64Array(16),
                            l.bN(a.terrainRttPosMatrix32f, 0, l.Z, l.Z, 0, 0, 1),
                            this._tiles[a.key] = new Ln(a,this.tileSize),
                            this._lastTilesetChange = oe.now());
                        for (const a in this._tiles)
                            o[a] || delete this._tiles[a]
                    }
                    freeRtt(e) {
                        for (const i in this._tiles) {
                            const o = this._tiles[i];
                            (!e || o.tileID.equals(e) || o.tileID.isChildOf(e) || e.isChildOf(o.tileID)) && (o.rtt = [])
                        }
                    }
                    getRenderableTiles() {
                        return this._renderableTilesKeys.map(e => this.getTileByID(e))
                    }
                    getTileByID(e) {
                        return this._tiles[e]
                    }
                    getTerrainCoords(e) {
                        const i = {};
                        for (const o of this._renderableTilesKeys) {
                            const a = this._tiles[o].tileID
                              , h = e.clone()
                              , m = l.b1();
                            if (a.canonical.equals(e.canonical))
                                l.bN(m, 0, l.Z, l.Z, 0, 0, 1);
                            else if (a.canonical.isChildOf(e.canonical)) {
                                const y = a.canonical.z - e.canonical.z
                                  , v = a.canonical.x - (a.canonical.x >> y << y)
                                  , T = a.canonical.y - (a.canonical.y >> y << y)
                                  , S = l.Z >> y;
                                l.bN(m, 0, S, S, 0, 0, 1),
                                l.L(m, m, [-v * S, -T * S, 0])
                            } else {
                                if (!e.canonical.isChildOf(a.canonical))
                                    continue;
                                {
                                    const y = e.canonical.z - a.canonical.z
                                      , v = e.canonical.x - (e.canonical.x >> y << y)
                                      , T = e.canonical.y - (e.canonical.y >> y << y)
                                      , S = l.Z >> y;
                                    l.bN(m, 0, l.Z, l.Z, 0, 0, 1),
                                    l.L(m, m, [v * S, T * S, 0]),
                                    l.M(m, m, [1 / 2 ** y, 1 / 2 ** y, 0])
                                }
                            }
                            h.terrainRttPosMatrix32f = new Float32Array(m),
                            i[o] = h
                        }
                        return i
                    }
                    getSourceTile(e, i) {
                        const o = this.sourceCache._source;
                        let a = e.overscaledZ - this.deltaZoom;
                        if (a > o.maxzoom && (a = o.maxzoom),
                        a < o.minzoom)
                            return null;
                        this._sourceTileCache[e.key] || (this._sourceTileCache[e.key] = e.scaledTo(a).key);
                        let h = this.sourceCache.getTileByID(this._sourceTileCache[e.key]);
                        if ((!h || !h.dem) && i)
                            for (; a >= o.minzoom && (!h || !h.dem); )
                                h = this.sourceCache.getTileByID(e.scaledTo(a--).key);
                        return h
                    }
                    anyTilesAfterTime(e=Date.now()) {
                        return this._lastTilesetChange >= e
                    }
                }
                class sn {
                    constructor(e, i, o) {
                        this._meshCache = {},
                        this.painter = e,
                        this.sourceCache = new au(i),
                        this.options = o,
                        this.exaggeration = typeof o.exaggeration == "number" ? o.exaggeration : 1,
                        this.qualityFactor = 2,
                        this.meshSize = 128,
                        this._demMatrixCache = {},
                        this.coordsIndex = [],
                        this._coordsTextureSize = 1024
                    }
                    getDEMElevation(e, i, o, a=l.Z) {
                        var h;
                        if (!(i >= 0 && i < a && o >= 0 && o < a))
                            return 0;
                        const m = this.getTerrainData(e)
                          , y = (h = m.tile) === null || h === void 0 ? void 0 : h.dem;
                        if (!y)
                            return 0;
                        const v = l.cb([], [i / a * l.Z, o / a * l.Z], m.u_terrain_matrix)
                          , T = [v[0] * y.dim, v[1] * y.dim]
                          , S = Math.floor(T[0])
                          , A = Math.floor(T[1])
                          , k = T[0] - S
                          , O = T[1] - A;
                        return y.get(S, A) * (1 - k) * (1 - O) + y.get(S + 1, A) * k * (1 - O) + y.get(S, A + 1) * (1 - k) * O + y.get(S + 1, A + 1) * k * O
                    }
                    getElevationForLngLatZoom(e, i) {
                        if (!l.cc(i, e.wrap()))
                            return 0;
                        const {tileID: o, mercatorX: a, mercatorY: h} = this._getOverscaledTileIDFromLngLatZoom(e, i);
                        return this.getElevation(o, a % l.Z, h % l.Z, l.Z)
                    }
                    getElevation(e, i, o, a=l.Z) {
                        return this.getDEMElevation(e, i, o, a) * this.exaggeration
                    }
                    getTerrainData(e) {
                        if (!this._emptyDemTexture) {
                            const a = this.painter.context
                              , h = new l.R({
                                width: 1,
                                height: 1
                            },new Uint8Array(4));
                            this._emptyDepthTexture = new It(a,h,a.gl.RGBA,{
                                premultiply: !1
                            }),
                            this._emptyDemUnpack = [0, 0, 0, 0],
                            this._emptyDemTexture = new It(a,new l.R({
                                width: 1,
                                height: 1
                            }),a.gl.RGBA,{
                                premultiply: !1
                            }),
                            this._emptyDemTexture.bind(a.gl.NEAREST, a.gl.CLAMP_TO_EDGE),
                            this._emptyDemMatrix = l.as([])
                        }
                        const i = this.sourceCache.getSourceTile(e, !0);
                        if (i && i.dem && (!i.demTexture || i.needsTerrainPrepare)) {
                            const a = this.painter.context;
                            i.demTexture = this.painter.getTileTexture(i.dem.stride),
                            i.demTexture ? i.demTexture.update(i.dem.getPixels(), {
                                premultiply: !1
                            }) : i.demTexture = new It(a,i.dem.getPixels(),a.gl.RGBA,{
                                premultiply: !1
                            }),
                            i.demTexture.bind(a.gl.NEAREST, a.gl.CLAMP_TO_EDGE),
                            i.needsTerrainPrepare = !1
                        }
                        const o = i && i + i.tileID.key + e.key;
                        if (o && !this._demMatrixCache[o]) {
                            const a = this.sourceCache.sourceCache._source.maxzoom;
                            let h = e.canonical.z - i.tileID.canonical.z;
                            e.overscaledZ > e.canonical.z && (e.canonical.z >= a ? h = e.canonical.z - a : l.w("cannot calculate elevation if elevation maxzoom > source.maxzoom"));
                            const m = e.canonical.x - (e.canonical.x >> h << h)
                              , y = e.canonical.y - (e.canonical.y >> h << h)
                              , v = l.cd(new Float64Array(16), [1 / (l.Z << h), 1 / (l.Z << h), 0]);
                            l.L(v, v, [m * l.Z, y * l.Z, 0]),
                            this._demMatrixCache[e.key] = {
                                matrix: v,
                                coord: e
                            }
                        }
                        return {
                            u_depth: 2,
                            u_terrain: 3,
                            u_terrain_dim: i && i.dem && i.dem.dim || 1,
                            u_terrain_matrix: o ? this._demMatrixCache[e.key].matrix : this._emptyDemMatrix,
                            u_terrain_unpack: i && i.dem && i.dem.getUnpackVector() || this._emptyDemUnpack,
                            u_terrain_exaggeration: this.exaggeration,
                            texture: (i && i.demTexture || this._emptyDemTexture).texture,
                            depthTexture: (this._fboDepthTexture || this._emptyDepthTexture).texture,
                            tile: i
                        }
                    }
                    getFramebuffer(e) {
                        const i = this.painter
                          , o = i.width / devicePixelRatio
                          , a = i.height / devicePixelRatio;
                        return !this._fbo || this._fbo.width === o && this._fbo.height === a || (this._fbo.destroy(),
                        this._fboCoordsTexture.destroy(),
                        this._fboDepthTexture.destroy(),
                        delete this._fbo,
                        delete this._fboDepthTexture,
                        delete this._fboCoordsTexture),
                        this._fboCoordsTexture || (this._fboCoordsTexture = new It(i.context,{
                            width: o,
                            height: a,
                            data: null
                        },i.context.gl.RGBA,{
                            premultiply: !1
                        }),
                        this._fboCoordsTexture.bind(i.context.gl.NEAREST, i.context.gl.CLAMP_TO_EDGE)),
                        this._fboDepthTexture || (this._fboDepthTexture = new It(i.context,{
                            width: o,
                            height: a,
                            data: null
                        },i.context.gl.RGBA,{
                            premultiply: !1
                        }),
                        this._fboDepthTexture.bind(i.context.gl.NEAREST, i.context.gl.CLAMP_TO_EDGE)),
                        this._fbo || (this._fbo = i.context.createFramebuffer(o, a, !0, !1),
                        this._fbo.depthAttachment.set(i.context.createRenderbuffer(i.context.gl.DEPTH_COMPONENT16, o, a))),
                        this._fbo.colorAttachment.set(e === "coords" ? this._fboCoordsTexture.texture : this._fboDepthTexture.texture),
                        this._fbo
                    }
                    getCoordsTexture() {
                        const e = this.painter.context;
                        if (this._coordsTexture)
                            return this._coordsTexture;
                        const i = new Uint8Array(this._coordsTextureSize * this._coordsTextureSize * 4);
                        for (let h = 0, m = 0; h < this._coordsTextureSize; h++)
                            for (let y = 0; y < this._coordsTextureSize; y++,
                            m += 4)
                                i[m + 0] = 255 & y,
                                i[m + 1] = 255 & h,
                                i[m + 2] = y >> 8 << 4 | h >> 8,
                                i[m + 3] = 0;
                        const o = new l.R({
                            width: this._coordsTextureSize,
                            height: this._coordsTextureSize
                        },new Uint8Array(i.buffer))
                          , a = new It(e,o,e.gl.RGBA,{
                            premultiply: !1
                        });
                        return a.bind(e.gl.NEAREST, e.gl.CLAMP_TO_EDGE),
                        this._coordsTexture = a,
                        a
                    }
                    pointCoordinate(e) {
                        this.painter.maybeDrawDepthAndCoords(!0);
                        const i = new Uint8Array(4)
                          , o = this.painter.context
                          , a = o.gl
                          , h = Math.round(e.x * this.painter.pixelRatio / devicePixelRatio)
                          , m = Math.round(e.y * this.painter.pixelRatio / devicePixelRatio)
                          , y = Math.round(this.painter.height / devicePixelRatio);
                        o.bindFramebuffer.set(this.getFramebuffer("coords").framebuffer),
                        a.readPixels(h, y - m - 1, 1, 1, a.RGBA, a.UNSIGNED_BYTE, i),
                        o.bindFramebuffer.set(null);
                        const v = i[0] + (i[2] >> 4 << 8)
                          , T = i[1] + ((15 & i[2]) << 8)
                          , S = this.coordsIndex[255 - i[3]]
                          , A = S && this.sourceCache.getTileByID(S);
                        if (!A)
                            return null;
                        const k = this._coordsTextureSize
                          , O = (1 << A.tileID.canonical.z) * k;
                        return new l.$((A.tileID.canonical.x * k + v) / O + A.tileID.wrap,(A.tileID.canonical.y * k + T) / O,this.getElevation(A.tileID, v, T, k))
                    }
                    depthAtPoint(e) {
                        const i = new Uint8Array(4)
                          , o = this.painter.context
                          , a = o.gl;
                        return o.bindFramebuffer.set(this.getFramebuffer("depth").framebuffer),
                        a.readPixels(e.x, this.painter.height / devicePixelRatio - e.y - 1, 1, 1, a.RGBA, a.UNSIGNED_BYTE, i),
                        o.bindFramebuffer.set(null),
                        (i[0] / 16777216 + i[1] / 65536 + i[2] / 256 + i[3]) / 256
                    }
                    getTerrainMesh(e) {
                        var i;
                        const o = ((i = this.painter.style.projection) === null || i === void 0 ? void 0 : i.transitionState) > 0
                          , a = o && e.canonical.y === 0
                          , h = o && e.canonical.y === (1 << e.canonical.z) - 1
                          , m = `m_${a ? "n" : ""}_${h ? "s" : ""}`;
                        if (this._meshCache[m])
                            return this._meshCache[m];
                        const y = this.painter.context
                          , v = new l.ce
                          , T = new l.aG
                          , S = this.meshSize
                          , A = l.Z / S
                          , k = S * S;
                        for (let se = 0; se <= S; se++)
                            for (let _e = 0; _e <= S; _e++)
                                v.emplaceBack(_e * A, se * A, 0);
                        for (let se = 0; se < k; se += S + 1)
                            for (let _e = 0; _e < S; _e++)
                                T.emplaceBack(_e + se, S + _e + se + 1, S + _e + se + 2),
                                T.emplaceBack(_e + se, S + _e + se + 2, _e + se + 1);
                        const O = v.length
                          , V = O + (S + 1)
                          , H = (S + 1) * S
                          , q = a ? l.b8 : 0
                          , W = a ? 0 : 1
                          , J = h ? l.b9 : l.Z
                          , te = h ? 0 : 1;
                        for (let se = 0; se <= S; se++)
                            v.emplaceBack(se * A, q, W);
                        for (let se = 0; se <= S; se++)
                            v.emplaceBack(se * A, J, te);
                        for (let se = 0; se < S; se++)
                            T.emplaceBack(H + se, V + se, V + se + 1),
                            T.emplaceBack(H + se, V + se + 1, H + se + 1),
                            T.emplaceBack(0 + se, O + se + 1, O + se),
                            T.emplaceBack(0 + se, 0 + se + 1, O + se + 1);
                        const ie = v.length
                          , ne = ie + 2 * (S + 1);
                        for (const se of [0, 1])
                            for (let _e = 0; _e <= S; _e++)
                                for (const xe of [0, 1])
                                    v.emplaceBack(se * l.Z, _e * A, xe);
                        for (let se = 0; se < 2 * S; se += 2)
                            T.emplaceBack(ie + se, ie + se + 1, ie + se + 3),
                            T.emplaceBack(ie + se, ie + se + 3, ie + se + 2),
                            T.emplaceBack(ne + se, ne + se + 3, ne + se + 1),
                            T.emplaceBack(ne + se, ne + se + 2, ne + se + 3);
                        const le = new lr(y.createVertexBuffer(v, rr.members),y.createIndexBuffer(T),l.aF.simpleSegment(0, 0, v.length, T.length));
                        return this._meshCache[m] = le,
                        le
                    }
                    getMeshFrameDelta(e) {
                        return 2 * Math.PI * l.bq / Math.pow(2, Math.max(e, 0)) / 5
                    }
                    getMinTileElevationForLngLatZoom(e, i) {
                        var o;
                        const {tileID: a} = this._getOverscaledTileIDFromLngLatZoom(e, i);
                        return (o = this.getMinMaxElevation(a).minElevation) !== null && o !== void 0 ? o : 0
                    }
                    getMinMaxElevation(e) {
                        const i = this.getTerrainData(e).tile
                          , o = {
                            minElevation: null,
                            maxElevation: null
                        };
                        return i && i.dem && (o.minElevation = i.dem.min * this.exaggeration,
                        o.maxElevation = i.dem.max * this.exaggeration),
                        o
                    }
                    _getOverscaledTileIDFromLngLatZoom(e, i) {
                        const o = l.$.fromLngLat(e.wrap())
                          , a = (1 << i) * l.Z
                          , h = o.x * a
                          , m = o.y * a
                          , y = Math.floor(h / l.Z)
                          , v = Math.floor(m / l.Z);
                        return {
                            tileID: new l.Y(i,0,i,y,v),
                            mercatorX: h,
                            mercatorY: m
                        }
                    }
                }
                class xh {
                    constructor(e, i, o) {
                        this._context = e,
                        this._size = i,
                        this._tileSize = o,
                        this._objects = [],
                        this._recentlyUsed = [],
                        this._stamp = 0
                    }
                    destruct() {
                        for (const e of this._objects)
                            e.texture.destroy(),
                            e.fbo.destroy()
                    }
                    _createObject(e) {
                        const i = this._context.createFramebuffer(this._tileSize, this._tileSize, !0, !0)
                          , o = new It(this._context,{
                            width: this._tileSize,
                            height: this._tileSize,
                            data: null
                        },this._context.gl.RGBA);
                        return o.bind(this._context.gl.LINEAR, this._context.gl.CLAMP_TO_EDGE),
                        this._context.extTextureFilterAnisotropic && this._context.gl.texParameterf(this._context.gl.TEXTURE_2D, this._context.extTextureFilterAnisotropic.TEXTURE_MAX_ANISOTROPY_EXT, this._context.extTextureFilterAnisotropicMax),
                        i.depthAttachment.set(this._context.createRenderbuffer(this._context.gl.DEPTH_STENCIL, this._tileSize, this._tileSize)),
                        i.colorAttachment.set(o.texture),
                        {
                            id: e,
                            fbo: i,
                            texture: o,
                            stamp: -1,
                            inUse: !1
                        }
                    }
                    getObjectForId(e) {
                        return this._objects[e]
                    }
                    useObject(e) {
                        e.inUse = !0,
                        this._recentlyUsed = this._recentlyUsed.filter(i => e.id !== i),
                        this._recentlyUsed.push(e.id)
                    }
                    stampObject(e) {
                        e.stamp = ++this._stamp
                    }
                    getOrCreateFreeObject() {
                        for (const i of this._recentlyUsed)
                            if (!this._objects[i].inUse)
                                return this._objects[i];
                        if (this._objects.length >= this._size)
                            throw new Error("No free RenderPool available, call freeAllObjects() required!");
                        const e = this._createObject(this._objects.length);
                        return this._objects.push(e),
                        e
                    }
                    freeObject(e) {
                        e.inUse = !1
                    }
                    freeAllObjects() {
                        for (const e of this._objects)
                            this.freeObject(e)
                    }
                    isFull() {
                        return !(this._objects.length < this._size) && this._objects.some(e => !e.inUse) === !1
                    }
                }
                const on = {
                    background: !0,
                    fill: !0,
                    line: !0,
                    raster: !0,
                    hillshade: !0
                };
                class Jt {
                    constructor(e, i) {
                        this.painter = e,
                        this.terrain = i,
                        this.pool = new xh(e.context,30,i.sourceCache.tileSize * i.qualityFactor)
                    }
                    destruct() {
                        this.pool.destruct()
                    }
                    getTexture(e) {
                        return this.pool.getObjectForId(e.rtt[this._stacks.length - 1].id).texture
                    }
                    prepareForRender(e, i) {
                        this._stacks = [],
                        this._prevType = null,
                        this._rttTiles = [],
                        this._renderableTiles = this.terrain.sourceCache.getRenderableTiles(),
                        this._renderableLayerIds = e._order.filter(o => !e._layers[o].isHidden(i)),
                        this._coordsAscending = {};
                        for (const o in e.sourceCaches) {
                            this._coordsAscending[o] = {};
                            const a = e.sourceCaches[o].getVisibleCoordinates();
                            for (const h of a) {
                                const m = this.terrain.sourceCache.getTerrainCoords(h);
                                for (const y in m)
                                    this._coordsAscending[o][y] || (this._coordsAscending[o][y] = []),
                                    this._coordsAscending[o][y].push(m[y])
                            }
                        }
                        this._coordsAscendingStr = {};
                        for (const o of e._order) {
                            const a = e._layers[o]
                              , h = a.source;
                            if (on[a.type] && !this._coordsAscendingStr[h]) {
                                this._coordsAscendingStr[h] = {};
                                for (const m in this._coordsAscending[h])
                                    this._coordsAscendingStr[h][m] = this._coordsAscending[h][m].map(y => y.key).sort().join()
                            }
                        }
                        for (const o of this._renderableTiles)
                            for (const a in this._coordsAscendingStr) {
                                const h = this._coordsAscendingStr[a][o.tileID.key];
                                h && h !== o.rttCoords[a] && (o.rtt = [])
                            }
                    }
                    renderLayer(e, i) {
                        if (e.isHidden(this.painter.transform.zoom))
                            return !1;
                        const o = Object.assign(Object.assign({}, i), {
                            isRenderingToTexture: !0
                        })
                          , a = e.type
                          , h = this.painter
                          , m = this._renderableLayerIds[this._renderableLayerIds.length - 1] === e.id;
                        if (on[a] && (this._prevType && on[this._prevType] || this._stacks.push([]),
                        this._prevType = a,
                        this._stacks[this._stacks.length - 1].push(e.id),
                        !m))
                            return !0;
                        if (on[this._prevType] || on[a] && m) {
                            this._prevType = a;
                            const y = this._stacks.length - 1
                              , v = this._stacks[y] || [];
                            for (const T of this._renderableTiles) {
                                if (this.pool.isFull() && (Ml(this.painter, this.terrain, this._rttTiles, o),
                                this._rttTiles = [],
                                this.pool.freeAllObjects()),
                                this._rttTiles.push(T),
                                T.rtt[y]) {
                                    const A = this.pool.getObjectForId(T.rtt[y].id);
                                    if (A.stamp === T.rtt[y].stamp) {
                                        this.pool.useObject(A);
                                        continue
                                    }
                                }
                                const S = this.pool.getOrCreateFreeObject();
                                this.pool.useObject(S),
                                this.pool.stampObject(S),
                                T.rtt[y] = {
                                    id: S.id,
                                    stamp: S.stamp
                                },
                                h.context.bindFramebuffer.set(S.fbo.framebuffer),
                                h.context.clear({
                                    color: l.b6.transparent,
                                    stencil: 0
                                }),
                                h.currentStencilSource = void 0;
                                for (let A = 0; A < v.length; A++) {
                                    const k = h.style._layers[v[A]]
                                      , O = k.source ? this._coordsAscending[k.source][T.tileID.key] : [T.tileID];
                                    h.context.viewport.set([0, 0, S.fbo.width, S.fbo.height]),
                                    h._renderTileClippingMasks(k, O, !0),
                                    h.renderLayer(h, h.style.sourceCaches[k.source], k, O, o),
                                    k.source && (T.rttCoords[k.source] = this._coordsAscendingStr[k.source][T.tileID.key])
                                }
                            }
                            return Ml(this.painter, this.terrain, this._rttTiles, o),
                            this._rttTiles = [],
                            this.pool.freeAllObjects(),
                            on[a]
                        }
                        return !1
                    }
                }
                const li = {
                    "AttributionControl.ToggleAttribution": "Toggle attribution",
                    "AttributionControl.MapFeedback": "Map feedback",
                    "FullscreenControl.Enter": "Enter fullscreen",
                    "FullscreenControl.Exit": "Exit fullscreen",
                    "GeolocateControl.FindMyLocation": "Find my location",
                    "GeolocateControl.LocationNotAvailable": "Location not available",
                    "LogoControl.Title": "MapLibre logo",
                    "Map.Title": "Map",
                    "Marker.Title": "Map marker",
                    "NavigationControl.ResetBearing": "Reset bearing to north",
                    "NavigationControl.ZoomIn": "Zoom in",
                    "NavigationControl.ZoomOut": "Zoom out",
                    "Popup.Close": "Close popup",
                    "ScaleControl.Feet": "ft",
                    "ScaleControl.Meters": "m",
                    "ScaleControl.Kilometers": "km",
                    "ScaleControl.Miles": "mi",
                    "ScaleControl.NauticalMiles": "nm",
                    "GlobeControl.Enable": "Enable globe",
                    "GlobeControl.Disable": "Disable globe",
                    "TerrainControl.Enable": "Enable terrain",
                    "TerrainControl.Disable": "Disable terrain",
                    "CooperativeGesturesHandler.WindowsHelpText": "Use Ctrl + scroll to zoom the map",
                    "CooperativeGesturesHandler.MacHelpText": "Use ⌘ + scroll to zoom the map",
                    "CooperativeGesturesHandler.MobileHelpText": "Use two fingers to move the map"
                }
                  , lu = ce
                  , Zs = {
                    hash: !1,
                    interactive: !0,
                    bearingSnap: 7,
                    attributionControl: et,
                    maplibreLogo: !1,
                    refreshExpiredTiles: !0,
                    canvasContextAttributes: {
                        antialias: !1,
                        preserveDrawingBuffer: !1,
                        powerPreference: "high-performance",
                        failIfMajorPerformanceCaveat: !1,
                        desynchronized: !1,
                        contextType: void 0
                    },
                    scrollZoom: !0,
                    minZoom: -2,
                    maxZoom: 22,
                    minPitch: 0,
                    maxPitch: 60,
                    boxZoom: !0,
                    dragRotate: !0,
                    dragPan: !0,
                    keyboard: !0,
                    doubleClickZoom: !0,
                    touchZoomRotate: !0,
                    touchPitch: !0,
                    cooperativeGestures: !1,
                    trackResize: !0,
                    center: [0, 0],
                    elevation: 0,
                    zoom: 0,
                    bearing: 0,
                    pitch: 0,
                    roll: 0,
                    renderWorldCopies: !0,
                    maxTileCacheSize: null,
                    maxTileCacheZoomLevels: l.a.MAX_TILE_CACHE_ZOOM_LEVELS,
                    transformRequest: null,
                    transformCameraUpdate: null,
                    fadeDuration: 300,
                    crossSourceCollisions: !0,
                    clickTolerance: 3,
                    localIdeographFontFamily: "sans-serif",
                    pitchWithRotate: !0,
                    rollEnabled: !1,
                    validateStyle: !0,
                    maxCanvasSize: [4096, 4096],
                    cancelPendingTileRequestsWhileZooming: !0,
                    centerClampedToGround: !0
                }
                  , fa = {
                    showCompass: !0,
                    showZoom: !0,
                    visualizePitch: !1,
                    visualizeRoll: !0
                };
                class Ol {
                    constructor(e, i, o=!1) {
                        this.mousedown = h => {
                            this.startMove(h, Y.mousePos(this.element, h)),
                            Y.addEventListener(window, "mousemove", this.mousemove),
                            Y.addEventListener(window, "mouseup", this.mouseup)
                        }
                        ,
                        this.mousemove = h => {
                            this.move(h, Y.mousePos(this.element, h))
                        }
                        ,
                        this.mouseup = h => {
                            this._rotatePitchHanlder.dragEnd(h),
                            this.offTemp()
                        }
                        ,
                        this.touchstart = h => {
                            h.targetTouches.length !== 1 ? this.reset() : (this._startPos = this._lastPos = Y.touchPos(this.element, h.targetTouches)[0],
                            this.startMove(h, this._startPos),
                            Y.addEventListener(window, "touchmove", this.touchmove, {
                                passive: !1
                            }),
                            Y.addEventListener(window, "touchend", this.touchend))
                        }
                        ,
                        this.touchmove = h => {
                            h.targetTouches.length !== 1 ? this.reset() : (this._lastPos = Y.touchPos(this.element, h.targetTouches)[0],
                            this.move(h, this._lastPos))
                        }
                        ,
                        this.touchend = h => {
                            h.targetTouches.length === 0 && this._startPos && this._lastPos && this._startPos.dist(this._lastPos) < this._clickTolerance && this.element.click(),
                            delete this._startPos,
                            delete this._lastPos,
                            this.offTemp()
                        }
                        ,
                        this.reset = () => {
                            this._rotatePitchHanlder.reset(),
                            delete this._startPos,
                            delete this._lastPos,
                            this.offTemp()
                        }
                        ,
                        this._clickTolerance = 10,
                        this.element = i;
                        const a = new iu;
                        this._rotatePitchHanlder = new ur({
                            clickTolerance: 3,
                            move: (h, m) => {
                                const y = i.getBoundingClientRect()
                                  , v = new l.P((y.bottom - y.top) / 2,(y.right - y.left) / 2);
                                return {
                                    bearingDelta: l.c9(new l.P(h.x,m.y), m, v),
                                    pitchDelta: o ? -.5 * (m.y - h.y) : void 0
                                }
                            }
                            ,
                            moveStateManager: a,
                            enable: !0,
                            assignEvents: () => {}
                        }),
                        this.map = e,
                        Y.addEventListener(i, "mousedown", this.mousedown),
                        Y.addEventListener(i, "touchstart", this.touchstart, {
                            passive: !1
                        }),
                        Y.addEventListener(i, "touchcancel", this.reset)
                    }
                    startMove(e, i) {
                        this._rotatePitchHanlder.dragStart(e, i),
                        Y.disableDrag()
                    }
                    move(e, i) {
                        const o = this.map
                          , {bearingDelta: a, pitchDelta: h} = this._rotatePitchHanlder.dragMove(e, i) || {};
                        a && o.setBearing(o.getBearing() + a),
                        h && o.setPitch(o.getPitch() + h)
                    }
                    off() {
                        const e = this.element;
                        Y.removeEventListener(e, "mousedown", this.mousedown),
                        Y.removeEventListener(e, "touchstart", this.touchstart, {
                            passive: !1
                        }),
                        Y.removeEventListener(window, "touchmove", this.touchmove, {
                            passive: !1
                        }),
                        Y.removeEventListener(window, "touchend", this.touchend),
                        Y.removeEventListener(e, "touchcancel", this.reset),
                        this.offTemp()
                    }
                    offTemp() {
                        Y.enableDrag(),
                        Y.removeEventListener(window, "mousemove", this.mousemove),
                        Y.removeEventListener(window, "mouseup", this.mouseup),
                        Y.removeEventListener(window, "touchmove", this.touchmove, {
                            passive: !1
                        }),
                        Y.removeEventListener(window, "touchend", this.touchend)
                    }
                }
                let xn;
                function ma(u, e, i) {
                    const o = new l.Q(u.lng,u.lat);
                    if (u = new l.Q(u.lng,u.lat),
                    e) {
                        const a = new l.Q(u.lng - 360,u.lat)
                          , h = new l.Q(u.lng + 360,u.lat)
                          , m = i.locationToScreenPoint(u).distSqr(e);
                        i.locationToScreenPoint(a).distSqr(e) < m ? u = a : i.locationToScreenPoint(h).distSqr(e) < m && (u = h)
                    }
                    for (; Math.abs(u.lng - i.center.lng) > 180; ) {
                        const a = i.locationToScreenPoint(u);
                        if (a.x >= 0 && a.y >= 0 && a.x <= i.width && a.y <= i.height)
                            break;
                        u.lng > i.center.lng ? u.lng -= 360 : u.lng += 360
                    }
                    return u.lng !== o.lng && i.isPointOnMapSurface(i.locationToScreenPoint(u)) ? u : o
                }
                const ds = {
                    center: "translate(-50%,-50%)",
                    top: "translate(-50%,0)",
                    "top-left": "translate(0,0)",
                    "top-right": "translate(-100%,0)",
                    bottom: "translate(-50%,-100%)",
                    "bottom-left": "translate(0,-100%)",
                    "bottom-right": "translate(-100%,-100%)",
                    left: "translate(0,-50%)",
                    right: "translate(-100%,-50%)"
                };
                function ga(u, e, i) {
                    const o = u.classList;
                    for (const a in ds)
                        o.remove(`maplibregl-${i}-anchor-${a}`);
                    o.add(`maplibregl-${i}-anchor-${e}`)
                }
                class wo extends l.E {
                    constructor(e) {
                        if (super(),
                        this._onKeyPress = i => {
                            const o = i.code
                              , a = i.charCode || i.keyCode;
                            o !== "Space" && o !== "Enter" && a !== 32 && a !== 13 || this.togglePopup()
                        }
                        ,
                        this._onMapClick = i => {
                            const o = i.originalEvent.target
                              , a = this._element;
                            this._popup && (o === a || a.contains(o)) && this.togglePopup()
                        }
                        ,
                        this._update = i => {
                            var o;
                            if (!this._map)
                                return;
                            const a = this._map.loaded() && !this._map.isMoving();
                            (i?.type === "terrain" || i?.type === "render" && !a) && this._map.once("render", this._update),
                            this._lngLat = this._map.transform.renderWorldCopies ? ma(this._lngLat, this._flatPos, this._map.transform) : (o = this._lngLat) === null || o === void 0 ? void 0 : o.wrap(),
                            this._flatPos = this._pos = this._map.project(this._lngLat)._add(this._offset),
                            this._map.terrain && (this._flatPos = this._map.transform.locationToScreenPoint(this._lngLat)._add(this._offset));
                            let h = "";
                            this._rotationAlignment === "viewport" || this._rotationAlignment === "auto" ? h = `rotateZ(${this._rotation}deg)` : this._rotationAlignment === "map" && (h = `rotateZ(${this._rotation - this._map.getBearing()}deg)`);
                            let m = "";
                            this._pitchAlignment === "viewport" || this._pitchAlignment === "auto" ? m = "rotateX(0deg)" : this._pitchAlignment === "map" && (m = `rotateX(${this._map.getPitch()}deg)`),
                            this._subpixelPositioning || i && i.type !== "moveend" || (this._pos = this._pos.round()),
                            Y.setTransform(this._element, `${ds[this._anchor]} translate(${this._pos.x}px, ${this._pos.y}px) ${m} ${h}`),
                            oe.frameAsync(new AbortController).then( () => {
                                this._updateOpacity(i && i.type === "moveend")
                            }
                            ).catch( () => {}
                            )
                        }
                        ,
                        this._onMove = i => {
                            if (!this._isDragging) {
                                const o = this._clickTolerance || this._map._clickTolerance;
                                this._isDragging = i.point.dist(this._pointerdownPos) >= o
                            }
                            this._isDragging && (this._pos = i.point.sub(this._positionDelta),
                            this._lngLat = this._map.unproject(this._pos),
                            this.setLngLat(this._lngLat),
                            this._element.style.pointerEvents = "none",
                            this._state === "pending" && (this._state = "active",
                            this.fire(new l.l("dragstart"))),
                            this.fire(new l.l("drag")))
                        }
                        ,
                        this._onUp = () => {
                            this._element.style.pointerEvents = "auto",
                            this._positionDelta = null,
                            this._pointerdownPos = null,
                            this._isDragging = !1,
                            this._map.off("mousemove", this._onMove),
                            this._map.off("touchmove", this._onMove),
                            this._state === "active" && this.fire(new l.l("dragend")),
                            this._state = "inactive"
                        }
                        ,
                        this._addDragHandler = i => {
                            this._element.contains(i.originalEvent.target) && (i.preventDefault(),
                            this._positionDelta = i.point.sub(this._pos).add(this._offset),
                            this._pointerdownPos = i.point,
                            this._state = "pending",
                            this._map.on("mousemove", this._onMove),
                            this._map.on("touchmove", this._onMove),
                            this._map.once("mouseup", this._onUp),
                            this._map.once("touchend", this._onUp))
                        }
                        ,
                        this._anchor = e && e.anchor || "center",
                        this._color = e && e.color || "#3FB1CE",
                        this._scale = e && e.scale || 1,
                        this._draggable = e && e.draggable || !1,
                        this._clickTolerance = e && e.clickTolerance || 0,
                        this._subpixelPositioning = e && e.subpixelPositioning || !1,
                        this._isDragging = !1,
                        this._state = "inactive",
                        this._rotation = e && e.rotation || 0,
                        this._rotationAlignment = e && e.rotationAlignment || "auto",
                        this._pitchAlignment = e && e.pitchAlignment && e.pitchAlignment !== "auto" ? e.pitchAlignment : this._rotationAlignment,
                        this.setOpacity(e?.opacity, e?.opacityWhenCovered),
                        e && e.element)
                            this._element = e.element,
                            this._offset = l.P.convert(e && e.offset || [0, 0]);
                        else {
                            this._defaultMarker = !0,
                            this._element = Y.create("div");
                            const i = Y.createNS("http://www.w3.org/2000/svg", "svg")
                              , o = 41
                              , a = 27;
                            i.setAttributeNS(null, "display", "block"),
                            i.setAttributeNS(null, "height", `${o}px`),
                            i.setAttributeNS(null, "width", `${a}px`),
                            i.setAttributeNS(null, "viewBox", `0 0 ${a} ${o}`);
                            const h = Y.createNS("http://www.w3.org/2000/svg", "g");
                            h.setAttributeNS(null, "stroke", "none"),
                            h.setAttributeNS(null, "stroke-width", "1"),
                            h.setAttributeNS(null, "fill", "none"),
                            h.setAttributeNS(null, "fill-rule", "evenodd");
                            const m = Y.createNS("http://www.w3.org/2000/svg", "g");
                            m.setAttributeNS(null, "fill-rule", "nonzero");
                            const y = Y.createNS("http://www.w3.org/2000/svg", "g");
                            y.setAttributeNS(null, "transform", "translate(3.0, 29.0)"),
                            y.setAttributeNS(null, "fill", "#000000");
                            const v = [{
                                rx: "10.5",
                                ry: "5.25002273"
                            }, {
                                rx: "10.5",
                                ry: "5.25002273"
                            }, {
                                rx: "9.5",
                                ry: "4.77275007"
                            }, {
                                rx: "8.5",
                                ry: "4.29549936"
                            }, {
                                rx: "7.5",
                                ry: "3.81822308"
                            }, {
                                rx: "6.5",
                                ry: "3.34094679"
                            }, {
                                rx: "5.5",
                                ry: "2.86367051"
                            }, {
                                rx: "4.5",
                                ry: "2.38636864"
                            }];
                            for (const W of v) {
                                const J = Y.createNS("http://www.w3.org/2000/svg", "ellipse");
                                J.setAttributeNS(null, "opacity", "0.04"),
                                J.setAttributeNS(null, "cx", "10.5"),
                                J.setAttributeNS(null, "cy", "5.80029008"),
                                J.setAttributeNS(null, "rx", W.rx),
                                J.setAttributeNS(null, "ry", W.ry),
                                y.appendChild(J)
                            }
                            const T = Y.createNS("http://www.w3.org/2000/svg", "g");
                            T.setAttributeNS(null, "fill", this._color);
                            const S = Y.createNS("http://www.w3.org/2000/svg", "path");
                            S.setAttributeNS(null, "d", "M27,13.5 C27,19.074644 20.250001,27.000002 14.75,34.500002 C14.016665,35.500004 12.983335,35.500004 12.25,34.500002 C6.7499993,27.000002 0,19.222562 0,13.5 C0,6.0441559 6.0441559,0 13.5,0 C20.955844,0 27,6.0441559 27,13.5 Z"),
                            T.appendChild(S);
                            const A = Y.createNS("http://www.w3.org/2000/svg", "g");
                            A.setAttributeNS(null, "opacity", "0.25"),
                            A.setAttributeNS(null, "fill", "#000000");
                            const k = Y.createNS("http://www.w3.org/2000/svg", "path");
                            k.setAttributeNS(null, "d", "M13.5,0 C6.0441559,0 0,6.0441559 0,13.5 C0,19.222562 6.7499993,27 12.25,34.5 C13,35.522727 14.016664,35.500004 14.75,34.5 C20.250001,27 27,19.074644 27,13.5 C27,6.0441559 20.955844,0 13.5,0 Z M13.5,1 C20.415404,1 26,6.584596 26,13.5 C26,15.898657 24.495584,19.181431 22.220703,22.738281 C19.945823,26.295132 16.705119,30.142167 13.943359,33.908203 C13.743445,34.180814 13.612715,34.322738 13.5,34.441406 C13.387285,34.322738 13.256555,34.180814 13.056641,33.908203 C10.284481,30.127985 7.4148684,26.314159 5.015625,22.773438 C2.6163816,19.232715 1,15.953538 1,13.5 C1,6.584596 6.584596,1 13.5,1 Z"),
                            A.appendChild(k);
                            const O = Y.createNS("http://www.w3.org/2000/svg", "g");
                            O.setAttributeNS(null, "transform", "translate(6.0, 7.0)"),
                            O.setAttributeNS(null, "fill", "#FFFFFF");
                            const V = Y.createNS("http://www.w3.org/2000/svg", "g");
                            V.setAttributeNS(null, "transform", "translate(8.0, 8.0)");
                            const H = Y.createNS("http://www.w3.org/2000/svg", "circle");
                            H.setAttributeNS(null, "fill", "#000000"),
                            H.setAttributeNS(null, "opacity", "0.25"),
                            H.setAttributeNS(null, "cx", "5.5"),
                            H.setAttributeNS(null, "cy", "5.5"),
                            H.setAttributeNS(null, "r", "5.4999962");
                            const q = Y.createNS("http://www.w3.org/2000/svg", "circle");
                            q.setAttributeNS(null, "fill", "#FFFFFF"),
                            q.setAttributeNS(null, "cx", "5.5"),
                            q.setAttributeNS(null, "cy", "5.5"),
                            q.setAttributeNS(null, "r", "5.4999962"),
                            V.appendChild(H),
                            V.appendChild(q),
                            m.appendChild(y),
                            m.appendChild(T),
                            m.appendChild(A),
                            m.appendChild(O),
                            m.appendChild(V),
                            i.appendChild(m),
                            i.setAttributeNS(null, "height", o * this._scale + "px"),
                            i.setAttributeNS(null, "width", a * this._scale + "px"),
                            this._element.appendChild(i),
                            this._offset = l.P.convert(e && e.offset || [0, -14])
                        }
                        if (this._element.classList.add("maplibregl-marker"),
                        this._element.addEventListener("dragstart", i => {
                            i.preventDefault()
                        }
                        ),
                        this._element.addEventListener("mousedown", i => {
                            i.preventDefault()
                        }
                        ),
                        ga(this._element, this._anchor, "marker"),
                        e && e.className)
                            for (const i of e.className.split(" "))
                                this._element.classList.add(i);
                        this._popup = null
                    }
                    addTo(e) {
                        return this.remove(),
                        this._map = e,
                        this._element.setAttribute("aria-label", e._getUIString("Marker.Title")),
                        e.getCanvasContainer().appendChild(this._element),
                        e.on("move", this._update),
                        e.on("moveend", this._update),
                        e.on("terrain", this._update),
                        e.on("projectiontransition", this._update),
                        this.setDraggable(this._draggable),
                        this._update(),
                        this._map.on("click", this._onMapClick),
                        this
                    }
                    remove() {
                        return this._opacityTimeout && (clearTimeout(this._opacityTimeout),
                        delete this._opacityTimeout),
                        this._map && (this._map.off("click", this._onMapClick),
                        this._map.off("move", this._update),
                        this._map.off("moveend", this._update),
                        this._map.off("terrain", this._update),
                        this._map.off("projectiontransition", this._update),
                        this._map.off("mousedown", this._addDragHandler),
                        this._map.off("touchstart", this._addDragHandler),
                        this._map.off("mouseup", this._onUp),
                        this._map.off("touchend", this._onUp),
                        this._map.off("mousemove", this._onMove),
                        this._map.off("touchmove", this._onMove),
                        delete this._map),
                        Y.remove(this._element),
                        this._popup && this._popup.remove(),
                        this
                    }
                    getLngLat() {
                        return this._lngLat
                    }
                    setLngLat(e) {
                        return this._lngLat = l.Q.convert(e),
                        this._pos = null,
                        this._popup && this._popup.setLngLat(this._lngLat),
                        this._update(),
                        this
                    }
                    getElement() {
                        return this._element
                    }
                    setPopup(e) {
                        if (this._popup && (this._popup.remove(),
                        this._popup = null,
                        this._element.removeEventListener("keypress", this._onKeyPress),
                        this._originalTabIndex || this._element.removeAttribute("tabindex")),
                        e) {
                            if (!("offset"in e.options)) {
                                const a = Math.abs(13.5) / Math.SQRT2;
                                e.options.offset = this._defaultMarker ? {
                                    top: [0, 0],
                                    "top-left": [0, 0],
                                    "top-right": [0, 0],
                                    bottom: [0, -38.1],
                                    "bottom-left": [a, -1 * (38.1 - 13.5 + a)],
                                    "bottom-right": [-a, -1 * (38.1 - 13.5 + a)],
                                    left: [13.5, -1 * (38.1 - 13.5)],
                                    right: [-13.5, -1 * (38.1 - 13.5)]
                                } : this._offset
                            }
                            this._popup = e,
                            this._originalTabIndex = this._element.getAttribute("tabindex"),
                            this._originalTabIndex || this._element.setAttribute("tabindex", "0"),
                            this._element.addEventListener("keypress", this._onKeyPress)
                        }
                        return this
                    }
                    setSubpixelPositioning(e) {
                        return this._subpixelPositioning = e,
                        this
                    }
                    getPopup() {
                        return this._popup
                    }
                    togglePopup() {
                        const e = this._popup;
                        return this._element.style.opacity === this._opacityWhenCovered ? this : e ? (e.isOpen() ? e.remove() : (e.setLngLat(this._lngLat),
                        e.addTo(this._map)),
                        this) : this
                    }
                    _updateOpacity(e=!1) {
                        var i, o;
                        if (!(!((i = this._map) === null || i === void 0) && i.terrain)) {
                            const A = this._map.transform.isLocationOccluded(this._lngLat) ? this._opacityWhenCovered : this._opacity;
                            return void (this._element.style.opacity !== A && (this._element.style.opacity = A))
                        }
                        if (e)
                            this._opacityTimeout = null;
                        else {
                            if (this._opacityTimeout)
                                return;
                            this._opacityTimeout = setTimeout( () => {
                                this._opacityTimeout = null
                            }
                            , 100)
                        }
                        const a = this._map
                          , h = a.terrain.depthAtPoint(this._pos)
                          , m = a.terrain.getElevationForLngLatZoom(this._lngLat, a.transform.tileZoom);
                        if (a.transform.lngLatToCameraDepth(this._lngLat, m) - h < .006)
                            return void (this._element.style.opacity = this._opacity);
                        const y = -this._offset.y / a.transform.pixelsPerMeter
                          , v = Math.sin(a.getPitch() * Math.PI / 180) * y
                          , T = a.terrain.depthAtPoint(new l.P(this._pos.x,this._pos.y - this._offset.y))
                          , S = a.transform.lngLatToCameraDepth(this._lngLat, m + v) - T > .006;
                        !((o = this._popup) === null || o === void 0) && o.isOpen() && S && this._popup.remove(),
                        this._element.style.opacity = S ? this._opacityWhenCovered : this._opacity
                    }
                    getOffset() {
                        return this._offset
                    }
                    setOffset(e) {
                        return this._offset = l.P.convert(e),
                        this._update(),
                        this
                    }
                    addClassName(e) {
                        this._element.classList.add(e)
                    }
                    removeClassName(e) {
                        this._element.classList.remove(e)
                    }
                    toggleClassName(e) {
                        return this._element.classList.toggle(e)
                    }
                    setDraggable(e) {
                        return this._draggable = !!e,
                        this._map && (e ? (this._map.on("mousedown", this._addDragHandler),
                        this._map.on("touchstart", this._addDragHandler)) : (this._map.off("mousedown", this._addDragHandler),
                        this._map.off("touchstart", this._addDragHandler))),
                        this
                    }
                    isDraggable() {
                        return this._draggable
                    }
                    setRotation(e) {
                        return this._rotation = e || 0,
                        this._update(),
                        this
                    }
                    getRotation() {
                        return this._rotation
                    }
                    setRotationAlignment(e) {
                        return this._rotationAlignment = e || "auto",
                        this._update(),
                        this
                    }
                    getRotationAlignment() {
                        return this._rotationAlignment
                    }
                    setPitchAlignment(e) {
                        return this._pitchAlignment = e && e !== "auto" ? e : this._rotationAlignment,
                        this._update(),
                        this
                    }
                    getPitchAlignment() {
                        return this._pitchAlignment
                    }
                    setOpacity(e, i) {
                        return (this._opacity === void 0 || e === void 0 && i === void 0) && (this._opacity = "1",
                        this._opacityWhenCovered = "0.2"),
                        e !== void 0 && (this._opacity = e),
                        i !== void 0 && (this._opacityWhenCovered = i),
                        this._map && this._updateOpacity(!0),
                        this
                    }
                }
                const Nl = {
                    positionOptions: {
                        enableHighAccuracy: !1,
                        maximumAge: 0,
                        timeout: 6e3
                    },
                    fitBoundsOptions: {
                        maxZoom: 15
                    },
                    trackUserLocation: !1,
                    showAccuracyCircle: !0,
                    showUserLocation: !0
                };
                let Gs = 0
                  , ps = !1;
                const jl = {
                    maxWidth: 100,
                    unit: "metric"
                };
                function _a(u, e, i) {
                    const o = i && i.maxWidth || 100
                      , a = u._container.clientHeight / 2
                      , h = u._container.clientWidth / 2
                      , m = u.unproject([h - o / 2, a])
                      , y = u.unproject([h + o / 2, a])
                      , v = Math.round(u.project(y).x - u.project(m).x)
                      , T = Math.min(o, v, u._container.clientWidth)
                      , S = m.distanceTo(y);
                    if (i && i.unit === "imperial") {
                        const A = 3.2808 * S;
                        A > 5280 ? fs(e, T, A / 5280, u._getUIString("ScaleControl.Miles")) : fs(e, T, A, u._getUIString("ScaleControl.Feet"))
                    } else
                        i && i.unit === "nautical" ? fs(e, T, S / 1852, u._getUIString("ScaleControl.NauticalMiles")) : S >= 1e3 ? fs(e, T, S / 1e3, u._getUIString("ScaleControl.Kilometers")) : fs(e, T, S, u._getUIString("ScaleControl.Meters"))
                }
                function fs(u, e, i, o) {
                    const a = function(h) {
                        const m = Math.pow(10, `${Math.floor(h)}`.length - 1);
                        let y = h / m;
                        return y = y >= 10 ? 10 : y >= 5 ? 5 : y >= 3 ? 3 : y >= 2 ? 2 : y >= 1 ? 1 : function(v) {
                            const T = Math.pow(10, Math.ceil(-Math.log(v) / Math.LN10));
                            return Math.round(v * T) / T
                        }(y),
                        m * y
                    }(i);
                    u.style.width = e * (a / i) + "px",
                    u.innerHTML = `${a}&nbsp;${o}`
                }
                const ya = {
                    closeButton: !0,
                    closeOnClick: !0,
                    focusAfterOpen: !0,
                    className: "",
                    maxWidth: "240px",
                    subpixelPositioning: !1,
                    locationOccludedOpacity: void 0
                }
                  , Vl = ["a[href]", "[tabindex]:not([tabindex='-1'])", "[contenteditable]:not([contenteditable='false'])", "button:not([disabled])", "input:not([disabled])", "select:not([disabled])", "textarea:not([disabled])"].join(", ");
                function xa(u) {
                    if (u) {
                        if (typeof u == "number") {
                            const e = Math.round(Math.abs(u) / Math.SQRT2);
                            return {
                                center: new l.P(0,0),
                                top: new l.P(0,u),
                                "top-left": new l.P(e,e),
                                "top-right": new l.P(-e,e),
                                bottom: new l.P(0,-u),
                                "bottom-left": new l.P(e,-e),
                                "bottom-right": new l.P(-e,-e),
                                left: new l.P(u,0),
                                right: new l.P(-u,0)
                            }
                        }
                        if (u instanceof l.P || Array.isArray(u)) {
                            const e = l.P.convert(u);
                            return {
                                center: e,
                                top: e,
                                "top-left": e,
                                "top-right": e,
                                bottom: e,
                                "bottom-left": e,
                                "bottom-right": e,
                                left: e,
                                right: e
                            }
                        }
                        return {
                            center: l.P.convert(u.center || [0, 0]),
                            top: l.P.convert(u.top || [0, 0]),
                            "top-left": l.P.convert(u["top-left"] || [0, 0]),
                            "top-right": l.P.convert(u["top-right"] || [0, 0]),
                            bottom: l.P.convert(u.bottom || [0, 0]),
                            "bottom-left": l.P.convert(u["bottom-left"] || [0, 0]),
                            "bottom-right": l.P.convert(u["bottom-right"] || [0, 0]),
                            left: l.P.convert(u.left || [0, 0]),
                            right: l.P.convert(u.right || [0, 0])
                        }
                    }
                    return xa(new l.P(0,0))
                }
                const va = ce;
                M.AJAXError = l.ci,
                M.Event = l.l,
                M.Evented = l.E,
                M.LngLat = l.Q,
                M.MercatorCoordinate = l.$,
                M.Point = l.P,
                M.addProtocol = l.cj,
                M.config = l.a,
                M.removeProtocol = l.ck,
                M.AttributionControl = bo,
                M.BoxZoomHandler = tu,
                M.CanvasSource = ws,
                M.CooperativeGesturesHandler = Fl,
                M.DoubleClickZoomHandler = ou,
                M.DragPanHandler = xo,
                M.DragRotateHandler = ha,
                M.EdgeInsets = Ii,
                M.FullscreenControl = class extends l.E {
                    constructor(u={}) {
                        super(),
                        this._onFullscreenChange = () => {
                            var e;
                            let i = window.document.fullscreenElement || window.document.mozFullScreenElement || window.document.webkitFullscreenElement || window.document.msFullscreenElement;
                            for (; !((e = i?.shadowRoot) === null || e === void 0) && e.fullscreenElement; )
                                i = i.shadowRoot.fullscreenElement;
                            i === this._container !== this._fullscreen && this._handleFullscreenChange()
                        }
                        ,
                        this._onClickFullscreen = () => {
                            this._isFullscreen() ? this._exitFullscreen() : this._requestFullscreen()
                        }
                        ,
                        this._fullscreen = !1,
                        u && u.container && (u.container instanceof HTMLElement ? this._container = u.container : l.w("Full screen control 'container' must be a DOM element.")),
                        "onfullscreenchange"in document ? this._fullscreenchange = "fullscreenchange" : "onmozfullscreenchange"in document ? this._fullscreenchange = "mozfullscreenchange" : "onwebkitfullscreenchange"in document ? this._fullscreenchange = "webkitfullscreenchange" : "onmsfullscreenchange"in document && (this._fullscreenchange = "MSFullscreenChange")
                    }
                    onAdd(u) {
                        return this._map = u,
                        this._container || (this._container = this._map.getContainer()),
                        this._controlContainer = Y.create("div", "maplibregl-ctrl maplibregl-ctrl-group"),
                        this._setupUI(),
                        this._controlContainer
                    }
                    onRemove() {
                        Y.remove(this._controlContainer),
                        this._map = null,
                        window.document.removeEventListener(this._fullscreenchange, this._onFullscreenChange)
                    }
                    _setupUI() {
                        const u = this._fullscreenButton = Y.create("button", "maplibregl-ctrl-fullscreen", this._controlContainer);
                        Y.create("span", "maplibregl-ctrl-icon", u).setAttribute("aria-hidden", "true"),
                        u.type = "button",
                        this._updateTitle(),
                        this._fullscreenButton.addEventListener("click", this._onClickFullscreen),
                        window.document.addEventListener(this._fullscreenchange, this._onFullscreenChange)
                    }
                    _updateTitle() {
                        const u = this._getTitle();
                        this._fullscreenButton.setAttribute("aria-label", u),
                        this._fullscreenButton.title = u
                    }
                    _getTitle() {
                        return this._map._getUIString(this._isFullscreen() ? "FullscreenControl.Exit" : "FullscreenControl.Enter")
                    }
                    _isFullscreen() {
                        return this._fullscreen
                    }
                    _handleFullscreenChange() {
                        this._fullscreen = !this._fullscreen,
                        this._fullscreenButton.classList.toggle("maplibregl-ctrl-shrink"),
                        this._fullscreenButton.classList.toggle("maplibregl-ctrl-fullscreen"),
                        this._updateTitle(),
                        this._fullscreen ? (this.fire(new l.l("fullscreenstart")),
                        this._prevCooperativeGesturesEnabled = this._map.cooperativeGestures.isEnabled(),
                        this._map.cooperativeGestures.disable()) : (this.fire(new l.l("fullscreenend")),
                        this._prevCooperativeGesturesEnabled && this._map.cooperativeGestures.enable())
                    }
                    _exitFullscreen() {
                        window.document.exitFullscreen ? window.document.exitFullscreen() : window.document.mozCancelFullScreen ? window.document.mozCancelFullScreen() : window.document.msExitFullscreen ? window.document.msExitFullscreen() : window.document.webkitCancelFullScreen ? window.document.webkitCancelFullScreen() : this._togglePseudoFullScreen()
                    }
                    _requestFullscreen() {
                        this._container.requestFullscreen ? this._container.requestFullscreen() : this._container.mozRequestFullScreen ? this._container.mozRequestFullScreen() : this._container.msRequestFullscreen ? this._container.msRequestFullscreen() : this._container.webkitRequestFullscreen ? this._container.webkitRequestFullscreen() : this._togglePseudoFullScreen()
                    }
                    _togglePseudoFullScreen() {
                        this._container.classList.toggle("maplibregl-pseudo-fullscreen"),
                        this._handleFullscreenChange(),
                        this._map.resize()
                    }
                }
                ,
                M.GeoJSONSource = kn,
                M.GeolocateControl = class extends l.E {
                    constructor(u) {
                        super(),
                        this._onSuccess = e => {
                            if (this._map) {
                                if (this._isOutOfMapMaxBounds(e))
                                    return this._setErrorState(),
                                    this.fire(new l.l("outofmaxbounds",e)),
                                    this._updateMarker(),
                                    void this._finish();
                                if (this.options.trackUserLocation)
                                    switch (this._lastKnownPosition = e,
                                    this._watchState) {
                                    case "WAITING_ACTIVE":
                                    case "ACTIVE_LOCK":
                                    case "ACTIVE_ERROR":
                                        this._watchState = "ACTIVE_LOCK",
                                        this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"),
                                        this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"),
                                        this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                                        break;
                                    case "BACKGROUND":
                                    case "BACKGROUND_ERROR":
                                        this._watchState = "BACKGROUND",
                                        this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"),
                                        this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"),
                                        this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background");
                                        break;
                                    default:
                                        throw new Error(`Unexpected watchState ${this._watchState}`)
                                    }
                                this.options.showUserLocation && this._watchState !== "OFF" && this._updateMarker(e),
                                this.options.trackUserLocation && this._watchState !== "ACTIVE_LOCK" || this._updateCamera(e),
                                this.options.showUserLocation && this._dotElement.classList.remove("maplibregl-user-location-dot-stale"),
                                this.fire(new l.l("geolocate",e)),
                                this._finish()
                            }
                        }
                        ,
                        this._updateCamera = e => {
                            const i = new l.Q(e.coords.longitude,e.coords.latitude)
                              , o = e.coords.accuracy
                              , a = this._map.getBearing()
                              , h = l.e({
                                bearing: a
                            }, this.options.fitBoundsOptions)
                              , m = oi.fromLngLat(i, o);
                            this._map.fitBounds(m, h, {
                                geolocateSource: !0
                            })
                        }
                        ,
                        this._updateMarker = e => {
                            if (e) {
                                const i = new l.Q(e.coords.longitude,e.coords.latitude);
                                this._accuracyCircleMarker.setLngLat(i).addTo(this._map),
                                this._userLocationDotMarker.setLngLat(i).addTo(this._map),
                                this._accuracy = e.coords.accuracy,
                                this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius()
                            } else
                                this._userLocationDotMarker.remove(),
                                this._accuracyCircleMarker.remove()
                        }
                        ,
                        this._onZoom = () => {
                            this.options.showUserLocation && this.options.showAccuracyCircle && this._updateCircleRadius()
                        }
                        ,
                        this._onError = e => {
                            if (this._map) {
                                if (this.options.trackUserLocation)
                                    if (e.code === 1) {
                                        this._watchState = "OFF",
                                        this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"),
                                        this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"),
                                        this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"),
                                        this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"),
                                        this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"),
                                        this._geolocateButton.disabled = !0;
                                        const i = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                                        this._geolocateButton.title = i,
                                        this._geolocateButton.setAttribute("aria-label", i),
                                        this._geolocationWatchID !== void 0 && this._clearWatch()
                                    } else {
                                        if (e.code === 3 && ps)
                                            return;
                                        this._setErrorState()
                                    }
                                this._watchState !== "OFF" && this.options.showUserLocation && this._dotElement.classList.add("maplibregl-user-location-dot-stale"),
                                this.fire(new l.l("error",e)),
                                this._finish()
                            }
                        }
                        ,
                        this._finish = () => {
                            this._timeoutId && clearTimeout(this._timeoutId),
                            this._timeoutId = void 0
                        }
                        ,
                        this._setupUI = () => {
                            this._map && (this._container.addEventListener("contextmenu", e => e.preventDefault()),
                            this._geolocateButton = Y.create("button", "maplibregl-ctrl-geolocate", this._container),
                            Y.create("span", "maplibregl-ctrl-icon", this._geolocateButton).setAttribute("aria-hidden", "true"),
                            this._geolocateButton.type = "button",
                            this._geolocateButton.disabled = !0)
                        }
                        ,
                        this._finishSetupUI = e => {
                            if (this._map) {
                                if (e === !1) {
                                    l.w("Geolocation support is not available so the GeolocateControl will be disabled.");
                                    const i = this._map._getUIString("GeolocateControl.LocationNotAvailable");
                                    this._geolocateButton.disabled = !0,
                                    this._geolocateButton.title = i,
                                    this._geolocateButton.setAttribute("aria-label", i)
                                } else {
                                    const i = this._map._getUIString("GeolocateControl.FindMyLocation");
                                    this._geolocateButton.disabled = !1,
                                    this._geolocateButton.title = i,
                                    this._geolocateButton.setAttribute("aria-label", i)
                                }
                                this.options.trackUserLocation && (this._geolocateButton.setAttribute("aria-pressed", "false"),
                                this._watchState = "OFF"),
                                this.options.showUserLocation && (this._dotElement = Y.create("div", "maplibregl-user-location-dot"),
                                this._userLocationDotMarker = new wo({
                                    element: this._dotElement
                                }),
                                this._circleElement = Y.create("div", "maplibregl-user-location-accuracy-circle"),
                                this._accuracyCircleMarker = new wo({
                                    element: this._circleElement,
                                    pitchAlignment: "map"
                                }),
                                this.options.trackUserLocation && (this._watchState = "OFF"),
                                this._map.on("zoom", this._onZoom)),
                                this._geolocateButton.addEventListener("click", () => this.trigger()),
                                this._setup = !0,
                                this.options.trackUserLocation && this._map.on("movestart", i => {
                                    i.geolocateSource || this._watchState !== "ACTIVE_LOCK" || i.originalEvent && i.originalEvent.type === "resize" || (this._watchState = "BACKGROUND",
                                    this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background"),
                                    this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"),
                                    this.fire(new l.l("trackuserlocationend")),
                                    this.fire(new l.l("userlocationlostfocus")))
                                }
                                )
                            }
                        }
                        ,
                        this.options = l.e({}, Nl, u)
                    }
                    onAdd(u) {
                        return this._map = u,
                        this._container = Y.create("div", "maplibregl-ctrl maplibregl-ctrl-group"),
                        this._setupUI(),
                        function() {
                            return l._(this, arguments, void 0, function*(e=!1) {
                                if (xn !== void 0 && !e)
                                    return xn;
                                if (window.navigator.permissions === void 0)
                                    return xn = !!window.navigator.geolocation,
                                    xn;
                                try {
                                    xn = (yield window.navigator.permissions.query({
                                        name: "geolocation"
                                    })).state !== "denied"
                                } catch {
                                    xn = !!window.navigator.geolocation
                                }
                                return xn
                            })
                        }().then(e => this._finishSetupUI(e)),
                        this._container
                    }
                    onRemove() {
                        this._geolocationWatchID !== void 0 && (window.navigator.geolocation.clearWatch(this._geolocationWatchID),
                        this._geolocationWatchID = void 0),
                        this.options.showUserLocation && this._userLocationDotMarker && this._userLocationDotMarker.remove(),
                        this.options.showAccuracyCircle && this._accuracyCircleMarker && this._accuracyCircleMarker.remove(),
                        Y.remove(this._container),
                        this._map.off("zoom", this._onZoom),
                        this._map = void 0,
                        Gs = 0,
                        ps = !1
                    }
                    _isOutOfMapMaxBounds(u) {
                        const e = this._map.getMaxBounds()
                          , i = u.coords;
                        return e && (i.longitude < e.getWest() || i.longitude > e.getEast() || i.latitude < e.getSouth() || i.latitude > e.getNorth())
                    }
                    _setErrorState() {
                        switch (this._watchState) {
                        case "WAITING_ACTIVE":
                            this._watchState = "ACTIVE_ERROR",
                            this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"),
                            this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error");
                            break;
                        case "ACTIVE_LOCK":
                            this._watchState = "ACTIVE_ERROR",
                            this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"),
                            this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active-error"),
                            this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
                            break;
                        case "BACKGROUND":
                            this._watchState = "BACKGROUND_ERROR",
                            this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"),
                            this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-background-error"),
                            this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting");
                            break;
                        case "ACTIVE_ERROR":
                            break;
                        default:
                            throw new Error(`Unexpected watchState ${this._watchState}`)
                        }
                    }
                    _updateCircleRadius() {
                        const u = this._map.getBounds()
                          , e = u.getSouthEast()
                          , i = u.getNorthEast()
                          , o = e.distanceTo(i)
                          , a = Math.ceil(this._accuracy / (o / this._map._container.clientHeight) * 2);
                        this._circleElement.style.width = `${a}px`,
                        this._circleElement.style.height = `${a}px`
                    }
                    trigger() {
                        if (!this._setup)
                            return l.w("Geolocate control triggered before added to a map"),
                            !1;
                        if (this.options.trackUserLocation) {
                            switch (this._watchState) {
                            case "OFF":
                                this._watchState = "WAITING_ACTIVE",
                                this.fire(new l.l("trackuserlocationstart"));
                                break;
                            case "WAITING_ACTIVE":
                            case "ACTIVE_LOCK":
                            case "ACTIVE_ERROR":
                            case "BACKGROUND_ERROR":
                                Gs--,
                                ps = !1,
                                this._watchState = "OFF",
                                this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"),
                                this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active"),
                                this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-active-error"),
                                this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"),
                                this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background-error"),
                                this.fire(new l.l("trackuserlocationend"));
                                break;
                            case "BACKGROUND":
                                this._watchState = "ACTIVE_LOCK",
                                this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-background"),
                                this._lastKnownPosition && this._updateCamera(this._lastKnownPosition),
                                this.fire(new l.l("trackuserlocationstart")),
                                this.fire(new l.l("userlocationfocus"));
                                break;
                            default:
                                throw new Error(`Unexpected watchState ${this._watchState}`)
                            }
                            switch (this._watchState) {
                            case "WAITING_ACTIVE":
                                this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"),
                                this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                                break;
                            case "ACTIVE_LOCK":
                                this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-active");
                                break;
                            case "OFF":
                                break;
                            default:
                                throw new Error(`Unexpected watchState ${this._watchState}`)
                            }
                            if (this._watchState === "OFF" && this._geolocationWatchID !== void 0)
                                this._clearWatch();
                            else if (this._geolocationWatchID === void 0) {
                                let u;
                                this._geolocateButton.classList.add("maplibregl-ctrl-geolocate-waiting"),
                                this._geolocateButton.setAttribute("aria-pressed", "true"),
                                Gs++,
                                Gs > 1 ? (u = {
                                    maximumAge: 6e5,
                                    timeout: 0
                                },
                                ps = !0) : (u = this.options.positionOptions,
                                ps = !1),
                                this._geolocationWatchID = window.navigator.geolocation.watchPosition(this._onSuccess, this._onError, u)
                            }
                        } else
                            window.navigator.geolocation.getCurrentPosition(this._onSuccess, this._onError, this.options.positionOptions),
                            this._timeoutId = setTimeout(this._finish, 1e4);
                        return !0
                    }
                    _clearWatch() {
                        window.navigator.geolocation.clearWatch(this._geolocationWatchID),
                        this._geolocationWatchID = void 0,
                        this._geolocateButton.classList.remove("maplibregl-ctrl-geolocate-waiting"),
                        this._geolocateButton.setAttribute("aria-pressed", "false"),
                        this.options.showUserLocation && this._updateMarker(null)
                    }
                }
                ,
                M.GlobeControl = class {
                    constructor() {
                        this._toggleProjection = () => {
                            var u;
                            const e = (u = this._map.getProjection()) === null || u === void 0 ? void 0 : u.type;
                            this._map.setProjection(e !== "mercator" && e ? {
                                type: "mercator"
                            } : {
                                type: "globe"
                            }),
                            this._updateGlobeIcon()
                        }
                        ,
                        this._updateGlobeIcon = () => {
                            var u;
                            this._globeButton.classList.remove("maplibregl-ctrl-globe"),
                            this._globeButton.classList.remove("maplibregl-ctrl-globe-enabled"),
                            ((u = this._map.getProjection()) === null || u === void 0 ? void 0 : u.type) === "globe" ? (this._globeButton.classList.add("maplibregl-ctrl-globe-enabled"),
                            this._globeButton.title = this._map._getUIString("GlobeControl.Disable")) : (this._globeButton.classList.add("maplibregl-ctrl-globe"),
                            this._globeButton.title = this._map._getUIString("GlobeControl.Enable"))
                        }
                    }
                    onAdd(u) {
                        return this._map = u,
                        this._container = Y.create("div", "maplibregl-ctrl maplibregl-ctrl-group"),
                        this._globeButton = Y.create("button", "maplibregl-ctrl-globe", this._container),
                        Y.create("span", "maplibregl-ctrl-icon", this._globeButton).setAttribute("aria-hidden", "true"),
                        this._globeButton.type = "button",
                        this._globeButton.addEventListener("click", this._toggleProjection),
                        this._updateGlobeIcon(),
                        this._map.on("styledata", this._updateGlobeIcon),
                        this._container
                    }
                    onRemove() {
                        Y.remove(this._container),
                        this._map.off("styledata", this._updateGlobeIcon),
                        this._globeButton.removeEventListener("click", this._toggleProjection),
                        this._map = void 0
                    }
                }
                ,
                M.Hash = On,
                M.ImageSource = tn,
                M.KeyboardHandler = Ll,
                M.LngLatBounds = oi,
                M.LogoControl = pa,
                M.Map = class extends Xe {
                    constructor(u) {
                        var e, i;
                        l.cf.mark(l.cg.create);
                        const o = Object.assign(Object.assign(Object.assign({}, Zs), u), {
                            canvasContextAttributes: Object.assign(Object.assign({}, Zs.canvasContextAttributes), u.canvasContextAttributes)
                        });
                        if (o.minZoom != null && o.maxZoom != null && o.minZoom > o.maxZoom)
                            throw new Error("maxZoom must be greater than or equal to minZoom");
                        if (o.minPitch != null && o.maxPitch != null && o.minPitch > o.maxPitch)
                            throw new Error("maxPitch must be greater than or equal to minPitch");
                        if (o.minPitch != null && o.minPitch < 0)
                            throw new Error("minPitch must be greater than or equal to 0");
                        if (o.maxPitch != null && o.maxPitch > 180)
                            throw new Error("maxPitch must be less than or equal to 180");
                        const a = new Pr
                          , h = new Ur;
                        if (o.minZoom !== void 0 && a.setMinZoom(o.minZoom),
                        o.maxZoom !== void 0 && a.setMaxZoom(o.maxZoom),
                        o.minPitch !== void 0 && a.setMinPitch(o.minPitch),
                        o.maxPitch !== void 0 && a.setMaxPitch(o.maxPitch),
                        o.renderWorldCopies !== void 0 && a.setRenderWorldCopies(o.renderWorldCopies),
                        super(a, h, {
                            bearingSnap: o.bearingSnap
                        }),
                        this._idleTriggered = !1,
                        this._crossFadingFactor = 1,
                        this._renderTaskQueue = new Bl,
                        this._controls = [],
                        this._mapId = l.a3(),
                        this._contextLost = y => {
                            y.preventDefault(),
                            this._frameRequest && (this._frameRequest.abort(),
                            this._frameRequest = null),
                            this.fire(new l.l("webglcontextlost",{
                                originalEvent: y
                            }))
                        }
                        ,
                        this._contextRestored = y => {
                            this._setupPainter(),
                            this.resize(),
                            this._update(),
                            this.fire(new l.l("webglcontextrestored",{
                                originalEvent: y
                            }))
                        }
                        ,
                        this._onMapScroll = y => {
                            if (y.target === this._container)
                                return this._container.scrollTop = 0,
                                this._container.scrollLeft = 0,
                                !1
                        }
                        ,
                        this._onWindowOnline = () => {
                            this._update()
                        }
                        ,
                        this._interactive = o.interactive,
                        this._maxTileCacheSize = o.maxTileCacheSize,
                        this._maxTileCacheZoomLevels = o.maxTileCacheZoomLevels,
                        this._canvasContextAttributes = Object.assign({}, o.canvasContextAttributes),
                        this._trackResize = o.trackResize === !0,
                        this._bearingSnap = o.bearingSnap,
                        this._centerClampedToGround = o.centerClampedToGround,
                        this._refreshExpiredTiles = o.refreshExpiredTiles === !0,
                        this._fadeDuration = o.fadeDuration,
                        this._crossSourceCollisions = o.crossSourceCollisions === !0,
                        this._collectResourceTiming = o.collectResourceTiming === !0,
                        this._locale = Object.assign(Object.assign({}, li), o.locale),
                        this._clickTolerance = o.clickTolerance,
                        this._overridePixelRatio = o.pixelRatio,
                        this._maxCanvasSize = o.maxCanvasSize,
                        this.transformCameraUpdate = o.transformCameraUpdate,
                        this.cancelPendingTileRequestsWhileZooming = o.cancelPendingTileRequestsWhileZooming === !0,
                        this._imageQueueHandle = Wt.addThrottleControl( () => this.isMoving()),
                        this._requestManager = new pi(o.transformRequest),
                        typeof o.container == "string") {
                            if (this._container = document.getElementById(o.container),
                            !this._container)
                                throw new Error(`Container '${o.container}' not found.`)
                        } else {
                            if (!(o.container instanceof HTMLElement))
                                throw new Error("Invalid type: 'container' must be a String or HTMLElement.");
                            this._container = o.container
                        }
                        if (o.maxBounds && this.setMaxBounds(o.maxBounds),
                        this._setupContainer(),
                        this._setupPainter(),
                        this.on("move", () => this._update(!1)),
                        this.on("moveend", () => this._update(!1)),
                        this.on("zoom", () => this._update(!0)),
                        this.on("terrain", () => {
                            this.painter.terrainFacilitator.dirty = !0,
                            this._update(!0)
                        }
                        ),
                        this.once("idle", () => {
                            this._idleTriggered = !0
                        }
                        ),
                        typeof window < "u") {
                            addEventListener("online", this._onWindowOnline, !1);
                            let y = !1;
                            const v = Pl(T => {
                                this._trackResize && !this._removed && (this.resize(T),
                                this.redraw())
                            }
                            , 50);
                            this._resizeObserver = new ResizeObserver(T => {
                                y ? v(T) : y = !0
                            }
                            ),
                            this._resizeObserver.observe(this._container)
                        }
                        this.handlers = new da(this,o),
                        this._hash = o.hash && new On(typeof o.hash == "string" && o.hash || void 0).addTo(this),
                        this._hash && this._hash._onHashChange() || (this.jumpTo({
                            center: o.center,
                            elevation: o.elevation,
                            zoom: o.zoom,
                            bearing: o.bearing,
                            pitch: o.pitch,
                            roll: o.roll
                        }),
                        o.bounds && (this.resize(),
                        this.fitBounds(o.bounds, l.e({}, o.fitBoundsOptions, {
                            duration: 0
                        }))));
                        const m = typeof o.style == "string" || ((i = (e = o.style) === null || e === void 0 ? void 0 : e.projection) === null || i === void 0 ? void 0 : i.type) !== "globe";
                        this.resize(null, m),
                        this._localIdeographFontFamily = o.localIdeographFontFamily,
                        this._validateStyle = o.validateStyle,
                        o.style && this.setStyle(o.style, {
                            localIdeographFontFamily: o.localIdeographFontFamily
                        }),
                        o.attributionControl && this.addControl(new bo(typeof o.attributionControl == "boolean" ? void 0 : o.attributionControl)),
                        o.maplibreLogo && this.addControl(new pa, o.logoPosition),
                        this.on("style.load", () => {
                            if (m || this._resizeTransform(),
                            this.transform.unmodified) {
                                const y = l.O(this.style.stylesheet, ["center", "zoom", "bearing", "pitch", "roll"]);
                                this.jumpTo(y)
                            }
                        }
                        ),
                        this.on("data", y => {
                            this._update(y.dataType === "style"),
                            this.fire(new l.l(`${y.dataType}data`,y))
                        }
                        ),
                        this.on("dataloading", y => {
                            this.fire(new l.l(`${y.dataType}dataloading`,y))
                        }
                        ),
                        this.on("dataabort", y => {
                            this.fire(new l.l("sourcedataabort",y))
                        }
                        )
                    }
                    _getMapId() {
                        return this._mapId
                    }
                    addControl(u, e) {
                        if (e === void 0 && (e = u.getDefaultPosition ? u.getDefaultPosition() : "top-right"),
                        !u || !u.onAdd)
                            return this.fire(new l.k(new Error("Invalid argument to map.addControl(). Argument must be a control with onAdd and onRemove methods.")));
                        const i = u.onAdd(this);
                        this._controls.push(u);
                        const o = this._controlPositions[e];
                        return e.indexOf("bottom") !== -1 ? o.insertBefore(i, o.firstChild) : o.appendChild(i),
                        this
                    }
                    removeControl(u) {
                        if (!u || !u.onRemove)
                            return this.fire(new l.k(new Error("Invalid argument to map.removeControl(). Argument must be a control with onAdd and onRemove methods.")));
                        const e = this._controls.indexOf(u);
                        return e > -1 && this._controls.splice(e, 1),
                        u.onRemove(this),
                        this
                    }
                    hasControl(u) {
                        return this._controls.indexOf(u) > -1
                    }
                    calculateCameraOptionsFromTo(u, e, i, o) {
                        return o == null && this.terrain && (o = this.terrain.getElevationForLngLatZoom(i, this.transform.tileZoom)),
                        super.calculateCameraOptionsFromTo(u, e, i, o)
                    }
                    resize(u, e=!0) {
                        const [i,o] = this._containerDimensions()
                          , a = this._getClampedPixelRatio(i, o);
                        if (this._resizeCanvas(i, o, a),
                        this.painter.resize(i, o, a),
                        this.painter.overLimit()) {
                            const m = this.painter.context.gl;
                            this._maxCanvasSize = [m.drawingBufferWidth, m.drawingBufferHeight];
                            const y = this._getClampedPixelRatio(i, o);
                            this._resizeCanvas(i, o, y),
                            this.painter.resize(i, o, y)
                        }
                        this._resizeTransform(e);
                        const h = !this._moving;
                        return h && (this.stop(),
                        this.fire(new l.l("movestart",u)).fire(new l.l("move",u))),
                        this.fire(new l.l("resize",u)),
                        h && this.fire(new l.l("moveend",u)),
                        this
                    }
                    _resizeTransform(u=!0) {
                        var e;
                        const [i,o] = this._containerDimensions();
                        this.transform.resize(i, o, u),
                        (e = this._requestedCameraState) === null || e === void 0 || e.resize(i, o, u)
                    }
                    _getClampedPixelRatio(u, e) {
                        const {0: i, 1: o} = this._maxCanvasSize
                          , a = this.getPixelRatio()
                          , h = u * a
                          , m = e * a;
                        return Math.min(h > i ? i / h : 1, m > o ? o / m : 1) * a
                    }
                    getPixelRatio() {
                        var u;
                        return (u = this._overridePixelRatio) !== null && u !== void 0 ? u : devicePixelRatio
                    }
                    setPixelRatio(u) {
                        this._overridePixelRatio = u,
                        this.resize()
                    }
                    getBounds() {
                        return this.transform.getBounds()
                    }
                    getMaxBounds() {
                        return this.transform.getMaxBounds()
                    }
                    setMaxBounds(u) {
                        return this.transform.setMaxBounds(oi.convert(u)),
                        this._update()
                    }
                    setMinZoom(u) {
                        if ((u = u ?? -2) >= -2 && u <= this.transform.maxZoom)
                            return this.transform.setMinZoom(u),
                            this._update(),
                            this.getZoom() < u && this.setZoom(u),
                            this;
                        throw new Error("minZoom must be between -2 and the current maxZoom, inclusive")
                    }
                    getMinZoom() {
                        return this.transform.minZoom
                    }
                    setMaxZoom(u) {
                        if ((u = u ?? 22) >= this.transform.minZoom)
                            return this.transform.setMaxZoom(u),
                            this._update(),
                            this.getZoom() > u && this.setZoom(u),
                            this;
                        throw new Error("maxZoom must be greater than the current minZoom")
                    }
                    getMaxZoom() {
                        return this.transform.maxZoom
                    }
                    setMinPitch(u) {
                        if ((u = u ?? 0) < 0)
                            throw new Error("minPitch must be greater than or equal to 0");
                        if (u >= 0 && u <= this.transform.maxPitch)
                            return this.transform.setMinPitch(u),
                            this._update(),
                            this.getPitch() < u && this.setPitch(u),
                            this;
                        throw new Error("minPitch must be between 0 and the current maxPitch, inclusive")
                    }
                    getMinPitch() {
                        return this.transform.minPitch
                    }
                    setMaxPitch(u) {
                        if ((u = u ?? 60) > 180)
                            throw new Error("maxPitch must be less than or equal to 180");
                        if (u >= this.transform.minPitch)
                            return this.transform.setMaxPitch(u),
                            this._update(),
                            this.getPitch() > u && this.setPitch(u),
                            this;
                        throw new Error("maxPitch must be greater than the current minPitch")
                    }
                    getMaxPitch() {
                        return this.transform.maxPitch
                    }
                    getRenderWorldCopies() {
                        return this.transform.renderWorldCopies
                    }
                    setRenderWorldCopies(u) {
                        return this.transform.setRenderWorldCopies(u),
                        this._update()
                    }
                    project(u) {
                        return this.transform.locationToScreenPoint(l.Q.convert(u), this.style && this.terrain)
                    }
                    unproject(u) {
                        return this.transform.screenPointToLocation(l.P.convert(u), this.terrain)
                    }
                    isMoving() {
                        var u;
                        return this._moving || ((u = this.handlers) === null || u === void 0 ? void 0 : u.isMoving())
                    }
                    isZooming() {
                        var u;
                        return this._zooming || ((u = this.handlers) === null || u === void 0 ? void 0 : u.isZooming())
                    }
                    isRotating() {
                        var u;
                        return this._rotating || ((u = this.handlers) === null || u === void 0 ? void 0 : u.isRotating())
                    }
                    _createDelegatedListener(u, e, i) {
                        if (u === "mouseenter" || u === "mouseover") {
                            let o = !1;
                            return {
                                layers: e,
                                listener: i,
                                delegates: {
                                    mousemove: h => {
                                        const m = e.filter(v => this.getLayer(v))
                                          , y = m.length !== 0 ? this.queryRenderedFeatures(h.point, {
                                            layers: m
                                        }) : [];
                                        y.length ? o || (o = !0,
                                        i.call(this, new Kt(u,this,h.originalEvent,{
                                            features: y
                                        }))) : o = !1
                                    }
                                    ,
                                    mouseout: () => {
                                        o = !1
                                    }
                                }
                            }
                        }
                        if (u === "mouseleave" || u === "mouseout") {
                            let o = !1;
                            return {
                                layers: e,
                                listener: i,
                                delegates: {
                                    mousemove: m => {
                                        const y = e.filter(v => this.getLayer(v));
                                        (y.length !== 0 ? this.queryRenderedFeatures(m.point, {
                                            layers: y
                                        }) : []).length ? o = !0 : o && (o = !1,
                                        i.call(this, new Kt(u,this,m.originalEvent)))
                                    }
                                    ,
                                    mouseout: m => {
                                        o && (o = !1,
                                        i.call(this, new Kt(u,this,m.originalEvent)))
                                    }
                                }
                            }
                        }
                        {
                            const o = a => {
                                const h = e.filter(y => this.getLayer(y))
                                  , m = h.length !== 0 ? this.queryRenderedFeatures(a.point, {
                                    layers: h
                                }) : [];
                                m.length && (a.features = m,
                                i.call(this, a),
                                delete a.features)
                            }
                            ;
                            return {
                                layers: e,
                                listener: i,
                                delegates: {
                                    [u]: o
                                }
                            }
                        }
                    }
                    _saveDelegatedListener(u, e) {
                        this._delegatedListeners = this._delegatedListeners || {},
                        this._delegatedListeners[u] = this._delegatedListeners[u] || [],
                        this._delegatedListeners[u].push(e)
                    }
                    _removeDelegatedListener(u, e, i) {
                        if (!this._delegatedListeners || !this._delegatedListeners[u])
                            return;
                        const o = this._delegatedListeners[u];
                        for (let a = 0; a < o.length; a++) {
                            const h = o[a];
                            if (h.listener === i && h.layers.length === e.length && h.layers.every(m => e.includes(m))) {
                                for (const m in h.delegates)
                                    this.off(m, h.delegates[m]);
                                return void o.splice(a, 1)
                            }
                        }
                    }
                    on(u, e, i) {
                        if (i === void 0)
                            return super.on(u, e);
                        const o = typeof e == "string" ? [e] : e
                          , a = this._createDelegatedListener(u, o, i);
                        this._saveDelegatedListener(u, a);
                        for (const h in a.delegates)
                            this.on(h, a.delegates[h]);
                        return {
                            unsubscribe: () => {
                                this._removeDelegatedListener(u, o, i)
                            }
                        }
                    }
                    once(u, e, i) {
                        if (i === void 0)
                            return super.once(u, e);
                        const o = typeof e == "string" ? [e] : e
                          , a = this._createDelegatedListener(u, o, i);
                        for (const h in a.delegates) {
                            const m = a.delegates[h];
                            a.delegates[h] = (...y) => {
                                this._removeDelegatedListener(u, o, i),
                                m(...y)
                            }
                        }
                        this._saveDelegatedListener(u, a);
                        for (const h in a.delegates)
                            this.once(h, a.delegates[h]);
                        return this
                    }
                    off(u, e, i) {
                        return i === void 0 ? super.off(u, e) : (this._removeDelegatedListener(u, typeof e == "string" ? [e] : e, i),
                        this)
                    }
                    queryRenderedFeatures(u, e) {
                        if (!this.style)
                            return [];
                        let i;
                        const o = u instanceof l.P || Array.isArray(u)
                          , a = o ? u : [[0, 0], [this.transform.width, this.transform.height]];
                        if (e = e || (o ? {} : u) || {},
                        a instanceof l.P || typeof a[0] == "number")
                            i = [l.P.convert(a)];
                        else {
                            const h = l.P.convert(a[0])
                              , m = l.P.convert(a[1]);
                            i = [h, new l.P(m.x,h.y), m, new l.P(h.x,m.y), h]
                        }
                        return this.style.queryRenderedFeatures(i, e, this.transform)
                    }
                    querySourceFeatures(u, e) {
                        return this.style.querySourceFeatures(u, e)
                    }
                    setStyle(u, e) {
                        return (e = l.e({}, {
                            localIdeographFontFamily: this._localIdeographFontFamily,
                            validate: this._validateStyle
                        }, e)).diff !== !1 && e.localIdeographFontFamily === this._localIdeographFontFamily && this.style && u ? (this._diffStyle(u, e),
                        this) : (this._localIdeographFontFamily = e.localIdeographFontFamily,
                        this._updateStyle(u, e))
                    }
                    setTransformRequest(u) {
                        return this._requestManager.setTransformRequest(u),
                        this
                    }
                    _getUIString(u) {
                        const e = this._locale[u];
                        if (e == null)
                            throw new Error(`Missing UI string '${u}'`);
                        return e
                    }
                    _updateStyle(u, e) {
                        var i, o;
                        if (e.transformStyle && this.style && !this.style._loaded)
                            return void this.style.once("style.load", () => this._updateStyle(u, e));
                        const a = this.style && e.transformStyle ? this.style.serialize() : void 0;
                        return this.style && (this.style.setEventedParent(null),
                        this.style._remove(!u)),
                        u ? (this.style = new lo(this,e || {}),
                        this.style.setEventedParent(this, {
                            style: this.style
                        }),
                        typeof u == "string" ? this.style.loadURL(u, e, a) : this.style.loadJSON(u, e, a),
                        this) : ((o = (i = this.style) === null || i === void 0 ? void 0 : i.projection) === null || o === void 0 || o.destroy(),
                        delete this.style,
                        this)
                    }
                    _lazyInitEmptyStyle() {
                        this.style || (this.style = new lo(this,{}),
                        this.style.setEventedParent(this, {
                            style: this.style
                        }),
                        this.style.loadEmpty())
                    }
                    _diffStyle(u, e) {
                        if (typeof u == "string") {
                            const i = this._requestManager.transformRequest(u, "Style");
                            l.j(i, new AbortController).then(o => {
                                this._updateDiff(o.data, e)
                            }
                            ).catch(o => {
                                o && this.fire(new l.k(o))
                            }
                            )
                        } else
                            typeof u == "object" && this._updateDiff(u, e)
                    }
                    _updateDiff(u, e) {
                        try {
                            this.style.setState(u, e) && this._update(!0)
                        } catch (i) {
                            l.w(`Unable to perform style diff: ${i.message || i.error || i}.  Rebuilding the style from scratch.`),
                            this._updateStyle(u, e)
                        }
                    }
                    getStyle() {
                        if (this.style)
                            return this.style.serialize()
                    }
                    isStyleLoaded() {
                        return this.style ? this.style.loaded() : l.w("There is no style added to the map.")
                    }
                    addSource(u, e) {
                        return this._lazyInitEmptyStyle(),
                        this.style.addSource(u, e),
                        this._update(!0)
                    }
                    isSourceLoaded(u) {
                        const e = this.style && this.style.sourceCaches[u];
                        if (e !== void 0)
                            return e.loaded();
                        this.fire(new l.k(new Error(`There is no source with ID '${u}'`)))
                    }
                    setTerrain(u) {
                        if (this.style._checkLoaded(),
                        this._terrainDataCallback && this.style.off("data", this._terrainDataCallback),
                        u) {
                            const e = this.style.sourceCaches[u.source];
                            if (!e)
                                throw new Error(`cannot load terrain, because there exists no source with ID: ${u.source}`);
                            this.terrain === null && e.reload();
                            for (const i in this.style._layers) {
                                const o = this.style._layers[i];
                                o.type === "hillshade" && o.source === u.source && l.w("You are using the same source for a hillshade layer and for 3D terrain. Please consider using two separate sources to improve rendering quality.")
                            }
                            this.terrain = new sn(this.painter,e,u),
                            this.painter.renderToTexture = new Jt(this.painter,this.terrain),
                            this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)),
                            this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)),
                            this._terrainDataCallback = i => {
                                i.dataType === "style" ? this.terrain.sourceCache.freeRtt() : i.dataType === "source" && i.tile && (i.sourceId !== u.source || this._elevationFreeze || (this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)),
                                this._centerClampedToGround && this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom))),
                                this.terrain.sourceCache.freeRtt(i.tile.tileID))
                            }
                            ,
                            this.style.on("data", this._terrainDataCallback)
                        } else
                            this.terrain && this.terrain.sourceCache.destruct(),
                            this.terrain = null,
                            this.painter.renderToTexture && this.painter.renderToTexture.destruct(),
                            this.painter.renderToTexture = null,
                            this.transform.setMinElevationForCurrentTile(0),
                            this._centerClampedToGround && this.transform.setElevation(0);
                        return this.fire(new l.l("terrain",{
                            terrain: u
                        })),
                        this
                    }
                    getTerrain() {
                        var u, e;
                        return (e = (u = this.terrain) === null || u === void 0 ? void 0 : u.options) !== null && e !== void 0 ? e : null
                    }
                    areTilesLoaded() {
                        const u = this.style && this.style.sourceCaches;
                        for (const e in u) {
                            const i = u[e]._tiles;
                            for (const o in i) {
                                const a = i[o];
                                if (a.state !== "loaded" && a.state !== "errored")
                                    return !1
                            }
                        }
                        return !0
                    }
                    removeSource(u) {
                        return this.style.removeSource(u),
                        this._update(!0)
                    }
                    getSource(u) {
                        return this.style.getSource(u)
                    }
                    addImage(u, e, i={}) {
                        const {pixelRatio: o=1, sdf: a=!1, stretchX: h, stretchY: m, content: y, textFitWidth: v, textFitHeight: T} = i;
                        if (this._lazyInitEmptyStyle(),
                        !(e instanceof HTMLImageElement || l.b(e))) {
                            if (e.width === void 0 || e.height === void 0)
                                return this.fire(new l.k(new Error("Invalid arguments to map.addImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
                            {
                                const {width: S, height: A, data: k} = e
                                  , O = e;
                                return this.style.addImage(u, {
                                    data: new l.R({
                                        width: S,
                                        height: A
                                    },new Uint8Array(k)),
                                    pixelRatio: o,
                                    stretchX: h,
                                    stretchY: m,
                                    content: y,
                                    textFitWidth: v,
                                    textFitHeight: T,
                                    sdf: a,
                                    version: 0,
                                    userImage: O
                                }),
                                O.onAdd && O.onAdd(this, u),
                                this
                            }
                        }
                        {
                            const {width: S, height: A, data: k} = oe.getImageData(e);
                            this.style.addImage(u, {
                                data: new l.R({
                                    width: S,
                                    height: A
                                },k),
                                pixelRatio: o,
                                stretchX: h,
                                stretchY: m,
                                content: y,
                                textFitWidth: v,
                                textFitHeight: T,
                                sdf: a,
                                version: 0
                            })
                        }
                    }
                    updateImage(u, e) {
                        const i = this.style.getImage(u);
                        if (!i)
                            return this.fire(new l.k(new Error("The map has no image with that id. If you are adding a new image use `map.addImage(...)` instead.")));
                        const o = e instanceof HTMLImageElement || l.b(e) ? oe.getImageData(e) : e
                          , {width: a, height: h, data: m} = o;
                        if (a === void 0 || h === void 0)
                            return this.fire(new l.k(new Error("Invalid arguments to map.updateImage(). The second argument must be an `HTMLImageElement`, `ImageData`, `ImageBitmap`, or object with `width`, `height`, and `data` properties with the same format as `ImageData`")));
                        if (a !== i.data.width || h !== i.data.height)
                            return this.fire(new l.k(new Error("The width and height of the updated image must be that same as the previous version of the image")));
                        const y = !(e instanceof HTMLImageElement || l.b(e));
                        return i.data.replace(m, y),
                        this.style.updateImage(u, i),
                        this
                    }
                    getImage(u) {
                        return this.style.getImage(u)
                    }
                    hasImage(u) {
                        return u ? !!this.style.getImage(u) : (this.fire(new l.k(new Error("Missing required image id"))),
                        !1)
                    }
                    removeImage(u) {
                        this.style.removeImage(u)
                    }
                    loadImage(u) {
                        return Wt.getImage(this._requestManager.transformRequest(u, "Image"), new AbortController)
                    }
                    listImages() {
                        return this.style.listImages()
                    }
                    addLayer(u, e) {
                        return this._lazyInitEmptyStyle(),
                        this.style.addLayer(u, e),
                        this._update(!0)
                    }
                    moveLayer(u, e) {
                        return this.style.moveLayer(u, e),
                        this._update(!0)
                    }
                    removeLayer(u) {
                        return this.style.removeLayer(u),
                        this._update(!0)
                    }
                    getLayer(u) {
                        return this.style.getLayer(u)
                    }
                    getLayersOrder() {
                        return this.style.getLayersOrder()
                    }
                    setLayerZoomRange(u, e, i) {
                        return this.style.setLayerZoomRange(u, e, i),
                        this._update(!0)
                    }
                    setFilter(u, e, i={}) {
                        return this.style.setFilter(u, e, i),
                        this._update(!0)
                    }
                    getFilter(u) {
                        return this.style.getFilter(u)
                    }
                    setPaintProperty(u, e, i, o={}) {
                        return this.style.setPaintProperty(u, e, i, o),
                        this._update(!0)
                    }
                    getPaintProperty(u, e) {
                        return this.style.getPaintProperty(u, e)
                    }
                    setLayoutProperty(u, e, i, o={}) {
                        return this.style.setLayoutProperty(u, e, i, o),
                        this._update(!0)
                    }
                    getLayoutProperty(u, e) {
                        return this.style.getLayoutProperty(u, e)
                    }
                    setGlyphs(u, e={}) {
                        return this._lazyInitEmptyStyle(),
                        this.style.setGlyphs(u, e),
                        this._update(!0)
                    }
                    getGlyphs() {
                        return this.style.getGlyphsUrl()
                    }
                    addSprite(u, e, i={}) {
                        return this._lazyInitEmptyStyle(),
                        this.style.addSprite(u, e, i, o => {
                            o || this._update(!0)
                        }
                        ),
                        this
                    }
                    removeSprite(u) {
                        return this._lazyInitEmptyStyle(),
                        this.style.removeSprite(u),
                        this._update(!0)
                    }
                    getSprite() {
                        return this.style.getSprite()
                    }
                    setSprite(u, e={}) {
                        return this._lazyInitEmptyStyle(),
                        this.style.setSprite(u, e, i => {
                            i || this._update(!0)
                        }
                        ),
                        this
                    }
                    setLight(u, e={}) {
                        return this._lazyInitEmptyStyle(),
                        this.style.setLight(u, e),
                        this._update(!0)
                    }
                    getLight() {
                        return this.style.getLight()
                    }
                    setSky(u, e={}) {
                        return this._lazyInitEmptyStyle(),
                        this.style.setSky(u, e),
                        this._update(!0)
                    }
                    getSky() {
                        return this.style.getSky()
                    }
                    setFeatureState(u, e) {
                        return this.style.setFeatureState(u, e),
                        this._update()
                    }
                    removeFeatureState(u, e) {
                        return this.style.removeFeatureState(u, e),
                        this._update()
                    }
                    getFeatureState(u) {
                        return this.style.getFeatureState(u)
                    }
                    getContainer() {
                        return this._container
                    }
                    getCanvasContainer() {
                        return this._canvasContainer
                    }
                    getCanvas() {
                        return this._canvas
                    }
                    _containerDimensions() {
                        let u = 0
                          , e = 0;
                        return this._container && (u = this._container.clientWidth || 400,
                        e = this._container.clientHeight || 300),
                        [u, e]
                    }
                    _setupContainer() {
                        const u = this._container;
                        u.classList.add("maplibregl-map");
                        const e = this._canvasContainer = Y.create("div", "maplibregl-canvas-container", u);
                        this._interactive && e.classList.add("maplibregl-interactive"),
                        this._canvas = Y.create("canvas", "maplibregl-canvas", e),
                        this._canvas.addEventListener("webglcontextlost", this._contextLost, !1),
                        this._canvas.addEventListener("webglcontextrestored", this._contextRestored, !1),
                        this._canvas.setAttribute("tabindex", this._interactive ? "0" : "-1"),
                        this._canvas.setAttribute("aria-label", this._getUIString("Map.Title")),
                        this._canvas.setAttribute("role", "region");
                        const i = this._containerDimensions()
                          , o = this._getClampedPixelRatio(i[0], i[1]);
                        this._resizeCanvas(i[0], i[1], o);
                        const a = this._controlContainer = Y.create("div", "maplibregl-control-container", u)
                          , h = this._controlPositions = {};
                        ["top-left", "top-right", "bottom-left", "bottom-right"].forEach(m => {
                            h[m] = Y.create("div", `maplibregl-ctrl-${m} `, a)
                        }
                        ),
                        this._container.addEventListener("scroll", this._onMapScroll, !1)
                    }
                    _resizeCanvas(u, e, i) {
                        this._canvas.width = Math.floor(i * u),
                        this._canvas.height = Math.floor(i * e),
                        this._canvas.style.width = `${u}px`,
                        this._canvas.style.height = `${e}px`
                    }
                    _setupPainter() {
                        const u = Object.assign(Object.assign({}, this._canvasContextAttributes), {
                            alpha: !0,
                            depth: !0,
                            stencil: !0,
                            premultipliedAlpha: !0
                        });
                        let e = null;
                        this._canvas.addEventListener("webglcontextcreationerror", o => {
                            e = {
                                requestedAttributes: u
                            },
                            o && (e.statusMessage = o.statusMessage,
                            e.type = o.type)
                        }
                        , {
                            once: !0
                        });
                        let i = null;
                        if (i = this._canvasContextAttributes.contextType ? this._canvas.getContext(this._canvasContextAttributes.contextType, u) : this._canvas.getContext("webgl2", u) || this._canvas.getContext("webgl", u),
                        !i) {
                            const o = "Failed to initialize WebGL";
                            throw e ? (e.message = o,
                            new Error(JSON.stringify(e))) : new Error(o)
                        }
                        this.painter = new Wc(i,this.transform),
                        Te.testSupport(i)
                    }
                    migrateProjection(u, e) {
                        super.migrateProjection(u, e),
                        this.painter.transform = u,
                        this.fire(new l.l("projectiontransition",{
                            newProjection: this.style.projection.name
                        }))
                    }
                    loaded() {
                        return !this._styleDirty && !this._sourcesDirty && !!this.style && this.style.loaded()
                    }
                    _update(u) {
                        return this.style && this.style._loaded ? (this._styleDirty = this._styleDirty || u,
                        this._sourcesDirty = !0,
                        this.triggerRepaint(),
                        this) : this
                    }
                    _requestRenderFrame(u) {
                        return this._update(),
                        this._renderTaskQueue.add(u)
                    }
                    _cancelRenderFrame(u) {
                        this._renderTaskQueue.remove(u)
                    }
                    _render(u) {
                        var e, i, o, a, h;
                        const m = this._idleTriggered ? this._fadeDuration : 0
                          , y = ((e = this.style.projection) === null || e === void 0 ? void 0 : e.transitionState) > 0;
                        if (this.painter.context.setDirty(),
                        this.painter.setBaseState(),
                        this._renderTaskQueue.run(u),
                        this._removed)
                            return;
                        let v = !1;
                        if (this.style && this._styleDirty) {
                            this._styleDirty = !1;
                            const A = this.transform.zoom
                              , k = oe.now();
                            this.style.zoomHistory.update(A, k);
                            const O = new l.C(A,{
                                now: k,
                                fadeDuration: m,
                                zoomHistory: this.style.zoomHistory,
                                transition: this.style.getTransition()
                            })
                              , V = O.crossFadingFactor();
                            V === 1 && V === this._crossFadingFactor || (v = !0,
                            this._crossFadingFactor = V),
                            this.style.update(O)
                        }
                        const T = ((i = this.style.projection) === null || i === void 0 ? void 0 : i.transitionState) > 0 !== y;
                        (o = this.style.projection) === null || o === void 0 || o.setErrorQueryLatitudeDegrees(this.transform.center.lat),
                        this.transform.setTransitionState((a = this.style.projection) === null || a === void 0 ? void 0 : a.transitionState, (h = this.style.projection) === null || h === void 0 ? void 0 : h.latitudeErrorCorrectionRadians),
                        this.style && (this._sourcesDirty || T) && (this._sourcesDirty = !1,
                        this.style._updateSources(this.transform)),
                        this.terrain ? (this.terrain.sourceCache.update(this.transform, this.terrain),
                        this.transform.setMinElevationForCurrentTile(this.terrain.getMinTileElevationForLngLatZoom(this.transform.center, this.transform.tileZoom)),
                        !this._elevationFreeze && this._centerClampedToGround && this.transform.setElevation(this.terrain.getElevationForLngLatZoom(this.transform.center, this.transform.tileZoom))) : (this.transform.setMinElevationForCurrentTile(0),
                        this._centerClampedToGround && this.transform.setElevation(0)),
                        this._placementDirty = this.style && this.style._updatePlacement(this.transform, this.showCollisionBoxes, m, this._crossSourceCollisions, T),
                        this.painter.render(this.style, {
                            showTileBoundaries: this.showTileBoundaries,
                            showOverdrawInspector: this._showOverdrawInspector,
                            rotating: this.isRotating(),
                            zooming: this.isZooming(),
                            moving: this.isMoving(),
                            fadeDuration: m,
                            showPadding: this.showPadding
                        }),
                        this.fire(new l.l("render")),
                        this.loaded() && !this._loaded && (this._loaded = !0,
                        l.cf.mark(l.cg.load),
                        this.fire(new l.l("load"))),
                        this.style && (this.style.hasTransitions() || v) && (this._styleDirty = !0),
                        this.style && !this._placementDirty && this.style._releaseSymbolFadeTiles();
                        const S = this._sourcesDirty || this._styleDirty || this._placementDirty;
                        return S || this._repaint ? this.triggerRepaint() : !this.isMoving() && this.loaded() && this.fire(new l.l("idle")),
                        !this._loaded || this._fullyLoaded || S || (this._fullyLoaded = !0,
                        l.cf.mark(l.cg.fullLoad)),
                        this
                    }
                    redraw() {
                        return this.style && (this._frameRequest && (this._frameRequest.abort(),
                        this._frameRequest = null),
                        this._render(0)),
                        this
                    }
                    remove() {
                        var u;
                        this._hash && this._hash.remove();
                        for (const i of this._controls)
                            i.onRemove(this);
                        this._controls = [],
                        this._frameRequest && (this._frameRequest.abort(),
                        this._frameRequest = null),
                        this._renderTaskQueue.clear(),
                        this.painter.destroy(),
                        this.handlers.destroy(),
                        delete this.handlers,
                        this.setStyle(null),
                        typeof window < "u" && removeEventListener("online", this._onWindowOnline, !1),
                        Wt.removeThrottleControl(this._imageQueueHandle),
                        (u = this._resizeObserver) === null || u === void 0 || u.disconnect();
                        const e = this.painter.context.gl.getExtension("WEBGL_lose_context");
                        e?.loseContext && e.loseContext(),
                        this._canvas.removeEventListener("webglcontextrestored", this._contextRestored, !1),
                        this._canvas.removeEventListener("webglcontextlost", this._contextLost, !1),
                        Y.remove(this._canvasContainer),
                        Y.remove(this._controlContainer),
                        this._container.removeEventListener("scroll", this._onMapScroll, !1),
                        this._container.classList.remove("maplibregl-map"),
                        l.cf.clearMetrics(),
                        this._removed = !0,
                        this.fire(new l.l("remove"))
                    }
                    triggerRepaint() {
                        this.style && !this._frameRequest && (this._frameRequest = new AbortController,
                        oe.frame(this._frameRequest, u => {
                            l.cf.frame(u),
                            this._frameRequest = null;
                            try {
                                this._render(u)
                            } catch (e) {
                                if (!l.ch(e) && !function(i) {
                                    return i.message === Uc
                                }(e))
                                    throw e
                            }
                        }
                        , () => {}
                        ))
                    }
                    get showTileBoundaries() {
                        return !!this._showTileBoundaries
                    }
                    set showTileBoundaries(u) {
                        this._showTileBoundaries !== u && (this._showTileBoundaries = u,
                        this._update())
                    }
                    get showPadding() {
                        return !!this._showPadding
                    }
                    set showPadding(u) {
                        this._showPadding !== u && (this._showPadding = u,
                        this._update())
                    }
                    get showCollisionBoxes() {
                        return !!this._showCollisionBoxes
                    }
                    set showCollisionBoxes(u) {
                        this._showCollisionBoxes !== u && (this._showCollisionBoxes = u,
                        u ? this.style._generateCollisionBoxes() : this._update())
                    }
                    get showOverdrawInspector() {
                        return !!this._showOverdrawInspector
                    }
                    set showOverdrawInspector(u) {
                        this._showOverdrawInspector !== u && (this._showOverdrawInspector = u,
                        this._update())
                    }
                    get repaint() {
                        return !!this._repaint
                    }
                    set repaint(u) {
                        this._repaint !== u && (this._repaint = u,
                        this.triggerRepaint())
                    }
                    get vertices() {
                        return !!this._vertices
                    }
                    set vertices(u) {
                        this._vertices = u,
                        this._update()
                    }
                    get version() {
                        return lu
                    }
                    getCameraTargetElevation() {
                        return this.transform.elevation
                    }
                    getProjection() {
                        return this.style.getProjection()
                    }
                    setProjection(u) {
                        return this._lazyInitEmptyStyle(),
                        this.style.setProjection(u),
                        this._update(!0)
                    }
                }
                ,
                M.MapMouseEvent = Kt,
                M.MapTouchEvent = ir,
                M.MapWheelEvent = Sl,
                M.Marker = wo,
                M.NavigationControl = class {
                    constructor(u) {
                        this._updateZoomButtons = () => {
                            const e = this._map.getZoom()
                              , i = e === this._map.getMaxZoom()
                              , o = e === this._map.getMinZoom();
                            this._zoomInButton.disabled = i,
                            this._zoomOutButton.disabled = o,
                            this._zoomInButton.setAttribute("aria-disabled", i.toString()),
                            this._zoomOutButton.setAttribute("aria-disabled", o.toString())
                        }
                        ,
                        this._rotateCompassArrow = () => {
                            this._compassIcon.style.transform = this.options.visualizePitch && this.options.visualizeRoll ? `scale(${1 / Math.pow(Math.cos(this._map.transform.pitchInRadians), .5)}) rotateZ(${-this._map.transform.roll}deg) rotateX(${this._map.transform.pitch}deg) rotateZ(${-this._map.transform.bearing}deg)` : this.options.visualizePitch ? `scale(${1 / Math.pow(Math.cos(this._map.transform.pitchInRadians), .5)}) rotateX(${this._map.transform.pitch}deg) rotateZ(${-this._map.transform.bearing}deg)` : this.options.visualizeRoll ? `rotate(${-this._map.transform.bearing - this._map.transform.roll}deg)` : `rotate(${-this._map.transform.bearing}deg)`
                        }
                        ,
                        this._setButtonTitle = (e, i) => {
                            const o = this._map._getUIString(`NavigationControl.${i}`);
                            e.title = o,
                            e.setAttribute("aria-label", o)
                        }
                        ,
                        this.options = l.e({}, fa, u),
                        this._container = Y.create("div", "maplibregl-ctrl maplibregl-ctrl-group"),
                        this._container.addEventListener("contextmenu", e => e.preventDefault()),
                        this.options.showZoom && (this._zoomInButton = this._createButton("maplibregl-ctrl-zoom-in", e => this._map.zoomIn({}, {
                            originalEvent: e
                        })),
                        Y.create("span", "maplibregl-ctrl-icon", this._zoomInButton).setAttribute("aria-hidden", "true"),
                        this._zoomOutButton = this._createButton("maplibregl-ctrl-zoom-out", e => this._map.zoomOut({}, {
                            originalEvent: e
                        })),
                        Y.create("span", "maplibregl-ctrl-icon", this._zoomOutButton).setAttribute("aria-hidden", "true")),
                        this.options.showCompass && (this._compass = this._createButton("maplibregl-ctrl-compass", e => {
                            this.options.visualizePitch ? this._map.resetNorthPitch({}, {
                                originalEvent: e
                            }) : this._map.resetNorth({}, {
                                originalEvent: e
                            })
                        }
                        ),
                        this._compassIcon = Y.create("span", "maplibregl-ctrl-icon", this._compass),
                        this._compassIcon.setAttribute("aria-hidden", "true"))
                    }
                    onAdd(u) {
                        return this._map = u,
                        this.options.showZoom && (this._setButtonTitle(this._zoomInButton, "ZoomIn"),
                        this._setButtonTitle(this._zoomOutButton, "ZoomOut"),
                        this._map.on("zoom", this._updateZoomButtons),
                        this._updateZoomButtons()),
                        this.options.showCompass && (this._setButtonTitle(this._compass, "ResetBearing"),
                        this.options.visualizePitch && this._map.on("pitch", this._rotateCompassArrow),
                        this.options.visualizeRoll && this._map.on("roll", this._rotateCompassArrow),
                        this._map.on("rotate", this._rotateCompassArrow),
                        this._rotateCompassArrow(),
                        this._handler = new Ol(this._map,this._compass,this.options.visualizePitch)),
                        this._container
                    }
                    onRemove() {
                        Y.remove(this._container),
                        this.options.showZoom && this._map.off("zoom", this._updateZoomButtons),
                        this.options.showCompass && (this.options.visualizePitch && this._map.off("pitch", this._rotateCompassArrow),
                        this.options.visualizeRoll && this._map.off("roll", this._rotateCompassArrow),
                        this._map.off("rotate", this._rotateCompassArrow),
                        this._handler.off(),
                        delete this._handler),
                        delete this._map
                    }
                    _createButton(u, e) {
                        const i = Y.create("button", u, this._container);
                        return i.type = "button",
                        i.addEventListener("click", e),
                        i
                    }
                }
                ,
                M.Popup = class extends l.E {
                    constructor(u) {
                        super(),
                        this._updateOpacity = () => {
                            this.options.locationOccludedOpacity !== void 0 && (this._container.style.opacity = this._map.transform.isLocationOccluded(this.getLngLat()) ? `${this.options.locationOccludedOpacity}` : void 0)
                        }
                        ,
                        this.remove = () => (this._content && Y.remove(this._content),
                        this._container && (Y.remove(this._container),
                        delete this._container),
                        this._closeButton && this._closeButton.removeEventListener("click", this._onClose),
                        this._map && (this._map.off("move", this._update),
                        this._map.off("move", this._onClose),
                        this._map.off("click", this._onClose),
                        this._map.off("remove", this.remove),
                        this._map.off("mousemove", this._onMouseMove),
                        this._map.off("mouseup", this._onMouseUp),
                        this._map.off("drag", this._onDrag),
                        this._map._canvasContainer.classList.remove("maplibregl-track-pointer"),
                        delete this._map,
                        this.fire(new l.l("close"))),
                        this),
                        this._onMouseUp = e => {
                            this._update(e.point)
                        }
                        ,
                        this._onMouseMove = e => {
                            this._update(e.point)
                        }
                        ,
                        this._onDrag = e => {
                            this._update(e.point)
                        }
                        ,
                        this._update = e => {
                            var i;
                            if (!this._map || !this._lngLat && !this._trackPointer || !this._content)
                                return;
                            if (!this._container) {
                                if (this._container = Y.create("div", "maplibregl-popup", this._map.getContainer()),
                                this._tip = Y.create("div", "maplibregl-popup-tip", this._container),
                                this._container.appendChild(this._content),
                                this.options.className)
                                    for (const y of this.options.className.split(" "))
                                        this._container.classList.add(y);
                                this._closeButton && this._closeButton.setAttribute("aria-label", this._map._getUIString("Popup.Close")),
                                this._trackPointer && this._container.classList.add("maplibregl-popup-track-pointer")
                            }
                            if (this.options.maxWidth && this._container.style.maxWidth !== this.options.maxWidth && (this._container.style.maxWidth = this.options.maxWidth),
                            this._lngLat = this._map.transform.renderWorldCopies && !this._trackPointer ? ma(this._lngLat, this._flatPos, this._map.transform) : (i = this._lngLat) === null || i === void 0 ? void 0 : i.wrap(),
                            this._trackPointer && !e)
                                return;
                            const o = this._flatPos = this._pos = this._trackPointer && e ? e : this._map.project(this._lngLat);
                            this._map.terrain && (this._flatPos = this._trackPointer && e ? e : this._map.transform.locationToScreenPoint(this._lngLat));
                            let a = this.options.anchor;
                            const h = xa(this.options.offset);
                            if (!a) {
                                const y = this._container.offsetWidth
                                  , v = this._container.offsetHeight;
                                let T;
                                T = o.y + h.bottom.y < v ? ["top"] : o.y > this._map.transform.height - v ? ["bottom"] : [],
                                o.x < y / 2 ? T.push("left") : o.x > this._map.transform.width - y / 2 && T.push("right"),
                                a = T.length === 0 ? "bottom" : T.join("-")
                            }
                            let m = o.add(h[a]);
                            this.options.subpixelPositioning || (m = m.round()),
                            Y.setTransform(this._container, `${ds[a]} translate(${m.x}px,${m.y}px)`),
                            ga(this._container, a, "popup"),
                            this._updateOpacity()
                        }
                        ,
                        this._onClose = () => {
                            this.remove()
                        }
                        ,
                        this.options = l.e(Object.create(ya), u)
                    }
                    addTo(u) {
                        return this._map && this.remove(),
                        this._map = u,
                        this.options.closeOnClick && this._map.on("click", this._onClose),
                        this.options.closeOnMove && this._map.on("move", this._onClose),
                        this._map.on("remove", this.remove),
                        this._update(),
                        this._focusFirstElement(),
                        this._trackPointer ? (this._map.on("mousemove", this._onMouseMove),
                        this._map.on("mouseup", this._onMouseUp),
                        this._container && this._container.classList.add("maplibregl-popup-track-pointer"),
                        this._map._canvasContainer.classList.add("maplibregl-track-pointer")) : this._map.on("move", this._update),
                        this.fire(new l.l("open")),
                        this
                    }
                    isOpen() {
                        return !!this._map
                    }
                    getLngLat() {
                        return this._lngLat
                    }
                    setLngLat(u) {
                        return this._lngLat = l.Q.convert(u),
                        this._pos = null,
                        this._flatPos = null,
                        this._trackPointer = !1,
                        this._update(),
                        this._map && (this._map.on("move", this._update),
                        this._map.off("mousemove", this._onMouseMove),
                        this._container && this._container.classList.remove("maplibregl-popup-track-pointer"),
                        this._map._canvasContainer.classList.remove("maplibregl-track-pointer")),
                        this
                    }
                    trackPointer() {
                        return this._trackPointer = !0,
                        this._pos = null,
                        this._flatPos = null,
                        this._update(),
                        this._map && (this._map.off("move", this._update),
                        this._map.on("mousemove", this._onMouseMove),
                        this._map.on("drag", this._onDrag),
                        this._container && this._container.classList.add("maplibregl-popup-track-pointer"),
                        this._map._canvasContainer.classList.add("maplibregl-track-pointer")),
                        this
                    }
                    getElement() {
                        return this._container
                    }
                    setText(u) {
                        return this.setDOMContent(document.createTextNode(u))
                    }
                    setHTML(u) {
                        const e = document.createDocumentFragment()
                          , i = document.createElement("body");
                        let o;
                        for (i.innerHTML = u; o = i.firstChild,
                        o; )
                            e.appendChild(o);
                        return this.setDOMContent(e)
                    }
                    getMaxWidth() {
                        var u;
                        return (u = this._container) === null || u === void 0 ? void 0 : u.style.maxWidth
                    }
                    setMaxWidth(u) {
                        return this.options.maxWidth = u,
                        this._update(),
                        this
                    }
                    setDOMContent(u) {
                        if (this._content)
                            for (; this._content.hasChildNodes(); )
                                this._content.firstChild && this._content.removeChild(this._content.firstChild);
                        else
                            this._content = Y.create("div", "maplibregl-popup-content", this._container);
                        return this._content.appendChild(u),
                        this._createCloseButton(),
                        this._update(),
                        this._focusFirstElement(),
                        this
                    }
                    addClassName(u) {
                        return this._container && this._container.classList.add(u),
                        this
                    }
                    removeClassName(u) {
                        return this._container && this._container.classList.remove(u),
                        this
                    }
                    setOffset(u) {
                        return this.options.offset = u,
                        this._update(),
                        this
                    }
                    toggleClassName(u) {
                        if (this._container)
                            return this._container.classList.toggle(u)
                    }
                    setSubpixelPositioning(u) {
                        this.options.subpixelPositioning = u
                    }
                    _createCloseButton() {
                        this.options.closeButton && (this._closeButton = Y.create("button", "maplibregl-popup-close-button", this._content),
                        this._closeButton.type = "button",
                        this._closeButton.innerHTML = "&#215;",
                        this._closeButton.addEventListener("click", this._onClose))
                    }
                    _focusFirstElement() {
                        if (!this.options.focusAfterOpen || !this._container)
                            return;
                        const u = this._container.querySelector(Vl);
                        u && u.focus()
                    }
                }
                ,
                M.RasterDEMTileSource = zn,
                M.RasterTileSource = Or,
                M.ScaleControl = class {
                    constructor(u) {
                        this._onMove = () => {
                            _a(this._map, this._container, this.options)
                        }
                        ,
                        this.setUnit = e => {
                            this.options.unit = e,
                            _a(this._map, this._container, this.options)
                        }
                        ,
                        this.options = Object.assign(Object.assign({}, jl), u)
                    }
                    getDefaultPosition() {
                        return "bottom-left"
                    }
                    onAdd(u) {
                        return this._map = u,
                        this._container = Y.create("div", "maplibregl-ctrl maplibregl-ctrl-scale", u.getContainer()),
                        this._map.on("move", this._onMove),
                        this._onMove(),
                        this._container
                    }
                    onRemove() {
                        Y.remove(this._container),
                        this._map.off("move", this._onMove),
                        this._map = void 0
                    }
                }
                ,
                M.ScrollZoomHandler = su,
                M.Style = lo,
                M.TerrainControl = class {
                    constructor(u) {
                        this._toggleTerrain = () => {
                            this._map.getTerrain() ? this._map.setTerrain(null) : this._map.setTerrain(this.options),
                            this._updateTerrainIcon()
                        }
                        ,
                        this._updateTerrainIcon = () => {
                            this._terrainButton.classList.remove("maplibregl-ctrl-terrain"),
                            this._terrainButton.classList.remove("maplibregl-ctrl-terrain-enabled"),
                            this._map.terrain ? (this._terrainButton.classList.add("maplibregl-ctrl-terrain-enabled"),
                            this._terrainButton.title = this._map._getUIString("TerrainControl.Disable")) : (this._terrainButton.classList.add("maplibregl-ctrl-terrain"),
                            this._terrainButton.title = this._map._getUIString("TerrainControl.Enable"))
                        }
                        ,
                        this.options = u
                    }
                    onAdd(u) {
                        return this._map = u,
                        this._container = Y.create("div", "maplibregl-ctrl maplibregl-ctrl-group"),
                        this._terrainButton = Y.create("button", "maplibregl-ctrl-terrain", this._container),
                        Y.create("span", "maplibregl-ctrl-icon", this._terrainButton).setAttribute("aria-hidden", "true"),
                        this._terrainButton.type = "button",
                        this._terrainButton.addEventListener("click", this._toggleTerrain),
                        this._updateTerrainIcon(),
                        this._map.on("terrain", this._updateTerrainIcon),
                        this._container
                    }
                    onRemove() {
                        Y.remove(this._container),
                        this._map.off("terrain", this._updateTerrainIcon),
                        this._map = void 0
                    }
                }
                ,
                M.TwoFingersTouchPitchHandler = zl,
                M.TwoFingersTouchRotateHandler = nu,
                M.TwoFingersTouchZoomHandler = ru,
                M.TwoFingersTouchZoomRotateHandler = Rl,
                M.VectorTileSource = Xn,
                M.VideoSource = Nr,
                M.addSourceType = (u, e) => l._(void 0, void 0, void 0, function*() {
                    if (Jn(u))
                        throw new Error(`A source type called "${u}" already exists.`);
                    ( (i, o) => {
                        Kn[i] = o
                    }
                    )(u, e)
                }),
                M.clearPrewarmedResources = function() {
                    const u = _i;
                    u && (u.isPreloaded() && u.numActive() === 1 ? (u.release(Br),
                    _i = null) : console.warn("Could not clear WebWorkers since there are active Map instances that still reference it. The pre-warmed WebWorker pool can only be cleared when all map instances have been removed with map.remove()"))
                }
                ,
                M.createTileMesh = oo,
                M.getMaxParallelImageRequests = function() {
                    return l.a.MAX_PARALLEL_IMAGE_REQUESTS
                }
                ,
                M.getRTLTextPluginStatus = function() {
                    return gn().getRTLTextPluginStatus()
                }
                ,
                M.getVersion = function() {
                    return va
                }
                ,
                M.getWorkerCount = function() {
                    return gi.workerCount
                }
                ,
                M.getWorkerUrl = function() {
                    return l.a.WORKER_URL
                }
                ,
                M.importScriptInWorkers = function(u) {
                    return en().broadcast("IS", u)
                }
                ,
                M.prewarm = function() {
                    Yi().acquire(Br)
                }
                ,
                M.setMaxParallelImageRequests = function(u) {
                    l.a.MAX_PARALLEL_IMAGE_REQUESTS = u
                }
                ,
                M.setRTLTextPlugin = function(u, e) {
                    return gn().setRTLTextPlugin(u, e)
                }
                ,
                M.setWorkerCount = function(u) {
                    gi.workerCount = u
                }
                ,
                M.setWorkerUrl = function(u) {
                    l.a.WORKER_URL = u
                }
            });
            var N = w;
            return N
        })
    }(Ru)),
    Ru.exports
}
var vs = M_();
const C_ = Va(vs);
let mr = {
    waterDeep: "rgb(110, 160, 245)",
    regionBorders: "rgb(107,  42,  33)",
    regionLabels: "rgb( 17,  42,  97)",
    regionLabelsOut: "rgb(213, 195, 138)",
    nationBorders: "rgb(170, 170, 170)",
    white: "rgb(255, 255, 255)",
    black: "rgb( 10,  10,  10)"
};
const Ri = window.devicePixelRatio === 1 ? 1.5 : 1
  , gr = {
    filterMinzoom: ["get", "filterMinzoom"],
    filterMaxzoom: ["get", "filterMaxzoom"]
};
function Sf(f, _) {
    return ["interpolate", ["linear"], ["zoom"], f, 0, f + .5, 1, _ - .5, 1, _, 0]
}
function Xr(f, _) {
    return Object.assign({
        id: _.type + "_" + f,
        source: "golarion",
        "source-layer": f,
        filter: ["all", ["any", ["!", ["has", "filterMinzoom"]], [">=", ["zoom"], gr.filterMinzoom]], ["any", ["!", ["has", "filterMaxzoom"]], ["<=", ["zoom"], gr.filterMaxzoom]]]
    }, _)
}
let P_ = [{
    id: "background",
    type: "background",
    paint: {
        "background-color": mr.waterDeep
    }
}, Xr("geometry", {
    type: "fill",
    paint: {
        "fill-color": ["get", "color"],
        "fill-antialias": !1
    }
}), Xr("province-borders", {
    type: "line",
    minzoom: 3,
    paint: {
        "line-color": mr.nationBorders,
        "line-width": 1,
        "line-opacity": Sf(3, 99)
    },
    layout: {
        "line-cap": "round"
    }
}), Xr("nation-borders", {
    type: "line",
    paint: {
        "line-color": mr.nationBorders,
        "line-width": ["interpolate", ["exponential", 2], ["zoom"], 3, .375, 6, 3]
    },
    layout: {
        "line-cap": "round"
    }
}), Xr("subregion-borders", {
    type: "line",
    maxzoom: 6,
    paint: {
        "line-color": mr.nationBorders,
        "line-width": ["interpolate", ["exponential", 2], ["zoom"], 0, .375, 3, 3]
    },
    layout: {
        "line-cap": "round"
    }
}), Xr("region-borders", {
    type: "line",
    minzoom: 2,
    maxzoom: 4,
    paint: {
        "line-color": mr.regionBorders,
        "line-width": 2,
        "line-opacity": Sf(2, 4)
    },
    layout: {
        "line-cap": "round"
    }
}), Xr("line-labels", {
    type: "symbol",
    layout: {
        "symbol-placement": "line",
        "text-max-angle": 20,
        "text-field": ["get", "label"],
        "text-font": ["NotoSans-Medium"],
        "symbol-spacing": 300,
        "text-size": ["interpolate", ["linear"], ["zoom"], 5, 2, 10, 16]
    },
    paint: {
        "text-color": ["get", "color"],
        "text-halo-color": ["get", "halo"],
        "text-halo-width": ["interpolate", ["linear"], ["zoom"], 5, .125 * Ri, 10, 1 * Ri]
    }
}), Xr("locations", {
    id: "location-icons",
    type: "symbol",
    layout: {
        "icon-image": ["get", "icon"],
        "icon-pitch-alignment": "map",
        "icon-overlap": "always",
        "icon-ignore-placement": !0,
        "icon-size": ["interpolate", ["exponential", 2], ["zoom"], 0, ["^", 2, ["-", -3, gr.filterMinzoom]], 1, ["^", 2, ["-", -2, gr.filterMinzoom]], 2, ["min", 1, ["^", 2, ["-", -1, gr.filterMinzoom]]], 3, ["min", 1, ["^", 2, ["-", 0, gr.filterMinzoom]]], 4, ["min", 1, ["^", 2, ["-", 1, gr.filterMinzoom]]], 5, ["min", 1, ["^", 2, ["-", 2, gr.filterMinzoom]]], 6, ["min", 1, ["^", 2, ["-", 3, gr.filterMinzoom]]], 7, ["min", 1, ["^", 2, ["-", 4, gr.filterMinzoom]]], 8, ["min", 1, ["^", 2, ["-", 5, gr.filterMinzoom]]], 9, ["min", 1, ["^", 2, ["-", 6, gr.filterMinzoom]]], 10, ["min", 1, ["^", 2, ["-", 7, gr.filterMinzoom]]]]
    },
    paint: {}
}), Xr("labels", {
    type: "symbol",
    layout: {
        "text-field": ["get", "label"],
        "text-rotate": ["get", "angle"],
        "text-rotation-alignment": "map",
        "text-font": ["NotoSans-Medium"],
        "text-size": 16 * Ri
    },
    paint: {
        "text-color": ["get", "color"],
        "text-halo-color": ["get", "halo"],
        "text-halo-width": 1.5 * Ri
    }
}), Xr("locations", {
    id: "location-labels",
    type: "symbol",
    filter: ["all", [">", ["zoom"], ["+", gr.filterMinzoom, 3]], ["any", ["!", ["has", "filterMaxzoom"]], ["<=", ["zoom"], gr.filterMaxzoom]]],
    layout: {
        "text-field": ["get", "label"],
        "text-font": ["NotoSans-Medium"],
        "text-size": 14 * Ri,
        "text-variable-anchor": ["left", "right"],
        "text-radial-offset": .5,
        "text-rotation-alignment": "map"
    },
    paint: {
        "text-color": mr.white,
        "text-halo-color": mr.black,
        "text-halo-width": .8 * Ri
    }
}), Xr("province-labels", {
    minzoom: 4,
    maxzoom: 7,
    type: "symbol",
    layout: {
        "text-field": ["get", "label"],
        "text-font": ["NotoSans-Medium"],
        "text-size": ["interpolate", ["linear"], ["zoom"], 5, 5 * Ri, 7, 20 * Ri],
        "text-rotation-alignment": "map",
        "text-variable-anchor": ["center", "top", "bottom"],
        "symbol-z-order": "source"
    },
    paint: {
        "text-color": mr.white,
        "text-halo-color": mr.regionLabels,
        "text-halo-width": ["interpolate", ["linear"], ["zoom"], 5, .375 * Ri, 7, 1.5 * Ri]
    }
}), Xr("nation-labels", {
    minzoom: 3,
    maxzoom: 6,
    type: "symbol",
    filter: ["any", ["!", ["get", "inSubregion"]], [">", ["zoom"], 4]],
    layout: {
        "text-field": ["get", "label"],
        "text-font": ["NotoSans-Medium"],
        "text-size": ["interpolate", ["linear"], ["zoom"], 4, 10 * Ri, 5, 25 * Ri],
        "text-rotation-alignment": "map",
        "text-variable-anchor": ["center", "top", "bottom"],
        "symbol-z-order": "source"
    },
    paint: {
        "text-color": mr.white,
        "text-halo-color": mr.regionLabels,
        "text-halo-width": ["interpolate", ["linear"], ["zoom"], 4, .75 * Ri, 5, 1.875 * Ri]
    }
}), Xr("subregion-labels", {
    minzoom: 3,
    maxzoom: 5,
    type: "symbol",
    layout: {
        "text-field": ["get", "label"],
        "text-font": ["NotoSans-Medium"],
        "text-size": ["interpolate", ["linear"], ["zoom"], 4, 10 * Ri, 5, 25 * Ri],
        "text-rotation-alignment": "map",
        "text-variable-anchor": ["center", "top", "bottom"],
        "symbol-z-order": "source"
    },
    paint: {
        "text-color": mr.white,
        "text-halo-color": mr.regionLabels,
        "text-halo-width": ["interpolate", ["linear"], ["zoom"], 4, .75 * Ri, 5, 1.875 * Ri]
    }
}), Xr("region-labels", {
    minzoom: 1,
    maxzoom: 3,
    type: "symbol",
    layout: {
        "text-field": ["get", "label"],
        "text-font": ["NotoSans-Medium"],
        "text-size": 20 * Ri,
        "text-rotation-alignment": "map",
        "text-variable-anchor": ["center", "top", "bottom"],
        "symbol-z-order": "source"
    },
    paint: {
        "text-color": mr.regionLabels,
        "text-halo-color": mr.regionLabelsOut,
        "text-halo-width": 1.5 * Ri
    }
})];
function S_(f) {
    let _ = P_;
    return f.get("hideLabels") === "true" && (_ = _.filter(w => !w.id.includes("label"))),
    f.get("hideLocations") === "true" && (_ = _.filter(w => !w.id.includes("location"))),
    f.get("hideBorders") === "true" && (_ = _.filter(w => !w.id.includes("border"))),
    _
}
const xd = function(f, _) {
    const w = {
        drag: [],
        click: [],
        mousemove: [],
        mousedown: [],
        mouseup: [],
        mouseout: [],
        keydown: [],
        keyup: [],
        touchstart: [],
        touchmove: [],
        touchend: [],
        tap: []
    }
      , I = {
        on(N, M, l) {
            if (w[N] === void 0)
                throw new Error(`Invalid event type: ${N}`);
            w[N].push({
                selector: M,
                fn: l
            })
        },
        render(N) {
            _.store.featureChanged(N)
        }
    }
      , z = function(N, M) {
        const l = w[N];
        let ce = l.length;
        for (; ce--; ) {
            const de = l[ce];
            if (de.selector(M)) {
                de.fn.call(I, M) || _.store.render(),
                _.ui.updateMapClasses();
                break
            }
        }
    };
    return f.start.call(I),
    {
        render: f.render,
        stop() {
            f.stop && f.stop()
        },
        trash() {
            f.trash && (f.trash(),
            _.store.render())
        },
        combineFeatures() {
            f.combineFeatures && f.combineFeatures()
        },
        uncombineFeatures() {
            f.uncombineFeatures && f.uncombineFeatures()
        },
        drag(N) {
            z("drag", N)
        },
        click(N) {
            z("click", N)
        },
        mousemove(N) {
            z("mousemove", N)
        },
        mousedown(N) {
            z("mousedown", N)
        },
        mouseup(N) {
            z("mouseup", N)
        },
        mouseout(N) {
            z("mouseout", N)
        },
        keydown(N) {
            z("keydown", N)
        },
        keyup(N) {
            z("keyup", N)
        },
        touchstart(N) {
            z("touchstart", N)
        },
        touchmove(N) {
            z("touchmove", N)
        },
        touchend(N) {
            z("touchend", N)
        },
        tap(N) {
            z("tap", N)
        }
    }
};
var zu = {}, lc = {}, If;
function I_() {
    return If || (If = 1,
    lc.RADIUS = 6378137,
    lc.FLATTENING = 1 / 298.257223563,
    lc.POLAR_RADIUS = 63567523142e-4),
    lc
}
var Ef;
function E_() {
    if (Ef)
        return zu;
    Ef = 1;
    var f = I_();
    zu.geometry = _,
    zu.ring = I;
    function _(N) {
        var M = 0, l;
        switch (N.type) {
        case "Polygon":
            return w(N.coordinates);
        case "MultiPolygon":
            for (l = 0; l < N.coordinates.length; l++)
                M += w(N.coordinates[l]);
            return M;
        case "Point":
        case "MultiPoint":
        case "LineString":
        case "MultiLineString":
            return 0;
        case "GeometryCollection":
            for (l = 0; l < N.geometries.length; l++)
                M += _(N.geometries[l]);
            return M
        }
    }
    function w(N) {
        var M = 0;
        if (N && N.length > 0) {
            M += Math.abs(I(N[0]));
            for (var l = 1; l < N.length; l++)
                M -= Math.abs(I(N[l]))
        }
        return M
    }
    function I(N) {
        var M, l, ce, de, ge, ze, oe, Y = 0, Te = N.length;
        if (Te > 2) {
            for (oe = 0; oe < Te; oe++)
                oe === Te - 2 ? (de = Te - 2,
                ge = Te - 1,
                ze = 0) : oe === Te - 1 ? (de = Te - 1,
                ge = 0,
                ze = 1) : (de = oe,
                ge = oe + 1,
                ze = oe + 2),
                M = N[de],
                l = N[ge],
                ce = N[ze],
                Y += (z(ce[0]) - z(M[0])) * Math.sin(z(l[1]));
            Y = Y * f.RADIUS * f.RADIUS / 2
        }
        return Y
    }
    function z(N) {
        return N * Math.PI / 180
    }
    return zu
}
var A_ = E_();
const z_ = Va(A_)
  , Dr = {
    CANVAS: "mapboxgl-canvas",
    CONTROL_BASE: "mapboxgl-ctrl",
    CONTROL_PREFIX: "mapboxgl-ctrl-",
    CONTROL_BUTTON: "mapbox-gl-draw_ctrl-draw-btn",
    CONTROL_BUTTON_LINE: "mapbox-gl-draw_line",
    CONTROL_BUTTON_POLYGON: "mapbox-gl-draw_polygon",
    CONTROL_BUTTON_POINT: "mapbox-gl-draw_point",
    CONTROL_BUTTON_TRASH: "mapbox-gl-draw_trash",
    CONTROL_BUTTON_COMBINE_FEATURES: "mapbox-gl-draw_combine",
    CONTROL_BUTTON_UNCOMBINE_FEATURES: "mapbox-gl-draw_uncombine",
    CONTROL_GROUP: "mapboxgl-ctrl-group",
    ATTRIBUTION: "mapboxgl-ctrl-attrib",
    ACTIVE_BUTTON: "active",
    BOX_SELECT: "mapbox-gl-draw_boxselect"
}
  , hn = {
    HOT: "mapbox-gl-draw-hot",
    COLD: "mapbox-gl-draw-cold"
}
  , ni = {
    ADD: "add",
    MOVE: "move",
    DRAG: "drag",
    POINTER: "pointer",
    NONE: "none"
}
  , Rr = {
    POLYGON: "polygon",
    LINE: "line_string",
    POINT: "point"
}
  , rt = {
    FEATURE: "Feature",
    POLYGON: "Polygon",
    LINE_STRING: "LineString",
    POINT: "Point",
    FEATURE_COLLECTION: "FeatureCollection",
    MULTI_PREFIX: "Multi",
    MULTI_POINT: "MultiPoint",
    MULTI_LINE_STRING: "MultiLineString",
    MULTI_POLYGON: "MultiPolygon"
}
  , Tt = {
    DRAW_LINE_STRING: "draw_line_string",
    DRAW_POLYGON: "draw_polygon",
    DRAW_POINT: "draw_point",
    SIMPLE_SELECT: "simple_select",
    DIRECT_SELECT: "direct_select"
}
  , xr = {
    CREATE: "draw.create",
    DELETE: "draw.delete",
    UPDATE: "draw.update",
    SELECTION_CHANGE: "draw.selectionchange",
    MODE_CHANGE: "draw.modechange",
    ACTIONABLE: "draw.actionable",
    RENDER: "draw.render",
    COMBINE_FEATURES: "draw.combine",
    UNCOMBINE_FEATURES: "draw.uncombine"
}
  , mc = {
    MOVE: "move",
    CHANGE_PROPERTIES: "change_properties",
    CHANGE_COORDINATES: "change_coordinates"
}
  , sr = {
    FEATURE: "feature",
    MIDPOINT: "midpoint",
    VERTEX: "vertex"
}
  , Hi = {
    ACTIVE: "true",
    INACTIVE: "false"
}
  , Wf = ["scrollZoom", "boxZoom", "dragRotate", "dragPan", "keyboard", "doubleClickZoom", "touchZoomRotate"]
  , k_ = -90
  , vd = -85
  , L_ = 90
  , bd = 85
  , D_ = -270
  , R_ = 270
  , Xf = Object.freeze(Object.defineProperty({
    __proto__: null,
    LAT_MAX: L_,
    LAT_MIN: k_,
    LAT_RENDERED_MAX: bd,
    LAT_RENDERED_MIN: vd,
    LNG_MAX: R_,
    LNG_MIN: D_,
    activeStates: Hi,
    classes: Dr,
    cursors: ni,
    events: xr,
    geojsonTypes: rt,
    interactions: Wf,
    meta: sr,
    modes: Tt,
    sources: hn,
    types: Rr,
    updateActions: mc
}, Symbol.toStringTag, {
    value: "Module"
}))
  , Af = {
    Point: 0,
    LineString: 1,
    MultiLineString: 1,
    Polygon: 2
};
function F_(f, _) {
    const w = Af[f.geometry.type] - Af[_.geometry.type];
    return w === 0 && f.geometry.type === rt.POLYGON ? f.area - _.area : w
}
function Kf(f) {
    return f.map(_ => (_.geometry.type === rt.POLYGON && (_.area = z_.geometry({
        type: rt.FEATURE,
        property: {},
        geometry: _.geometry
    })),
    _)).sort(F_).map(_ => (delete _.area,
    _))
}
function Jf(f, _=0) {
    return [[f.point.x - _, f.point.y - _], [f.point.x + _, f.point.y + _]]
}
function pn(f) {
    if (this._items = {},
    this._nums = {},
    this._length = f ? f.length : 0,
    !!f)
        for (let _ = 0, w = f.length; _ < w; _++)
            this.add(f[_]),
            f[_] !== void 0 && (typeof f[_] == "string" ? this._items[f[_]] = _ : this._nums[f[_]] = _)
}
pn.prototype.add = function(f) {
    return this.has(f) ? this : (this._length++,
    typeof f == "string" ? this._items[f] = this._length : this._nums[f] = this._length,
    this)
}
;
pn.prototype.delete = function(f) {
    return this.has(f) === !1 ? this : (this._length--,
    delete this._items[f],
    delete this._nums[f],
    this)
}
;
pn.prototype.has = function(f) {
    return typeof f != "string" && typeof f != "number" ? !1 : this._items[f] !== void 0 || this._nums[f] !== void 0
}
;
pn.prototype.values = function() {
    const f = [];
    return Object.keys(this._items).forEach(_ => {
        f.push({
            k: _,
            v: this._items[_]
        })
    }
    ),
    Object.keys(this._nums).forEach(_ => {
        f.push({
            k: JSON.parse(_),
            v: this._nums[_]
        })
    }
    ),
    f.sort( (_, w) => _.v - w.v).map(_ => _.k)
}
;
pn.prototype.clear = function() {
    return this._length = 0,
    this._items = {},
    this._nums = {},
    this
}
;
const B_ = [sr.FEATURE, sr.MIDPOINT, sr.VERTEX]
  , Na = {
    click: O_,
    touch: N_
};
function O_(f, _, w) {
    return Yf(f, _, w, w.options.clickBuffer)
}
function N_(f, _, w) {
    return Yf(f, _, w, w.options.touchBuffer)
}
function Yf(f, _, w, I) {
    if (w.map === null)
        return [];
    const z = f ? Jf(f, I) : _
      , N = {};
    w.options.styles && (N.layers = w.options.styles.map(de => de.id).filter(de => w.map.getLayer(de) != null));
    const M = w.map.queryRenderedFeatures(z, N).filter(de => B_.indexOf(de.properties.meta) !== -1)
      , l = new pn
      , ce = [];
    return M.forEach(de => {
        const ge = de.properties.id;
        l.has(ge) || (l.add(ge),
        ce.push(de))
    }
    ),
    Kf(ce)
}
function Fu(f, _) {
    const w = Na.click(f, null, _)
      , I = {
        mouse: ni.NONE
    };
    return w[0] && (I.mouse = w[0].properties.active === Hi.ACTIVE ? ni.MOVE : ni.POINTER,
    I.feature = w[0].properties.meta),
    _.events.currentModeName().indexOf("draw") !== -1 && (I.mouse = ni.ADD),
    _.ui.queueMapClasses(I),
    _.ui.updateMapClasses(),
    w[0]
}
function Ed(f, _) {
    const w = f.x - _.x
      , I = f.y - _.y;
    return Math.sqrt(w * w + I * I)
}
const j_ = 4
  , V_ = 12
  , U_ = 500;
function wd(f, _, w={}) {
    const I = w.fineTolerance != null ? w.fineTolerance : j_
      , z = w.grossTolerance != null ? w.grossTolerance : V_
      , N = w.interval != null ? w.interval : U_;
    f.point = f.point || _.point,
    f.time = f.time || _.time;
    const M = Ed(f.point, _.point);
    return M < I || M < z && _.time - f.time < N
}
const Z_ = 25
  , G_ = 250;
function Td(f, _, w={}) {
    const I = w.tolerance != null ? w.tolerance : Z_
      , z = w.interval != null ? w.interval : G_;
    return f.point = f.point || _.point,
    f.time = f.time || _.time,
    Ed(f.point, _.point) < I && _.time - f.time < z
}
let $_ = (f, _=21) => (w=_) => {
    let I = ""
      , z = w | 0;
    for (; z--; )
        I += f[Math.random() * f.length | 0];
    return I
}
;
const q_ = $_("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz", 32);
function Ad() {
    return q_()
}
const br = function(f, _) {
    this.ctx = f,
    this.properties = _.properties || {},
    this.coordinates = _.geometry.coordinates,
    this.id = _.id || Ad(),
    this.type = _.geometry.type
};
br.prototype.changed = function() {
    this.ctx.store.featureChanged(this.id)
}
;
br.prototype.incomingCoords = function(f) {
    this.setCoordinates(f)
}
;
br.prototype.setCoordinates = function(f) {
    this.coordinates = f,
    this.changed()
}
;
br.prototype.getCoordinates = function() {
    return JSON.parse(JSON.stringify(this.coordinates))
}
;
br.prototype.setProperty = function(f, _) {
    this.properties[f] = _
}
;
br.prototype.toGeoJSON = function() {
    return JSON.parse(JSON.stringify({
        id: this.id,
        type: rt.FEATURE,
        properties: this.properties,
        geometry: {
            coordinates: this.getCoordinates(),
            type: this.type
        }
    }))
}
;
br.prototype.internal = function(f) {
    const _ = {
        id: this.id,
        meta: sr.FEATURE,
        "meta:type": this.type,
        active: Hi.INACTIVE,
        mode: f
    };
    if (this.ctx.options.userProperties)
        for (const w in this.properties)
            _[`user_${w}`] = this.properties[w];
    return {
        type: rt.FEATURE,
        properties: _,
        geometry: {
            coordinates: this.getCoordinates(),
            type: this.type
        }
    }
}
;
const Ys = function(f, _) {
    br.call(this, f, _)
};
Ys.prototype = Object.create(br.prototype);
Ys.prototype.isValid = function() {
    return typeof this.coordinates[0] == "number" && typeof this.coordinates[1] == "number"
}
;
Ys.prototype.updateCoordinate = function(f, _, w) {
    arguments.length === 3 ? this.coordinates = [_, w] : this.coordinates = [f, _],
    this.changed()
}
;
Ys.prototype.getCoordinate = function() {
    return this.getCoordinates()
}
;
const qn = function(f, _) {
    br.call(this, f, _)
};
qn.prototype = Object.create(br.prototype);
qn.prototype.isValid = function() {
    return this.coordinates.length > 1
}
;
qn.prototype.addCoordinate = function(f, _, w) {
    this.changed();
    const I = parseInt(f, 10);
    this.coordinates.splice(I, 0, [_, w])
}
;
qn.prototype.getCoordinate = function(f) {
    const _ = parseInt(f, 10);
    return JSON.parse(JSON.stringify(this.coordinates[_]))
}
;
qn.prototype.removeCoordinate = function(f) {
    this.changed(),
    this.coordinates.splice(parseInt(f, 10), 1)
}
;
qn.prototype.updateCoordinate = function(f, _, w) {
    const I = parseInt(f, 10);
    this.coordinates[I] = [_, w],
    this.changed()
}
;
const Qr = function(f, _) {
    br.call(this, f, _),
    this.coordinates = this.coordinates.map(w => w.slice(0, -1))
};
Qr.prototype = Object.create(br.prototype);
Qr.prototype.isValid = function() {
    return this.coordinates.length === 0 ? !1 : this.coordinates.every(f => f.length > 2)
}
;
Qr.prototype.incomingCoords = function(f) {
    this.coordinates = f.map(_ => _.slice(0, -1)),
    this.changed()
}
;
Qr.prototype.setCoordinates = function(f) {
    this.coordinates = f,
    this.changed()
}
;
Qr.prototype.addCoordinate = function(f, _, w) {
    this.changed();
    const I = f.split(".").map(N => parseInt(N, 10));
    this.coordinates[I[0]].splice(I[1], 0, [_, w])
}
;
Qr.prototype.removeCoordinate = function(f) {
    this.changed();
    const _ = f.split(".").map(I => parseInt(I, 10))
      , w = this.coordinates[_[0]];
    w && (w.splice(_[1], 1),
    w.length < 3 && this.coordinates.splice(_[0], 1))
}
;
Qr.prototype.getCoordinate = function(f) {
    const _ = f.split(".").map(I => parseInt(I, 10))
      , w = this.coordinates[_[0]];
    return JSON.parse(JSON.stringify(w[_[1]]))
}
;
Qr.prototype.getCoordinates = function() {
    return this.coordinates.map(f => f.concat([f[0]]))
}
;
Qr.prototype.updateCoordinate = function(f, _, w) {
    this.changed();
    const I = f.split(".")
      , z = parseInt(I[0], 10)
      , N = parseInt(I[1], 10);
    this.coordinates[z] === void 0 && (this.coordinates[z] = []),
    this.coordinates[z][N] = [_, w]
}
;
const H_ = {
    MultiPoint: Ys,
    MultiLineString: qn,
    MultiPolygon: Qr
}
  , Zu = (f, _, w, I, z) => {
    const N = w.split(".")
      , M = parseInt(N[0], 10)
      , l = N[1] ? N.slice(1).join(".") : null;
    return f[M][_](l, I, z)
}
  , yr = function(f, _) {
    if (br.call(this, f, _),
    delete this.coordinates,
    this.model = H_[_.geometry.type],
    this.model === void 0)
        throw new TypeError(`${_.geometry.type} is not a valid type`);
    this.features = this._coordinatesToFeatures(_.geometry.coordinates)
};
yr.prototype = Object.create(br.prototype);
yr.prototype._coordinatesToFeatures = function(f) {
    const _ = this.model.bind(this);
    return f.map(w => new _(this.ctx,{
        id: Ad(),
        type: rt.FEATURE,
        properties: {},
        geometry: {
            coordinates: w,
            type: this.type.replace("Multi", "")
        }
    }))
}
;
yr.prototype.isValid = function() {
    return this.features.every(f => f.isValid())
}
;
yr.prototype.setCoordinates = function(f) {
    this.features = this._coordinatesToFeatures(f),
    this.changed()
}
;
yr.prototype.getCoordinate = function(f) {
    return Zu(this.features, "getCoordinate", f)
}
;
yr.prototype.getCoordinates = function() {
    return JSON.parse(JSON.stringify(this.features.map(f => f.type === rt.POLYGON ? f.getCoordinates() : f.coordinates)))
}
;
yr.prototype.updateCoordinate = function(f, _, w) {
    Zu(this.features, "updateCoordinate", f, _, w),
    this.changed()
}
;
yr.prototype.addCoordinate = function(f, _, w) {
    Zu(this.features, "addCoordinate", f, _, w),
    this.changed()
}
;
yr.prototype.removeCoordinate = function(f) {
    Zu(this.features, "removeCoordinate", f),
    this.changed()
}
;
yr.prototype.getFeatures = function() {
    return this.features
}
;
function dt(f) {
    this.map = f.map,
    this.drawConfig = JSON.parse(JSON.stringify(f.options || {})),
    this._ctx = f
}
dt.prototype.setSelected = function(f) {
    return this._ctx.store.setSelected(f)
}
;
dt.prototype.setSelectedCoordinates = function(f) {
    this._ctx.store.setSelectedCoordinates(f),
    f.reduce( (_, w) => (_[w.feature_id] === void 0 && (_[w.feature_id] = !0,
    this._ctx.store.get(w.feature_id).changed()),
    _), {})
}
;
dt.prototype.getSelected = function() {
    return this._ctx.store.getSelected()
}
;
dt.prototype.getSelectedIds = function() {
    return this._ctx.store.getSelectedIds()
}
;
dt.prototype.isSelected = function(f) {
    return this._ctx.store.isSelected(f)
}
;
dt.prototype.getFeature = function(f) {
    return this._ctx.store.get(f)
}
;
dt.prototype.select = function(f) {
    return this._ctx.store.select(f)
}
;
dt.prototype.deselect = function(f) {
    return this._ctx.store.deselect(f)
}
;
dt.prototype.deleteFeature = function(f, _={}) {
    return this._ctx.store.delete(f, _)
}
;
dt.prototype.addFeature = function(f, _={}) {
    return this._ctx.store.add(f, _)
}
;
dt.prototype.clearSelectedFeatures = function() {
    return this._ctx.store.clearSelected()
}
;
dt.prototype.clearSelectedCoordinates = function() {
    return this._ctx.store.clearSelectedCoordinates()
}
;
dt.prototype.setActionableState = function(f={}) {
    const _ = {
        trash: f.trash || !1,
        combineFeatures: f.combineFeatures || !1,
        uncombineFeatures: f.uncombineFeatures || !1
    };
    return this._ctx.events.actionable(_)
}
;
dt.prototype.changeMode = function(f, _={}, w={}) {
    return this._ctx.events.changeMode(f, _, w)
}
;
dt.prototype.fire = function(f, _) {
    return this._ctx.events.fire(f, _)
}
;
dt.prototype.updateUIClasses = function(f) {
    return this._ctx.ui.queueMapClasses(f)
}
;
dt.prototype.activateUIButton = function(f) {
    return this._ctx.ui.setActiveButton(f)
}
;
dt.prototype.featuresAt = function(f, _, w="click") {
    if (w !== "click" && w !== "touch")
        throw new Error("invalid buffer type");
    return Na[w](f, _, this._ctx)
}
;
dt.prototype.newFeature = function(f) {
    const _ = f.geometry.type;
    return _ === rt.POINT ? new Ys(this._ctx,f) : _ === rt.LINE_STRING ? new qn(this._ctx,f) : _ === rt.POLYGON ? new Qr(this._ctx,f) : new yr(this._ctx,f)
}
;
dt.prototype.isInstanceOf = function(f, _) {
    if (f === rt.POINT)
        return _ instanceof Ys;
    if (f === rt.LINE_STRING)
        return _ instanceof qn;
    if (f === rt.POLYGON)
        return _ instanceof Qr;
    if (f === "MultiFeature")
        return _ instanceof yr;
    throw new Error(`Unknown feature class: ${f}`)
}
;
dt.prototype.doRender = function(f) {
    return this._ctx.store.featureChanged(f)
}
;
dt.prototype.onSetup = function() {}
;
dt.prototype.onDrag = function() {}
;
dt.prototype.onClick = function() {}
;
dt.prototype.onMouseMove = function() {}
;
dt.prototype.onMouseDown = function() {}
;
dt.prototype.onMouseUp = function() {}
;
dt.prototype.onMouseOut = function() {}
;
dt.prototype.onKeyUp = function() {}
;
dt.prototype.onKeyDown = function() {}
;
dt.prototype.onTouchStart = function() {}
;
dt.prototype.onTouchMove = function() {}
;
dt.prototype.onTouchEnd = function() {}
;
dt.prototype.onTap = function() {}
;
dt.prototype.onStop = function() {}
;
dt.prototype.onTrash = function() {}
;
dt.prototype.onCombineFeature = function() {}
;
dt.prototype.onUncombineFeature = function() {}
;
dt.prototype.toDisplayFeatures = function() {
    throw new Error("You must overwrite toDisplayFeatures")
}
;
const Qf = {
    drag: "onDrag",
    click: "onClick",
    mousemove: "onMouseMove",
    mousedown: "onMouseDown",
    mouseup: "onMouseUp",
    mouseout: "onMouseOut",
    keyup: "onKeyUp",
    keydown: "onKeyDown",
    touchstart: "onTouchStart",
    touchmove: "onTouchMove",
    touchend: "onTouchEnd",
    tap: "onTap"
}
  , W_ = Object.keys(Qf);
function X_(f) {
    const _ = Object.keys(f);
    return function(w, I={}) {
        let z = {};
        const N = _.reduce( (l, ce) => (l[ce] = f[ce],
        l), new dt(w));
        function M(l) {
            return ce => N[l](z, ce)
        }
        return {
            start() {
                z = N.onSetup(I),
                W_.forEach(l => {
                    const ce = Qf[l];
                    let de = () => !1;
                    f[ce] && (de = () => !0),
                    this.on(l, de, M(ce))
                }
                )
            },
            stop() {
                N.onStop(z)
            },
            trash() {
                N.onTrash(z)
            },
            combineFeatures() {
                N.onCombineFeatures(z)
            },
            uncombineFeatures() {
                N.onUncombineFeatures(z)
            },
            render(l, ce) {
                N.toDisplayFeatures(z, l, ce)
            }
        }
    }
}
function K_(f) {
    const _ = Object.keys(f.options.modes).reduce( (oe, Y) => (oe[Y] = X_(f.options.modes[Y]),
    oe), {});
    let w = {}
      , I = {};
    const z = {};
    let N = null
      , M = null;
    z.drag = function(oe, Y) {
        Y({
            point: oe.point,
            time: new Date().getTime()
        }) ? (f.ui.queueMapClasses({
            mouse: ni.DRAG
        }),
        M.drag(oe)) : oe.originalEvent.stopPropagation()
    }
    ,
    z.mousedrag = function(oe) {
        z.drag(oe, Y => !wd(w, Y))
    }
    ,
    z.touchdrag = function(oe) {
        z.drag(oe, Y => !Td(I, Y))
    }
    ,
    z.mousemove = function(oe) {
        if ((oe.originalEvent.buttons !== void 0 ? oe.originalEvent.buttons : oe.originalEvent.which) === 1)
            return z.mousedrag(oe);
        const Te = Fu(oe, f);
        oe.featureTarget = Te,
        M.mousemove(oe)
    }
    ,
    z.mousedown = function(oe) {
        w = {
            time: new Date().getTime(),
            point: oe.point
        };
        const Y = Fu(oe, f);
        oe.featureTarget = Y,
        M.mousedown(oe)
    }
    ,
    z.mouseup = function(oe) {
        const Y = Fu(oe, f);
        oe.featureTarget = Y,
        wd(w, {
            point: oe.point,
            time: new Date().getTime()
        }) ? M.click(oe) : M.mouseup(oe)
    }
    ,
    z.mouseout = function(oe) {
        M.mouseout(oe)
    }
    ,
    z.touchstart = function(oe) {
        if (!f.options.touchEnabled)
            return;
        I = {
            time: new Date().getTime(),
            point: oe.point
        };
        const Y = Na.touch(oe, null, f)[0];
        oe.featureTarget = Y,
        M.touchstart(oe)
    }
    ,
    z.touchmove = function(oe) {
        if (f.options.touchEnabled)
            return M.touchmove(oe),
            z.touchdrag(oe)
    }
    ,
    z.touchend = function(oe) {
        if (oe.originalEvent.preventDefault(),
        !f.options.touchEnabled)
            return;
        const Y = Na.touch(oe, null, f)[0];
        oe.featureTarget = Y,
        Td(I, {
            time: new Date().getTime(),
            point: oe.point
        }) ? M.tap(oe) : M.touchend(oe)
    }
    ;
    const l = oe => !(oe === 8 || oe === 46 || oe >= 48 && oe <= 57);
    z.keydown = function(oe) {
        (oe.srcElement || oe.target).classList.contains(Dr.CANVAS) && ((oe.keyCode === 8 || oe.keyCode === 46) && f.options.controls.trash ? (oe.preventDefault(),
        M.trash()) : l(oe.keyCode) ? M.keydown(oe) : oe.keyCode === 49 && f.options.controls.point ? ce(Tt.DRAW_POINT) : oe.keyCode === 50 && f.options.controls.line_string ? ce(Tt.DRAW_LINE_STRING) : oe.keyCode === 51 && f.options.controls.polygon && ce(Tt.DRAW_POLYGON))
    }
    ,
    z.keyup = function(oe) {
        l(oe.keyCode) && M.keyup(oe)
    }
    ,
    z.zoomend = function() {
        f.store.changeZoom()
    }
    ,
    z.data = function(oe) {
        if (oe.dataType === "style") {
            const {setup: Y, map: Te, options: He, store: ft} = f;
            He.styles.some(vt => Te.getLayer(vt.id)) || (Y.addLayers(),
            ft.setDirty(),
            ft.render())
        }
    }
    ;
    function ce(oe, Y, Te={}) {
        M.stop();
        const He = _[oe];
        if (He === void 0)
            throw new Error(`${oe} is not valid`);
        N = oe;
        const ft = He(f, Y);
        M = xd(ft, f),
        Te.silent || f.map.fire(xr.MODE_CHANGE, {
            mode: oe
        }),
        f.store.setDirty(),
        f.store.render()
    }
    const de = {
        trash: !1,
        combineFeatures: !1,
        uncombineFeatures: !1
    };
    function ge(oe) {
        let Y = !1;
        Object.keys(oe).forEach(Te => {
            if (de[Te] === void 0)
                throw new Error("Invalid action type");
            de[Te] !== oe[Te] && (Y = !0),
            de[Te] = oe[Te]
        }
        ),
        Y && f.map.fire(xr.ACTIONABLE, {
            actions: de
        })
    }
    return {
        start() {
            N = f.options.defaultMode,
            M = xd(_[N](f), f)
        },
        changeMode: ce,
        actionable: ge,
        currentModeName() {
            return N
        },
        currentModeRender(oe, Y) {
            return M.render(oe, Y)
        },
        fire(oe, Y) {
            f.map && f.map.fire(oe, Y)
        },
        addEventListeners() {
            f.map.on("mousemove", z.mousemove),
            f.map.on("mousedown", z.mousedown),
            f.map.on("mouseup", z.mouseup),
            f.map.on("data", z.data),
            f.map.on("touchmove", z.touchmove),
            f.map.on("touchstart", z.touchstart),
            f.map.on("touchend", z.touchend),
            f.container.addEventListener("mouseout", z.mouseout),
            f.options.keybindings && (f.container.addEventListener("keydown", z.keydown),
            f.container.addEventListener("keyup", z.keyup))
        },
        removeEventListeners() {
            f.map.off("mousemove", z.mousemove),
            f.map.off("mousedown", z.mousedown),
            f.map.off("mouseup", z.mouseup),
            f.map.off("data", z.data),
            f.map.off("touchmove", z.touchmove),
            f.map.off("touchstart", z.touchstart),
            f.map.off("touchend", z.touchend),
            f.container.removeEventListener("mouseout", z.mouseout),
            f.options.keybindings && (f.container.removeEventListener("keydown", z.keydown),
            f.container.removeEventListener("keyup", z.keyup))
        },
        trash(oe) {
            M.trash(oe)
        },
        combineFeatures() {
            M.combineFeatures()
        },
        uncombineFeatures() {
            M.uncombineFeatures()
        },
        getMode() {
            return N
        }
    }
}
function gc(f) {
    return [].concat(f).filter(_ => _ !== void 0)
}
function J_() {
    const f = this;
    if (!(f.ctx.map && f.ctx.map.getSource(hn.HOT) !== void 0))
        return ce();
    const w = f.ctx.events.currentModeName();
    f.ctx.ui.queueMapClasses({
        mode: w
    });
    let I = []
      , z = [];
    f.isDirty ? z = f.getAllIds() : (I = f.getChangedIds().filter(de => f.get(de) !== void 0),
    z = f.sources.hot.filter(de => de.properties.id && I.indexOf(de.properties.id) === -1 && f.get(de.properties.id) !== void 0).map(de => de.properties.id)),
    f.sources.hot = [];
    const N = f.sources.cold.length;
    f.sources.cold = f.isDirty ? [] : f.sources.cold.filter(de => {
        const ge = de.properties.id || de.properties.parent;
        return I.indexOf(ge) === -1
    }
    );
    const M = N !== f.sources.cold.length || z.length > 0;
    I.forEach(de => l(de, "hot")),
    z.forEach(de => l(de, "cold"));
    function l(de, ge) {
        const oe = f.get(de).internal(w);
        f.ctx.events.currentModeRender(oe, Y => {
            Y.properties.mode = w,
            f.sources[ge].push(Y)
        }
        )
    }
    M && f.ctx.map.getSource(hn.COLD).setData({
        type: rt.FEATURE_COLLECTION,
        features: f.sources.cold
    }),
    f.ctx.map.getSource(hn.HOT).setData({
        type: rt.FEATURE_COLLECTION,
        features: f.sources.hot
    }),
    ce();
    function ce() {
        f.isDirty = !1,
        f.clearChangedIds()
    }
}
function Ht(f) {
    this._features = {},
    this._featureIds = new pn,
    this._selectedFeatureIds = new pn,
    this._selectedCoordinates = [],
    this._changedFeatureIds = new pn,
    this._emitSelectionChange = !1,
    this._mapInitialConfig = {},
    this.ctx = f,
    this.sources = {
        hot: [],
        cold: []
    };
    let _;
    this.render = () => {
        _ || (_ = requestAnimationFrame( () => {
            _ = null,
            J_.call(this),
            this._emitSelectionChange && (this.ctx.events.fire(xr.SELECTION_CHANGE, {
                features: this.getSelected().map(w => w.toGeoJSON()),
                points: this.getSelectedCoordinates().map(w => ({
                    type: rt.FEATURE,
                    properties: {},
                    geometry: {
                        type: rt.POINT,
                        coordinates: w.coordinates
                    }
                }))
            }),
            this._emitSelectionChange = !1),
            this.ctx.events.fire(xr.RENDER, {})
        }
        ))
    }
    ,
    this.isDirty = !1
}
Ht.prototype.createRenderBatch = function() {
    const f = this.render;
    let _ = 0;
    return this.render = function() {
        _++
    }
    ,
    () => {
        this.render = f,
        _ > 0 && this.render()
    }
}
;
Ht.prototype.setDirty = function() {
    return this.isDirty = !0,
    this
}
;
Ht.prototype.featureCreated = function(f, _={}) {
    if (this._changedFeatureIds.add(f),
    (_.silent != null ? _.silent : this.ctx.options.suppressAPIEvents) !== !0) {
        const I = this.get(f);
        this.ctx.events.fire(xr.CREATE, {
            features: [I.toGeoJSON()]
        })
    }
    return this
}
;
Ht.prototype.featureChanged = function(f, _={}) {
    return this._changedFeatureIds.add(f),
    (_.silent != null ? _.silent : this.ctx.options.suppressAPIEvents) !== !0 && this.ctx.events.fire(xr.UPDATE, {
        action: _.action ? _.action : mc.CHANGE_COORDINATES,
        features: [this.get(f).toGeoJSON()]
    }),
    this
}
;
Ht.prototype.getChangedIds = function() {
    return this._changedFeatureIds.values()
}
;
Ht.prototype.clearChangedIds = function() {
    return this._changedFeatureIds.clear(),
    this
}
;
Ht.prototype.getAllIds = function() {
    return this._featureIds.values()
}
;
Ht.prototype.add = function(f, _={}) {
    return this._features[f.id] = f,
    this._featureIds.add(f.id),
    this.featureCreated(f.id, {
        silent: _.silent
    }),
    this
}
;
Ht.prototype.delete = function(f, _={}) {
    const w = [];
    return gc(f).forEach(I => {
        this._featureIds.has(I) && (this._featureIds.delete(I),
        this._selectedFeatureIds.delete(I),
        _.silent || w.indexOf(this._features[I]) === -1 && w.push(this._features[I].toGeoJSON()),
        delete this._features[I],
        this.isDirty = !0)
    }
    ),
    w.length && this.ctx.events.fire(xr.DELETE, {
        features: w
    }),
    em(this, _),
    this
}
;
Ht.prototype.get = function(f) {
    return this._features[f]
}
;
Ht.prototype.getAll = function() {
    return Object.keys(this._features).map(f => this._features[f])
}
;
Ht.prototype.select = function(f, _={}) {
    return gc(f).forEach(w => {
        this._selectedFeatureIds.has(w) || (this._selectedFeatureIds.add(w),
        this._changedFeatureIds.add(w),
        _.silent || (this._emitSelectionChange = !0))
    }
    ),
    this
}
;
Ht.prototype.deselect = function(f, _={}) {
    return gc(f).forEach(w => {
        this._selectedFeatureIds.has(w) && (this._selectedFeatureIds.delete(w),
        this._changedFeatureIds.add(w),
        _.silent || (this._emitSelectionChange = !0))
    }
    ),
    em(this, _),
    this
}
;
Ht.prototype.clearSelected = function(f={}) {
    return this.deselect(this._selectedFeatureIds.values(), {
        silent: f.silent
    }),
    this
}
;
Ht.prototype.setSelected = function(f, _={}) {
    return f = gc(f),
    this.deselect(this._selectedFeatureIds.values().filter(w => f.indexOf(w) === -1), {
        silent: _.silent
    }),
    this.select(f.filter(w => !this._selectedFeatureIds.has(w)), {
        silent: _.silent
    }),
    this
}
;
Ht.prototype.setSelectedCoordinates = function(f) {
    return this._selectedCoordinates = f,
    this._emitSelectionChange = !0,
    this
}
;
Ht.prototype.clearSelectedCoordinates = function() {
    return this._selectedCoordinates = [],
    this._emitSelectionChange = !0,
    this
}
;
Ht.prototype.getSelectedIds = function() {
    return this._selectedFeatureIds.values()
}
;
Ht.prototype.getSelected = function() {
    return this.getSelectedIds().map(f => this.get(f))
}
;
Ht.prototype.getSelectedCoordinates = function() {
    return this._selectedCoordinates.map(_ => ({
        coordinates: this.get(_.feature_id).getCoordinate(_.coord_path)
    }))
}
;
Ht.prototype.isSelected = function(f) {
    return this._selectedFeatureIds.has(f)
}
;
Ht.prototype.setFeatureProperty = function(f, _, w, I={}) {
    this.get(f).setProperty(_, w),
    this.featureChanged(f, {
        silent: I.silent,
        action: mc.CHANGE_PROPERTIES
    })
}
;
function em(f, _={}) {
    const w = f._selectedCoordinates.filter(I => f._selectedFeatureIds.has(I.feature_id));
    f._selectedCoordinates.length !== w.length && !_.silent && (f._emitSelectionChange = !0),
    f._selectedCoordinates = w
}
Ht.prototype.storeMapConfig = function() {
    Wf.forEach(f => {
        this.ctx.map[f] && (this._mapInitialConfig[f] = this.ctx.map[f].isEnabled())
    }
    )
}
;
Ht.prototype.restoreMapConfig = function() {
    Object.keys(this._mapInitialConfig).forEach(f => {
        this._mapInitialConfig[f] ? this.ctx.map[f].enable() : this.ctx.map[f].disable()
    }
    )
}
;
Ht.prototype.getInitialConfigValue = function(f) {
    return this._mapInitialConfig[f] !== void 0 ? this._mapInitialConfig[f] : !0
}
;
const Y_ = ["mode", "feature", "mouse"];
function Q_(f) {
    const _ = {};
    let w = null
      , I = {
        mode: null,
        feature: null,
        mouse: null
    }
      , z = {
        mode: null,
        feature: null,
        mouse: null
    };
    function N() {
        M({
            mode: null,
            feature: null,
            mouse: null
        }),
        l()
    }
    function M(Y) {
        z = Object.assign(z, Y)
    }
    function l() {
        if (!f.container)
            return;
        const Y = []
          , Te = [];
        Y_.forEach(He => {
            z[He] !== I[He] && (Y.push(`${He}-${I[He]}`),
            z[He] !== null && Te.push(`${He}-${z[He]}`))
        }
        ),
        Y.length > 0 && f.container.classList.remove(...Y),
        Te.length > 0 && f.container.classList.add(...Te),
        I = Object.assign(I, z)
    }
    function ce(Y, Te={}) {
        const He = document.createElement("button");
        return He.className = `${Dr.CONTROL_BUTTON} ${Te.className}`,
        He.setAttribute("title", Te.title),
        Te.container.appendChild(He),
        He.addEventListener("click", ft => {
            if (ft.preventDefault(),
            ft.stopPropagation(),
            ft.target === w) {
                de(),
                Te.onDeactivate();
                return
            }
            ge(Y),
            Te.onActivate()
        }
        , !0),
        He
    }
    function de() {
        w && (w.classList.remove(Dr.ACTIVE_BUTTON),
        w = null)
    }
    function ge(Y) {
        de();
        const Te = _[Y];
        Te && Te && Y !== "trash" && (Te.classList.add(Dr.ACTIVE_BUTTON),
        w = Te)
    }
    function ze() {
        const Y = f.options.controls
          , Te = document.createElement("div");
        return Te.className = `${Dr.CONTROL_GROUP} ${Dr.CONTROL_BASE}`,
        Y && (Y[Rr.LINE] && (_[Rr.LINE] = ce(Rr.LINE, {
            container: Te,
            className: Dr.CONTROL_BUTTON_LINE,
            title: `LineString tool ${f.options.keybindings ? "(l)" : ""}`,
            onActivate: () => f.events.changeMode(Tt.DRAW_LINE_STRING),
            onDeactivate: () => f.events.trash()
        })),
        Y[Rr.POLYGON] && (_[Rr.POLYGON] = ce(Rr.POLYGON, {
            container: Te,
            className: Dr.CONTROL_BUTTON_POLYGON,
            title: `Polygon tool ${f.options.keybindings ? "(p)" : ""}`,
            onActivate: () => f.events.changeMode(Tt.DRAW_POLYGON),
            onDeactivate: () => f.events.trash()
        })),
        Y[Rr.POINT] && (_[Rr.POINT] = ce(Rr.POINT, {
            container: Te,
            className: Dr.CONTROL_BUTTON_POINT,
            title: `Marker tool ${f.options.keybindings ? "(m)" : ""}`,
            onActivate: () => f.events.changeMode(Tt.DRAW_POINT),
            onDeactivate: () => f.events.trash()
        })),
        Y.trash && (_.trash = ce("trash", {
            container: Te,
            className: Dr.CONTROL_BUTTON_TRASH,
            title: "Delete",
            onActivate: () => {
                f.events.trash()
            }
        })),
        Y.combine_features && (_.combine_features = ce("combineFeatures", {
            container: Te,
            className: Dr.CONTROL_BUTTON_COMBINE_FEATURES,
            title: "Combine",
            onActivate: () => {
                f.events.combineFeatures()
            }
        })),
        Y.uncombine_features && (_.uncombine_features = ce("uncombineFeatures", {
            container: Te,
            className: Dr.CONTROL_BUTTON_UNCOMBINE_FEATURES,
            title: "Uncombine",
            onActivate: () => {
                f.events.uncombineFeatures()
            }
        }))),
        Te
    }
    function oe() {
        Object.keys(_).forEach(Y => {
            const Te = _[Y];
            Te.parentNode && Te.parentNode.removeChild(Te),
            delete _[Y]
        }
        )
    }
    return {
        setActiveButton: ge,
        queueMapClasses: M,
        updateMapClasses: l,
        clearMapClasses: N,
        addButtons: ze,
        removeButtons: oe
    }
}
function ey(f) {
    let _ = null
      , w = null;
    const I = {
        onRemove() {
            return f.map.off("load", I.connect),
            clearInterval(w),
            I.removeLayers(),
            f.store.restoreMapConfig(),
            f.ui.removeButtons(),
            f.events.removeEventListeners(),
            f.ui.clearMapClasses(),
            f.boxZoomInitial && f.map.boxZoom.enable(),
            f.map = null,
            f.container = null,
            f.store = null,
            _ && _.parentNode && _.parentNode.removeChild(_),
            _ = null,
            this
        },
        connect() {
            f.map.off("load", I.connect),
            clearInterval(w),
            I.addLayers(),
            f.store.storeMapConfig(),
            f.events.addEventListeners()
        },
        onAdd(z) {
            if (f.map = z,
            f.events = K_(f),
            f.ui = Q_(f),
            f.container = z.getContainer(),
            f.store = new Ht(f),
            _ = f.ui.addButtons(),
            f.options.boxSelect) {
                f.boxZoomInitial = z.boxZoom.isEnabled(),
                z.boxZoom.disable();
                const N = z.dragPan.isEnabled();
                z.dragPan.disable(),
                z.dragPan.enable(),
                N || z.dragPan.disable()
            }
            return z.loaded() ? I.connect() : (z.on("load", I.connect),
            w = setInterval( () => {
                z.loaded() && I.connect()
            }
            , 16)),
            f.events.start(),
            _
        },
        addLayers() {
            f.map.addSource(hn.COLD, {
                data: {
                    type: rt.FEATURE_COLLECTION,
                    features: []
                },
                type: "geojson"
            }),
            f.map.addSource(hn.HOT, {
                data: {
                    type: rt.FEATURE_COLLECTION,
                    features: []
                },
                type: "geojson"
            }),
            f.options.styles.forEach(z => {
                f.map.addLayer(z)
            }
            ),
            f.store.setDirty(!0),
            f.store.render()
        },
        removeLayers() {
            f.options.styles.forEach(z => {
                f.map.getLayer(z.id) && f.map.removeLayer(z.id)
            }
            ),
            f.map.getSource(hn.COLD) && f.map.removeSource(hn.COLD),
            f.map.getSource(hn.HOT) && f.map.removeSource(hn.HOT)
        }
    };
    return f.setup = I,
    I
}
const cd = "#3bb2d0"
  , cc = "#fbb03b"
  , zf = "#fff"
  , tm = [{
    id: "gl-draw-polygon-fill",
    type: "fill",
    filter: ["all", ["==", "$type", "Polygon"]],
    paint: {
        "fill-color": ["case", ["==", ["get", "active"], "true"], cc, cd],
        "fill-opacity": .1
    }
}, {
    id: "gl-draw-lines",
    type: "line",
    filter: ["any", ["==", "$type", "LineString"], ["==", "$type", "Polygon"]],
    layout: {
        "line-cap": "round",
        "line-join": "round"
    },
    paint: {
        "line-color": ["case", ["==", ["get", "active"], "true"], cc, cd],
        "line-dasharray": ["case", ["==", ["get", "active"], "true"], [.2, 2], [2, 0]],
        "line-width": 2
    }
}, {
    id: "gl-draw-point-outer",
    type: "circle",
    filter: ["all", ["==", "$type", "Point"], ["==", "meta", "feature"]],
    paint: {
        "circle-radius": ["case", ["==", ["get", "active"], "true"], 7, 5],
        "circle-color": zf
    }
}, {
    id: "gl-draw-point-inner",
    type: "circle",
    filter: ["all", ["==", "$type", "Point"], ["==", "meta", "feature"]],
    paint: {
        "circle-radius": ["case", ["==", ["get", "active"], "true"], 5, 3],
        "circle-color": ["case", ["==", ["get", "active"], "true"], cc, cd]
    }
}, {
    id: "gl-draw-vertex-outer",
    type: "circle",
    filter: ["all", ["==", "$type", "Point"], ["==", "meta", "vertex"], ["!=", "mode", "simple_select"]],
    paint: {
        "circle-radius": ["case", ["==", ["get", "active"], "true"], 7, 5],
        "circle-color": zf
    }
}, {
    id: "gl-draw-vertex-inner",
    type: "circle",
    filter: ["all", ["==", "$type", "Point"], ["==", "meta", "vertex"], ["!=", "mode", "simple_select"]],
    paint: {
        "circle-radius": ["case", ["==", ["get", "active"], "true"], 5, 3],
        "circle-color": cc
    }
}, {
    id: "gl-draw-midpoint",
    type: "circle",
    filter: ["all", ["==", "meta", "midpoint"]],
    paint: {
        "circle-radius": 3,
        "circle-color": cc
    }
}];
function Gu(f) {
    return function(_) {
        const w = _.featureTarget;
        return !w || !w.properties ? !1 : w.properties.meta === f
    }
}
function im(f) {
    return !f.originalEvent || !f.originalEvent.shiftKey ? !1 : f.originalEvent.button === 0
}
function Eo(f) {
    return !f.featureTarget || !f.featureTarget.properties ? !1 : f.featureTarget.properties.active === Hi.ACTIVE && f.featureTarget.properties.meta === sr.FEATURE
}
function zd(f) {
    return !f.featureTarget || !f.featureTarget.properties ? !1 : f.featureTarget.properties.active === Hi.INACTIVE && f.featureTarget.properties.meta === sr.FEATURE
}
function $u(f) {
    return f.featureTarget === void 0
}
function kd(f) {
    return !f.featureTarget || !f.featureTarget.properties ? !1 : f.featureTarget.properties.meta === sr.FEATURE
}
function _c(f) {
    const _ = f.featureTarget;
    return !_ || !_.properties ? !1 : _.properties.meta === sr.VERTEX
}
function Nu(f) {
    return f.originalEvent ? f.originalEvent.shiftKey === !0 : !1
}
function qu(f) {
    return f.keyCode === 27
}
function Hu(f) {
    return f.keyCode === 13
}
function ty() {
    return !0
}
const iy = Object.freeze(Object.defineProperty({
    __proto__: null,
    isActiveFeature: Eo,
    isEnterKey: Hu,
    isEscapeKey: qu,
    isFeature: kd,
    isInactiveFeature: zd,
    isOfMetaType: Gu,
    isShiftDown: Nu,
    isShiftMousedown: im,
    isTrue: ty,
    isVertex: _c,
    noTarget: $u
}, Symbol.toStringTag, {
    value: "Module"
}));
function Js(f, _) {
    this.x = f,
    this.y = _
}
Js.prototype = {
    clone() {
        return new Js(this.x,this.y)
    },
    add(f) {
        return this.clone()._add(f)
    },
    sub(f) {
        return this.clone()._sub(f)
    },
    multByPoint(f) {
        return this.clone()._multByPoint(f)
    },
    divByPoint(f) {
        return this.clone()._divByPoint(f)
    },
    mult(f) {
        return this.clone()._mult(f)
    },
    div(f) {
        return this.clone()._div(f)
    },
    rotate(f) {
        return this.clone()._rotate(f)
    },
    rotateAround(f, _) {
        return this.clone()._rotateAround(f, _)
    },
    matMult(f) {
        return this.clone()._matMult(f)
    },
    unit() {
        return this.clone()._unit()
    },
    perp() {
        return this.clone()._perp()
    },
    round() {
        return this.clone()._round()
    },
    mag() {
        return Math.sqrt(this.x * this.x + this.y * this.y)
    },
    equals(f) {
        return this.x === f.x && this.y === f.y
    },
    dist(f) {
        return Math.sqrt(this.distSqr(f))
    },
    distSqr(f) {
        const _ = f.x - this.x
          , w = f.y - this.y;
        return _ * _ + w * w
    },
    angle() {
        return Math.atan2(this.y, this.x)
    },
    angleTo(f) {
        return Math.atan2(this.y - f.y, this.x - f.x)
    },
    angleWith(f) {
        return this.angleWithSep(f.x, f.y)
    },
    angleWithSep(f, _) {
        return Math.atan2(this.x * _ - this.y * f, this.x * f + this.y * _)
    },
    _matMult(f) {
        const _ = f[0] * this.x + f[1] * this.y
          , w = f[2] * this.x + f[3] * this.y;
        return this.x = _,
        this.y = w,
        this
    },
    _add(f) {
        return this.x += f.x,
        this.y += f.y,
        this
    },
    _sub(f) {
        return this.x -= f.x,
        this.y -= f.y,
        this
    },
    _mult(f) {
        return this.x *= f,
        this.y *= f,
        this
    },
    _div(f) {
        return this.x /= f,
        this.y /= f,
        this
    },
    _multByPoint(f) {
        return this.x *= f.x,
        this.y *= f.y,
        this
    },
    _divByPoint(f) {
        return this.x /= f.x,
        this.y /= f.y,
        this
    },
    _unit() {
        return this._div(this.mag()),
        this
    },
    _perp() {
        const f = this.y;
        return this.y = this.x,
        this.x = -f,
        this
    },
    _rotate(f) {
        const _ = Math.cos(f)
          , w = Math.sin(f)
          , I = _ * this.x - w * this.y
          , z = w * this.x + _ * this.y;
        return this.x = I,
        this.y = z,
        this
    },
    _rotateAround(f, _) {
        const w = Math.cos(f)
          , I = Math.sin(f)
          , z = _.x + w * (this.x - _.x) - I * (this.y - _.y)
          , N = _.y + I * (this.x - _.x) + w * (this.y - _.y);
        return this.x = z,
        this.y = N,
        this
    },
    _round() {
        return this.x = Math.round(this.x),
        this.y = Math.round(this.y),
        this
    },
    constructor: Js
};
Js.convert = function(f) {
    if (f instanceof Js)
        return f;
    if (Array.isArray(f))
        return new Js(+f[0],+f[1]);
    if (f.x !== void 0 && f.y !== void 0)
        return new Js(+f.x,+f.y);
    throw new Error("Expected [x, y] or {x, y} point format")
}
;
function Ld(f, _) {
    const w = _.getBoundingClientRect();
    return new Js(f.clientX - w.left - (_.clientLeft || 0),f.clientY - w.top - (_.clientTop || 0))
}
function ja(f, _, w, I) {
    return {
        type: rt.FEATURE,
        properties: {
            meta: sr.VERTEX,
            parent: f,
            coord_path: w,
            active: I ? Hi.ACTIVE : Hi.INACTIVE
        },
        geometry: {
            type: rt.POINT,
            coordinates: _
        }
    }
}
function rm(f, _, w) {
    const I = _.geometry.coordinates
      , z = w.geometry.coordinates;
    if (I[1] > bd || I[1] < vd || z[1] > bd || z[1] < vd)
        return null;
    const N = {
        lng: (I[0] + z[0]) / 2,
        lat: (I[1] + z[1]) / 2
    };
    return {
        type: rt.FEATURE,
        properties: {
            meta: sr.MIDPOINT,
            parent: f,
            lng: N.lng,
            lat: N.lat,
            coord_path: w.properties.coord_path
        },
        geometry: {
            type: rt.POINT,
            coordinates: [N.lng, N.lat]
        }
    }
}
function Wu(f, _={}, w=null) {
    const {type: I, coordinates: z} = f.geometry
      , N = f.properties && f.properties.id;
    let M = [];
    I === rt.POINT ? M.push(ja(N, z, w, ce(w))) : I === rt.POLYGON ? z.forEach( (ge, ze) => {
        l(ge, w !== null ? `${w}.${ze}` : String(ze))
    }
    ) : I === rt.LINE_STRING ? l(z, w) : I.indexOf(rt.MULTI_PREFIX) === 0 && de();
    function l(ge, ze) {
        let oe = ""
          , Y = null;
        ge.forEach( (Te, He) => {
            const ft = ze != null ? `${ze}.${He}` : String(He)
              , Pt = ja(N, Te, ft, ce(ft));
            if (_.midpoints && Y) {
                const St = rm(N, Y, Pt);
                St && M.push(St)
            }
            Y = Pt;
            const vt = JSON.stringify(Te);
            oe !== vt && M.push(Pt),
            He === 0 && (oe = vt)
        }
        )
    }
    function ce(ge) {
        return _.selectedPaths ? _.selectedPaths.indexOf(ge) !== -1 : !1
    }
    function de() {
        const ge = I.replace(rt.MULTI_PREFIX, "");
        z.forEach( (ze, oe) => {
            const Y = {
                type: rt.FEATURE,
                properties: f.properties,
                geometry: {
                    type: ge,
                    coordinates: ze
                }
            };
            M = M.concat(Wu(Y, _, oe))
        }
        )
    }
    return M
}
const Sn = {
    enable(f) {
        setTimeout( () => {
            !f.map || !f.map.doubleClickZoom || !f._ctx || !f._ctx.store || !f._ctx.store.getInitialConfigValue || f._ctx.store.getInitialConfigValue("doubleClickZoom") && f.map.doubleClickZoom.enable()
        }
        , 0)
    },
    disable(f) {
        setTimeout( () => {
            !f.map || !f.map.doubleClickZoom || f.map.doubleClickZoom.disable()
        }
        , 0)
    }
}
  , {LAT_MIN: ku, LAT_MAX: Lu, LAT_RENDERED_MIN: kf, LAT_RENDERED_MAX: Lf, LNG_MIN: Df, LNG_MAX: Rf} = Xf;
function ry(f) {
    const _ = {
        Point: 0,
        LineString: 1,
        Polygon: 2,
        MultiPoint: 1,
        MultiLineString: 2,
        MultiPolygon: 3
    }[f.geometry.type]
      , w = [f.geometry.coordinates].flat(_)
      , I = w.map(l => l[0])
      , z = w.map(l => l[1])
      , N = l => Math.min.apply(null, l)
      , M = l => Math.max.apply(null, l);
    return [N(I), N(z), M(I), M(z)]
}
function Dd(f, _) {
    let w = ku
      , I = Lu
      , z = ku
      , N = Lu
      , M = Rf
      , l = Df;
    f.forEach(de => {
        const ge = ry(de)
          , ze = ge[1]
          , oe = ge[3]
          , Y = ge[0]
          , Te = ge[2];
        ze > w && (w = ze),
        oe < I && (I = oe),
        oe > z && (z = oe),
        ze < N && (N = ze),
        Y < M && (M = Y),
        Te > l && (l = Te)
    }
    );
    const ce = _;
    return w + ce.lat > Lf && (ce.lat = Lf - w),
    z + ce.lat > Lu && (ce.lat = Lu - z),
    I + ce.lat < kf && (ce.lat = kf - I),
    N + ce.lat < ku && (ce.lat = ku - N),
    M + ce.lng <= Df && (ce.lng += Math.ceil(Math.abs(ce.lng) / 360) * 360),
    l + ce.lng >= Rf && (ce.lng -= Math.ceil(Math.abs(ce.lng) / 360) * 360),
    ce
}
function Rd(f, _) {
    const w = Dd(f.map(I => I.toGeoJSON()), _);
    f.forEach(I => {
        const z = I.getCoordinates()
          , N = de => {
            const ge = {
                lng: de[0] + w.lng,
                lat: de[1] + w.lat
            };
            return [ge.lng, ge.lat]
        }
          , M = de => de.map(ge => N(ge))
          , l = de => de.map(ge => M(ge));
        let ce;
        I.type === rt.POINT ? ce = N(z) : I.type === rt.LINE_STRING || I.type === rt.MULTI_POINT ? ce = z.map(N) : I.type === rt.POLYGON || I.type === rt.MULTI_LINE_STRING ? ce = z.map(M) : I.type === rt.MULTI_POLYGON && (ce = z.map(l)),
        I.incomingCoords(ce)
    }
    )
}
const Gt = {};
Gt.onSetup = function(f) {
    const _ = {
        dragMoveLocation: null,
        boxSelectStartLocation: null,
        boxSelectElement: void 0,
        boxSelecting: !1,
        canBoxSelect: !1,
        dragMoving: !1,
        canDragMove: !1,
        initialDragPanState: this.map.dragPan.isEnabled(),
        initiallySelectedFeatureIds: f.featureIds || []
    };
    return this.setSelected(_.initiallySelectedFeatureIds.filter(w => this.getFeature(w) !== void 0)),
    this.fireActionable(),
    this.setActionableState({
        combineFeatures: !0,
        uncombineFeatures: !0,
        trash: !0
    }),
    _
}
;
Gt.fireUpdate = function() {
    this.fire(xr.UPDATE, {
        action: mc.MOVE,
        features: this.getSelected().map(f => f.toGeoJSON())
    })
}
;
Gt.fireActionable = function() {
    const f = this.getSelected()
      , _ = f.filter(N => this.isInstanceOf("MultiFeature", N));
    let w = !1;
    if (f.length > 1) {
        w = !0;
        const N = f[0].type.replace("Multi", "");
        f.forEach(M => {
            M.type.replace("Multi", "") !== N && (w = !1)
        }
        )
    }
    const I = _.length > 0
      , z = f.length > 0;
    this.setActionableState({
        combineFeatures: w,
        uncombineFeatures: I,
        trash: z
    })
}
;
Gt.getUniqueIds = function(f) {
    return f.length ? f.map(w => w.properties.id).filter(w => w !== void 0).reduce( (w, I) => (w.add(I),
    w), new pn).values() : []
}
;
Gt.stopExtendedInteractions = function(f) {
    f.boxSelectElement && (f.boxSelectElement.parentNode && f.boxSelectElement.parentNode.removeChild(f.boxSelectElement),
    f.boxSelectElement = null),
    (f.canDragMove || f.canBoxSelect) && f.initialDragPanState === !0 && this.map.dragPan.enable(),
    f.boxSelecting = !1,
    f.canBoxSelect = !1,
    f.dragMoving = !1,
    f.canDragMove = !1
}
;
Gt.onStop = function() {
    Sn.enable(this)
}
;
Gt.onMouseMove = function(f, _) {
    return kd(_) && f.dragMoving && this.fireUpdate(),
    this.stopExtendedInteractions(f),
    !0
}
;
Gt.onMouseOut = function(f) {
    return f.dragMoving ? this.fireUpdate() : !0
}
;
Gt.onTap = Gt.onClick = function(f, _) {
    if ($u(_))
        return this.clickAnywhere(f, _);
    if (Gu(sr.VERTEX)(_))
        return this.clickOnVertex(f, _);
    if (kd(_))
        return this.clickOnFeature(f, _)
}
;
Gt.clickAnywhere = function(f) {
    const _ = this.getSelectedIds();
    _.length && (this.clearSelectedFeatures(),
    _.forEach(w => this.doRender(w))),
    Sn.enable(this),
    this.stopExtendedInteractions(f)
}
;
Gt.clickOnVertex = function(f, _) {
    this.changeMode(Tt.DIRECT_SELECT, {
        featureId: _.featureTarget.properties.parent,
        coordPath: _.featureTarget.properties.coord_path,
        startPos: _.lngLat
    }),
    this.updateUIClasses({
        mouse: ni.MOVE
    })
}
;
Gt.startOnActiveFeature = function(f, _) {
    this.stopExtendedInteractions(f),
    this.map.dragPan.disable(),
    this.doRender(_.featureTarget.properties.id),
    f.canDragMove = !0,
    f.dragMoveLocation = _.lngLat
}
;
Gt.clickOnFeature = function(f, _) {
    Sn.disable(this),
    this.stopExtendedInteractions(f);
    const w = Nu(_)
      , I = this.getSelectedIds()
      , z = _.featureTarget.properties.id
      , N = this.isSelected(z);
    if (!w && N && this.getFeature(z).type !== rt.POINT)
        return this.changeMode(Tt.DIRECT_SELECT, {
            featureId: z
        });
    N && w ? (this.deselect(z),
    this.updateUIClasses({
        mouse: ni.POINTER
    }),
    I.length === 1 && Sn.enable(this)) : !N && w ? (this.select(z),
    this.updateUIClasses({
        mouse: ni.MOVE
    })) : !N && !w && (I.forEach(M => this.doRender(M)),
    this.setSelected(z),
    this.updateUIClasses({
        mouse: ni.MOVE
    })),
    this.doRender(z)
}
;
Gt.onMouseDown = function(f, _) {
    if (f.initialDragPanState = this.map.dragPan.isEnabled(),
    Eo(_))
        return this.startOnActiveFeature(f, _);
    if (this.drawConfig.boxSelect && im(_))
        return this.startBoxSelect(f, _)
}
;
Gt.startBoxSelect = function(f, _) {
    this.stopExtendedInteractions(f),
    this.map.dragPan.disable(),
    f.boxSelectStartLocation = Ld(_.originalEvent, this.map.getContainer()),
    f.canBoxSelect = !0
}
;
Gt.onTouchStart = function(f, _) {
    if (Eo(_))
        return this.startOnActiveFeature(f, _)
}
;
Gt.onDrag = function(f, _) {
    if (f.canDragMove)
        return this.dragMove(f, _);
    if (this.drawConfig.boxSelect && f.canBoxSelect)
        return this.whileBoxSelect(f, _)
}
;
Gt.whileBoxSelect = function(f, _) {
    f.boxSelecting = !0,
    this.updateUIClasses({
        mouse: ni.ADD
    }),
    f.boxSelectElement || (f.boxSelectElement = document.createElement("div"),
    f.boxSelectElement.classList.add(Dr.BOX_SELECT),
    this.map.getContainer().appendChild(f.boxSelectElement));
    const w = Ld(_.originalEvent, this.map.getContainer())
      , I = Math.min(f.boxSelectStartLocation.x, w.x)
      , z = Math.max(f.boxSelectStartLocation.x, w.x)
      , N = Math.min(f.boxSelectStartLocation.y, w.y)
      , M = Math.max(f.boxSelectStartLocation.y, w.y)
      , l = `translate(${I}px, ${N}px)`;
    f.boxSelectElement.style.transform = l,
    f.boxSelectElement.style.WebkitTransform = l,
    f.boxSelectElement.style.width = `${z - I}px`,
    f.boxSelectElement.style.height = `${M - N}px`
}
;
Gt.dragMove = function(f, _) {
    f.dragMoving = !0,
    _.originalEvent.stopPropagation();
    const w = {
        lng: _.lngLat.lng - f.dragMoveLocation.lng,
        lat: _.lngLat.lat - f.dragMoveLocation.lat
    };
    Rd(this.getSelected(), w),
    f.dragMoveLocation = _.lngLat
}
;
Gt.onTouchEnd = Gt.onMouseUp = function(f, _) {
    if (f.dragMoving)
        this.fireUpdate();
    else if (f.boxSelecting) {
        const w = [f.boxSelectStartLocation, Ld(_.originalEvent, this.map.getContainer())]
          , I = this.featuresAt(null, w, "click")
          , z = this.getUniqueIds(I).filter(N => !this.isSelected(N));
        z.length && (this.select(z),
        z.forEach(N => this.doRender(N)),
        this.updateUIClasses({
            mouse: ni.MOVE
        }))
    }
    this.stopExtendedInteractions(f)
}
;
Gt.toDisplayFeatures = function(f, _, w) {
    _.properties.active = this.isSelected(_.properties.id) ? Hi.ACTIVE : Hi.INACTIVE,
    w(_),
    this.fireActionable(),
    !(_.properties.active !== Hi.ACTIVE || _.geometry.type === rt.POINT) && Wu(_).forEach(w)
}
;
Gt.onTrash = function() {
    this.deleteFeature(this.getSelectedIds()),
    this.fireActionable()
}
;
Gt.onCombineFeatures = function() {
    const f = this.getSelected();
    if (f.length === 0 || f.length < 2)
        return;
    const _ = []
      , w = []
      , I = f[0].type.replace("Multi", "");
    for (let z = 0; z < f.length; z++) {
        const N = f[z];
        if (N.type.replace("Multi", "") !== I)
            return;
        N.type.includes("Multi") ? N.getCoordinates().forEach(M => {
            _.push(M)
        }
        ) : _.push(N.getCoordinates()),
        w.push(N.toGeoJSON())
    }
    if (w.length > 1) {
        const z = this.newFeature({
            type: rt.FEATURE,
            properties: w[0].properties,
            geometry: {
                type: `Multi${I}`,
                coordinates: _
            }
        });
        this.addFeature(z),
        this.deleteFeature(this.getSelectedIds(), {
            silent: !0
        }),
        this.setSelected([z.id]),
        this.fire(xr.COMBINE_FEATURES, {
            createdFeatures: [z.toGeoJSON()],
            deletedFeatures: w
        })
    }
    this.fireActionable()
}
;
Gt.onUncombineFeatures = function() {
    const f = this.getSelected();
    if (f.length === 0)
        return;
    const _ = []
      , w = [];
    for (let I = 0; I < f.length; I++) {
        const z = f[I];
        this.isInstanceOf("MultiFeature", z) && (z.getFeatures().forEach(N => {
            this.addFeature(N),
            N.properties = z.properties,
            _.push(N.toGeoJSON()),
            this.select([N.id])
        }
        ),
        this.deleteFeature(z.id, {
            silent: !0
        }),
        w.push(z.toGeoJSON()))
    }
    _.length > 1 && this.fire(xr.UNCOMBINE_FEATURES, {
        createdFeatures: _,
        deletedFeatures: w
    }),
    this.fireActionable()
}
;
const nm = Gu(sr.VERTEX)
  , sm = Gu(sr.MIDPOINT)
  , $t = {};
$t.fireUpdate = function() {
    this.fire(xr.UPDATE, {
        action: mc.CHANGE_COORDINATES,
        features: this.getSelected().map(f => f.toGeoJSON())
    })
}
;
$t.fireActionable = function(f) {
    this.setActionableState({
        combineFeatures: !1,
        uncombineFeatures: !1,
        trash: f.selectedCoordPaths.length > 0
    })
}
;
$t.startDragging = function(f, _) {
    f.initialDragPanState = this.map.dragPan.isEnabled(),
    this.map.dragPan.disable(),
    f.canDragMove = !0,
    f.dragMoveLocation = _.lngLat
}
;
$t.stopDragging = function(f) {
    f.canDragMove && f.initialDragPanState === !0 && this.map.dragPan.enable(),
    f.dragMoving = !1,
    f.canDragMove = !1,
    f.dragMoveLocation = null
}
;
$t.onVertex = function(f, _) {
    this.startDragging(f, _);
    const w = _.featureTarget.properties
      , I = f.selectedCoordPaths.indexOf(w.coord_path);
    !Nu(_) && I === -1 ? f.selectedCoordPaths = [w.coord_path] : Nu(_) && I === -1 && f.selectedCoordPaths.push(w.coord_path);
    const z = this.pathsToCoordinates(f.featureId, f.selectedCoordPaths);
    this.setSelectedCoordinates(z)
}
;
$t.onMidpoint = function(f, _) {
    this.startDragging(f, _);
    const w = _.featureTarget.properties;
    f.feature.addCoordinate(w.coord_path, w.lng, w.lat),
    this.fireUpdate(),
    f.selectedCoordPaths = [w.coord_path]
}
;
$t.pathsToCoordinates = function(f, _) {
    return _.map(w => ({
        feature_id: f,
        coord_path: w
    }))
}
;
$t.onFeature = function(f, _) {
    f.selectedCoordPaths.length === 0 ? this.startDragging(f, _) : this.stopDragging(f)
}
;
$t.dragFeature = function(f, _, w) {
    Rd(this.getSelected(), w),
    f.dragMoveLocation = _.lngLat
}
;
$t.dragVertex = function(f, _, w) {
    const I = f.selectedCoordPaths.map(M => f.feature.getCoordinate(M))
      , z = I.map(M => ({
        type: rt.FEATURE,
        properties: {},
        geometry: {
            type: rt.POINT,
            coordinates: M
        }
    }))
      , N = Dd(z, w);
    for (let M = 0; M < I.length; M++) {
        const l = I[M];
        f.feature.updateCoordinate(f.selectedCoordPaths[M], l[0] + N.lng, l[1] + N.lat)
    }
}
;
$t.clickNoTarget = function() {
    this.changeMode(Tt.SIMPLE_SELECT)
}
;
$t.clickInactive = function() {
    this.changeMode(Tt.SIMPLE_SELECT)
}
;
$t.clickActiveFeature = function(f) {
    f.selectedCoordPaths = [],
    this.clearSelectedCoordinates(),
    f.feature.changed()
}
;
$t.onSetup = function(f) {
    const _ = f.featureId
      , w = this.getFeature(_);
    if (!w)
        throw new Error("You must provide a featureId to enter direct_select mode");
    if (w.type === rt.POINT)
        throw new TypeError("direct_select mode doesn't handle point features");
    const I = {
        featureId: _,
        feature: w,
        dragMoveLocation: f.startPos || null,
        dragMoving: !1,
        canDragMove: !1,
        selectedCoordPaths: f.coordPath ? [f.coordPath] : []
    };
    return this.setSelectedCoordinates(this.pathsToCoordinates(_, I.selectedCoordPaths)),
    this.setSelected(_),
    Sn.disable(this),
    this.setActionableState({
        trash: !0
    }),
    I
}
;
$t.onStop = function() {
    Sn.enable(this),
    this.clearSelectedCoordinates()
}
;
$t.toDisplayFeatures = function(f, _, w) {
    f.featureId === _.properties.id ? (_.properties.active = Hi.ACTIVE,
    w(_),
    Wu(_, {
        map: this.map,
        midpoints: !0,
        selectedPaths: f.selectedCoordPaths
    }).forEach(w)) : (_.properties.active = Hi.INACTIVE,
    w(_)),
    this.fireActionable(f)
}
;
$t.onTrash = function(f) {
    f.selectedCoordPaths.sort( (_, w) => w.localeCompare(_, "en", {
        numeric: !0
    })).forEach(_ => f.feature.removeCoordinate(_)),
    this.fireUpdate(),
    f.selectedCoordPaths = [],
    this.clearSelectedCoordinates(),
    this.fireActionable(f),
    f.feature.isValid() === !1 && (this.deleteFeature([f.featureId]),
    this.changeMode(Tt.SIMPLE_SELECT, {}))
}
;
$t.onMouseMove = function(f, _) {
    const w = Eo(_)
      , I = nm(_)
      , z = sm(_)
      , N = f.selectedCoordPaths.length === 0;
    return w && N ? this.updateUIClasses({
        mouse: ni.MOVE
    }) : I && !N ? this.updateUIClasses({
        mouse: ni.MOVE
    }) : this.updateUIClasses({
        mouse: ni.NONE
    }),
    (I || w || z) && f.dragMoving && this.fireUpdate(),
    this.stopDragging(f),
    !0
}
;
$t.onMouseOut = function(f) {
    return f.dragMoving && this.fireUpdate(),
    !0
}
;
$t.onTouchStart = $t.onMouseDown = function(f, _) {
    if (nm(_))
        return this.onVertex(f, _);
    if (Eo(_))
        return this.onFeature(f, _);
    if (sm(_))
        return this.onMidpoint(f, _)
}
;
$t.onDrag = function(f, _) {
    if (f.canDragMove !== !0)
        return;
    f.dragMoving = !0,
    _.originalEvent.stopPropagation();
    const w = {
        lng: _.lngLat.lng - f.dragMoveLocation.lng,
        lat: _.lngLat.lat - f.dragMoveLocation.lat
    };
    f.selectedCoordPaths.length > 0 ? this.dragVertex(f, _, w) : this.dragFeature(f, _, w),
    f.dragMoveLocation = _.lngLat
}
;
$t.onClick = function(f, _) {
    if ($u(_))
        return this.clickNoTarget(f, _);
    if (Eo(_))
        return this.clickActiveFeature(f, _);
    if (zd(_))
        return this.clickInactive(f, _);
    this.stopDragging(f)
}
;
$t.onTap = function(f, _) {
    if ($u(_))
        return this.clickNoTarget(f, _);
    if (Eo(_))
        return this.clickActiveFeature(f, _);
    if (zd(_))
        return this.clickInactive(f, _)
}
;
$t.onTouchEnd = $t.onMouseUp = function(f) {
    f.dragMoving && this.fireUpdate(),
    this.stopDragging(f)
}
;
const $n = {};
$n.onSetup = function() {
    const f = this.newFeature({
        type: rt.FEATURE,
        properties: {},
        geometry: {
            type: rt.POINT,
            coordinates: []
        }
    });
    return this.addFeature(f),
    this.clearSelectedFeatures(),
    this.updateUIClasses({
        mouse: ni.ADD
    }),
    this.activateUIButton(Rr.POINT),
    this.setActionableState({
        trash: !0
    }),
    {
        point: f
    }
}
;
$n.stopDrawingAndRemove = function(f) {
    this.deleteFeature([f.point.id], {
        silent: !0
    }),
    this.changeMode(Tt.SIMPLE_SELECT)
}
;
$n.onTap = $n.onClick = function(f, _) {
    this.updateUIClasses({
        mouse: ni.MOVE
    }),
    f.point.updateCoordinate("", _.lngLat.lng, _.lngLat.lat),
    this.fire(xr.CREATE, {
        features: [f.point.toGeoJSON()]
    }),
    this.changeMode(Tt.SIMPLE_SELECT, {
        featureIds: [f.point.id]
    })
}
;
$n.onStop = function(f) {
    this.activateUIButton(),
    f.point.getCoordinate().length || this.deleteFeature([f.point.id], {
        silent: !0
    })
}
;
$n.toDisplayFeatures = function(f, _, w) {
    const I = _.properties.id === f.point.id;
    if (_.properties.active = I ? Hi.ACTIVE : Hi.INACTIVE,
    !I)
        return w(_)
}
;
$n.onTrash = $n.stopDrawingAndRemove;
$n.onKeyUp = function(f, _) {
    if (qu(_) || Hu(_))
        return this.stopDrawingAndRemove(f, _)
}
;
function ju(f, _) {
    return f.lngLat ? f.lngLat.lng === _[0] && f.lngLat.lat === _[1] : !1
}
const In = {};
In.onSetup = function() {
    const f = this.newFeature({
        type: rt.FEATURE,
        properties: {},
        geometry: {
            type: rt.POLYGON,
            coordinates: [[]]
        }
    });
    return this.addFeature(f),
    this.clearSelectedFeatures(),
    Sn.disable(this),
    this.updateUIClasses({
        mouse: ni.ADD
    }),
    this.activateUIButton(Rr.POLYGON),
    this.setActionableState({
        trash: !0
    }),
    {
        polygon: f,
        currentVertexPosition: 0
    }
}
;
In.clickAnywhere = function(f, _) {
    if (f.currentVertexPosition > 0 && ju(_, f.polygon.coordinates[0][f.currentVertexPosition - 1]))
        return this.changeMode(Tt.SIMPLE_SELECT, {
            featureIds: [f.polygon.id]
        });
    this.updateUIClasses({
        mouse: ni.ADD
    }),
    f.polygon.updateCoordinate(`0.${f.currentVertexPosition}`, _.lngLat.lng, _.lngLat.lat),
    f.currentVertexPosition++,
    f.polygon.updateCoordinate(`0.${f.currentVertexPosition}`, _.lngLat.lng, _.lngLat.lat)
}
;
In.clickOnVertex = function(f) {
    return this.changeMode(Tt.SIMPLE_SELECT, {
        featureIds: [f.polygon.id]
    })
}
;
In.onMouseMove = function(f, _) {
    f.polygon.updateCoordinate(`0.${f.currentVertexPosition}`, _.lngLat.lng, _.lngLat.lat),
    _c(_) && this.updateUIClasses({
        mouse: ni.POINTER
    })
}
;
In.onTap = In.onClick = function(f, _) {
    return _c(_) ? this.clickOnVertex(f, _) : this.clickAnywhere(f, _)
}
;
In.onKeyUp = function(f, _) {
    qu(_) ? (this.deleteFeature([f.polygon.id], {
        silent: !0
    }),
    this.changeMode(Tt.SIMPLE_SELECT)) : Hu(_) && this.changeMode(Tt.SIMPLE_SELECT, {
        featureIds: [f.polygon.id]
    })
}
;
In.onStop = function(f) {
    this.updateUIClasses({
        mouse: ni.NONE
    }),
    Sn.enable(this),
    this.activateUIButton(),
    this.getFeature(f.polygon.id) !== void 0 && (f.polygon.removeCoordinate(`0.${f.currentVertexPosition}`),
    f.polygon.isValid() ? this.fire(xr.CREATE, {
        features: [f.polygon.toGeoJSON()]
    }) : (this.deleteFeature([f.polygon.id], {
        silent: !0
    }),
    this.changeMode(Tt.SIMPLE_SELECT, {}, {
        silent: !0
    })))
}
;
In.toDisplayFeatures = function(f, _, w) {
    const I = _.properties.id === f.polygon.id;
    if (_.properties.active = I ? Hi.ACTIVE : Hi.INACTIVE,
    !I)
        return w(_);
    if (_.geometry.coordinates.length === 0)
        return;
    const z = _.geometry.coordinates[0].length;
    if (!(z < 3)) {
        if (_.properties.meta = sr.FEATURE,
        w(ja(f.polygon.id, _.geometry.coordinates[0][0], "0.0", !1)),
        z > 3) {
            const N = _.geometry.coordinates[0].length - 3;
            w(ja(f.polygon.id, _.geometry.coordinates[0][N], `0.${N}`, !1))
        }
        if (z <= 4) {
            const N = [[_.geometry.coordinates[0][0][0], _.geometry.coordinates[0][0][1]], [_.geometry.coordinates[0][1][0], _.geometry.coordinates[0][1][1]]];
            if (w({
                type: rt.FEATURE,
                properties: _.properties,
                geometry: {
                    coordinates: N,
                    type: rt.LINE_STRING
                }
            }),
            z === 3)
                return
        }
        return w(_)
    }
}
;
In.onTrash = function(f) {
    this.deleteFeature([f.polygon.id], {
        silent: !0
    }),
    this.changeMode(Tt.SIMPLE_SELECT)
}
;
const En = {};
En.onSetup = function(f) {
    f = f || {};
    const _ = f.featureId;
    let w, I, z = "forward";
    if (_) {
        if (w = this.getFeature(_),
        !w)
            throw new Error("Could not find a feature with the provided featureId");
        let N = f.from;
        if (N && N.type === "Feature" && N.geometry && N.geometry.type === "Point" && (N = N.geometry),
        N && N.type === "Point" && N.coordinates && N.coordinates.length === 2 && (N = N.coordinates),
        !N || !Array.isArray(N))
            throw new Error("Please use the `from` property to indicate which point to continue the line from");
        const M = w.coordinates.length - 1;
        if (w.coordinates[M][0] === N[0] && w.coordinates[M][1] === N[1])
            I = M + 1,
            w.addCoordinate(I, ...w.coordinates[M]);
        else if (w.coordinates[0][0] === N[0] && w.coordinates[0][1] === N[1])
            z = "backwards",
            I = 0,
            w.addCoordinate(I, ...w.coordinates[0]);
        else
            throw new Error("`from` should match the point at either the start or the end of the provided LineString")
    } else
        w = this.newFeature({
            type: rt.FEATURE,
            properties: {},
            geometry: {
                type: rt.LINE_STRING,
                coordinates: []
            }
        }),
        I = 0,
        this.addFeature(w);
    return this.clearSelectedFeatures(),
    Sn.disable(this),
    this.updateUIClasses({
        mouse: ni.ADD
    }),
    this.activateUIButton(Rr.LINE),
    this.setActionableState({
        trash: !0
    }),
    {
        line: w,
        currentVertexPosition: I,
        direction: z
    }
}
;
En.clickAnywhere = function(f, _) {
    if (f.currentVertexPosition > 0 && ju(_, f.line.coordinates[f.currentVertexPosition - 1]) || f.direction === "backwards" && ju(_, f.line.coordinates[f.currentVertexPosition + 1]))
        return this.changeMode(Tt.SIMPLE_SELECT, {
            featureIds: [f.line.id]
        });
    this.updateUIClasses({
        mouse: ni.ADD
    }),
    f.line.updateCoordinate(f.currentVertexPosition, _.lngLat.lng, _.lngLat.lat),
    f.direction === "forward" ? (f.currentVertexPosition++,
    f.line.updateCoordinate(f.currentVertexPosition, _.lngLat.lng, _.lngLat.lat)) : f.line.addCoordinate(0, _.lngLat.lng, _.lngLat.lat)
}
;
En.clickOnVertex = function(f) {
    return this.changeMode(Tt.SIMPLE_SELECT, {
        featureIds: [f.line.id]
    })
}
;
En.onMouseMove = function(f, _) {
    f.line.updateCoordinate(f.currentVertexPosition, _.lngLat.lng, _.lngLat.lat),
    _c(_) && this.updateUIClasses({
        mouse: ni.POINTER
    })
}
;
En.onTap = En.onClick = function(f, _) {
    if (_c(_))
        return this.clickOnVertex(f, _);
    this.clickAnywhere(f, _)
}
;
En.onKeyUp = function(f, _) {
    Hu(_) ? this.changeMode(Tt.SIMPLE_SELECT, {
        featureIds: [f.line.id]
    }) : qu(_) && (this.deleteFeature([f.line.id], {
        silent: !0
    }),
    this.changeMode(Tt.SIMPLE_SELECT))
}
;
En.onStop = function(f) {
    Sn.enable(this),
    this.activateUIButton(),
    this.getFeature(f.line.id) !== void 0 && (f.line.removeCoordinate(`${f.currentVertexPosition}`),
    f.line.isValid() ? this.fire(xr.CREATE, {
        features: [f.line.toGeoJSON()]
    }) : (this.deleteFeature([f.line.id], {
        silent: !0
    }),
    this.changeMode(Tt.SIMPLE_SELECT, {}, {
        silent: !0
    })))
}
;
En.onTrash = function(f) {
    this.deleteFeature([f.line.id], {
        silent: !0
    }),
    this.changeMode(Tt.SIMPLE_SELECT)
}
;
En.toDisplayFeatures = function(f, _, w) {
    const I = _.properties.id === f.line.id;
    if (_.properties.active = I ? Hi.ACTIVE : Hi.INACTIVE,
    !I)
        return w(_);
    _.geometry.coordinates.length < 2 || (_.properties.meta = sr.FEATURE,
    w(ja(f.line.id, _.geometry.coordinates[f.direction === "forward" ? _.geometry.coordinates.length - 2 : 1], `${f.direction === "forward" ? _.geometry.coordinates.length - 2 : 1}`, !1)),
    w(_))
}
;
const om = {
    simple_select: Gt,
    direct_select: $t,
    draw_point: $n,
    draw_polygon: In,
    draw_line_string: En
}
  , ny = {
    defaultMode: Tt.SIMPLE_SELECT,
    keybindings: !0,
    touchEnabled: !0,
    clickBuffer: 2,
    touchBuffer: 25,
    boxSelect: !0,
    displayControlsDefault: !0,
    styles: tm,
    modes: om,
    controls: {},
    userProperties: !1,
    suppressAPIEvents: !0
}
  , sy = {
    point: !0,
    line_string: !0,
    polygon: !0,
    trash: !0,
    combine_features: !0,
    uncombine_features: !0
}
  , oy = {
    point: !1,
    line_string: !1,
    polygon: !1,
    trash: !1,
    combine_features: !1,
    uncombine_features: !1
};
function Ff(f, _) {
    return f.map(w => w.source ? w : Object.assign({}, w, {
        id: `${w.id}.${_}`,
        source: _ === "hot" ? hn.HOT : hn.COLD
    }))
}
function ay(f={}) {
    let _ = Object.assign({}, f);
    return f.controls || (_.controls = {}),
    f.displayControlsDefault === !1 ? _.controls = Object.assign({}, oy, f.controls) : _.controls = Object.assign({}, sy, f.controls),
    _ = Object.assign({}, ny, _),
    _.styles = Ff(_.styles, "cold").concat(Ff(_.styles, "hot")),
    _
}
var ud, Bf;
function ly() {
    return Bf || (Bf = 1,
    ud = function f(_, w) {
        if (_ === w)
            return !0;
        if (_ && w && typeof _ == "object" && typeof w == "object") {
            if (_.constructor !== w.constructor)
                return !1;
            var I, z, N;
            if (Array.isArray(_)) {
                if (I = _.length,
                I != w.length)
                    return !1;
                for (z = I; z-- !== 0; )
                    if (!f(_[z], w[z]))
                        return !1;
                return !0
            }
            if (_.constructor === RegExp)
                return _.source === w.source && _.flags === w.flags;
            if (_.valueOf !== Object.prototype.valueOf)
                return _.valueOf() === w.valueOf();
            if (_.toString !== Object.prototype.toString)
                return _.toString() === w.toString();
            if (N = Object.keys(_),
            I = N.length,
            I !== Object.keys(w).length)
                return !1;
            for (z = I; z-- !== 0; )
                if (!Object.prototype.hasOwnProperty.call(w, N[z]))
                    return !1;
            for (z = I; z-- !== 0; ) {
                var M = N[z];
                if (!f(_[M], w[M]))
                    return !1
            }
            return !0
        }
        return _ !== _ && w !== w
    }
    ),
    ud
}
var cy = ly();
const Of = Va(cy);
var hd, Nf;
function uy() {
    if (Nf)
        return hd;
    Nf = 1,
    hd = _;
    var f = {
        Point: "geometry",
        MultiPoint: "geometry",
        LineString: "geometry",
        MultiLineString: "geometry",
        Polygon: "geometry",
        MultiPolygon: "geometry",
        GeometryCollection: "geometry",
        Feature: "feature",
        FeatureCollection: "featurecollection"
    };
    function _(w) {
        if (!w || !w.type)
            return null;
        var I = f[w.type];
        if (!I)
            return null;
        if (I === "geometry")
            return {
                type: "FeatureCollection",
                features: [{
                    type: "Feature",
                    properties: {},
                    geometry: w
                }]
            };
        if (I === "feature")
            return {
                type: "FeatureCollection",
                features: [w]
            };
        if (I === "featurecollection")
            return w
    }
    return hd
}
var hy = uy();
const dy = Va(hy);
function am(f, _) {
    return f.length !== _.length ? !1 : JSON.stringify(f.map(w => w).sort()) === JSON.stringify(_.map(w => w).sort())
}
const py = {
    Polygon: Qr,
    LineString: qn,
    Point: Ys,
    MultiPolygon: yr,
    MultiLineString: yr,
    MultiPoint: yr
};
function fy(f, _) {
    _.modes = Tt;
    const w = f.options.suppressAPIEvents !== void 0 ? !!f.options.suppressAPIEvents : !0;
    return _.getFeatureIdsAt = function(I) {
        return Na.click({
            point: I
        }, null, f).map(N => N.properties.id)
    }
    ,
    _.getSelectedIds = function() {
        return f.store.getSelectedIds()
    }
    ,
    _.getSelected = function() {
        return {
            type: rt.FEATURE_COLLECTION,
            features: f.store.getSelectedIds().map(I => f.store.get(I)).map(I => I.toGeoJSON())
        }
    }
    ,
    _.getSelectedPoints = function() {
        return {
            type: rt.FEATURE_COLLECTION,
            features: f.store.getSelectedCoordinates().map(I => ({
                type: rt.FEATURE,
                properties: {},
                geometry: {
                    type: rt.POINT,
                    coordinates: I.coordinates
                }
            }))
        }
    }
    ,
    _.set = function(I) {
        if (I.type === void 0 || I.type !== rt.FEATURE_COLLECTION || !Array.isArray(I.features))
            throw new Error("Invalid FeatureCollection");
        const z = f.store.createRenderBatch();
        let N = f.store.getAllIds().slice();
        const M = _.add(I)
          , l = new pn(M);
        return N = N.filter(ce => !l.has(ce)),
        N.length && _.delete(N),
        z(),
        M
    }
    ,
    _.add = function(I) {
        const N = JSON.parse(JSON.stringify(dy(I))).features.map(M => {
            if (M.id = M.id || Ad(),
            M.geometry === null)
                throw new Error("Invalid geometry: null");
            if (f.store.get(M.id) === void 0 || f.store.get(M.id).type !== M.geometry.type) {
                const l = py[M.geometry.type];
                if (l === void 0)
                    throw new Error(`Invalid geometry type: ${M.geometry.type}.`);
                const ce = new l(f,M);
                f.store.add(ce, {
                    silent: w
                })
            } else {
                const l = f.store.get(M.id)
                  , ce = l.properties;
                l.properties = M.properties,
                Of(ce, M.properties) || f.store.featureChanged(l.id, {
                    silent: w
                }),
                Of(l.getCoordinates(), M.geometry.coordinates) || l.incomingCoords(M.geometry.coordinates)
            }
            return M.id
        }
        );
        return f.store.render(),
        N
    }
    ,
    _.get = function(I) {
        const z = f.store.get(I);
        if (z)
            return z.toGeoJSON()
    }
    ,
    _.getAll = function() {
        return {
            type: rt.FEATURE_COLLECTION,
            features: f.store.getAll().map(I => I.toGeoJSON())
        }
    }
    ,
    _.delete = function(I) {
        return f.store.delete(I, {
            silent: w
        }),
        _.getMode() === Tt.DIRECT_SELECT && !f.store.getSelectedIds().length ? f.events.changeMode(Tt.SIMPLE_SELECT, void 0, {
            silent: w
        }) : f.store.render(),
        _
    }
    ,
    _.deleteAll = function() {
        return f.store.delete(f.store.getAllIds(), {
            silent: w
        }),
        _.getMode() === Tt.DIRECT_SELECT ? f.events.changeMode(Tt.SIMPLE_SELECT, void 0, {
            silent: w
        }) : f.store.render(),
        _
    }
    ,
    _.changeMode = function(I, z={}) {
        return I === Tt.SIMPLE_SELECT && _.getMode() === Tt.SIMPLE_SELECT ? (am(z.featureIds || [], f.store.getSelectedIds()) || (f.store.setSelected(z.featureIds, {
            silent: w
        }),
        f.store.render()),
        _) : (I === Tt.DIRECT_SELECT && _.getMode() === Tt.DIRECT_SELECT && z.featureId === f.store.getSelectedIds()[0] || f.events.changeMode(I, z, {
            silent: w
        }),
        _)
    }
    ,
    _.getMode = function() {
        return f.events.getMode()
    }
    ,
    _.trash = function() {
        return f.events.trash({
            silent: w
        }),
        _
    }
    ,
    _.combineFeatures = function() {
        return f.events.combineFeatures({
            silent: w
        }),
        _
    }
    ,
    _.uncombineFeatures = function() {
        return f.events.uncombineFeatures({
            silent: w
        }),
        _
    }
    ,
    _.setFeatureProperty = function(I, z, N) {
        return f.store.setFeatureProperty(I, z, N, {
            silent: w
        }),
        _
    }
    ,
    _
}
const my = Object.freeze(Object.defineProperty({
    __proto__: null,
    CommonSelectors: iy,
    ModeHandler: xd,
    StringSet: pn,
    constrainFeatureMovement: Dd,
    createMidPoint: rm,
    createSupplementaryPoints: Wu,
    createVertex: ja,
    doubleClickZoom: Sn,
    euclideanDistance: Ed,
    featuresAt: Na,
    getFeatureAtAndSetCursors: Fu,
    isClick: wd,
    isEventAtCoordinates: ju,
    isTap: Td,
    mapEventToBoundingBox: Jf,
    moveFeatures: Rd,
    sortFeatures: Kf,
    stringSetsAreEqual: am,
    theme: tm,
    toDenseArray: gc
}, Symbol.toStringTag, {
    value: "Module"
}))
  , gy = function(f, _) {
    f = ay(f);
    const w = {
        options: f
    };
    _ = fy(w, _),
    w.api = _;
    const I = ey(w);
    return _.onAdd = I.onAdd,
    _.onRemove = I.onRemove,
    _.types = Rr,
    _.options = f,
    _
};
function fn(f) {
    gy(f, this)
}
fn.modes = om;
fn.constants = Xf;
fn.lib = my;
var dd = {
    exports: {}
}, jf;
function _y() {
    if (jf)
        return dd.exports;
    jf = 1;
    var f = dd.exports = function(_, w) {
        if (w || (w = 16),
        _ === void 0 && (_ = 128),
        _ <= 0)
            return "0";
        for (var I = Math.log(Math.pow(2, _)) / Math.log(w), z = 2; I === 1 / 0; z *= 2)
            I = Math.log(Math.pow(2, _ / z)) / Math.log(w) * z;
        for (var N = I - Math.floor(I), M = "", z = 0; z < Math.floor(I); z++) {
            var l = Math.floor(Math.random() * w).toString(w);
            M = l + M
        }
        if (N) {
            var ce = Math.pow(w, N)
              , l = Math.floor(Math.random() * ce).toString(w);
            M = l + M
        }
        var de = parseInt(M, w);
        return de !== 1 / 0 && de >= Math.pow(2, _) ? f(_, w) : M
    }
    ;
    return f.rack = function(_, w, I) {
        var z = function(M) {
            var l = 0;
            do {
                if (l++ > 10)
                    if (I)
                        _ += I;
                    else
                        throw new Error("too many ID collisions, use more bits");
                var ce = f(_, w)
            } while (Object.hasOwnProperty.call(N, ce));
            return N[ce] = M,
            ce
        }
          , N = z.hats = {};
        return z.get = function(M) {
            return z.hats[M]
        }
        ,
        z.set = function(M, l) {
            return z.hats[M] = l,
            z
        }
        ,
        z.bits = _ || 128,
        z.base = w || 16,
        z
    }
    ,
    dd.exports
}
var yy = _y();
const xy = Va(yy);
var pd = {
    exports: {}
}, Vf;
function vy() {
    return Vf || (Vf = 1,
    function(f) {
        var _ = Math.PI / 180
          , w = 180 / Math.PI
          , I = function(ce, de) {
            this.lon = ce,
            this.lat = de,
            this.x = _ * ce,
            this.y = _ * de
        }
          , z = function(ce) {
            for (var de = 6, ge = Math.pow(10, de), ze = 0; ze < ce.length; ze++)
                ce[ze] = Math.round((ce[ze] + Number.EPSILON) * ge) / ge;
            return ce
        };
        I.prototype.view = function() {
            return String(this.lon).slice(0, 4) + "," + String(this.lat).slice(0, 4)
        }
        ,
        I.prototype.antipode = function() {
            var ce = -1 * this.lat
              , de = this.lon < 0 ? 180 + this.lon : (180 - this.lon) * -1;
            return new I(de,ce)
        }
        ;
        var N = function() {
            this.coords = [],
            this.length = 0
        };
        N.prototype.move_to = function(ce) {
            this.length++,
            this.coords.push(ce)
        }
        ;
        var M = function(ce) {
            this.properties = ce || {},
            this.geometries = []
        };
        M.prototype.json = function() {
            if (this.geometries.length <= 0)
                return {
                    geometry: {
                        type: "LineString",
                        coordinates: null
                    },
                    type: "Feature",
                    properties: this.properties
                };
            if (this.geometries.length == 1)
                return {
                    geometry: {
                        type: "LineString",
                        coordinates: this.geometries[0].coords
                    },
                    type: "Feature",
                    properties: this.properties
                };
            for (var ce = [], de = 0; de < this.geometries.length; de++)
                ce.push(this.geometries[de].coords);
            return {
                geometry: {
                    type: "MultiLineString",
                    coordinates: ce
                },
                type: "Feature",
                properties: this.properties
            }
        }
        ,
        M.prototype.wkt = function() {
            for (var ce = "", de = "LINESTRING(", ge = function(Y) {
                de += Y[0] + " " + Y[1] + ","
            }, ze = 0; ze < this.geometries.length; ze++) {
                if (this.geometries[ze].coords.length === 0)
                    return "LINESTRING(empty)";
                var oe = this.geometries[ze].coords;
                oe.forEach(ge),
                ce += de.substring(0, de.length - 1) + ")"
            }
            return ce
        }
        ;
        var l = function(ce, de, ge) {
            if (!ce || ce.x === void 0 || ce.y === void 0)
                throw new Error("GreatCircle constructor expects two args: start and end objects with x and y properties");
            if (!de || de.x === void 0 || de.y === void 0)
                throw new Error("GreatCircle constructor expects two args: start and end objects with x and y properties");
            this.start = new I(ce.x,ce.y),
            this.end = new I(de.x,de.y),
            this.properties = ge || {};
            var ze = this.start.x - this.end.x
              , oe = this.start.y - this.end.y
              , Y = Math.pow(Math.sin(oe / 2), 2) + Math.cos(this.start.y) * Math.cos(this.end.y) * Math.pow(Math.sin(ze / 2), 2);
            if (this.g = 2 * Math.asin(Math.sqrt(Y)),
            this.g == Math.PI)
                throw new Error("it appears " + this.start.view() + " and " + this.end.view() + " are 'antipodal', e.g diametrically opposite, thus there is no single route but rather infinite");
            if (isNaN(this.g))
                throw new Error("could not calculate great circle between " + ce + " and " + de)
        };
        l.prototype.interpolate = function(ce) {
            var de = Math.sin((1 - ce) * this.g) / Math.sin(this.g)
              , ge = Math.sin(ce * this.g) / Math.sin(this.g)
              , ze = de * Math.cos(this.start.y) * Math.cos(this.start.x) + ge * Math.cos(this.end.y) * Math.cos(this.end.x)
              , oe = de * Math.cos(this.start.y) * Math.sin(this.start.x) + ge * Math.cos(this.end.y) * Math.sin(this.end.x)
              , Y = de * Math.sin(this.start.y) + ge * Math.sin(this.end.y)
              , Te = w * Math.atan2(Y, Math.sqrt(Math.pow(ze, 2) + Math.pow(oe, 2)))
              , He = w * Math.atan2(oe, ze);
            return [He, Te]
        }
        ,
        l.prototype.Arc = function(ce, de) {
            var ge = [];
            if (!ce || ce <= 2)
                ge.push([this.start.lon, this.start.lat]),
                ge.push([this.end.lon, this.end.lat]);
            else
                for (var ze = 1 / (ce - 1), oe = 0; oe < ce; ++oe) {
                    var Y = ze * oe
                      , Te = this.interpolate(Y);
                    ge.push(Te)
                }
            for (var He = !1, ft = 0, Pt = de && de.offset ? de.offset : 10, vt = 180 - Pt, St = -180 + Pt, Wt = 360 - Pt, pi = 1; pi < ge.length; ++pi) {
                var Mt = ge[pi - 1][0]
                  , gt = ge[pi][0]
                  , It = Math.abs(gt - Mt);
                It > Wt && (gt > vt && Mt < St || Mt > vt && gt < St) ? He = !0 : It > ft && (ft = It)
            }
            var Pi = [];
            if (He && ft < Pt) {
                var ei = [];
                Pi.push(ei);
                for (var nt = 0; nt < ge.length; ++nt) {
                    var Wi = parseFloat(ge[nt][0]);
                    if (nt > 0 && Math.abs(Wi - ge[nt - 1][0]) > Wt) {
                        var Lt = parseFloat(ge[nt - 1][0])
                          , ti = parseFloat(ge[nt - 1][1])
                          , fi = parseFloat(ge[nt][0])
                          , ut = parseFloat(ge[nt][1]);
                        if (Lt > -180 && Lt < St && fi == 180 && nt + 1 < ge.length && ge[nt - 1][0] > -180 && ge[nt - 1][0] < St) {
                            ei.push([-180, ge[nt][1]]),
                            nt++,
                            ei.push([ge[nt][0], ge[nt][1]]);
                            continue
                        } else if (Lt > vt && Lt < 180 && fi == -180 && nt + 1 < ge.length && ge[nt - 1][0] > vt && ge[nt - 1][0] < 180) {
                            ei.push([180, ge[nt][1]]),
                            nt++,
                            ei.push([ge[nt][0], ge[nt][1]]);
                            continue
                        }
                        if (Lt < St && fi > vt) {
                            var or = Lt;
                            Lt = fi,
                            fi = or;
                            var ar = ti;
                            ti = ut,
                            ut = ar
                        }
                        if (Lt > vt && fi < St && (fi += 360),
                        Lt <= 180 && fi >= 180 && Lt < fi) {
                            var mi = (180 - Lt) / (fi - Lt)
                              , wr = mi * ut + (1 - mi) * ti;
                            ei.push([ge[nt - 1][0] > vt ? 180 : -180, wr]),
                            ei = [],
                            ei.push([ge[nt - 1][0] > vt ? -180 : 180, wr]),
                            Pi.push(ei)
                        } else
                            ei = [],
                            Pi.push(ei);
                        ei.push([Wi, ge[nt][1]])
                    } else
                        ei.push([ge[nt][0], ge[nt][1]])
                }
            } else {
                var Br = [];
                Pi.push(Br);
                for (var gi = 0; gi < ge.length; ++gi)
                    Br.push([ge[gi][0], ge[gi][1]])
            }
            for (var si = new M(this.properties), _i = 0; _i < Pi.length; ++_i) {
                var Ft = new N;
                si.geometries.push(Ft);
                for (var Yi = Pi[_i], Xi = 0; Xi < Yi.length; ++Xi)
                    Ft.move_to(z(Yi[Xi]))
            }
            return si
        }
        ,
        f.exports.Coord = I,
        f.exports.Arc = M,
        f.exports.GreatCircle = l
    }(pd)),
    pd.exports
}
var fd, Uf;
function by() {
    return Uf || (Uf = 1,
    fd = vy()),
    fd
}
var wy = by();
const Ty = Va(wy)
  , lm = 6371e3;
function My(f, _) {
    return !(Math.abs(f[0] - _[0]) > Number.EPSILON || Math.abs(f[1] - _[1]) > Number.EPSILON)
}
function Fr(f) {
    return f / 180 * Math.PI
}
function pc(f) {
    return f / Math.PI * 180
}
function Cy(f) {
    return (f + 360) % 360
}
function Py(f, _, w=lm) {
    const I = w
      , z = Fr(f[1])
      , N = Fr(f[0])
      , M = Fr(_[1])
      , l = Fr(_[0])
      , ce = M - z
      , de = l - N
      , ge = Math.sin(ce / 2) * Math.sin(ce / 2) + Math.cos(z) * Math.cos(M) * Math.sin(de / 2) * Math.sin(de / 2)
      , ze = 2 * Math.atan2(Math.sqrt(ge), Math.sqrt(1 - ge));
    return I * ze
}
function cm(f, _) {
    if (My(f, _))
        return NaN;
    const w = Fr(f[1])
      , I = Fr(_[1])
      , z = Fr(_[0] - f[0])
      , N = Math.cos(w) * Math.sin(I) - Math.sin(w) * Math.cos(I) * Math.cos(z)
      , M = Math.sin(z) * Math.cos(I)
      , l = Math.atan2(M, N)
      , ce = pc(l);
    return Cy(ce)
}
function Sy(f, _) {
    const w = Fr(f[1])
      , I = Fr(f[0])
      , z = Fr(_[1])
      , N = Fr(_[0] - f[0])
      , M = {
        x: Math.cos(w),
        y: 0,
        z: Math.sin(w)
    }
      , l = {
        x: Math.cos(z) * Math.cos(N),
        y: Math.cos(z) * Math.sin(N),
        z: Math.sin(z)
    }
      , ce = {
        x: M.x + l.x,
        y: M.y + l.y,
        z: M.z + l.z
    }
      , de = Math.atan2(ce.z, Math.sqrt(ce.x * ce.x + ce.y * ce.y))
      , ge = I + Math.atan2(ce.y, ce.x)
      , ze = pc(de);
    return [pc(ge), ze]
}
function Iy(f, _, w, I=lm) {
    const z = _ / I
      , N = Fr(w)
      , M = Fr(f[1])
      , l = Fr(f[0])
      , ce = Math.sin(M) * Math.cos(z) + Math.cos(M) * Math.sin(z) * Math.cos(N)
      , de = Math.asin(ce)
      , ge = Math.sin(N) * Math.sin(z) * Math.cos(M)
      , ze = Math.cos(z) - Math.sin(M) * ce
      , oe = l + Math.atan2(ge, ze)
      , Y = pc(de);
    return [pc(oe), Y]
}
const {cursors: um, geojsonTypes: dn, events: Ey, meta: Ay, activeStates: Md} = fn.constants
  , _r = {
    ...fn.constants.modes,
    DRAW_CIRCLE: "draw_circle"
}
  , bs = {
    CIRCLE_RADIUS: "circleRadius",
    CIRCLE_HANDLE_BEARING: "circleHandleBearing"
};
function zy(f, _) {
    let w = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};
    if (!(_ > 0))
        throw new Error("Radius has to be greater then 0");
    return {
        id: xy(),
        type: dn.FEATURE,
        properties: {
            [bs.CIRCLE_RADIUS]: _,
            ...w
        },
        geometry: {
            type: dn.POLYGON,
            coordinates: [[f, f, f, f]]
        }
    }
}
function hm(f, _) {
    return f === dn.POLYGON && typeof _[bs.CIRCLE_RADIUS] == "number" && _[bs.CIRCLE_RADIUS] > 0
}
function Fd(f) {
    return hm(f.geometry.type, f.properties)
}
function Bd(f) {
    if (!Fd(f))
        throw new Error("GeoJSON is not a circle");
    return f.geometry.coordinates[0][0]
}
function ky(f) {
    if (!Fd(f))
        throw new Error("GeoJSON is not a circle");
    return f.properties[bs.CIRCLE_RADIUS]
}
function dm(f, _) {
    return f[0] === _[0] && f[1] === _[1]
}
function Ly(f) {
    return f.slice(0, -1).map( (_, w) => [_, f[w + 1]]).filter(_ => !dm(_[0], _[1]))
}
function Zf(f) {
    let _ = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 32;
    const I = Ly(f).map(M => new Ty.GreatCircle({
        x: M[0][0],
        y: M[0][1]
    },{
        x: M[1][0],
        y: M[1][1]
    }).Arc(_, {
        offset: 90
    }).json());
    let z = 0;
    const N = I.map(M => {
        if (M.geometry.type === dn.MULTI_LINE_STRING) {
            const l = z
              , ce = z + (M.geometry.coordinates[0][0][0] > M.geometry.coordinates[1][0][0] ? 1 : -1)
              , de = [...M.geometry.coordinates[0].map(ge => [ge[0] + l * 360, ge[1]]), ...M.geometry.coordinates[1].map(ge => [ge[0] + ce * 360, ge[1]])];
            return z = ce,
            de
        } else
            return M.geometry.coordinates.map(ce => [ce[0] + z * 360, ce[1]])
    }
    ).flat();
    return N.filter( (M, l) => l === N.length - 1 || !dm(M, N[l + 1]))
}
const pm = 6371.0088;
function fm(f, _) {
    return Py(f, _, pm)
}
function mm(f, _, w) {
    return Iy(f, _, w, pm)
}
function Dy(f, _, w, I) {
    const z = [];
    for (let N = 0; N < I; ++N)
        z.push(mm(f, _, w + 360 * -N / I));
    return z.push(z[0]),
    z
}
const Ry = 32
  , Fy = 45;
function Gf(f) {
    return hm(f.type, f.properties)
}
function By(f) {
    return f.split(".").map( (_, w, I) => w === I.length - 1 ? (parseInt(_, 10) - 1).toString() : _).join(".")
}
function Oy(f, _) {
    if (f.type === dn.POLYGON || f.type === dn.MULTI_POLYGON)
        try {
            return f.getCoordinate(_),
            _
        } catch {
            return _.split(".").map( (I, z, N) => z === N.length - 1 ? "0" : I).join(".")
        }
    else
        return _
}
function Qs(f, _) {
    _ = {
        steps: Ry,
        ..._
    };
    const w = f.properties
      , I = f.geometry.type
      , z = f.geometry.coordinates
      , N = w.parent || w.id
      , M = _.ctx.store.get(N);
    if (I === dn.POINT)
        return Gf(M) ? [] : w.meta === Ay.MIDPOINT ? ce() : [f];
    if (I === dn.LINE_STRING)
        return de();
    if (I === dn.POLYGON)
        return Gf(M) ? ze() : ge();
    if (I.indexOf(dn.MULTI_PREFIX) === 0)
        return oe();
    function l(Y) {
        return _.selectedPaths ? _.selectedPaths.indexOf(Y) !== -1 : !1
    }
    function ce() {
        const Y = w.coord_path
          , Te = By(Y)
          , He = Oy(M, Y)
          , ft = M.getCoordinate(Te)
          , Pt = M.getCoordinate(He)
          , vt = Sy(ft, Pt);
        return [{
            ...f,
            properties: {
                ...w,
                lng: vt[0],
                lat: vt[1]
            },
            geometry: {
                ...f.geometry,
                coordinates: vt
            }
        }]
    }
    function de() {
        const Y = Zf(z, _.steps);
        return [{
            ...f,
            geometry: {
                ...f.geometry,
                coordinates: Y
            }
        }]
    }
    function ge() {
        const Y = z.map(He => Zf(He));
        return [{
            ...f,
            geometry: {
                ...f.geometry,
                coordinates: Y
            }
        }]
    }
    function ze() {
        const Y = M.toGeoJSON()
          , Te = Bd(Y)
          , He = ky(Y)
          , ft = M[bs.CIRCLE_HANDLE_BEARING] || Fy
          , Pt = Dy(Te, He, ft, _.steps * 4)
          , vt = {
            ...f,
            geometry: {
                ...f.geometry,
                coordinates: [Pt]
            }
        };
        if (w.active === Md.ACTIVE) {
            const St = mm(Te, He, ft)
              , pi = [Te, St].map( (Mt, gt) => fn.lib.createVertex(w.id, Mt, `0.${gt}`, l(`0.${gt}`)));
            return [vt, ...pi]
        } else
            return [vt]
    }
    function oe() {
        const Y = I.replace(dn.MULTI_PREFIX, "")
          , He = z.map(Pt => {
            const vt = {
                type: dn.FEATURE,
                properties: w,
                geometry: {
                    type: Y,
                    coordinates: Pt
                }
            };
            return Qs(vt, _)
        }
        ).flat().map(Pt => Pt.geometry.coordinates);
        return [{
            ...f,
            geometry: {
                ...f.geometry,
                coordinates: He
            }
        }]
    }
}
function Ny(f) {
    const _ = {
        ...f
    };
    return _.toDisplayFeatures = function(w, I, z) {
        const N = M => {
            Qs(M, {
                ctx: this._ctx
            }).forEach(z)
        }
        ;
        f.toDisplayFeatures.call(this, w, I, N)
    }
    ,
    _
}
function jy(f) {
    const _ = {
        ...f
    };
    return _.toDisplayFeatures = function(w, I, z) {
        const N = M => {
            Qs(M, {
                ctx: this._ctx
            }).forEach(z)
        }
        ;
        f.toDisplayFeatures.call(this, w, I, N)
    }
    ,
    _
}
const gm = {
    enable(f) {
        setTimeout( () => {
            !f.map || !f.map.dragPan || !f._ctx || !f._ctx.store || !f._ctx.store.getInitialConfigValue || f._ctx.store.getInitialConfigValue("dragPan") && f.map.dragPan.enable()
        }
        , 0)
    },
    disable(f) {
        setTimeout( () => {
            !f.map || !f.map.doubleClickZoom || f.map.dragPan.disable()
        }
        , 0)
    }
}
  , An = {};
An.onSetup = function(f) {
    return this.clearSelectedFeatures(),
    fn.lib.doubleClickZoom.disable(this),
    gm.disable(this),
    this.updateUIClasses({
        mouse: um.ADD
    }),
    this.setActionableState(),
    {}
}
;
An.onMouseDown = An.onTouchStart = function(f, _) {
    const w = [_.lngLat.lng, _.lngLat.lat]
      , I = this.newFeature(zy(w, Number.EPSILON));
    this.addFeature(I),
    f.circle = I
}
;
An.onDrag = An.onTouchMove = function(f, _) {
    if (f.circle) {
        const w = f.circle.toGeoJSON()
          , I = Bd(w)
          , z = [_.lngLat.lng, _.lngLat.lat]
          , N = fm(I, z)
          , M = cm(I, z);
        f.circle.properties[bs.CIRCLE_RADIUS] = N,
        f.circle[bs.CIRCLE_HANDLE_BEARING] = M,
        f.circle.changed()
    }
}
;
An.onMouseUp = An.onTouchEnd = function(f, _) {
    return this.map.fire(Ey.CREATE, {
        features: [f.circle.toGeoJSON()]
    }),
    this.changeMode(_r.SIMPLE_SELECT, {
        featureIds: [f.circle.id]
    })
}
;
An.onKeyUp = function(f, _) {
    fn.lib.CommonSelectors.isEscapeKey(_) ? (f.circle && this.deleteFeature([f.circle.id], {
        silent: !0
    }),
    this.changeMode(_r.SIMPLE_SELECT)) : fn.lib.CommonSelectors.isEnterKey(_) && this.changeMode(_r.SIMPLE_SELECT, {
        featureIds: [f.circle.id]
    })
}
;
An.onStop = function() {
    this.updateUIClasses({
        mouse: um.NONE
    }),
    fn.lib.doubleClickZoom.enable(this),
    gm.enable(this),
    this.activateUIButton()
}
;
An.toDisplayFeatures = function(f, _, w) {
    if (f.circle) {
        const z = _.properties.id === f.circle.id;
        _.properties.active = z ? Md.ACTIVE : Md.INACTIVE
    }
    (z => {
        Qs(z, {
            ctx: this._ctx
        }).forEach(w)
    }
    )(_)
}
;
function Vy(f) {
    const _ = {
        ...f
    };
    return _.toDisplayFeatures = function(w, I, z) {
        const N = M => {
            Qs(M, {
                ctx: this._ctx
            }).forEach(z)
        }
        ;
        f.toDisplayFeatures.call(this, w, I, N)
    }
    ,
    _
}
function Uy(f) {
    const _ = {
        ...f
    };
    return _.toDisplayFeatures = function(w, I, z) {
        const N = M => {
            Qs(M, {
                ctx: this._ctx
            }).forEach(z)
        }
        ;
        f.toDisplayFeatures.call(this, w, I, N)
    }
    ,
    _
}
function Zy(f) {
    const _ = {
        ...f
    };
    return _.dragVertex = function(w, I, z) {
        const N = w.feature.toGeoJSON();
        if (Fd(N))
            if (w.selectedCoordPaths[0] === "0.1") {
                const M = Bd(N)
                  , l = [I.lngLat.lng, I.lngLat.lat]
                  , ce = fm(M, l)
                  , de = cm(M, l);
                w.feature.properties[bs.CIRCLE_RADIUS] = ce,
                w.feature[bs.CIRCLE_HANDLE_BEARING] = de,
                w.feature.changed()
            } else
                f.dragFeature.call(this, w, I, z);
        else
            f.dragVertex.call(this, w, I, z)
    }
    ,
    _.toDisplayFeatures = function(w, I, z) {
        const N = M => {
            Qs(M, {
                ctx: this._ctx,
                selectedPaths: w.selectedCoordPaths
            }).forEach(z)
        }
        ;
        f.toDisplayFeatures.call(this, w, I, N)
    }
    ,
    _
}
const Od = {};
Od.onSetup = function() {
    return this.setActionableState(),
    {}
}
;
Od.toDisplayFeatures = function(f, _, w) {
    (z => {
        Qs(z, {
            ctx: this._ctx
        }).forEach(w)
    }
    )(_)
}
;
function Gy(f) {
    return {
        ...f,
        [_r.DRAW_LINE_STRING]: Ny(f[_r.DRAW_LINE_STRING]),
        [_r.DRAW_POLYGON]: jy(f[_r.DRAW_POLYGON]),
        [_r.DRAW_CIRCLE]: An,
        [_r.DRAW_POINT]: Vy(f[_r.DRAW_POINT]),
        [_r.SIMPLE_SELECT]: Uy(f[_r.SIMPLE_SELECT]),
        [_r.DIRECT_SELECT]: Zy(f[_r.DIRECT_SELECT]),
        [_r.STATIC]: Od
    }
}
var Kr = 63710088e-1
  , _m = {
    centimeters: Kr * 100,
    centimetres: Kr * 100,
    degrees: 360 / (2 * Math.PI),
    feet: Kr * 3.28084,
    inches: Kr * 39.37,
    kilometers: Kr / 1e3,
    kilometres: Kr / 1e3,
    meters: Kr,
    metres: Kr,
    miles: Kr / 1609.344,
    millimeters: Kr * 1e3,
    millimetres: Kr * 1e3,
    nauticalmiles: Kr / 1852,
    radians: 1,
    yards: Kr * 1.0936
};
function Vu(f, _, w={}) {
    const I = {
        type: "Feature"
    };
    return (w.id === 0 || w.id) && (I.id = w.id),
    w.bbox && (I.bbox = w.bbox),
    I.properties = _ || {},
    I.geometry = f,
    I
}
function $y(f, _, w={}) {
    if (!f)
        throw new Error("coordinates is required");
    if (!Array.isArray(f))
        throw new Error("coordinates must be an Array");
    if (f.length < 2)
        throw new Error("coordinates must be at least 2 numbers long");
    if (!$f(f[0]) || !$f(f[1]))
        throw new Error("coordinates must contain numbers");
    return Vu({
        type: "Point",
        coordinates: f
    }, _, w)
}
function qy(f, _, w={}) {
    if (f.length < 2)
        throw new Error("coordinates must be an array of two or more positions");
    return Vu({
        type: "LineString",
        coordinates: f
    }, _, w)
}
function Hy(f, _={}) {
    const w = {
        type: "FeatureCollection"
    };
    return _.id && (w.id = _.id),
    _.bbox && (w.bbox = _.bbox),
    w.features = f,
    w
}
function Wy(f, _="kilometers") {
    const w = _m[_];
    if (!w)
        throw new Error(_ + " units is invalid");
    return f * w
}
function Xy(f, _="kilometers") {
    const w = _m[_];
    if (!w)
        throw new Error(_ + " units is invalid");
    return f / w
}
function Cd(f) {
    return f % (2 * Math.PI) * 180 / Math.PI
}
function Pn(f) {
    return f % 360 * Math.PI / 180
}
function $f(f) {
    return !isNaN(f) && f !== null && !Array.isArray(f)
}
function fc(f) {
    if (!f)
        throw new Error("coord is required");
    if (!Array.isArray(f)) {
        if (f.type === "Feature" && f.geometry !== null && f.geometry.type === "Point")
            return [...f.geometry.coordinates];
        if (f.type === "Point")
            return [...f.coordinates]
    }
    if (Array.isArray(f) && f.length >= 2 && !Array.isArray(f[0]) && !Array.isArray(f[1]))
        return [...f];
    throw new Error("coord must be GeoJSON Point or an Array of numbers")
}
function qf(f) {
    if (Array.isArray(f))
        return f;
    if (f.type === "Feature") {
        if (f.geometry !== null)
            return f.geometry.coordinates
    } else if (f.coordinates)
        return f.coordinates;
    throw new Error("coords must be GeoJSON Feature, Geometry Object or an Array")
}
function ym(f, _, w={}) {
    var I = fc(f)
      , z = fc(_)
      , N = Pn(z[1] - I[1])
      , M = Pn(z[0] - I[0])
      , l = Pn(I[1])
      , ce = Pn(z[1])
      , de = Math.pow(Math.sin(N / 2), 2) + Math.pow(Math.sin(M / 2), 2) * Math.cos(l) * Math.cos(ce);
    return Wy(2 * Math.atan2(Math.sqrt(de), Math.sqrt(1 - de)), w.units)
}
var Ky = ym;
function xm(f, _, w={}) {
    if (w.final === !0)
        return Jy(f, _);
    const I = fc(f)
      , z = fc(_)
      , N = Pn(I[0])
      , M = Pn(z[0])
      , l = Pn(I[1])
      , ce = Pn(z[1])
      , de = Math.sin(M - N) * Math.cos(ce)
      , ge = Math.cos(l) * Math.sin(ce) - Math.sin(l) * Math.cos(ce) * Math.cos(M - N);
    return Cd(Math.atan2(de, ge))
}
function Jy(f, _) {
    let w = xm(_, f);
    return w = (w + 180) % 360,
    w
}
function Yy(f, _, w, I={}) {
    const z = fc(f)
      , N = Pn(z[0])
      , M = Pn(z[1])
      , l = Pn(w)
      , ce = Xy(_, I.units)
      , de = Math.asin(Math.sin(M) * Math.cos(ce) + Math.cos(M) * Math.sin(ce) * Math.cos(l))
      , ge = N + Math.atan2(Math.sin(l) * Math.sin(ce) * Math.cos(M), Math.cos(ce) - Math.sin(M) * Math.sin(de))
      , ze = Cd(ge)
      , oe = Cd(de);
    return $y([ze, oe], I.properties)
}
function Qy(f, _) {
    const w = ym(f, _)
      , I = xm(f, _);
    return Yy(f, w / 2, I)
}
var ex = Qy;
function tx(f, _) {
    var w, I, z, N, M, l, ce, de, ge, ze, oe = 0, Y = f.type === "FeatureCollection", Te = f.type === "Feature", He = Y ? f.features.length : 1;
    for (w = 0; w < He; w++) {
        for (l = Y ? f.features[w].geometry : Te ? f.geometry : f,
        de = Y ? f.features[w].properties : Te ? f.properties : {},
        ge = Y ? f.features[w].bbox : Te ? f.bbox : void 0,
        ze = Y ? f.features[w].id : Te ? f.id : void 0,
        ce = l ? l.type === "GeometryCollection" : !1,
        M = ce ? l.geometries.length : 1,
        z = 0; z < M; z++) {
            if (N = ce ? l.geometries[z] : l,
            N === null) {
                if (_(null, oe, de, ge, ze) === !1)
                    return !1;
                continue
            }
            switch (N.type) {
            case "Point":
            case "LineString":
            case "MultiPoint":
            case "Polygon":
            case "MultiLineString":
            case "MultiPolygon":
                {
                    if (_(N, oe, de, ge, ze) === !1)
                        return !1;
                    break
                }
            case "GeometryCollection":
                {
                    for (I = 0; I < N.geometries.length; I++)
                        if (_(N.geometries[I], oe, de, ge, ze) === !1)
                            return !1;
                    break
                }
            default:
                throw new Error("Unknown Geometry Type")
            }
        }
        oe++
    }
}
function ix(f, _) {
    tx(f, function(w, I, z, N, M) {
        var l = w === null ? null : w.type;
        switch (l) {
        case null:
        case "Point":
        case "LineString":
        case "Polygon":
            return _(Vu(w, z, {
                bbox: N,
                id: M
            }), I, 0) === !1 ? !1 : void 0
        }
        var ce;
        switch (l) {
        case "MultiPoint":
            ce = "Point";
            break;
        case "MultiLineString":
            ce = "LineString";
            break;
        case "MultiPolygon":
            ce = "Polygon";
            break
        }
        for (var de = 0; de < w.coordinates.length; de++) {
            var ge = w.coordinates[de]
              , ze = {
                type: ce,
                coordinates: ge
            };
            if (_(Vu(ze, z), I, de) === !1)
                return !1
        }
    })
}
function rx(f) {
    if (!f)
        throw new Error("geojson is required");
    const _ = [];
    return ix(f, w => {
        nx(w, _)
    }
    ),
    Hy(_)
}
function nx(f, _) {
    let w = [];
    const I = f.geometry;
    if (I !== null) {
        switch (I.type) {
        case "Polygon":
            w = qf(I);
            break;
        case "LineString":
            w = [qf(I)]
        }
        w.forEach(z => {
            sx(z, f.properties).forEach(M => {
                M.id = _.length,
                _.push(M)
            }
            )
        }
        )
    }
}
function sx(f, _) {
    const w = [];
    return f.reduce( (I, z) => {
        const N = qy([I, z], _);
        return N.bbox = ox(I, z),
        w.push(N),
        z
    }
    ),
    w
}
function ox(f, _) {
    const w = f[0]
      , I = f[1]
      , z = _[0]
      , N = _[1]
      , M = w < z ? w : z
      , l = I < N ? I : N
      , ce = w > z ? w : z
      , de = I > N ? I : N;
    return [M, l, ce, de]
}
var ax = rx;
class lx {
    drawCtrl;
    map;
    startMeasurement(_) {
        this.drawCtrl.deleteAll();
        let w = this.drawCtrl.add({
            type: "LineString",
            coordinates: [_.toArray()]
        })[0];
        this.drawCtrl.changeMode(this.drawCtrl.modes.DRAW_LINE_STRING, {
            featureId: w,
            from: _.toArray()
        })
    }
    onAdd(_) {
        return this.map = _,
        this.drawCtrl = new fn({
            displayControlsDefault: !1,
            userProperties: !0,
            modes: Gy(fn.modes),
            styles: [{
                id: "lines",
                type: "line",
                filter: ["all", ["==", "$type", "LineString"]],
                layout: {
                    "line-cap": "round",
                    "line-join": "round"
                },
                paint: {
                    "line-color": "#D20000",
                    "line-dasharray": [.2, 2],
                    "line-width": 2
                }
            }, {
                id: "endpoints",
                type: "circle",
                filter: ["all", ["==", "meta", "vertex"], ["==", "$type", "Point"]],
                paint: {
                    "circle-radius": 3,
                    "circle-color": "#D20000"
                }
            }, {
                id: "labels",
                type: "symbol",
                filter: ["all", ["==", "$type", "Point"], ["has", "user_measurement"]],
                layout: {
                    "text-font": ["NotoSans-Medium"],
                    "text-field": ["get", "user_measurement"],
                    "text-variable-anchor": ["center", "top", "bottom", "left", "right"],
                    "text-radial-offset": .5,
                    "text-justify": "right",
                    "text-size": 18
                },
                paint: {
                    "text-color": "#000",
                    "text-halo-color": "#fff",
                    "text-halo-width": 3
                }
            }]
        }),
        _.addControl(this.drawCtrl),
        _.on("load", () => {
            _.on("draw.create", this._updateLabels.bind(this)),
            _.on("draw.update", this._updateLabels.bind(this)),
            _.on("draw.delete", this._updateLabels.bind(this))
        }
        ),
        document.createElement("div")
    }
    onRemove(_) {}
    _updateLabels() {
        let _ = this.drawCtrl.getAll()
          , w = _.features.filter(I => I.properties.measurement && I.id).map(I => I.id);
        this.drawCtrl.delete(w),
        _.features.forEach(I => {
            try {
                I.geometry.type == "LineString" && ax(I).features.forEach(N => {
                    let M = N.geometry.coordinates[0]
                      , l = N.geometry.coordinates[1]
                      , ce = ex(M, l)
                      , de = Ky(M, l)
                      , ge = `${cx(de)}
${ux(de * .621371)}`
                      , ze = this.drawCtrl.add({
                        ...ce,
                        id: `${I.id}-${N.id}-mid`,
                        properties: {
                            measurement: ge
                        }
                    });
                    console.log(ze)
                }
                )
            } catch {}
        }
        )
    }
}
function cx(f) {
    return f >= 100 ? f.toFixed(0) + " km" : f >= 10 ? f.toFixed(1) + " km" : f >= 1 ? f.toFixed(2) + " km" : (1e3 * f).toFixed(0) + " m"
}
function ux(f) {
    return f >= 100 ? f.toFixed(0) + " mi" : f >= 10 ? f.toFixed(1) + " mi" : f >= 1 ? f.toFixed(2) + " mi" : (5280 * f).toFixed(0) + " ft"
}
var Yr = Uint8Array
  , Oa = Uint16Array
  , hx = Int32Array
  , vm = new Yr([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0])
  , bm = new Yr([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0])
  , dx = new Yr([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15])
  , wm = function(f, _) {
    for (var w = new Oa(31), I = 0; I < 31; ++I)
        w[I] = _ += 1 << f[I - 1];
    for (var z = new hx(w[30]), I = 1; I < 30; ++I)
        for (var N = w[I]; N < w[I + 1]; ++N)
            z[N] = N - w[I] << 5 | I;
    return {
        b: w,
        r: z
    }
}
  , Tm = wm(vm, 2)
  , Mm = Tm.b
  , px = Tm.r;
Mm[28] = 258,
px[258] = 28;
var fx = wm(bm, 0)
  , mx = fx.b
  , Pd = new Oa(32768);
for (var Qt = 0; Qt < 32768; ++Qt) {
    var Ks = (Qt & 43690) >> 1 | (Qt & 21845) << 1;
    Ks = (Ks & 52428) >> 2 | (Ks & 13107) << 2,
    Ks = (Ks & 61680) >> 4 | (Ks & 3855) << 4,
    Pd[Qt] = ((Ks & 65280) >> 8 | (Ks & 255) << 8) >> 1
}
var uc = function(f, _, w) {
    for (var I = f.length, z = 0, N = new Oa(_); z < I; ++z)
        f[z] && ++N[f[z] - 1];
    var M = new Oa(_);
    for (z = 1; z < _; ++z)
        M[z] = M[z - 1] + N[z - 1] << 1;
    var l;
    if (w) {
        l = new Oa(1 << _);
        var ce = 15 - _;
        for (z = 0; z < I; ++z)
            if (f[z])
                for (var de = z << 4 | f[z], ge = _ - f[z], ze = M[f[z] - 1]++ << ge, oe = ze | (1 << ge) - 1; ze <= oe; ++ze)
                    l[Pd[ze] >> ce] = de
    } else
        for (l = new Oa(I),
        z = 0; z < I; ++z)
            f[z] && (l[z] = Pd[M[f[z] - 1]++] >> 15 - f[z]);
    return l
}
  , yc = new Yr(288);
for (var Qt = 0; Qt < 144; ++Qt)
    yc[Qt] = 8;
for (var Qt = 144; Qt < 256; ++Qt)
    yc[Qt] = 9;
for (var Qt = 256; Qt < 280; ++Qt)
    yc[Qt] = 7;
for (var Qt = 280; Qt < 288; ++Qt)
    yc[Qt] = 8;
var Cm = new Yr(32);
for (var Qt = 0; Qt < 32; ++Qt)
    Cm[Qt] = 5;
var gx = uc(yc, 9, 1)
  , _x = uc(Cm, 5, 1)
  , md = function(f) {
    for (var _ = f[0], w = 1; w < f.length; ++w)
        f[w] > _ && (_ = f[w]);
    return _
}
  , Cn = function(f, _, w) {
    var I = _ / 8 | 0;
    return (f[I] | f[I + 1] << 8) >> (_ & 7) & w
}
  , gd = function(f, _) {
    var w = _ / 8 | 0;
    return (f[w] | f[w + 1] << 8 | f[w + 2] << 16) >> (_ & 7)
}
  , yx = function(f) {
    return (f + 7) / 8 | 0
}
  , xx = function(f, _, w) {
    return (w == null || w > f.length) && (w = f.length),
    new Yr(f.subarray(_, w))
}
  , vx = ["unexpected EOF", "invalid block type", "invalid length/literal", "invalid distance", "stream finished", "no stream handler", , "no callback", "invalid UTF-8 data", "extra field too long", "date not in range 1980-2099", "filename too long", "stream finishing", "invalid zip data"]
  , Jr = function(f, _, w) {
    var I = new Error(_ || vx[f]);
    if (I.code = f,
    Error.captureStackTrace && Error.captureStackTrace(I, Jr),
    !w)
        throw I;
    return I
}
  , Nd = function(f, _, w, I) {
    var z = f.length
      , N = 0;
    if (!z || _.f && !_.l)
        return w || new Yr(0);
    var M = !w
      , l = M || _.i != 2
      , ce = _.i;
    M && (w = new Yr(z * 3));
    var de = function(yi) {
        var ii = w.length;
        if (yi > ii) {
            var Tr = new Yr(Math.max(ii * 2, yi));
            Tr.set(w),
            w = Tr
        }
    }
      , ge = _.f || 0
      , ze = _.p || 0
      , oe = _.b || 0
      , Y = _.l
      , Te = _.d
      , He = _.m
      , ft = _.n
      , Pt = z * 8;
    do {
        if (!Y) {
            ge = Cn(f, ze, 1);
            var vt = Cn(f, ze + 1, 3);
            if (ze += 3,
            vt)
                if (vt == 1)
                    Y = gx,
                    Te = _x,
                    He = 9,
                    ft = 5;
                else if (vt == 2) {
                    var Mt = Cn(f, ze, 31) + 257
                      , gt = Cn(f, ze + 10, 15) + 4
                      , It = Mt + Cn(f, ze + 5, 31) + 1;
                    ze += 14;
                    for (var Pi = new Yr(It), ei = new Yr(19), nt = 0; nt < gt; ++nt)
                        ei[dx[nt]] = Cn(f, ze + nt * 3, 7);
                    ze += gt * 3;
                    for (var Wi = md(ei), Lt = (1 << Wi) - 1, ti = uc(ei, Wi, 1), nt = 0; nt < It; ) {
                        var fi = ti[Cn(f, ze, Lt)];
                        ze += fi & 15;
                        var St = fi >> 4;
                        if (St < 16)
                            Pi[nt++] = St;
                        else {
                            var ut = 0
                              , or = 0;
                            for (St == 16 ? (or = 3 + Cn(f, ze, 3),
                            ze += 2,
                            ut = Pi[nt - 1]) : St == 17 ? (or = 3 + Cn(f, ze, 7),
                            ze += 3) : St == 18 && (or = 11 + Cn(f, ze, 127),
                            ze += 7); or--; )
                                Pi[nt++] = ut
                        }
                    }
                    var ar = Pi.subarray(0, Mt)
                      , mi = Pi.subarray(Mt);
                    He = md(ar),
                    ft = md(mi),
                    Y = uc(ar, He, 1),
                    Te = uc(mi, ft, 1)
                } else
                    Jr(1);
            else {
                var St = yx(ze) + 4
                  , Wt = f[St - 4] | f[St - 3] << 8
                  , pi = St + Wt;
                if (pi > z) {
                    ce && Jr(0);
                    break
                }
                l && de(oe + Wt),
                w.set(f.subarray(St, pi), oe),
                _.b = oe += Wt,
                _.p = ze = pi * 8,
                _.f = ge;
                continue
            }
            if (ze > Pt) {
                ce && Jr(0);
                break
            }
        }
        l && de(oe + 131072);
        for (var wr = (1 << He) - 1, Br = (1 << ft) - 1, gi = ze; ; gi = ze) {
            var ut = Y[gd(f, ze) & wr]
              , si = ut >> 4;
            if (ze += ut & 15,
            ze > Pt) {
                ce && Jr(0);
                break
            }
            if (ut || Jr(2),
            si < 256)
                w[oe++] = si;
            else if (si == 256) {
                gi = ze,
                Y = null;
                break
            } else {
                var _i = si - 254;
                if (si > 264) {
                    var nt = si - 257
                      , Ft = vm[nt];
                    _i = Cn(f, ze, (1 << Ft) - 1) + Mm[nt],
                    ze += Ft
                }
                var Yi = Te[gd(f, ze) & Br]
                  , Xi = Yi >> 4;
                Yi || Jr(3),
                ze += Yi & 15;
                var mi = mx[Xi];
                if (Xi > 3) {
                    var Ft = bm[Xi];
                    mi += gd(f, ze) & (1 << Ft) - 1,
                    ze += Ft
                }
                if (ze > Pt) {
                    ce && Jr(0);
                    break
                }
                l && de(oe + 131072);
                var en = oe + _i;
                if (oe < mi) {
                    var Vi = N - mi
                      , Hn = Math.min(mi, en);
                    for (Vi + oe < 0 && Jr(3); oe < Hn; ++oe)
                        w[oe] = I[Vi + oe]
                }
                for (; oe < en; ++oe)
                    w[oe] = w[oe - mi]
            }
        }
        _.l = Y,
        _.p = gi,
        _.b = oe,
        _.f = ge,
        Y && (ge = 1,
        _.m = He,
        _.d = Te,
        _.n = ft)
    } while (!ge);
    return oe != w.length && M ? xx(w, 0, oe) : w.subarray(0, oe)
}
  , bx = new Yr(0)
  , wx = function(f) {
    (f[0] != 31 || f[1] != 139 || f[2] != 8) && Jr(6, "invalid gzip data");
    var _ = f[3]
      , w = 10;
    _ & 4 && (w += (f[10] | f[11] << 8) + 2);
    for (var I = (_ >> 3 & 1) + (_ >> 4 & 1); I > 0; I -= !f[w++])
        ;
    return w + (_ & 2)
}
  , Tx = function(f) {
    var _ = f.length;
    return (f[_ - 4] | f[_ - 3] << 8 | f[_ - 2] << 16 | f[_ - 1] << 24) >>> 0
}
  , Mx = function(f, _) {
    return ((f[0] & 15) != 8 || f[0] >> 4 > 7 || (f[0] << 8 | f[1]) % 31) && Jr(6, "invalid zlib data"),
    (f[1] >> 5 & 1) == 1 && Jr(6, "invalid zlib data: " + (f[1] & 32 ? "need" : "unexpected") + " dictionary"),
    (f[1] >> 3 & 4) + 2
};
function Cx(f, _) {
    return Nd(f, {
        i: 2
    }, _, _)
}
function Px(f, _) {
    var w = wx(f);
    return w + 8 > f.length && Jr(6, "invalid gzip data"),
    Nd(f.subarray(w, -8), {
        i: 2
    }, new Yr(Tx(f)), _)
}
function Sx(f, _) {
    return Nd(f.subarray(Mx(f), -4), {
        i: 2
    }, _, _)
}
function Ix(f, _) {
    return f[0] == 31 && f[1] == 139 && f[2] == 8 ? Px(f, _) : (f[0] & 15) != 8 || f[0] >> 4 > 7 || (f[0] << 8 | f[1]) % 31 ? Cx(f, _) : Sx(f, _)
}
var Ex = typeof TextDecoder < "u" && new TextDecoder
  , Ax = 0;
try {
    Ex.decode(bx, {
        stream: !0
    }),
    Ax = 1
} catch {}
var zx = Object.defineProperty
  , hc = Math.pow
  , jt = (f, _) => zx(f, "name", {
    value: _,
    configurable: !0
})
  , qi = (f, _, w) => new Promise( (I, z) => {
    var N = ce => {
        try {
            l(w.next(ce))
        } catch (de) {
            z(de)
        }
    }
      , M = ce => {
        try {
            l(w.throw(ce))
        } catch (de) {
            z(de)
        }
    }
      , l = ce => ce.done ? I(ce.value) : Promise.resolve(ce.value).then(N, M);
    l((w = w.apply(f, _)).next())
}
);
jt( (f, _) => {
    let w = !1
      , I = ""
      , z = L.GridLayer.extend({
        createTile: jt( (N, M) => {
            let l = document.createElement("img")
              , ce = new AbortController
              , de = ce.signal;
            return l.cancel = () => {
                ce.abort()
            }
            ,
            w || (f.getHeader().then(ge => {
                ge.tileType === 1 ? console.error("Error: archive contains MVT vector tiles, but leafletRasterLayer is for displaying raster tiles. See https://github.com/protomaps/PMTiles/tree/main/js for details.") : ge.tileType === 2 ? I = "image/png" : ge.tileType === 3 ? I = "image/jpeg" : ge.tileType === 4 ? I = "image/webp" : ge.tileType === 5 && (I = "image/avif")
            }
            ),
            w = !0),
            f.getZxy(N.z, N.x, N.y, de).then(ge => {
                if (ge) {
                    let ze = new Blob([ge.data],{
                        type: I
                    })
                      , oe = window.URL.createObjectURL(ze);
                    l.src = oe,
                    l.cancel = void 0,
                    M(void 0, l)
                }
            }
            ).catch(ge => {
                if (ge.name !== "AbortError")
                    throw ge
            }
            ),
            l
        }
        , "createTile"),
        _removeTile: jt(function(N) {
            let M = this._tiles[N];
            M && (M.el.cancel && M.el.cancel(),
            M.el.width = 0,
            M.el.height = 0,
            M.el.deleted = !0,
            L.DomUtil.remove(M.el),
            delete this._tiles[N],
            this.fire("tileunload", {
                tile: M.el,
                coords: this._keyToTileCoords(N)
            }))
        }, "_removeTile")
    });
    return new z(_)
}
, "leafletRasterLayer");
var kx = jt(f => (_, w) => {
    if (w instanceof AbortController)
        return f(_, w);
    let I = new AbortController;
    return f(_, I).then(z => w(void 0, z.data, z.cacheControl || "", z.expires || ""), z => w(z)).catch(z => w(z)),
    {
        cancel: jt( () => I.abort(), "cancel")
    }
}
, "v3compat")
  , Pm = class {
    constructor(_) {
        this.tilev4 = jt( (w, I) => qi(this, null, function*() {
            if (w.type === "json") {
                let Y = w.url.substr(10)
                  , Te = this.tiles.get(Y);
                if (Te || (Te = new Id(Y),
                this.tiles.set(Y, Te)),
                this.metadata)
                    return {
                        data: yield Te.getTileJson(w.url)
                    };
                let He = yield Te.getHeader();
                return (He.minLon >= He.maxLon || He.minLat >= He.maxLat) && console.error(`Bounds of PMTiles archive ${He.minLon},${He.minLat},${He.maxLon},${He.maxLat} are not valid.`),
                {
                    data: {
                        tiles: [`${w.url}/{z}/{x}/{y}`],
                        minzoom: He.minZoom,
                        maxzoom: He.maxZoom,
                        bounds: [He.minLon, He.minLat, He.maxLon, He.maxLat]
                    }
                }
            }
            let z = new RegExp(/pmtiles:\/\/(.+)\/(\d+)\/(\d+)\/(\d+)/)
              , N = w.url.match(z);
            if (!N)
                throw new Error("Invalid PMTiles protocol URL");
            let M = N[1]
              , l = this.tiles.get(M);
            l || (l = new Id(M),
            this.tiles.set(M, l));
            let ce = N[2]
              , de = N[3]
              , ge = N[4]
              , ze = yield l.getHeader()
              , oe = yield l?.getZxy(+ce, +de, +ge, I.signal);
            if (oe)
                return {
                    data: new Uint8Array(oe.data),
                    cacheControl: oe.cacheControl,
                    expires: oe.expires
                };
            if (ze.tileType === 1) {
                if (this.errorOnMissingTile)
                    throw new Error("Tile not found.");
                return {
                    data: new Uint8Array
                }
            }
            return {
                data: null
            }
        }), "tilev4"),
        this.tile = kx(this.tilev4),
        this.tiles = new Map,
        this.metadata = _?.metadata || !1,
        this.errorOnMissingTile = _?.errorOnMissingTile || !1
    }
    add(_) {
        this.tiles.set(_.source.getKey(), _)
    }
    get(_) {
        return this.tiles.get(_)
    }
}
;
jt(Pm, "Protocol");
var Lx = Pm;
function Sm(f, _) {
    return (_ >>> 0) * 4294967296 + (f >>> 0)
}
jt(Sm, "toNum");
function Im(f, _) {
    let w = _.buf
      , I = w[_.pos++]
      , z = (I & 112) >> 4;
    if (I < 128 || (I = w[_.pos++],
    z |= (I & 127) << 3,
    I < 128) || (I = w[_.pos++],
    z |= (I & 127) << 10,
    I < 128) || (I = w[_.pos++],
    z |= (I & 127) << 17,
    I < 128) || (I = w[_.pos++],
    z |= (I & 127) << 24,
    I < 128) || (I = w[_.pos++],
    z |= (I & 1) << 31,
    I < 128))
        return Sm(f, z);
    throw new Error("Expected varint not more than 10 bytes")
}
jt(Im, "readVarintRemainder");
function Ba(f) {
    let _ = f.buf
      , w = _[f.pos++]
      , I = w & 127;
    return w < 128 || (w = _[f.pos++],
    I |= (w & 127) << 7,
    w < 128) || (w = _[f.pos++],
    I |= (w & 127) << 14,
    w < 128) || (w = _[f.pos++],
    I |= (w & 127) << 21,
    w < 128) ? I : (w = _[f.pos],
    I |= (w & 15) << 28,
    Im(I, f))
}
jt(Ba, "readVarint");
function jd(f, _, w, I) {
    if (I === 0) {
        w === 1 && (_[0] = f - 1 - _[0],
        _[1] = f - 1 - _[1]);
        let z = _[0];
        _[0] = _[1],
        _[1] = z
    }
}
jt(jd, "rotate");
function Em(f, _) {
    let w = hc(2, f)
      , I = _
      , z = _
      , N = _
      , M = [0, 0]
      , l = 1;
    for (; l < w; )
        I = 1 & N / 2,
        z = 1 & (N ^ I),
        jd(l, M, I, z),
        M[0] += l * I,
        M[1] += l * z,
        N = N / 4,
        l *= 2;
    return [f, M[0], M[1]]
}
jt(Em, "idOnLevel");
var Dx = [0, 1, 5, 21, 85, 341, 1365, 5461, 21845, 87381, 349525, 1398101, 5592405, 22369621, 89478485, 357913941, 1431655765, 5726623061, 22906492245, 91625968981, 366503875925, 1466015503701, 5864062014805, 23456248059221, 93824992236885, 375299968947541, 0x5555555555555];
function Am(f, _, w) {
    if (f > 26)
        throw new Error("Tile zoom level exceeds max safe number limit (26)");
    if (_ > hc(2, f) - 1 || w > hc(2, f) - 1)
        throw new Error("tile x/y outside zoom level bounds");
    let I = Dx[f]
      , z = hc(2, f)
      , N = 0
      , M = 0
      , l = 0
      , ce = [_, w]
      , de = z / 2;
    for (; de > 0; )
        N = (ce[0] & de) > 0 ? 1 : 0,
        M = (ce[1] & de) > 0 ? 1 : 0,
        l += de * de * (3 * N ^ M),
        jd(de, ce, N, M),
        de = de / 2;
    return I + l
}
jt(Am, "zxyToTileId");
function Rx(f) {
    let _ = 0;
    for (let w = 0; w < 27; w++) {
        let I = (1 << w) * (1 << w);
        if (_ + I > f)
            return Em(w, f - _);
        _ += I
    }
    throw new Error("Tile zoom level exceeds max safe number limit (26)")
}
jt(Rx, "tileIdToZxy");
var Fx = (f => (f[f.Unknown = 0] = "Unknown",
f[f.None = 1] = "None",
f[f.Gzip = 2] = "Gzip",
f[f.Brotli = 3] = "Brotli",
f[f.Zstd = 4] = "Zstd",
f))(Fx || {});
function Xu(f, _) {
    return qi(this, null, function*() {
        if (_ === 1 || _ === 0)
            return f;
        if (_ === 2) {
            if (typeof globalThis.DecompressionStream > "u")
                return Ix(new Uint8Array(f));
            let w = new Response(f).body;
            if (!w)
                throw new Error("Failed to read response stream");
            let I = w.pipeThrough(new globalThis.DecompressionStream("gzip"));
            return new Response(I).arrayBuffer()
        }
        throw new Error("Compression method not supported")
    })
}
jt(Xu, "defaultDecompress");
var Bx = (f => (f[f.Unknown = 0] = "Unknown",
f[f.Mvt = 1] = "Mvt",
f[f.Png = 2] = "Png",
f[f.Jpeg = 3] = "Jpeg",
f[f.Webp = 4] = "Webp",
f[f.Avif = 5] = "Avif",
f))(Bx || {});
function zm(f) {
    return f === 1 ? ".mvt" : f === 2 ? ".png" : f === 3 ? ".jpg" : f === 4 ? ".webp" : f === 5 ? ".avif" : ""
}
jt(zm, "tileTypeExt");
var Ox = 127;
function km(f, _) {
    let w = 0
      , I = f.length - 1;
    for (; w <= I; ) {
        let z = I + w >> 1
          , N = _ - f[z].tileId;
        if (N > 0)
            w = z + 1;
        else if (N < 0)
            I = z - 1;
        else
            return f[z]
    }
    return I >= 0 && (f[I].runLength === 0 || _ - f[I].tileId < f[I].runLength) ? f[I] : null
}
jt(km, "findTile");
var Nx = class {
    constructor(_) {
        this.file = _
    }
    getKey() {
        return this.file.name
    }
    getBytes(_, w) {
        return qi(this, null, function*() {
            return {
                data: yield this.file.slice(_, _ + w).arrayBuffer()
            }
        })
    }
}
;
jt(Nx, "FileSource");
var Lm = class {
    constructor(_, w=new Headers) {
        this.url = _,
        this.customHeaders = w,
        this.mustReload = !1;
        let I = "";
        "navigator"in globalThis && (I = globalThis.navigator.userAgent || "");
        let z = I.indexOf("Windows") > -1
          , N = /Chrome|Chromium|Edg|OPR|Brave/.test(I);
        this.chromeWindowsNoCache = !1,
        z && N && (this.chromeWindowsNoCache = !0)
    }
    getKey() {
        return this.url
    }
    setHeaders(_) {
        this.customHeaders = _
    }
    getBytes(_, w, I, z) {
        return qi(this, null, function*() {
            let N, M;
            I ? M = I : (N = new AbortController,
            M = N.signal);
            let l = new Headers(this.customHeaders);
            l.set("range", `bytes=${_}-${_ + w - 1}`);
            let ce;
            this.mustReload ? ce = "reload" : this.chromeWindowsNoCache && (ce = "no-store");
            let de = yield fetch(this.url, {
                signal: M,
                cache: ce,
                headers: l
            });
            if (_ === 0 && de.status === 416) {
                let oe = de.headers.get("Content-Range");
                if (!oe || !oe.startsWith("bytes */"))
                    throw new Error("Missing content-length on 416 response");
                let Y = +oe.substr(8);
                de = yield fetch(this.url, {
                    signal: M,
                    cache: "reload",
                    headers: {
                        range: `bytes=0-${Y - 1}`
                    }
                })
            }
            let ge = de.headers.get("Etag");
            if (ge != null && ge.startsWith("W/") && (ge = null),
            de.status === 416 || z && ge && ge !== z)
                throw this.mustReload = !0,
                new Sd(`Server returned non-matching ETag ${z} after one retry. Check browser extensions and servers for issues that may affect correct ETag headers.`);
            if (de.status >= 300)
                throw new Error(`Bad response code: ${de.status}`);
            let ze = de.headers.get("Content-Length");
            if (de.status === 200 && (!ze || +ze > w))
                throw N && N.abort(),
                new Error("Server returned no content-length header or content-length exceeding request. Check that your storage backend supports HTTP Byte Serving.");
            return {
                data: yield de.arrayBuffer(),
                etag: ge || void 0,
                cacheControl: de.headers.get("Cache-Control") || void 0,
                expires: de.headers.get("Expires") || void 0
            }
        })
    }
}
;
jt(Lm, "FetchSource");
var Dm = Lm;
function un(f, _) {
    let w = f.getUint32(_ + 4, !0)
      , I = f.getUint32(_ + 0, !0);
    return w * hc(2, 32) + I
}
jt(un, "getUint64");
function Rm(f, _) {
    let w = new DataView(f)
      , I = w.getUint8(7);
    if (I > 3)
        throw new Error(`Archive is spec version ${I} but this library supports up to spec version 3`);
    return {
        specVersion: I,
        rootDirectoryOffset: un(w, 8),
        rootDirectoryLength: un(w, 16),
        jsonMetadataOffset: un(w, 24),
        jsonMetadataLength: un(w, 32),
        leafDirectoryOffset: un(w, 40),
        leafDirectoryLength: un(w, 48),
        tileDataOffset: un(w, 56),
        tileDataLength: un(w, 64),
        numAddressedTiles: un(w, 72),
        numTileEntries: un(w, 80),
        numTileContents: un(w, 88),
        clustered: w.getUint8(96) === 1,
        internalCompression: w.getUint8(97),
        tileCompression: w.getUint8(98),
        tileType: w.getUint8(99),
        minZoom: w.getUint8(100),
        maxZoom: w.getUint8(101),
        minLon: w.getInt32(102, !0) / 1e7,
        minLat: w.getInt32(106, !0) / 1e7,
        maxLon: w.getInt32(110, !0) / 1e7,
        maxLat: w.getInt32(114, !0) / 1e7,
        centerZoom: w.getUint8(118),
        centerLon: w.getInt32(119, !0) / 1e7,
        centerLat: w.getInt32(123, !0) / 1e7,
        etag: _
    }
}
jt(Rm, "bytesToHeader");
function Vd(f) {
    let _ = {
        buf: new Uint8Array(f),
        pos: 0
    }
      , w = Ba(_)
      , I = []
      , z = 0;
    for (let N = 0; N < w; N++) {
        let M = Ba(_);
        I.push({
            tileId: z + M,
            offset: 0,
            length: 0,
            runLength: 1
        }),
        z += M
    }
    for (let N = 0; N < w; N++)
        I[N].runLength = Ba(_);
    for (let N = 0; N < w; N++)
        I[N].length = Ba(_);
    for (let N = 0; N < w; N++) {
        let M = Ba(_);
        M === 0 && N > 0 ? I[N].offset = I[N - 1].offset + I[N - 1].length : I[N].offset = M - 1
    }
    return I
}
jt(Vd, "deserializeIndex");
var Fm = class extends Error {
}
;
jt(Fm, "EtagMismatch");
var Sd = Fm;
function Ud(f, _) {
    return qi(this, null, function*() {
        let w = yield f.getBytes(0, 16384);
        if (new DataView(w.data).getUint16(0, !0) !== 19792)
            throw new Error("Wrong magic number for PMTiles archive");
        let I = w.data.slice(0, Ox)
          , z = Rm(I, w.etag)
          , N = w.data.slice(z.rootDirectoryOffset, z.rootDirectoryOffset + z.rootDirectoryLength)
          , M = `${f.getKey()}|${z.etag || ""}|${z.rootDirectoryOffset}|${z.rootDirectoryLength}`
          , l = Vd(yield _(N, z.internalCompression));
        return [z, [M, l.length, l]]
    })
}
jt(Ud, "getHeaderAndRoot");
function Zd(f, _, w, I, z) {
    return qi(this, null, function*() {
        let N = yield f.getBytes(w, I, void 0, z.etag)
          , M = yield _(N.data, z.internalCompression)
          , l = Vd(M);
        if (l.length === 0)
            throw new Error("Empty directory is invalid");
        return l
    })
}
jt(Zd, "getDirectory");
var jx = class {
    constructor(_=100, w=!0, I=Xu) {
        this.cache = new Map,
        this.maxCacheEntries = _,
        this.counter = 1,
        this.decompress = I
    }
    getHeader(_) {
        return qi(this, null, function*() {
            let w = _.getKey()
              , I = this.cache.get(w);
            if (I)
                return I.lastUsed = this.counter++,
                I.data;
            let z = yield Ud(_, this.decompress);
            return z[1] && this.cache.set(z[1][0], {
                lastUsed: this.counter++,
                data: z[1][2]
            }),
            this.cache.set(w, {
                lastUsed: this.counter++,
                data: z[0]
            }),
            this.prune(),
            z[0]
        })
    }
    getDirectory(_, w, I, z) {
        return qi(this, null, function*() {
            let N = `${_.getKey()}|${z.etag || ""}|${w}|${I}`
              , M = this.cache.get(N);
            if (M)
                return M.lastUsed = this.counter++,
                M.data;
            let l = yield Zd(_, this.decompress, w, I, z);
            return this.cache.set(N, {
                lastUsed: this.counter++,
                data: l
            }),
            this.prune(),
            l
        })
    }
    prune() {
        if (this.cache.size > this.maxCacheEntries) {
            let _ = 1 / 0, w;
            this.cache.forEach( (I, z) => {
                I.lastUsed < _ && (_ = I.lastUsed,
                w = z)
            }
            ),
            w && this.cache.delete(w)
        }
    }
    invalidate(_) {
        return qi(this, null, function*() {
            this.cache.delete(_.getKey())
        })
    }
}
;
jt(jx, "ResolvedValueCache");
var Bm = class {
    constructor(_=100, w=!0, I=Xu) {
        this.cache = new Map,
        this.invalidations = new Map,
        this.maxCacheEntries = _,
        this.counter = 1,
        this.decompress = I
    }
    getHeader(_) {
        return qi(this, null, function*() {
            let w = _.getKey()
              , I = this.cache.get(w);
            if (I)
                return I.lastUsed = this.counter++,
                yield I.data;
            let z = new Promise( (N, M) => {
                Ud(_, this.decompress).then(l => {
                    l[1] && this.cache.set(l[1][0], {
                        lastUsed: this.counter++,
                        data: Promise.resolve(l[1][2])
                    }),
                    N(l[0]),
                    this.prune()
                }
                ).catch(l => {
                    M(l)
                }
                )
            }
            );
            return this.cache.set(w, {
                lastUsed: this.counter++,
                data: z
            }),
            z
        })
    }
    getDirectory(_, w, I, z) {
        return qi(this, null, function*() {
            let N = `${_.getKey()}|${z.etag || ""}|${w}|${I}`
              , M = this.cache.get(N);
            if (M)
                return M.lastUsed = this.counter++,
                yield M.data;
            let l = new Promise( (ce, de) => {
                Zd(_, this.decompress, w, I, z).then(ge => {
                    ce(ge),
                    this.prune()
                }
                ).catch(ge => {
                    de(ge)
                }
                )
            }
            );
            return this.cache.set(N, {
                lastUsed: this.counter++,
                data: l
            }),
            l
        })
    }
    prune() {
        if (this.cache.size >= this.maxCacheEntries) {
            let _ = 1 / 0, w;
            this.cache.forEach( (I, z) => {
                I.lastUsed < _ && (_ = I.lastUsed,
                w = z)
            }
            ),
            w && this.cache.delete(w)
        }
    }
    invalidate(_) {
        return qi(this, null, function*() {
            let w = _.getKey();
            if (this.invalidations.get(w))
                return yield this.invalidations.get(w);
            this.cache.delete(_.getKey());
            let I = new Promise( (z, N) => {
                this.getHeader(_).then(M => {
                    z(),
                    this.invalidations.delete(w)
                }
                ).catch(M => {
                    N(M)
                }
                )
            }
            );
            this.invalidations.set(w, I)
        })
    }
}
;
jt(Bm, "SharedPromiseCache");
var Vx = Bm
  , Om = class {
    constructor(_, w, I) {
        typeof _ == "string" ? this.source = new Dm(_) : this.source = _,
        I ? this.decompress = I : this.decompress = Xu,
        w ? this.cache = w : this.cache = new Vx
    }
    getHeader() {
        return qi(this, null, function*() {
            return yield this.cache.getHeader(this.source)
        })
    }
    getZxyAttempt(_, w, I, z) {
        return qi(this, null, function*() {
            let N = Am(_, w, I)
              , M = yield this.cache.getHeader(this.source);
            if (_ < M.minZoom || _ > M.maxZoom)
                return;
            let l = M.rootDirectoryOffset
              , ce = M.rootDirectoryLength;
            for (let de = 0; de <= 3; de++) {
                let ge = yield this.cache.getDirectory(this.source, l, ce, M)
                  , ze = km(ge, N);
                if (ze) {
                    if (ze.runLength > 0) {
                        let oe = yield this.source.getBytes(M.tileDataOffset + ze.offset, ze.length, z, M.etag);
                        return {
                            data: yield this.decompress(oe.data, M.tileCompression),
                            cacheControl: oe.cacheControl,
                            expires: oe.expires
                        }
                    }
                    l = M.leafDirectoryOffset + ze.offset,
                    ce = ze.length
                } else
                    return
            }
            throw new Error("Maximum directory depth exceeded")
        })
    }
    getZxy(_, w, I, z) {
        return qi(this, null, function*() {
            try {
                return yield this.getZxyAttempt(_, w, I, z)
            } catch (N) {
                if (N instanceof Sd)
                    return this.cache.invalidate(this.source),
                    yield this.getZxyAttempt(_, w, I, z);
                throw N
            }
        })
    }
    getMetadataAttempt() {
        return qi(this, null, function*() {
            let _ = yield this.cache.getHeader(this.source)
              , w = yield this.source.getBytes(_.jsonMetadataOffset, _.jsonMetadataLength, void 0, _.etag)
              , I = yield this.decompress(w.data, _.internalCompression)
              , z = new TextDecoder("utf-8");
            return JSON.parse(z.decode(I))
        })
    }
    getMetadata() {
        return qi(this, null, function*() {
            try {
                return yield this.getMetadataAttempt()
            } catch (_) {
                if (_ instanceof Sd)
                    return this.cache.invalidate(this.source),
                    yield this.getMetadataAttempt();
                throw _
            }
        })
    }
    getTileJson(_) {
        return qi(this, null, function*() {
            let w = yield this.getHeader()
              , I = yield this.getMetadata()
              , z = zm(w.tileType);
            return {
                tilejson: "3.0.0",
                scheme: "xyz",
                tiles: [`${_}/{z}/{x}/{y}${z}`],
                vector_layers: I.vector_layers,
                attribution: I.attribution,
                description: I.description,
                name: I.name,
                version: I.version,
                bounds: [w.minLon, w.minLat, w.maxLon, w.maxLat],
                center: [w.centerLon, w.centerLat, w.centerZoom],
                minzoom: w.minZoom,
                maxzoom: w.maxZoom
            }
        })
    }
}
;
jt(Om, "PMTiles");
var Id = Om;
function Ux(f) {
    function _() {
        f.getCanvas().style.cursor = "pointer"
    }
    function w() {
        f.getCanvas().style.cursor = ""
    }
    f.on("mouseenter", "city-icons", _),
    f.on("mouseenter", "city-labels", _),
    f.on("mouseleave", "city-icons", w),
    f.on("mouseleave", "city-labels", w),
    f.on("mouseenter", "location-icons", _),
    f.on("mouseenter", "location-labels", _),
    f.on("mouseleave", "location-icons", w),
    f.on("mouseleave", "location-labels", w);
    const I = new vs.Popup;
    function z(N) {
        let M = N.features[0].geometry, l, ce = N.features[0].properties;
        for (M.type === "MultiPoint" ? l = M.coordinates.slice().reduce( (de, ge) => {
            if (de === void 0)
                return ge;
            let ze = N.lngLat.distanceTo(new vs.LngLat(...de))
              , oe = N.lngLat.distanceTo(new vs.LngLat(...ge));
            return ze < oe ? de : ge
        }
        ) : l = M.coordinates.slice(); Math.abs(N.lngLat.lng - l[0]) > 180; )
            l[0] += N.lngLat.lng > l[0] ? 360 : -360;
        I.setLngLat(l).setHTML(`<div class="wiki-popup"><h3><a href="${ce.link}" target="_blank">${ce.label}</a></h3>${ce.text || ""}</div>`).addTo(f)
    }
    f.on("click", "city-icons", z),
    f.on("click", "city-labels", z),
    f.on("click", "location-icons", z),
    f.on("click", "location-labels", z)
}
/**
 * Pure context menu
 * https://github.com/lekoala/pure-context-menu
 * @license MIT
 */
let Du = {
    contextMenuClass: "pure-context-menu",
    dropdownClass: "dropdown-menu",
    dividerClass: "dropdown-divider",
    menuItemClass: "pure-context-menu-item",
    itemClass: "dropdown-item pure-context-menu-item",
    disabledClass: ["disabled", "user-select-none"],
    zIndex: "9999",
    preventCloseOnClick: !1,
    useLists: !1,
    listClass: "list-group",
    listItemClass: "list-group-item list-group-item-action",
    fastClick: !1,
    closeIfOpen: !1,
    show: (f, _) => !0,
    minWidth: "120px",
    maxWidth: "240px",
    popover: !1
};
function Zx() {
    return typeof HTMLElement < "u" && typeof HTMLElement.prototype == "object" && "popover"in HTMLElement.prototype
}
let _d = new Set;
class Gx {
    _el;
    _contextMenu;
    _items;
    _options;
    _currentEvent;
    constructor(_, w, I) {
        this._items = w,
        this._el = _,
        this._contextMenu = null,
        this._options = Object.assign({}, Du, I),
        ["contextmenu", "long-press", "keydown"].forEach(z => {
            _.addEventListener(z, this)
        }
        ),
        this._clickEvents().forEach(z => {
            document.addEventListener(z, this)
        }
        ),
        _d.add(this)
    }
    _clickEvents() {
        return this._options.fastClick ? ["click", "touchstart"] : ["click"]
    }
    handleEvent = _ => {
        const I = {
            "long-press": "contextmenu",
            touchstart: "click"
        }[_.type] || _.type;
        this[`on${I}`](_)
    }
    ;
    static updateDefaultOptions(_) {
        Du = Object.assign(Du, _)
    }
    static getDefaultOptions() {
        return Du
    }
    getItems() {
        return this._items
    }
    setItems(_) {
        this._items = _
    }
    _buildContextMenu = () => {
        const _ = this._options.useLists
          , w = document.createElement("ul");
        w.style.minWidth = this._options.minWidth,
        w.style.maxWidth = this._options.maxWidth,
        w.style.display = "block",
        w.classList.add(this._options.contextMenuClass),
        w.classList.add(...this._options.dropdownClass.split(" ")),
        _ && w.classList.add(this._options.listClass),
        Zx() && this._options.popover && w.setAttribute("popover", "manual");
        for (const I of this._items) {
            const z = document.createElement("li");
            if (z.classList.add(this._options.menuItemClass),
            _ && (z.classList.add(...this._options.listItemClass.split(" ")),
            I.disabled && z.classList.add(...this._options.disabledClass)),
            I.classes && z.classList.add(...I.classes),
            I === "-") {
                const N = document.createElement("hr");
                N.classList.add(this._options.dividerClass),
                z.appendChild(N)
            } else {
                const N = document.createElement("a");
                I.html ? N.innerHTML = I.label : N.innerText = I.label,
                N.style.cursor = "pointer",
                N.style.whiteSpace = "normal",
                _ || (N.classList.add(...this._options.itemClass.split(" ")),
                I.disabled && N.classList.add(...this._options.disabledClass)),
                z.appendChild(N)
            }
            w.appendChild(z)
        }
        return w
    }
    ;
    _normalizePosition = (_, w, I) => {
        const z = this._el
          , N = window.getComputedStyle(I)
          , M = parseInt(N.borderWidth) + 1
          , l = z.getBoundingClientRect();
        let ce = _
          , de = w;
        ["BODY", "HTML"].includes(z.tagName) || (ce -= l.left,
        de -= l.top);
        const ge = parseInt(N.width)
          , ze = ce + ge > z.clientWidth
          , oe = de + I.clientHeight > z.clientHeight;
        let Y = _
          , Te = w;
        return ze && (Y = z.clientWidth - ge - M,
        ["BODY", "HTML"].includes(z.tagName) || (Y += l.left)),
        oe && (Te = z.clientHeight - I.clientHeight - M,
        ["BODY", "HTML"].includes(z.tagName) || (Te += l.top)),
        {
            normalizedX: Y,
            normalizedY: Te
        }
    }
    ;
    close = () => this._contextMenu ? (this._contextMenu.remove(),
    this._contextMenu = null,
    !0) : !1;
    onkeydown(_) {
        switch (_.keyCode || _.key) {
        case 27:
        case "Escape":
            this.close();
            break
        }
    }
    oncontextmenu = _ => {
        if (!this._options.show(_, this))
            return;
        _.preventDefault(),
        _.stopPropagation();
        let w = !1;
        if (_d.forEach(de => {
            de.close() && de === this && (w = !0)
        }
        ),
        this._options.closeIfOpen && w || _.target.closest(`.${this._options.contextMenuClass}`))
            return;
        this._currentEvent = _,
        this.close();
        const z = this._buildContextMenu();
        document.querySelector("body").append(z),
        z.hasAttribute("popover") && z.showPopover(),
        z.style.position = "fixed",
        z.style.zIndex = this._options.zIndex;
        const N = _.detail.clientX ?? _.clientX
          , M = _.detail.clientY ?? _.clientY
          , {normalizedX: l, normalizedY: ce} = this._normalizePosition(N, M, z);
        z.style.top = `${ce}px`,
        z.style.left = `${l}px`,
        this._contextMenu = z
    }
    ;
    _isCurrentTarget = _ => !!(_.target.closest(`.${this._options.contextMenuClass}`) == this._contextMenu && this._contextMenu);
    _handleItemClick = _ => {
        const I = _.target.closest("li");
        if (I) {
            const z = [...I.parentElement.childNodes].findIndex(M => M === I)
              , N = this._items[z];
            N.callback && !N.disabled && (N.callback(this._currentEvent, this),
            (N.preventCloseOnClick ?? this._options.preventCloseOnClick ?? !1) || this.close())
        }
    }
    ;
    onclick = _ => {
        if (this._isCurrentTarget(_)) {
            this._handleItemClick(_);
            return
        }
        this.close()
    }
    ;
    off = () => {
        _d.delete(this),
        this.close(),
        this._clickEvents().forEach(_ => {
            document.removeEventListener(_, this)
        }
        ),
        ["contextmenu", "long-press", "keydown"].forEach(_ => {
            this._el.removeEventListener(_, this)
        }
        )
    }
}
function $x(f, _, w) {
    var I = null;
    _.on("contextmenu", function(N) {
        I = N.lngLat
    });
    let z = [{
        label: "Measure Distance",
        callback: N => {
            w.startMeasurement(I)
        }
    }, {
        label: "Copy Lat/Long",
        callback: N => {
            let M = I.wrap().lat.toFixed(7) + ", " + I.wrap().lng.toFixed(7);
            if (!navigator.clipboard) {
                alert(M);
                return
            }
            navigator.clipboard.writeText(M).then(function() {
                console.log(`Copied '${M}' into clipboard`)
            }, function(l) {
                alert(M)
            })
        }
    }];
    new Gx(_.getContainer(),z,{
        show: N => N.target.classList.contains("maplibregl-canvas")
    })
}
function qx(f) {
    if (!window.location.hash)
        return;
    let _ = new URLSearchParams(window.location.hash.substring(1));
    if (f.on("load", function() {
        if (_.has("flyTo")) {
            console.log("Fly to");
            let w = _.get("flyTo").split("/");
            _.delete("flyTo"),
            window.location.hash = "#" + _.toString(),
            f.flyTo({
                center: [Number(w[2]), Number(w[1])],
                zoom: Number(w[0]),
                speed: .8
            })
        }
    }),
    _.get("bbox")) {
        let w = _.get("bbox").split(",").map(Number.parseFloat)
          , I = _.get("zoom") ? Number.parseFloat(_.get("zoom")) : 7;
        console.log(`bbox with ${w}`),
        _.delete("bbox"),
        window.location.hash = "#" + _.toString();
        let z;
        w.length == 4 ? z = f.cameraForBounds(w) : w.length == 2 ? z = {
            center: w,
            zoom: I
        } : z = {
            center: [0, 0],
            zoom: I
        },
        f.jumpTo(z)
    }
}
const dc = parseInt("29188983") || 0
  , Hx = `map-db-${dc}`
  , yd = navigator.storage.getDirectory().then(f => f.getDirectoryHandle(Hx, {
    create: !0
}));
setTimeout(async () => {
    let f = await navigator.storage.getDirectory();
    for await(const _ of f.values())
        if (_.name.startsWith("map-db-"))
            try {
                let w = parseInt(_.name.substring(7));
                w < dc ? (console.log(`Deleting old version ${w} as the new version is ${dc}`),
                f.removeEntry(_.name, {
                    recursive: !0
                })) : console.log(`Can't delete version ${w} as the my version is ${dc}`)
            } catch (w) {
                console.error(w)
            }
}
, 5e3);
class Wx {
    fetcher;
    constructor(_) {
        this.fetcher = new Dm(_);
        let w = !!dc;
        this.getBytes = w ? this.waitLoadCacheStore : this.waitLoadWebStore,
        yd.then(I => {
            w ? this.getBytes = (z, N, M, l) => this.loadCacheStore(I, z, N, M, l) : this.getBytes = (z, N, M, l) => this.loadWebStore(I, z, N, M, l)
        }
        ).catch(I => {
            this.getBytes = this.loadWeb,
            console.log(I)
        }
        )
    }
    getBytes;
    key(_, w) {
        return `${_}-${w}`
    }
    loadCacheStore(_, w, I, z, N) {
        return _.getFileHandle(this.key(w, I)).catch(M => {
            if (M instanceof DOMException && M.name == "NotFoundError")
                return this.loadWebStore(_, w, I, z, N);
            console.log(M),
            this.loadWeb(w, I, z, N)
        }
        ).then(M => M instanceof FileSystemFileHandle ? M.getFile().then(l => l.arrayBuffer()).then(l => ({
            data: l
        })) : M)
    }
    loadWebStore(_, w, I, z, N) {
        let M = this.loadWeb(w, I, z, N);
        return M.then(async l => {
            let de = await (await _.getFileHandle(this.key(w, I), {
                create: !0
            })).createWritable();
            await de.write(l.data),
            await de.close()
        }
        ),
        M
    }
    waitLoadWebStore(_, w, I, z) {
        return yd.then(N => this.loadWebStore(N, _, w, I, z))
    }
    waitLoadCacheStore(_, w, I, z) {
        return yd.then(N => this.loadCacheStore(N, _, w, I, z))
    }
    loadWeb(_, w, I, z) {
        return this.fetcher.getBytes(_, w, I, z)
    }
    getKey() {
        return this.fetcher.getKey()
    }
}
class Xx {
    onAdd(_) {
        let w = document.createElement("div");
        w.className = "maplibregl-ctrl maplibregl-ctrl-group";
        let I = document.createElement("button");
        I.className = "maplibregl-ctrl-fullscreen",
        I.type = "button",
        w.appendChild(I);
        let z = document.createElement("span");
        return z.className = "maplibregl-ctrl-icon",
        z.setAttribute("aria-hidden", "true"),
        I.appendChild(z),
        I.addEventListener("click", this._openInTab),
        w
    }
    onRemove(_) {}
    _openInTab() {
        window.open(window.location.href.replace("&embedded=true", ""), "_blank").focus()
    }
}
class Kx extends vs.AttributionControl {
    oldUpdateCompact;
    constructor(_) {
        super({
            compact: !0
        }),
        _ && (this.oldUpdateCompact = this._updateCompact,
        this._updateCompact = () => {
            this.oldUpdateCompact(),
            this._toggleAttribution()
        }
        )
    }
}
var Uu = new URLSearchParams(window.location.hash.replace("#", "?"));
const Ao = Uu.get("embedded") === "true"
  , Jx = document.getElementById("map-container");
Ao || Jx.classList.remove("embedded");
var Bu = `${location.protocol}//${location.host}/`;
let Nm = new Lx;
C_.addProtocol("pmtiles", Nm.tilev4);
if (indexedDB)
    try {
        Nm.add(new Id(new Wx(Bu + "golarion.pmtiles?v=29188983")))
    } catch (f) {
        console.log("Failed to initialize IndexDB cache"),
        console.log(f)
    }
const vr = new vs.Map({
    container: "map-container",
    hash: "location",
    attributionControl: !1,
    pitchWithRotate: !1,
    style: {
        version: 8,
        sources: {
            golarion: {
                type: "vector",
                attribution: '<a href="https://paizo.com/licenses/communityuse">Paizo CUP</a>, <a href="https://github.com/pf-wikis/mapping#acknowledgments">Acknowledgments</a>',
                url: "pmtiles://" + Bu + "golarion.pmtiles?v=29188983"
            }
        },
        sprite: Bu + "sprites/sprites",
        layers: S_(Uu),
        glyphs: Bu + "fonts/{fontstack}/{range}.pbf",
        transition: {
            duration: 300,
            delay: 0
        },
        sky: {
            "atmosphere-blend": .5
        }
    }
});
let Ou;
Uu.get("projection") === "globe" ? Ou = "globe" : Uu.get("projection") === "mercator" ? Ou = "mercator" : Ou = ["interpolate", ["linear"], ["zoom"], 4, "vertical-perspective", 5, "mercator"];
vr.on("style.load", () => {
    vr.setProjection({
        type: Ou
    })
}
);
vr.dragRotate.disable();
vr.touchZoomRotate.disableRotation();
vr.on("error", function(f) {
    console.log(f.error.message)
});
Ao || vr.addControl(new vs.NavigationControl({
    showCompass: !1
}));
vr.addControl(new vs.ScaleControl({
    unit: "imperial",
    maxWidth: Ao ? 50 : 100
}));
vr.addControl(new vs.ScaleControl({
    unit: "metric",
    maxWidth: Ao ? 50 : 100
}));
vr.addControl(new Kx(Ao));
let jm = new lx;
vr.addControl(jm);
Ao && vr.addControl(new Xx);
Ux(vr);
$x(Ao, vr, jm);
qx(vr);
window.map = vr;
//# sourceMappingURL=index-DylS0ZFJ.js.map
